(******************************************************************************)
(* A verified SAT solver                                                      *)
(* Jonathan Laurent                                                           *)
(*                                                                            *)
(* Proved using Alt-Ergo and Z3                                               *)
(******************************************************************************)


(******************************************************************************)
(* Utilities                                                                  *)
(******************************************************************************)

module NumOf

use import int.Int
use import array.Array
use import array.NumOfEq

(*
function total_numof (t : array 'a) (v : 'a) : int =
  numof t v 0 (length t)

let lemma decreases_numof (v : 'a) (t t' : array 'a) (i : int) =
  requires { length t = length t' }
  requires { 0 <= i < length t }
  requires { t[i] = v && not (t'[i] = v) }
  requires { forall j:int. 0 <= j < length t -> j <> i -> t[j] = t'[j] }
  ensures { numof t' v 0 (length t') = numof t v 0 (length t) - 1 }

  let rec aux j =
    variant { length t - j }
    requires { 0 <= j <= length t }
    ensures { result = numof t v j (length t) }
    ensures { (j <= i) -> numof t' v j (length t') = result - 1 }
    ensures { (j > i) -> numof t' v j (length t') = result }

    if j = length t then 0
    else if j = i then aux (j+1) + 1
    else if t[j] = v then aux (j+1) + 1
    else aux (j+1) in

  let _ = aux 0 in ()

end
*)

use bool.Bool
let eqb (l: bool) (r: bool) =
    not (xorb l r)

function total_numof (t : array bool) (v : bool) : int =
  numof t v 0 (length t)

let lemma decreases_numof (v : bool) (t t' : array bool) (i : int) =
  requires { length t = length t' }
  requires { 0 <= i < length t }
  requires { t[i] = v && not (t'[i] = v) }
  requires { forall j:int. 0 <= j < length t -> j <> i -> t[j] = t'[j] }
  ensures { numof t' v 0 (length t') = numof t v 0 (length t) - 1 }

  let rec aux j =
    variant { length t - j }
    requires { 0 <= j <= length t }
    ensures { result = numof t v j (length t) }
    ensures { (j <= i) -> numof t' v j (length t') = result - 1 }
    ensures { (j > i) -> numof t' v j (length t') = result }

    if j = length t then 0
    else if j = i then (aux (j+1) + 1)
    else if eqb t[j] v then (aux (j+1) + 1)
    else aux (j+1) in

  let _ = aux 0 in ()

end


module Util

use import int.Int
use import list.List
use import list.Mem

(* Good exercise! *)
let rec range a b =
  requires { a <= b }
  variant { b - a }
  ensures { forall i:int. mem i result <-> a <= i < b }
  if a >= b then Nil
  else Cons a (range (a+1) b)

end


module Sat

use import int.Int
use import ref.Ref

use import list.List
use import list.Length as List
use import list.Mem

use import array.Array
use import array.ArrayEq
use import array.NumOfEq
use import option.Option

use import NumOf
use import Util


(******************************************************************************)
(* [LAB 1] Basic types and predicates                                         *)
(******************************************************************************)

type var = int

type lit = { var : var ; value : bool }

type clause = list lit


predicate vars_in_range (n : int) (c : clause) =
  forall l:lit. mem l c -> 0 <= l.var < n

type cnf = { clauses : array clause ; nvars : int }
  invariant { nvars >= 0 }
  invariant { forall i:int. 0 <= i < length clauses ->
              vars_in_range nvars clauses[i] }
    by { clauses = Array.make 0 Nil; nvars = 0 }


type valuation = array bool

predicate valid_valuation (rho : valuation) (cnf : cnf) =
  length rho = cnf.nvars


predicate clause_sat_with (rho : valuation) (c : clause) =
  exists l:lit. mem l c && rho[l.var] = l.value

predicate sat_with (rho : valuation) (cnf : cnf) =
  forall i:int. 0 <= i < length cnf.clauses ->
  clause_sat_with rho cnf.clauses[i]

predicate unsat (cnf : cnf) =
  forall rho:valuation. valid_valuation rho cnf -> not (sat_with rho cnf)


let rec eval_clause (rho : array bool) (c : clause) variant { c } =
    requires { vars_in_range (length rho) c }
    ensures  { result = clause_sat_with rho c }
    match c with
        | Nil -> false
        | Cons l ls ->
          eqb rho[l.var] l.value || eval_clause rho ls
    end

let eval_cnf (rho : array bool) (cnf : cnf) =
  requires { valid_valuation rho cnf }
  ensures { result = sat_with rho cnf }
  let sat = ref true in
  for i = 0 to length cnf.clauses - 1 do
    invariant { !sat <-> forall j:int. 0 <= j < i ->
                clause_sat_with rho cnf.clauses[j] = true }
    if not (eval_clause rho cnf.clauses[i]) then
      sat := false
  done ;
  !sat


(******************************************************************************)
(* Partial valuations                                                         *)
(******************************************************************************)

type pval = {
  get : valuation ;
  assigned : array bool }
  invariant { length get = length assigned }

function pval_len (pval : pval) : int = length pval.get

predicate valid_pval (pval : pval) (cnf : cnf) =
  valid_valuation pval.get cnf

predicate compatible (pval : pval) (rho : valuation) =
  forall i:int. 0 <= i < pval_len pval ->
  pval.assigned[i] -> rho[i] = pval.get[i]

predicate pval_eq (pval pval' : pval) =
  (pval_len pval = pval_len pval') &&
  (array_eq pval.assigned pval'.assigned) &&
  (compatible pval pval'.get)

let lemma pval_eq_sym (p p' : pval) =
  requires { pval_eq p p' }
  ensures { pval_eq p' p } ()

let lemma pval_eq_trans (p p' p'' : pval) =
  requires { pval_eq p p' }
  requires { pval_eq p' p'' }
  ensures {pval_eq p p'' } ()

let pval_copy pval =
  ensures { pval_eq pval result }
  { get = copy pval.get ; assigned = copy pval.assigned }



(******************************************************************************)
(* Partial evaluation of CNFs                                                 *)
(******************************************************************************)

type clause_status =
  | HasValue bool
  | Unit lit
  | Unknown

(* Sarek comment: The way of deciding the evaluation of the clause is pretty clever and could be mimiced *)

let rec partial_eval_clause (pval : pval) (c : clause) =
  variant  { c }
  requires { vars_in_range (pval_len pval) c }
  ensures  { forall b:bool. result = HasValue b ->
             forall rho:valuation. compatible pval rho ->
             clause_sat_with rho c = b }
  ensures  { forall l:lit. result = Unit l ->
             forall rho:valuation. compatible pval rho ->
             rho[l.var] <> l.value -> not (clause_sat_with rho c) }
  ensures  { forall l:lit. result = Unit l ->
             mem l c && not pval.assigned[l.var] }
  match c with
  | Nil -> HasValue false
  | Cons l ls ->
    match partial_eval_clause pval ls with
    | HasValue v ->
      if v then HasValue true
      else begin
        if not pval.assigned[l.var] then Unit l
        else if eqb pval.get[l.var] l.value then HasValue true
        else HasValue false
      end
    | Unknown ->
      if pval.assigned[l.var] && eqb pval.get[l.var] l.value then HasValue true
      else Unknown
    | Unit l' ->
      if not pval.assigned[l.var] then Unknown
      else if eqb pval.get[l.var] l.value then HasValue true
      else Unit l'
    end
  end


type cnf_status =
  | Unsat
  | Unit_clause lit
  | Other

exception Unsat_found
exception Unit_found lit

let partial_eval_cnf (pval : pval) (cnf : cnf) =
  requires { valid_pval pval cnf }
  ensures  { result = Unsat ->
             forall rho:valuation. compatible pval rho ->
             not (sat_with rho cnf) }
  ensures  { forall l:lit. result = Unit_clause l ->
             forall rho:valuation. compatible pval rho ->
             rho[l.var] <> l.value -> not (sat_with rho cnf) }
  ensures  { forall l:lit. result = Unit_clause l ->
             0 <= l.var < cnf.nvars  && not pval.assigned[l.var] }
  try
    for i = 0 to length cnf.clauses - 1 do
      match partial_eval_clause pval cnf.clauses[i] with
      | HasValue b -> if eqb b false then raise Unsat_found
      | Unit l -> raise (Unit_found l)
      | Unknown -> ()
      end
    done ;
    Other
  with
    | Unsat_found -> Unsat
    | Unit_found l -> Unit_clause l
  end



(******************************************************************************)
(* Backtracking mechanism for partial valuations                              *)
(******************************************************************************)

predicate delta (delta : list var) (pval pval' : pval) =
  (pval_len pval = pval_len pval') &&
  (compatible pval pval'.get) &&
  (forall v:var. mem v delta -> 0 <= v < pval_len pval) &&
  (forall v:var. 0 <= v < pval_len pval ->
    (not pval'.assigned[v] -> not pval.assigned[v]) &&
    (pval'.assigned[v] -> (pval.assigned[v] <-> not mem v delta)))

let rec backtrack diff pval (ghost old_pval : pval) =
  variant  { diff }
  writes   { pval.assigned }
  requires { delta diff old_pval pval }
  ensures  { array_eq old_pval.assigned pval.assigned }
  ensures  { pval_eq old_pval pval }

  match diff with
  | Nil -> ()
  | Cons v vs ->
    pval.assigned[v] <- false ;
    backtrack vs pval old_pval
  end


(******************************************************************************)
(* Unit clause propagation                                                    *)
(******************************************************************************)

predicate propagation_correct
  (cnf : cnf) (pval : pval) (diff : list var) (past_pval : pval) =
  forall rho:valuation. compatible past_pval rho -> sat_with rho cnf ->
  forall v:var. mem v diff -> rho[v] = pval.get[v]


let rec propagate pval diff cnf (ghost past_pval : pval) =
  variant  { total_numof pval.assigned false }
  requires { pval_len pval = pval_len past_pval = cnf.nvars }
  requires { delta !diff past_pval pval }
  ensures  { delta !diff past_pval pval }
  requires { propagation_correct cnf pval !diff past_pval }
  ensures  { propagation_correct cnf pval !diff past_pval }
  ensures  { result = false ->
             forall rho:valuation. compatible pval rho ->
             not sat_with rho cnf }
  
  match partial_eval_cnf pval cnf with
    | Unsat -> false
    | Unit_clause l ->
        pval.get[l.var] <- l.value ;
        pval.assigned[l.var] <- true ;
        diff := Cons l.var !diff ;
        let unsat = propagate pval diff cnf past_pval in
        unsat
    | Other -> true
  end


(******************************************************************************)
(* Main algorithm                                                             *)
(******************************************************************************)

predicate remaining_correct (remaining : list var) (pval : pval) =
  forall i:int. 0 <= i < pval_len pval ->
  not pval.assigned[i] -> mem i remaining

exception Sat

(*
let sat (cnf : cnf) : option (array bool) =
  ensures  { forall rho:valuation. result = Some rho -> sat_with rho cnf }
  ensures  { result = None -> unsat cnf }

  let pval = {
    get = make cnf.nvars false ;
    assigned = make cnf.nvars false } in

  let rec choose remaining =
    variant  { remaining }
    raises   { Sat -> sat_with pval.get cnf }
    requires { forall i:int. mem i remaining -> 0 <= i < cnf.nvars }
    requires { remaining_correct remaining pval }
    ensures  { forall rho:valuation. compatible pval rho ->
               not (sat_with rho cnf) }
    ensures  { pval_eq pval (old pval) }

    match remaining with
      | Nil -> if eval_cnf pval.get cnf then raise Sat
      | Cons v vs ->
        assert { mem v remaining && 0 <= v < cnf.nvars } ;
        if pval.assigned[v] then choose vs else
        begin

          let try_value b =
            requires { remaining_correct remaining pval }
            requires { not pval.assigned[v] }
            ensures  { pval_eq pval (old pval) }
            ensures  { forall rho:valuation. compatible pval rho ->
                       rho[v] = b -> not (sat_with rho cnf) }
            raises   { Sat -> sat_with pval.get cnf }

            (*'L: *)
            let diff = ref Nil in
            pval.assigned[v] <- true ;
            pval.get[v] <- b ;
            let ghost past_pval = pval_copy pval in
            assert { remaining_correct vs pval } ;
            if propagate pval diff cnf past_pval then
            begin
              try choose vs with Sat -> raise Sat end ;
            end ;
            backtrack !diff pval past_pval ;
            pval.assigned[v] <- false ;
            (* assert { array_eq pval.assigned (at pval.assigned 'L) } in *)

          try_value false ;
          try_value true ;
end
*)
        (*end *)
(*    end in *)
(*
  let remaining = range 0 cnf.nvars in
  try
    choose remaining ;
    assert { forall i:int. 0 <= i < cnf.nvars -> not pval.assigned[i] } ;
    None
  with Sat -> Some pval.get end
  *)

(*end *)

end