use seq.Seq
use seq.Mem
use int.Int
use bool.Bool

type assignment = seq bool

type lit = { var : int ; value : bool }

type clause = seq lit

predicate vars_in_range (n : int) (c : clause) =
    forall l:lit. mem l c -> 0 <= l.var <= n

predicate sat_clause (a : assignment) (c: clause) =
    exists l:lit. mem l c && a[l.var] = l.value

type formula = { clauses : seq clause; num_vars : int }
invariant { num_vars >= 0 }
invariant { forall i:int. 0 <= i < length clauses ->
            vars_in_range num_vars clauses[i] }
by { clauses = Seq.empty ; num_vars = 0 }

predicate sat_formula (a : assignment) (f : formula) =
    forall i:int. 0 <= i < f.clauses.length ->
                sat_clause a f.clauses[i]

type pasn = { assign : seq bool ; ix : int }
invariant { length assign >= ix >= 0}

let eqb (l: bool) (r: bool) =
    not (xorb l r)

let function complete (pa: pasn) =
    pa.ix = pa.assign.length

let interp_clause (a : assignment) (c : clause) =
  requires { vars_in_range a.length c }
  ensures { result <-> sat_clause a c }
  for i = 0 to c.length - 1 do
    invariant { forall j. 0 <= j < i -> a[c[j].var] <> c[j].value }
    if (eqb a[c[i].var] c[i].value) then
      return true

  done;
  return false

let interp_formula (a : assignment) (f : formula) =
  requires { length a = f.num_vars }
  ensures { result <-> sat_formula a f}
  for i = 0 to f.clauses.length - 1 do
    invariant { forall j. 0 <= j < i -> sat_clause a f.clauses[j] }
    if not (interp_clause a f.clauses[i]) then
      return false
  done;
  true

predicate compatible (pa : pasn) (a : assignment) =
    length pa.assign = length a &&
    pa.assign[..pa.ix] == a[..pa.ix]

let set_true (p : pasn) : pasn =
  requires { not (complete p) }
  ensures { compatible p result.assign }
  ensures { result.ix = p.ix + 1 }
  ensures { result.assign[p.ix] = true }
  { assign = set p.assign p.ix true ; ix = p.ix + 1 }

let set_false (p : pasn) : pasn =
  requires { not (complete p) }
  ensures { compatible p result.assign }
  ensures { result.ix = p.ix + 1 }
  ensures { result.assign[p.ix] = false }
  { assign = set p.assign p.ix false ; ix = p.ix + 1}

lemma complete_compat : forall pa : pasn, a : assignment.
    compatible pa a -> complete pa -> pa.assign == a

let rec inner (f : formula) (pa : pasn) =
  requires { length pa.assign = f.num_vars }
  ensures { result = true -> exists a. sat_formula a f }
  ensures { result = false -> forall a. compatible pa a -> not (sat_formula a f) }
  variant { f.num_vars - pa.ix }
  if complete pa then
    interp_formula pa.assign f
  else
    (* try assigning i to true *)
    if inner f (set_true pa) then
      return true
    else
    (* otherwise try false *)
      inner f (set_false pa)

let solver (f : formula) =
  ensures { result = true -> exists a. sat_formula a f }
  ensures { result = false -> forall a. a.length = f.num_vars -> not(sat_formula a f) }
  let base = { assign = Seq.create f.num_vars (fun _ -> false) ; ix = 0 } in
  inner f base
