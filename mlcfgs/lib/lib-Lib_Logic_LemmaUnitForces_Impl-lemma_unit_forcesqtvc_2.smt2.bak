;; produced by cvc4_17.drv ;;
(set-logic ALL_SUPPORTED)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

;; sort
(declare-fun sort (ty
  uni) Bool)

;; witness
(declare-fun witness (ty) uni)

;; witness_sort
(assert (forall ((a ty)) (sort a (witness a))))

;; int
(declare-fun int () ty)

;; real
(declare-fun real () ty)

;; string
(declare-fun string () ty)

;; bool
(declare-fun bool () ty)

;; match_bool
(declare-fun match_bool (ty
  Bool
  uni
  uni) uni)

;; match_bool_sort
(assert
  (forall ((a ty))
    (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni))
      (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni))
      (=> (sort a z1) (= (match_bool a false z z1) z1)))))

;; index_bool
(declare-fun index_bool (Bool) Int)

;; index_bool_True
(assert (= (index_bool true) 0))

;; index_bool_False
(assert (= (index_bool false) 1))

;; bool_inversion
(assert (forall ((u Bool)) (or (= u true) (= u false))))

(declare-sort tuple0 0)

;; tuple0
(declare-fun tuple01 () ty)

;; Tuple0
(declare-fun Tuple0 () tuple0)

;; tuple0_inversion
(assert (forall ((u tuple0)) (= u Tuple0)))

(declare-sort seq 1)

;; seq
(declare-fun seq1 (ty) ty)

(declare-sort uint8 0)

;; uint8
(declare-fun uint81 () ty)

;; length
(declare-fun length (ty
  uni) Int)

;; length
(declare-fun length1 ((seq uint8)) Int)

;; get
(declare-fun get (ty
  uni
  Int) uni)

;; get_sort
(assert (forall ((a ty)) (forall ((x uni) (x1 Int)) (sort a (get a x x1)))))

;; infix ==
(declare-fun infix_eqeq (ty
  uni
  uni) Bool)

;; infix ->
(declare-fun infix_mngt (ty
  ty) ty)

;; infix @
(declare-fun infix_at (ty
  ty
  uni
  uni) uni)

;; infix @_sort
(assert
  (forall ((a ty) (b ty))
    (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

;; create
(declare-fun create (ty
  Int
  uni) uni)

;; create_sort
(assert
  (forall ((a ty))
    (forall ((x Int) (x1 uni)) (sort (seq1 a) (create a x x1)))))

;; empty
(declare-fun empty (ty) uni)

;; empty_sort
(assert (forall ((a ty)) (sort (seq1 a) (empty a))))

;; set
(declare-fun set (ty
  uni
  Int
  uni) uni)

;; set_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int) (x2 uni)) (sort (seq1 a) (set a x x1 x2)))))

;; set
(declare-fun set1 ((seq uint8)
  Int
  uint8) (seq uint8))

;; set'spec
(assert
  (forall ((s (seq uint8)) (i Int) (v uint8))
    (=>
      (and (<= 0 i) (< i (length1 s)))
      (= (length1 (set1 s i v)) (length1 s)))))

;; set'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (v uni))
      (=>
        (and (<= 0 i) (< i (length a s)))
        (= (length a (set a s i v)) (length a s))))))

;; t2tb
(declare-fun t2tb (uint8) uni)

;; t2tb_sort
(assert (forall ((x uint8)) (sort uint81 (t2tb x))))

;; tb2t
(declare-fun tb2t (uni) uint8)

;; BridgeL
(assert (forall ((i uint8)) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
(assert
  (forall ((j uni))
    (! (=> (sort uint81 j) (= (t2tb (tb2t j)) j)) :pattern ((t2tb (tb2t j))) )))

;; t2tb
(declare-fun t2tb1 ((seq uint8)) uni)

;; t2tb_sort
(assert (forall ((x (seq uint8))) (sort (seq1 uint81) (t2tb1 x))))

;; tb2t
(declare-fun tb2t1 (uni) (seq uint8))

;; BridgeL
(assert
  (forall ((i (seq uint8)))
    (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
(assert
  (forall ((j uni))
    (! (= (t2tb1 (tb2t1 j)) j) :pattern ((t2tb1 (tb2t1 j))) )))

;; set'spec
(assert
  (forall ((s (seq uint8)) (i Int) (v uint8))
    (=>
      (and (<= 0 i) (< i (length1 s)))
      (= (tb2t (get uint81 (t2tb1 (set1 s i v)) i)) v))))

;; set'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (v uni))
      (=>
        (sort a v)
        (=> (and (<= 0 i) (< i (length a s))) (= (get a (set a s i v) i) v))))))

;; set'spec
(assert
  (forall ((s (seq uint8)) (i Int) (v uint8))
    (=>
      (and (<= 0 i) (< i (length1 s)))
      (forall ((j Int))
        (=>
          (and (and (<= 0 j) (< j (length1 s))) (not (= j i)))
          (= (tb2t (get uint81 (t2tb1 (set1 s i v)) j)) (tb2t
                                                          (get
                                                            uint81
                                                            (t2tb1 s)
                                                            j))))))))

;; set'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (v uni))
      (=>
        (and (<= 0 i) (< i (length a s)))
        (forall ((j Int))
          (=>
            (and (and (<= 0 j) (< j (length a s))) (not (= j i)))
            (= (get a (set a s i v) j) (get a s j))))))))

;; mixfix [<-]
(declare-fun mixfix_lblsmnrb (ty
  uni
  Int
  uni) uni)

;; mixfix [<-]_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int) (x2 uni))
      (sort (seq1 a) (mixfix_lblsmnrb a x x1 x2)))))

;; singleton
(declare-fun singleton1 (ty
  uni) uni)

;; singleton_sort
(assert
  (forall ((a ty)) (forall ((x uni)) (sort (seq1 a) (singleton1 a x)))))

;; cons
(declare-fun cons (ty
  uni
  uni) uni)

;; cons_sort
(assert
  (forall ((a ty)) (forall ((x uni) (x1 uni)) (sort (seq1 a) (cons a x x1)))))

;; snoc
(declare-fun snoc (ty
  uni
  uni) uni)

;; snoc_sort
(assert
  (forall ((a ty)) (forall ((x uni) (x1 uni)) (sort (seq1 a) (snoc a x x1)))))

;; mixfix [..]
(declare-fun mixfix_lbdtdtrb (ty
  uni
  Int
  Int) uni)

;; mixfix [..]_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int) (x2 Int))
      (sort (seq1 a) (mixfix_lbdtdtrb a x x1 x2)))))

;; mixfix [_..]
(declare-fun mixfix_lb_dtdtrb (ty
  uni
  Int) uni)

;; mixfix [_..]_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int)) (sort (seq1 a) (mixfix_lb_dtdtrb a x x1)))))

;; mixfix [.._]
(declare-fun mixfix_lbdtdt_rb (ty
  uni
  Int) uni)

;; mixfix [.._]_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int)) (sort (seq1 a) (mixfix_lbdtdt_rb a x x1)))))

;; infix ++
(declare-fun infix_plpl (ty
  uni
  uni) uni)

;; infix ++_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (seq1 a) (infix_plpl a x x1)))))

;; abs
(declare-fun abs1 (Int) Int)

;; div
(declare-fun div1 (Int
  Int) Int)

;; mod
(declare-fun mod1 (Int
  Int) Int)

(declare-sort int32 0)

;; int32
(declare-fun int321 () ty)

;; int32'int
(declare-fun int32qtint (int32) Int)

;; int32'axiom
(assert
  (forall ((i int32))
    (and (<= (- 2147483648) (int32qtint i)) (<= (int32qtint i) 2147483647))))

;; int32'maxInt
(declare-fun int32qtmaxInt () Int)

;; int32'minInt
(declare-fun int32qtminInt () Int)

;; min_int32
(declare-fun min_int32 () Int)

;; max_int32
(declare-fun max_int32 () Int)

;; to_int
(declare-fun to_int1 (int32) Int)

;; in_bounds
(declare-fun in_bounds (Int) Bool)

(declare-sort uint64 0)

;; uint64
(declare-fun uint641 () ty)

;; uint64'int
(declare-fun uint64qtint (uint64) Int)

;; uint64'axiom
(assert
  (forall ((i uint64))
    (and (<= 0 (uint64qtint i)) (<= (uint64qtint i) 18446744073709551615))))

;; uint64'maxInt
(declare-fun uint64qtmaxInt () Int)

;; uint64'minInt
(declare-fun uint64qtminInt () Int)

;; max_uint64
(declare-fun max_uint64 () Int)

;; length
(declare-fun length2 () Int)

;; radix
(declare-fun radix () Int)

;; to_int
(declare-fun to_int2 (uint64) Int)

;; min_unsigned
(declare-fun min_unsigned () Int)

;; in_bounds
(declare-fun in_bounds1 (Int) Bool)

;; zero_unsigned
(declare-fun zero_unsigned () uint64)

;; ref
(declare-fun ref (ty) ty)

;; ref'mk
(declare-fun refqtmk (ty
  uni) uni)

;; ref'mk_sort
(assert (forall ((a ty)) (forall ((x uni)) (sort (ref a) (refqtmk a x)))))

;; contents
(declare-fun contents (ty
  uni) uni)

;; contents_sort
(assert (forall ((a ty)) (forall ((x uni)) (sort a (contents a x)))))

;; contents'def
(assert
  (forall ((a ty))
    (forall ((u uni)) (=> (sort a u) (= (contents a (refqtmk a u)) u)))))

;; ref_inversion
(assert
  (forall ((a ty))
    (forall ((u uni)) (=> (sort (ref a) u) (= u (refqtmk a (contents a u)))))))

(declare-sort int8 0)

;; int8
(declare-fun int81 () ty)

;; int8'int
(declare-fun int8qtint (int8) Int)

;; int8'axiom
(assert
  (forall ((i int8)) (and (<= (- 128) (int8qtint i)) (<= (int8qtint i) 127))))

;; int8'maxInt
(declare-fun int8qtmaxInt () Int)

;; int8'minInt
(declare-fun int8qtminInt () Int)

;; min_int8
(declare-fun min_int8 () Int)

;; max_int8
(declare-fun max_int8 () Int)

;; to_int
(declare-fun to_int3 (int8) Int)

;; in_bounds
(declare-fun in_bounds2 (Int) Bool)

(declare-sort int16 0)

;; int16
(declare-fun int161 () ty)

;; int16'int
(declare-fun int16qtint (int16) Int)

;; int16'axiom
(assert
  (forall ((i int16))
    (and (<= (- 32768) (int16qtint i)) (<= (int16qtint i) 32767))))

;; int16'maxInt
(declare-fun int16qtmaxInt () Int)

;; int16'minInt
(declare-fun int16qtminInt () Int)

;; min_int16
(declare-fun min_int16 () Int)

;; max_int16
(declare-fun max_int16 () Int)

;; to_int
(declare-fun to_int4 (int16) Int)

;; in_bounds
(declare-fun in_bounds3 (Int) Bool)

(declare-sort int64 0)

;; int64
(declare-fun int641 () ty)

;; int64'int
(declare-fun int64qtint (int64) Int)

;; int64'axiom
(assert
  (forall ((i int64))
    (and
      (<= (- 9223372036854775808) (int64qtint i))
      (<= (int64qtint i) 9223372036854775807))))

;; int64'maxInt
(declare-fun int64qtmaxInt () Int)

;; int64'minInt
(declare-fun int64qtminInt () Int)

;; min_int64
(declare-fun min_int64 () Int)

;; max_int64
(declare-fun max_int64 () Int)

;; to_int
(declare-fun to_int5 (int64) Int)

;; in_bounds
(declare-fun in_bounds4 (Int) Bool)

;; uint8'int
(declare-fun uint8qtint (uint8) Int)

;; uint8'axiom
(assert
  (forall ((i uint8)) (and (<= 0 (uint8qtint i)) (<= (uint8qtint i) 255))))

;; uint8'maxInt
(declare-fun uint8qtmaxInt () Int)

;; uint8'minInt
(declare-fun uint8qtminInt () Int)

;; min_uint8
(declare-fun min_uint8 () Int)

;; max_uint8
(declare-fun max_uint8 () Int)

;; in_bounds
(declare-fun in_bounds5 (Int) Bool)

;; extensionality
(assert
  (forall ((x uint8) (y uint8))
    (=> (= (uint8qtint x) (uint8qtint y)) (= x y))))

(declare-sort uint16 0)

;; uint16
(declare-fun uint161 () ty)

;; uint16'int
(declare-fun uint16qtint (uint16) Int)

;; uint16'axiom
(assert
  (forall ((i uint16))
    (and (<= 0 (uint16qtint i)) (<= (uint16qtint i) 65535))))

;; uint16'maxInt
(declare-fun uint16qtmaxInt () Int)

;; uint16'minInt
(declare-fun uint16qtminInt () Int)

;; min_uint16
(declare-fun min_uint16 () Int)

;; max_uint16
(declare-fun max_uint16 () Int)

;; to_int
(declare-fun to_int6 (uint16) Int)

;; in_bounds
(declare-fun in_bounds6 (Int) Bool)

(declare-sort uint32 0)

;; uint32
(declare-fun uint321 () ty)

;; uint32'int
(declare-fun uint32qtint (uint32) Int)

;; uint32'axiom
(assert
  (forall ((i uint32))
    (and (<= 0 (uint32qtint i)) (<= (uint32qtint i) 4294967295))))

;; uint32'maxInt
(declare-fun uint32qtmaxInt () Int)

;; uint32'minInt
(declare-fun uint32qtminInt () Int)

;; max_uint32
(declare-fun max_uint32 () Int)

;; length
(declare-fun length3 () Int)

;; radix
(declare-fun radix1 () Int)

;; to_int
(declare-fun to_int7 (uint32) Int)

;; min_unsigned
(declare-fun min_unsigned1 () Int)

;; in_bounds
(declare-fun in_bounds7 (Int) Bool)

;; zero_unsigned
(declare-fun zero_unsigned1 () uint32)

;; empty
(declare-fun empty1 () uni)

;; empty_sort
(assert (sort string empty1))

;; concat
(declare-fun concat1 (uni
  uni) uni)

;; concat_sort
(assert (forall ((x uni) (x1 uni)) (sort string (concat1 x x1))))

;; length
(declare-fun length4 (uni) Int)

;; lt
(declare-fun lt (uni
  uni) Bool)

;; le
(declare-fun le (uni
  uni) Bool)

;; s_at
(declare-fun s_at (uni
  Int) uni)

;; s_at_sort
(assert (forall ((x uni) (x1 Int)) (sort string (s_at x x1))))

;; substring
(declare-fun substring (uni
  Int
  Int) uni)

;; substring_sort
(assert
  (forall ((x uni) (x1 Int) (x2 Int)) (sort string (substring x x1 x2))))

;; prefixof
(declare-fun prefixof (uni
  uni) Bool)

;; suffixof
(declare-fun suffixof (uni
  uni) Bool)

;; contains
(declare-fun contains (uni
  uni) Bool)

;; indexof
(declare-fun indexof (uni
  uni
  Int) Int)

;; replace
(declare-fun replace (uni
  uni
  uni) uni)

;; replace_sort
(assert (forall ((x uni) (x1 uni) (x2 uni)) (sort string (replace x x1 x2))))

;; replaceall
(declare-fun replaceall (uni
  uni
  uni) uni)

;; replaceall_sort
(assert
  (forall ((x uni) (x1 uni) (x2 uni)) (sort string (replaceall x x1 x2))))

;; to_int
(declare-fun to_int8 (uni) Int)

;; is_digit
(declare-fun is_digit (uni) Bool)

;; from_int
(declare-fun from_int (Int) uni)

;; from_int_sort
(assert (forall ((x Int)) (sort string (from_int x))))

;; char
(declare-fun char1 () ty)

;; contents
(declare-fun contents1 (uni) uni)

;; contents_sort
(assert (forall ((x uni)) (sort string (contents1 x))))

;; code
(declare-fun code (uni) Int)

;; chr
(declare-fun chr (Int) uni)

;; chr_sort
(assert (forall ((x Int)) (sort char1 (chr x))))

;; get
(declare-fun get1 (uni
  Int) uni)

;; get_sort
(assert (forall ((x uni) (x1 Int)) (sort char1 (get1 x x1))))

;; mixfix []
(declare-fun mixfix_lbrb (uni
  Int) uni)

;; mixfix []_sort
(assert (forall ((x uni) (x1 Int)) (sort char1 (mixfix_lbrb x x1))))

;; eq_string
(declare-fun eq_string (uni
  uni) Bool)

;; make
(declare-fun make (Int
  uni) uni)

;; make_sort
(assert (forall ((x Int) (x1 uni)) (sort string (make x x1))))

;; single
(declare-fun single () ty)

;; max_single
(declare-fun max_single () Real)

;; max_int
(declare-fun max_int () Int)

(declare-sort mode 0)

;; mode
(declare-fun mode1 () ty)

;; NearestTiesToEven
(declare-fun NearestTiesToEven () mode)

;; ToZero
(declare-fun ToZero () mode)

;; Up
(declare-fun Up () mode)

;; Down
(declare-fun Down () mode)

;; NearestTiesToAway
(declare-fun NearestTiesToAway () mode)

;; match_mode
(declare-fun match_mode (ty
  mode
  uni
  uni
  uni
  uni
  uni) uni)

;; match_mode_sort
(assert
  (forall ((a ty))
    (forall ((x mode) (x1 uni) (x2 uni) (x3 uni) (x4 uni) (x5 uni))
      (sort a (match_mode a x x1 x2 x3 x4 x5)))))

;; match_mode_NearestTiesToEven
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
      (=> (sort a z) (= (match_mode a NearestTiesToEven z z1 z2 z3 z4) z)))))

;; match_mode_ToZero
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
      (=> (sort a z1) (= (match_mode a ToZero z z1 z2 z3 z4) z1)))))

;; match_mode_Up
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
      (=> (sort a z2) (= (match_mode a Up z z1 z2 z3 z4) z2)))))

;; match_mode_Down
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
      (=> (sort a z3) (= (match_mode a Down z z1 z2 z3 z4) z3)))))

;; match_mode_NearestTiesToAway
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
      (=> (sort a z4) (= (match_mode a NearestTiesToAway z z1 z2 z3 z4) z4)))))

;; index_mode
(declare-fun index_mode (mode) Int)

;; index_mode_NearestTiesToEven
(assert (= (index_mode NearestTiesToEven) 0))

;; index_mode_ToZero
(assert (= (index_mode ToZero) 1))

;; index_mode_Up
(assert (= (index_mode Up) 2))

;; index_mode_Down
(assert (= (index_mode Down) 3))

;; index_mode_NearestTiesToAway
(assert (= (index_mode NearestTiesToAway) 4))

;; mode_inversion
(assert
  (forall ((u mode))
    (or
      (or (or (or (= u NearestTiesToEven) (= u ToZero)) (= u Up)) (= u Down))
      (= u NearestTiesToAway))))

;; round
(declare-fun round (mode
  Real) Real)

;; value
(declare-fun value (uni) Real)

;; exact
(declare-fun exact (uni) Real)

;; model
(declare-fun model1 (uni) Real)

;; round_error
(declare-fun round_error (uni) Real)

;; total_error
(declare-fun total_error (uni) Real)

;; no_overflow
(declare-fun no_overflow (mode
  Real) Bool)

;; round_logic
(declare-fun round_logic (mode
  Real) uni)

;; round_logic_sort
(assert (forall ((x mode) (x1 Real)) (sort single (round_logic x x1))))

;; of_real_post
(declare-fun of_real_post (mode
  Real
  uni) Bool)

;; add_post
(declare-fun add_post (mode
  uni
  uni
  uni) Bool)

;; sub_post
(declare-fun sub_post (mode
  uni
  uni
  uni) Bool)

;; mul_post
(declare-fun mul_post (mode
  uni
  uni
  uni) Bool)

;; div_post
(declare-fun div_post (mode
  uni
  uni
  uni) Bool)

;; neg_post
(declare-fun neg_post (uni
  uni) Bool)

;; lt
(declare-fun lt1 (uni
  uni) Bool)

;; gt
(declare-fun gt (uni
  uni) Bool)

;; double
(declare-fun double () ty)

;; max_double
(declare-fun max_double () Real)

;; max_int
(declare-fun max_int1 () Int)

;; round
(declare-fun round1 (mode
  Real) Real)

;; value
(declare-fun value1 (uni) Real)

;; exact
(declare-fun exact1 (uni) Real)

;; model
(declare-fun model2 (uni) Real)

;; round_error
(declare-fun round_error1 (uni) Real)

;; total_error
(declare-fun total_error1 (uni) Real)

;; no_overflow
(declare-fun no_overflow1 (mode
  Real) Bool)

;; round_logic
(declare-fun round_logic1 (mode
  Real) uni)

;; round_logic_sort
(assert (forall ((x mode) (x1 Real)) (sort double (round_logic1 x x1))))

;; of_real_post
(declare-fun of_real_post1 (mode
  Real
  uni) Bool)

;; add_post
(declare-fun add_post1 (mode
  uni
  uni
  uni) Bool)

;; sub_post
(declare-fun sub_post1 (mode
  uni
  uni
  uni) Bool)

;; mul_post
(declare-fun mul_post1 (mode
  uni
  uni
  uni) Bool)

;; div_post
(declare-fun div_post1 (mode
  uni
  uni
  uni) Bool)

;; neg_post
(declare-fun neg_post1 (uni
  uni) Bool)

;; lt
(declare-fun lt2 (uni
  uni) Bool)

;; gt
(declare-fun gt1 (uni
  uni) Bool)

(declare-sort opaque_ptr 0)

;; opaque_ptr
(declare-fun opaque_ptr1 () ty)

;; slice
(declare-fun slice (ty) ty)

;; borrowed
(declare-fun borrowed (ty) ty)

;; borrowed'mk
(declare-fun borrowedqtmk (ty
  uni
  uni) uni)

;; borrowed'mk_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (borrowed a) (borrowedqtmk a x x1)))))

;; current
(declare-fun current (ty
  uni) uni)

;; current_sort
(assert (forall ((a ty)) (forall ((x uni)) (sort a (current a x)))))

;; current'def
(assert
  (forall ((a ty))
    (forall ((u uni) (u1 uni))
      (=> (sort a u) (= (current a (borrowedqtmk a u u1)) u)))))

;; final
(declare-fun final (ty
  uni) uni)

;; final_sort
(assert (forall ((a ty)) (forall ((x uni)) (sort a (final a x)))))

;; final'def
(assert
  (forall ((a ty))
    (forall ((u uni) (u1 uni))
      (=> (sort a u1) (= (final a (borrowedqtmk a u u1)) u1)))))

;; borrowed_inversion
(assert
  (forall ((a ty))
    (forall ((u uni))
      (=>
        (sort (borrowed a) u)
        (= u (borrowedqtmk a (current a u) (final a u)))))))

;; prefix *
(declare-fun prefix_as (ty
  uni) uni)

;; prefix *_sort
(assert (forall ((xi ty)) (forall ((x uni)) (sort xi (prefix_as xi x)))))

;; prefix ^
(declare-fun prefix_cf (ty
  uni) uni)

;; prefix ^_sort
(assert (forall ((xi ty)) (forall ((x uni)) (sort xi (prefix_cf xi x)))))

;; id
(declare-fun id (ty
  uni) uni)

;; id_sort
(assert (forall ((a ty)) (forall ((x uni)) (sort a (id a x)))))

(declare-sort creusotcontracts_std1_vec_vec 1)

;; creusotcontracts_std1_vec_vec
(declare-fun creusotcontracts_std1_vec_vec1 (ty) ty)

(declare-sort lib_decision_decisions 0)

;; lib_decision_decisions
(declare-fun lib_decision_decisions1 () ty)

;; Lib_Decision_Decisions
(declare-fun Lib_Decision_Decisions ((creusotcontracts_std1_vec_vec uint64)) lib_decision_decisions)

;; Lib_Decision_Decisions_proj_1
(declare-fun Lib_Decision_Decisions_proj_1 (lib_decision_decisions) (creusotcontracts_std1_vec_vec uint64))

;; Lib_Decision_Decisions_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec uint64)))
    (= (Lib_Decision_Decisions_proj_1 (Lib_Decision_Decisions u)) u)))

;; lib_decision_decisions_inversion
(assert
  (forall ((u lib_decision_decisions))
    (= u (Lib_Decision_Decisions (Lib_Decision_Decisions_proj_1 u)))))

;; lib_decision_decisions_Decisions_lit_order
(declare-fun lib_decision_decisions_Decisions_lit_order (lib_decision_decisions) (creusotcontracts_std1_vec_vec uint64))

(declare-sort lib_lit_lit 0)

;; lib_lit_lit
(declare-fun lib_lit_lit1 () ty)

;; Lib_Lit_Lit
(declare-fun Lib_Lit_Lit (uint64
  Bool) lib_lit_lit)

;; Lib_Lit_Lit_proj_1
(declare-fun Lib_Lit_Lit_proj_1 (lib_lit_lit) uint64)

;; Lib_Lit_Lit_proj_1'def
(assert
  (forall ((u uint64) (u1 Bool))
    (= (Lib_Lit_Lit_proj_1 (Lib_Lit_Lit u u1)) u)))

;; Lib_Lit_Lit_proj_2
(declare-fun Lib_Lit_Lit_proj_2 (lib_lit_lit) Bool)

;; Lib_Lit_Lit_proj_2'def
(assert
  (forall ((u uint64) (u1 Bool))
    (= (Lib_Lit_Lit_proj_2 (Lib_Lit_Lit u u1)) u1)))

;; lib_lit_lit_inversion
(assert
  (forall ((u lib_lit_lit))
    (= u (Lib_Lit_Lit (Lib_Lit_Lit_proj_1 u) (Lib_Lit_Lit_proj_2 u)))))

;; lib_lit_lit_Lit_idx
(declare-fun lib_lit_lit_Lit_idx (lib_lit_lit) uint64)

;; lib_lit_lit_Lit_polarity
(declare-fun lib_lit_lit_Lit_polarity (lib_lit_lit) Bool)

(declare-sort lib_clause_clause 0)

;; lib_clause_clause
(declare-fun lib_clause_clause1 () ty)

;; Lib_Clause_Clause
(declare-fun Lib_Clause_Clause ((creusotcontracts_std1_vec_vec lib_lit_lit)) lib_clause_clause)

;; Lib_Clause_Clause_proj_1
(declare-fun Lib_Clause_Clause_proj_1 (lib_clause_clause) (creusotcontracts_std1_vec_vec lib_lit_lit))

;; Lib_Clause_Clause_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec lib_lit_lit)))
    (= (Lib_Clause_Clause_proj_1 (Lib_Clause_Clause u)) u)))

;; lib_clause_clause_inversion
(assert
  (forall ((u lib_clause_clause))
    (= u (Lib_Clause_Clause (Lib_Clause_Clause_proj_1 u)))))

;; lib_clause_clause_Clause_rest
(declare-fun lib_clause_clause_Clause_rest (lib_clause_clause) (creusotcontracts_std1_vec_vec lib_lit_lit))

(declare-sort lib_formula_formula 0)

;; lib_formula_formula
(declare-fun lib_formula_formula1 () ty)

;; Lib_Formula_Formula
(declare-fun Lib_Formula_Formula ((creusotcontracts_std1_vec_vec lib_clause_clause)
  uint64) lib_formula_formula)

;; Lib_Formula_Formula_proj_1
(declare-fun Lib_Formula_Formula_proj_1 (lib_formula_formula) (creusotcontracts_std1_vec_vec lib_clause_clause))

;; Lib_Formula_Formula_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec lib_clause_clause)) (u1 uint64))
    (= (Lib_Formula_Formula_proj_1 (Lib_Formula_Formula u u1)) u)))

;; Lib_Formula_Formula_proj_2
(declare-fun Lib_Formula_Formula_proj_2 (lib_formula_formula) uint64)

;; Lib_Formula_Formula_proj_2'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec lib_clause_clause)) (u1 uint64))
    (= (Lib_Formula_Formula_proj_2 (Lib_Formula_Formula u u1)) u1)))

;; lib_formula_formula_inversion
(assert
  (forall ((u lib_formula_formula))
    (= u (Lib_Formula_Formula
           (Lib_Formula_Formula_proj_1 u)
           (Lib_Formula_Formula_proj_2 u)))))

;; lib_formula_formula_Formula_clauses
(declare-fun lib_formula_formula_Formula_clauses (lib_formula_formula) (creusotcontracts_std1_vec_vec lib_clause_clause))

;; lib_formula_formula_Formula_num_vars
(declare-fun lib_formula_formula_Formula_num_vars (lib_formula_formula) uint64)

(declare-sort lib_assignments_assignments 0)

;; lib_assignments_assignments
(declare-fun lib_assignments_assignments1 () ty)

;; Lib_Assignments_Assignments
(declare-fun Lib_Assignments_Assignments ((creusotcontracts_std1_vec_vec uint8)
  uint64) lib_assignments_assignments)

;; Lib_Assignments_Assignments_proj_1
(declare-fun Lib_Assignments_Assignments_proj_1 (lib_assignments_assignments) (creusotcontracts_std1_vec_vec uint8))

;; Lib_Assignments_Assignments_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec uint8)) (u1 uint64))
    (= (Lib_Assignments_Assignments_proj_1
         (Lib_Assignments_Assignments u u1)) u)))

;; Lib_Assignments_Assignments_proj_2
(declare-fun Lib_Assignments_Assignments_proj_2 (lib_assignments_assignments) uint64)

;; Lib_Assignments_Assignments_proj_2'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec uint8)) (u1 uint64))
    (= (Lib_Assignments_Assignments_proj_2
         (Lib_Assignments_Assignments u u1)) u1)))

;; lib_assignments_assignments_inversion
(assert
  (forall ((u lib_assignments_assignments))
    (= u (Lib_Assignments_Assignments
           (Lib_Assignments_Assignments_proj_1 u)
           (Lib_Assignments_Assignments_proj_2 u)))))

;; lib_assignments_assignments_Assignments_0
(declare-fun lib_assignments_assignments_Assignments_0 (lib_assignments_assignments) (creusotcontracts_std1_vec_vec uint8))

;; lib_assignments_assignments_Assignments_1
(declare-fun lib_assignments_assignments_Assignments_1 (lib_assignments_assignments) uint64)

;; core_option_option
(declare-fun core_option_option (ty) ty)

;; Core_Option_Option_None
(declare-fun Core_Option_Option_None (ty) uni)

;; Core_Option_Option_None_sort
(assert
  (forall ((t ty)) (sort (core_option_option t) (Core_Option_Option_None t))))

;; Core_Option_Option_Some
(declare-fun Core_Option_Option_Some (ty
  uni) uni)

;; Core_Option_Option_Some_sort
(assert
  (forall ((t ty))
    (forall ((x uni))
      (sort (core_option_option t) (Core_Option_Option_Some t x)))))

;; match_core_option_option
(declare-fun match_core_option_option (ty
  ty
  uni
  uni
  uni) uni)

;; match_core_option_option_sort
(assert
  (forall ((t ty) (a ty))
    (forall ((x uni) (x1 uni) (x2 uni))
      (sort a (match_core_option_option a t x x1 x2)))))

;; match_core_option_option_Core_Option_Option_None
(assert
  (forall ((t ty) (a ty))
    (forall ((z uni) (z1 uni))
      (=>
        (sort a z)
        (= (match_core_option_option a t (Core_Option_Option_None t) z z1) z)))))

;; match_core_option_option_Core_Option_Option_Some
(assert
  (forall ((t ty) (a ty))
    (forall ((z uni) (z1 uni) (u uni))
      (=>
        (sort a z1)
        (= (match_core_option_option a t (Core_Option_Option_Some t u) z z1) z1)))))

;; index_core_option_option
(declare-fun index_core_option_option (ty
  uni) Int)

;; index_core_option_option_Core_Option_Option_None
(assert
  (forall ((t ty))
    (= (index_core_option_option t (Core_Option_Option_None t)) 0)))

;; index_core_option_option_Core_Option_Option_Some
(assert
  (forall ((t ty))
    (forall ((u uni))
      (! (= (index_core_option_option t (Core_Option_Option_Some t u)) 1) :pattern (
      (Core_Option_Option_Some
        t
        u)) ))))

;; Core_Option_Option_Some_proj_1
(declare-fun Core_Option_Option_Some_proj_1 (ty
  uni) uni)

;; Core_Option_Option_Some_proj_1_sort
(assert
  (forall ((t ty))
    (forall ((x uni)) (sort t (Core_Option_Option_Some_proj_1 t x)))))

;; Core_Option_Option_Some_proj_1'def
(assert
  (forall ((t ty))
    (forall ((u uni))
      (=>
        (sort t u)
        (= (Core_Option_Option_Some_proj_1 t (Core_Option_Option_Some t u)) u)))))

;; core_option_option_inversion
(assert
  (forall ((t ty))
    (forall ((u uni))
      (=>
        (sort (core_option_option t) u)
        (or
          (= u (Core_Option_Option_None t))
          (= u (Core_Option_Option_Some
                 t
                 (Core_Option_Option_Some_proj_1 t u))))))))

;; core_option_option_Some_0
(declare-fun core_option_option_Some_0 (ty
  uni) uni)

;; core_option_option_Some_0_sort
(assert
  (forall ((t ty))
    (forall ((x uni)) (sort t (core_option_option_Some_0 t x)))))

(declare-sort lib_trail_reason 0)

;; lib_trail_reason
(declare-fun lib_trail_reason1 () ty)

;; Lib_Trail_Reason_Undefined
(declare-fun Lib_Trail_Reason_Undefined () lib_trail_reason)

;; Lib_Trail_Reason_Decision
(declare-fun Lib_Trail_Reason_Decision () lib_trail_reason)

;; Lib_Trail_Reason_Unit
(declare-fun Lib_Trail_Reason_Unit () lib_trail_reason)

;; Lib_Trail_Reason_Long
(declare-fun Lib_Trail_Reason_Long (uint64) lib_trail_reason)

;; match_lib_trail_reason
(declare-fun match_lib_trail_reason (ty
  lib_trail_reason
  uni
  uni
  uni
  uni) uni)

;; match_lib_trail_reason_sort
(assert
  (forall ((a ty))
    (forall ((x lib_trail_reason) (x1 uni) (x2 uni) (x3 uni) (x4 uni))
      (sort a (match_lib_trail_reason a x x1 x2 x3 x4)))))

;; match_lib_trail_reason_Lib_Trail_Reason_Undefined
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z)
        (= (match_lib_trail_reason a Lib_Trail_Reason_Undefined z z1 z2 z3) z)))))

;; match_lib_trail_reason_Lib_Trail_Reason_Decision
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z1)
        (= (match_lib_trail_reason a Lib_Trail_Reason_Decision z z1 z2 z3) z1)))))

;; match_lib_trail_reason_Lib_Trail_Reason_Unit
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z2)
        (= (match_lib_trail_reason a Lib_Trail_Reason_Unit z z1 z2 z3) z2)))))

;; match_lib_trail_reason_Lib_Trail_Reason_Long
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (u uint64))
      (=>
        (sort a z3)
        (= (match_lib_trail_reason a (Lib_Trail_Reason_Long u) z z1 z2 z3) z3)))))

;; index_lib_trail_reason
(declare-fun index_lib_trail_reason (lib_trail_reason) Int)

;; index_lib_trail_reason_Lib_Trail_Reason_Undefined
(assert (= (index_lib_trail_reason Lib_Trail_Reason_Undefined) 0))

;; index_lib_trail_reason_Lib_Trail_Reason_Decision
(assert (= (index_lib_trail_reason Lib_Trail_Reason_Decision) 1))

;; index_lib_trail_reason_Lib_Trail_Reason_Unit
(assert (= (index_lib_trail_reason Lib_Trail_Reason_Unit) 2))

;; index_lib_trail_reason_Lib_Trail_Reason_Long
(assert
  (forall ((u uint64))
    (! (= (index_lib_trail_reason (Lib_Trail_Reason_Long u)) 3) :pattern (
    (Lib_Trail_Reason_Long
      u)) )))

;; Lib_Trail_Reason_Long_proj_1
(declare-fun Lib_Trail_Reason_Long_proj_1 (lib_trail_reason) uint64)

;; Lib_Trail_Reason_Long_proj_1'def
(assert
  (forall ((u uint64))
    (= (Lib_Trail_Reason_Long_proj_1 (Lib_Trail_Reason_Long u)) u)))

;; lib_trail_reason_inversion
(assert
  (forall ((u lib_trail_reason))
    (or
      (or
        (or (= u Lib_Trail_Reason_Undefined) (= u Lib_Trail_Reason_Decision))
        (= u Lib_Trail_Reason_Unit))
      (= u (Lib_Trail_Reason_Long (Lib_Trail_Reason_Long_proj_1 u))))))

(declare-sort lib_clause_clausestate 0)

;; lib_clause_clausestate
(declare-fun lib_clause_clausestate1 () ty)

;; Lib_Clause_ClauseState_Sat
(declare-fun Lib_Clause_ClauseState_Sat () lib_clause_clausestate)

;; Lib_Clause_ClauseState_Unsat
(declare-fun Lib_Clause_ClauseState_Unsat () lib_clause_clausestate)

;; Lib_Clause_ClauseState_Unit
(declare-fun Lib_Clause_ClauseState_Unit () lib_clause_clausestate)

;; Lib_Clause_ClauseState_Unknown
(declare-fun Lib_Clause_ClauseState_Unknown () lib_clause_clausestate)

;; match_lib_clause_clausestate
(declare-fun match_lib_clause_clausestate (ty
  lib_clause_clausestate
  uni
  uni
  uni
  uni) uni)

;; match_lib_clause_clausestate_sort
(assert
  (forall ((a ty))
    (forall ((x lib_clause_clausestate) (x1 uni) (x2 uni) (x3 uni) (x4 uni))
      (sort a (match_lib_clause_clausestate a x x1 x2 x3 x4)))))

;; match_lib_clause_clausestate_Lib_Clause_ClauseState_Sat
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z)
        (= (match_lib_clause_clausestate
             a
             Lib_Clause_ClauseState_Sat
             z
             z1
             z2
             z3) z)))))

;; match_lib_clause_clausestate_Lib_Clause_ClauseState_Unsat
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z1)
        (= (match_lib_clause_clausestate
             a
             Lib_Clause_ClauseState_Unsat
             z
             z1
             z2
             z3) z1)))))

;; match_lib_clause_clausestate_Lib_Clause_ClauseState_Unit
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z2)
        (= (match_lib_clause_clausestate
             a
             Lib_Clause_ClauseState_Unit
             z
             z1
             z2
             z3) z2)))))

;; match_lib_clause_clausestate_Lib_Clause_ClauseState_Unknown
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z3)
        (= (match_lib_clause_clausestate
             a
             Lib_Clause_ClauseState_Unknown
             z
             z1
             z2
             z3) z3)))))

;; index_lib_clause_clausestate
(declare-fun index_lib_clause_clausestate (lib_clause_clausestate) Int)

;; index_lib_clause_clausestate_Lib_Clause_ClauseState_Sat
(assert (= (index_lib_clause_clausestate Lib_Clause_ClauseState_Sat) 0))

;; index_lib_clause_clausestate_Lib_Clause_ClauseState_Unsat
(assert (= (index_lib_clause_clausestate Lib_Clause_ClauseState_Unsat) 1))

;; index_lib_clause_clausestate_Lib_Clause_ClauseState_Unit
(assert (= (index_lib_clause_clausestate Lib_Clause_ClauseState_Unit) 2))

;; index_lib_clause_clausestate_Lib_Clause_ClauseState_Unknown
(assert (= (index_lib_clause_clausestate Lib_Clause_ClauseState_Unknown) 3))

;; lib_clause_clausestate_inversion
(assert
  (forall ((u lib_clause_clausestate))
    (or
      (or
        (or
          (= u Lib_Clause_ClauseState_Sat)
          (= u Lib_Clause_ClauseState_Unsat))
        (= u Lib_Clause_ClauseState_Unit))
      (= u Lib_Clause_ClauseState_Unknown))))

(declare-sort tuple2 2)

;; tuple2
(declare-fun tuple21 (ty
  ty) ty)

;; Tuple2
(declare-fun Tuple2 (ty
  ty
  uni
  uni) uni)

;; Tuple2_sort
(assert
  (forall ((a ty) (a1 ty))
    (forall ((x uni) (x1 uni)) (sort (tuple21 a1 a) (Tuple2 a1 a x x1)))))

;; Tuple2_proj_1
(declare-fun Tuple2_proj_1 (ty
  ty
  uni) uni)

;; Tuple2_proj_1_sort
(assert
  (forall ((a ty) (a1 ty))
    (forall ((x uni)) (sort a1 (Tuple2_proj_1 a1 a x)))))

;; Tuple2_proj_1'def
(assert
  (forall ((a ty) (a1 ty))
    (forall ((u uni) (u1 uni))
      (=> (sort a1 u) (= (Tuple2_proj_1 a1 a (Tuple2 a1 a u u1)) u)))))

;; Tuple2_proj_2
(declare-fun Tuple2_proj_2 (ty
  ty
  uni) uni)

;; Tuple2_proj_2_sort
(assert
  (forall ((a ty) (a1 ty))
    (forall ((x uni)) (sort a (Tuple2_proj_2 a1 a x)))))

;; Tuple2_proj_2'def
(assert
  (forall ((a ty) (a1 ty))
    (forall ((u uni) (u1 uni))
      (=> (sort a u1) (= (Tuple2_proj_2 a1 a (Tuple2 a1 a u u1)) u1)))))

;; tuple2_inversion
(assert
  (forall ((a ty) (a1 ty))
    (forall ((u uni))
      (=>
        (sort (tuple21 a1 a) u)
        (= u (Tuple2 a1 a (Tuple2_proj_1 a1 a u) (Tuple2_proj_2 a1 a u)))))))

(declare-sort lib_trail_trail 0)

;; lib_trail_trail
(declare-fun lib_trail_trail1 () ty)

;; Lib_Trail_Trail
(declare-fun Lib_Trail_Trail ((creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit))
  (creusotcontracts_std1_vec_vec (tuple2 uint64
  lib_trail_reason))) lib_trail_trail)

;; Lib_Trail_Trail_proj_1
(declare-fun Lib_Trail_Trail_proj_1 (lib_trail_trail) (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit)))

;; Lib_Trail_Trail_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit))) (u1 (creusotcontracts_std1_vec_vec (tuple2 uint64 lib_trail_reason))))
    (= (Lib_Trail_Trail_proj_1 (Lib_Trail_Trail u u1)) u)))

;; Lib_Trail_Trail_proj_2
(declare-fun Lib_Trail_Trail_proj_2 (lib_trail_trail) (creusotcontracts_std1_vec_vec (tuple2 uint64
  lib_trail_reason)))

;; Lib_Trail_Trail_proj_2'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit))) (u1 (creusotcontracts_std1_vec_vec (tuple2 uint64 lib_trail_reason))))
    (= (Lib_Trail_Trail_proj_2 (Lib_Trail_Trail u u1)) u1)))

;; lib_trail_trail_inversion
(assert
  (forall ((u lib_trail_trail))
    (= u (Lib_Trail_Trail
           (Lib_Trail_Trail_proj_1 u)
           (Lib_Trail_Trail_proj_2 u)))))

;; lib_trail_trail_Trail_trail
(declare-fun lib_trail_trail_Trail_trail (lib_trail_trail) (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit)))

;; lib_trail_trail_Trail_vardata
(declare-fun lib_trail_trail_Trail_vardata (lib_trail_trail) (creusotcontracts_std1_vec_vec (tuple2 uint64
  lib_trail_reason)))

;; creusotcontracts_logic_ghost_ghost
(declare-fun creusotcontracts_logic_ghost_ghost (ty) ty)

;; CreusotContracts_Logic_Ghost_Ghost
(declare-fun CreusotContracts_Logic_Ghost_Ghost (ty
  opaque_ptr) uni)

;; CreusotContracts_Logic_Ghost_Ghost_sort
(assert
  (forall ((t ty))
    (forall ((x opaque_ptr))
      (sort
        (creusotcontracts_logic_ghost_ghost t)
        (CreusotContracts_Logic_Ghost_Ghost t x)))))

;; CreusotContracts_Logic_Ghost_Ghost_proj_1
(declare-fun CreusotContracts_Logic_Ghost_Ghost_proj_1 (ty
  uni) opaque_ptr)

;; CreusotContracts_Logic_Ghost_Ghost_proj_1'def
(assert
  (forall ((t ty))
    (forall ((u opaque_ptr))
      (= (CreusotContracts_Logic_Ghost_Ghost_proj_1
           t
           (CreusotContracts_Logic_Ghost_Ghost t u)) u))))

;; creusotcontracts_logic_ghost_ghost_inversion
(assert
  (forall ((t ty))
    (forall ((u uni))
      (=>
        (sort (creusotcontracts_logic_ghost_ghost t) u)
        (= u (CreusotContracts_Logic_Ghost_Ghost
               t
               (CreusotContracts_Logic_Ghost_Ghost_proj_1 t u)))))))

(declare-sort lib_formula_satstate 0)

;; lib_formula_satstate
(declare-fun lib_formula_satstate1 () ty)

;; Lib_Formula_SatState_Unknown
(declare-fun Lib_Formula_SatState_Unknown () lib_formula_satstate)

;; Lib_Formula_SatState_Sat
(declare-fun Lib_Formula_SatState_Sat () lib_formula_satstate)

;; Lib_Formula_SatState_Unsat
(declare-fun Lib_Formula_SatState_Unsat () lib_formula_satstate)

;; match_lib_formula_satstate
(declare-fun match_lib_formula_satstate (ty
  lib_formula_satstate
  uni
  uni
  uni) uni)

;; match_lib_formula_satstate_sort
(assert
  (forall ((a ty))
    (forall ((x lib_formula_satstate) (x1 uni) (x2 uni) (x3 uni))
      (sort a (match_lib_formula_satstate a x x1 x2 x3)))))

;; match_lib_formula_satstate_Lib_Formula_SatState_Unknown
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni))
      (=>
        (sort a z)
        (= (match_lib_formula_satstate
             a
             Lib_Formula_SatState_Unknown
             z
             z1
             z2) z)))))

;; match_lib_formula_satstate_Lib_Formula_SatState_Sat
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni))
      (=>
        (sort a z1)
        (= (match_lib_formula_satstate a Lib_Formula_SatState_Sat z z1 z2) z1)))))

;; match_lib_formula_satstate_Lib_Formula_SatState_Unsat
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni))
      (=>
        (sort a z2)
        (= (match_lib_formula_satstate a Lib_Formula_SatState_Unsat z z1 z2) z2)))))

;; index_lib_formula_satstate
(declare-fun index_lib_formula_satstate (lib_formula_satstate) Int)

;; index_lib_formula_satstate_Lib_Formula_SatState_Unknown
(assert (= (index_lib_formula_satstate Lib_Formula_SatState_Unknown) 0))

;; index_lib_formula_satstate_Lib_Formula_SatState_Sat
(assert (= (index_lib_formula_satstate Lib_Formula_SatState_Sat) 1))

;; index_lib_formula_satstate_Lib_Formula_SatState_Unsat
(assert (= (index_lib_formula_satstate Lib_Formula_SatState_Unsat) 2))

;; lib_formula_satstate_inversion
(assert
  (forall ((u lib_formula_satstate))
    (or
      (or (= u Lib_Formula_SatState_Unknown) (= u Lib_Formula_SatState_Sat))
      (= u Lib_Formula_SatState_Unsat))))

(declare-sort lib_watches_watcher 0)

;; lib_watches_watcher
(declare-fun lib_watches_watcher1 () ty)

;; Lib_Watches_Watcher
(declare-fun Lib_Watches_Watcher (uint64) lib_watches_watcher)

;; Lib_Watches_Watcher_proj_1
(declare-fun Lib_Watches_Watcher_proj_1 (lib_watches_watcher) uint64)

;; Lib_Watches_Watcher_proj_1'def
(assert
  (forall ((u uint64))
    (= (Lib_Watches_Watcher_proj_1 (Lib_Watches_Watcher u)) u)))

;; lib_watches_watcher_inversion
(assert
  (forall ((u lib_watches_watcher))
    (= u (Lib_Watches_Watcher (Lib_Watches_Watcher_proj_1 u)))))

;; lib_watches_watcher_Watcher_cref
(declare-fun lib_watches_watcher_Watcher_cref (lib_watches_watcher) uint64)

(declare-sort lib_watches_watches 0)

;; lib_watches_watches
(declare-fun lib_watches_watches1 () ty)

;; Lib_Watches_Watches
(declare-fun Lib_Watches_Watches ((creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_watches_watcher))) lib_watches_watches)

;; Lib_Watches_Watches_proj_1
(declare-fun Lib_Watches_Watches_proj_1 (lib_watches_watches) (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_watches_watcher)))

;; Lib_Watches_Watches_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_watches_watcher))))
    (= (Lib_Watches_Watches_proj_1 (Lib_Watches_Watches u)) u)))

;; lib_watches_watches_inversion
(assert
  (forall ((u lib_watches_watches))
    (= u (Lib_Watches_Watches (Lib_Watches_Watches_proj_1 u)))))

;; lib_watches_watches_Watches_watches
(declare-fun lib_watches_watches_Watches_watches (lib_watches_watches) (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_watches_watcher)))

;; invariant'
(declare-fun invariantqt (lib_lit_lit
  Int) Bool)

;; model
(declare-fun model3 ((creusotcontracts_std1_vec_vec lib_lit_lit)) uni)

;; model_sort
(assert
  (forall ((x (creusotcontracts_std1_vec_vec lib_lit_lit)))
    (sort (seq1 lib_lit_lit1) (model3 x))))

;; model
(declare-fun model4 (lib_clause_clause) uni)

;; model_sort
(assert
  (forall ((x lib_clause_clause)) (sort (seq1 lib_lit_lit1) (model4 x))))

;; no_duplicate_indexes
(declare-fun no_duplicate_indexes (lib_clause_clause) Bool)

;; vars_in_range
(declare-fun vars_in_range (lib_clause_clause
  Int) Bool)

;; invariant'
(declare-fun invariantqt1 (lib_clause_clause
  Int) Bool)

;; unsat_inner
(declare-fun unsat_inner (lib_lit_lit
  (seq uint8)) Bool)

;; unsat_inner
(declare-fun unsat_inner1 (lib_clause_clause
  (seq uint8)) Bool)

;; sat_inner
(declare-fun sat_inner (lib_lit_lit
  (seq uint8)) Bool)

;; sat_inner
(declare-fun sat_inner1 (lib_clause_clause
  (seq uint8)) Bool)

;; unset
(declare-fun unset (uint8) Bool)

;; unset'def
(assert
  (forall ((v uint8)) (ite (>= (uint8qtint v) 2) (unset v) (not (unset v)))))

;; complete_inner
(declare-fun complete_inner ((seq uint8)) Bool)

;; complete_inner'def
(assert
  (forall ((a (seq uint8)))
    (=
      (complete_inner a)
      (forall ((i Int))
        (=>
          (and (<= 0 i) (< i (length1 a)))
          (not (unset (tb2t (get uint81 (t2tb1 a) i)))))))))

;; compatible_inner
(declare-fun compatible_inner ((seq uint8)
  (seq uint8)) Bool)

;; compatible_inner'def
(assert
  (forall ((a (seq uint8)) (a2 (seq uint8)))
    (=
      (compatible_inner a a2)
      (and
        (= (length1 a) (length1 a2))
        (forall ((i Int))
          (=>
            (and (<= 0 i) (< i (length1 a)))
            (or
              (unset (tb2t (get uint81 (t2tb1 a) i)))
              (= (tb2t (get uint81 (t2tb1 a) i)) (tb2t
                                                   (get uint81 (t2tb1 a2) i))))))))))

;; compatible_complete_inner
(declare-fun compatible_complete_inner ((seq uint8)
  (seq uint8)) Bool)

;; compatible_complete_inner'def
(assert
  (forall ((a (seq uint8)) (a2 (seq uint8)))
    (=
      (compatible_complete_inner a a2)
      (and (compatible_inner a a2) (complete_inner a2)))))

;; model
(declare-fun model5 ((creusotcontracts_std1_vec_vec lib_clause_clause)) uni)

;; model_sort
(assert
  (forall ((x (creusotcontracts_std1_vec_vec lib_clause_clause)))
    (sort (seq1 lib_clause_clause1) (model5 x))))

;; invariant'
(declare-fun invariantqt2 (lib_formula_formula) Bool)

;; unsat_inner
(declare-fun unsat_inner2 (lib_formula_formula
  (seq uint8)) Bool)

;; sat_inner
(declare-fun sat_inner2 (lib_formula_formula
  (seq uint8)) Bool)

;; eventually_sat_complete_inner
(declare-fun eventually_sat_complete_inner (lib_formula_formula
  (seq uint8)) Bool)

;; eventually_sat_complete_inner'def
(assert
  (forall ((self lib_formula_formula) (a (seq uint8)))
    (=
      (eventually_sat_complete_inner self a)
      (exists ((a2 (seq uint8)))
        (and
          (= (length1 a2) (to_int2
                            (lib_formula_formula_Formula_num_vars self)))
          (and (compatible_complete_inner a a2) (sat_inner2 self a2)))))))

;; assignments_invariant
(declare-fun assignments_invariant ((seq uint8)
  lib_formula_formula) Bool)

;; lemma_not_sat_formula_implies_unsat_formula
(declare-fun lemma_not_sat_formula_implies_unsat_formula (lib_formula_formula
  (seq uint8)) tuple0)

;; flip_v
(declare-fun flip_v (uint8) uint8)

;; rliteral
(declare-fun rliteral () uint8)

;; rliteral_axiom
(assert (= (uint8qtint rliteral) 1))

;; rliteral
(declare-fun rliteral1 () uint8)

;; rliteral_axiom
(assert (= (uint8qtint rliteral1) 0))

;; flip_v'def
(assert
  (forall ((v uint8))
    (ite (= (uint8qtint v) 0)
      (= (flip_v v) rliteral)
      (ite (= (uint8qtint v) 1) (= (flip_v v) rliteral1) (= (flip_v v) v)))))

;; f
(declare-fun f () lib_formula_formula)

;; a
(declare-fun a () (seq uint8))

;; ix
(declare-fun ix () Int)

;; v
(declare-fun v () uint8)

;; Requires
(assert (not (eventually_sat_complete_inner f (set1 a ix (flip_v v)))))

;; Requires
(assert (eventually_sat_complete_inner f a))

;; H
(assert (<= 0 ix))

;; H
(assert (< ix (length1 a)))

;; Goal lemma_unit_forces'vc
;; File "/Users/sarek/sat/mlcfgs/lib.mlcfg", line 2832, characters 25-42
(assert
  (not
  (exists ((a2 (seq uint8)))
    (and
      (= (length1 a2) (to_int2 (lib_formula_formula_Formula_num_vars f)))
      (and (compatible_complete_inner (set1 a ix v) a2) (sat_inner2 f a2))))))

(check-sat)
(get-info :reason-unknown)
