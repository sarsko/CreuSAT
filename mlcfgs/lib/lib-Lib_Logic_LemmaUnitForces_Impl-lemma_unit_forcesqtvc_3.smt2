;; produced by cvc4_17.drv ;;
(set-logic ALL_SUPPORTED)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

;; sort
(declare-fun sort (ty
  uni) Bool)

;; witness
(declare-fun witness (ty) uni)

;; witness_sort
(assert (forall ((a ty)) (sort a (witness a))))

;; int
(declare-fun int () ty)

;; real
(declare-fun real () ty)

(declare-sort string 0)

;; string
(declare-fun string1 () ty)

;; bool
(declare-fun bool () ty)

;; match_bool
(declare-fun match_bool (ty
  Bool
  uni
  uni) uni)

;; match_bool_sort
(assert
  (forall ((a ty))
    (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni))
      (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni))
      (=> (sort a z1) (= (match_bool a false z z1) z1)))))

;; index_bool
(declare-fun index_bool (Bool) Int)

;; index_bool_True
(assert (= (index_bool true) 0))

;; index_bool_False
(assert (= (index_bool false) 1))

;; bool_inversion
(assert (forall ((u Bool)) (or (= u true) (= u false))))

(declare-sort tuple0 0)

;; tuple0
(declare-fun tuple01 () ty)

;; Tuple0
(declare-fun Tuple0 () tuple0)

;; tuple0_inversion
(assert (forall ((u tuple0)) (= u Tuple0)))

;; CompatOrderMult
(assert
  (forall ((x Int) (y Int) (z Int))
    (=> (<= x y) (=> (<= 0 z) (<= (* x z) (* y z))))))

(declare-sort seq 1)

;; seq
(declare-fun seq1 (ty) ty)

(declare-sort uint8 0)

;; uint8
(declare-fun uint81 () ty)

;; length
(declare-fun length (ty
  uni) Int)

;; length
(declare-fun length1 ((seq uint8)) Int)

;; length_nonnegative
(assert (forall ((s (seq uint8))) (<= 0 (length1 s))))

;; length_nonnegative
(assert (forall ((a ty)) (forall ((s uni)) (<= 0 (length a s)))))

;; get
(declare-fun get (ty
  uni
  Int) uni)

;; get_sort
(assert (forall ((a ty)) (forall ((x uni) (x1 Int)) (sort a (get a x x1)))))

;; infix ==
(declare-fun infix_eqeq (ty
  uni
  uni) Bool)

;; t2tb
(declare-fun t2tb ((seq uint8)) uni)

;; t2tb_sort
(assert (forall ((x (seq uint8))) (sort (seq1 uint81) (t2tb x))))

;; tb2t
(declare-fun tb2t (uni) (seq uint8))

;; BridgeL
(assert
  (forall ((i (seq uint8))) (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
(assert
  (forall ((j uni)) (! (= (t2tb (tb2t j)) j) :pattern ((t2tb (tb2t j))) )))

;; infix =='spec
(assert
  (forall ((s1 (seq uint8)) (s2 (seq uint8)))
    (=>
      (infix_eqeq uint81 (t2tb s1) (t2tb s2))
      (= (length1 s1) (length1 s2)))))

;; infix =='spec
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (=> (infix_eqeq a s1 s2) (= (length a s1) (length a s2))))))

;; t2tb
(declare-fun t2tb1 (uint8) uni)

;; t2tb_sort
(assert (forall ((x uint8)) (sort uint81 (t2tb1 x))))

;; tb2t
(declare-fun tb2t1 (uni) uint8)

;; BridgeL
(assert
  (forall ((i uint8)) (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
(assert
  (forall ((j uni))
    (! (=> (sort uint81 j) (= (t2tb1 (tb2t1 j)) j)) :pattern ((t2tb1
                                                                (tb2t1 j))) )))

;; infix =='spec
(assert
  (forall ((s1 (seq uint8)) (s2 (seq uint8)))
    (=>
      (infix_eqeq uint81 (t2tb s1) (t2tb s2))
      (forall ((i Int))
        (=>
          (and (<= 0 i) (< i (length1 s1)))
          (= (tb2t1 (get uint81 (t2tb s1) i)) (tb2t1
                                                (get uint81 (t2tb s2) i))))))))

;; infix =='spec
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (=>
        (infix_eqeq a s1 s2)
        (forall ((i Int))
          (=>
            (and (<= 0 i) (< i (length a s1)))
            (= (get a s1 i) (get a s2 i))))))))

;; infix =='spec
(assert
  (forall ((s1 (seq uint8)) (s2 (seq uint8)))
    (=>
      (and
        (= (length1 s1) (length1 s2))
        (forall ((i Int))
          (=>
            (and (<= 0 i) (< i (length1 s1)))
            (= (tb2t1 (get uint81 (t2tb s1) i)) (tb2t1
                                                  (get uint81 (t2tb s2) i))))))
      (infix_eqeq uint81 (t2tb s1) (t2tb s2)))))

;; infix =='spec
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (=>
        (and
          (= (length a s1) (length a s2))
          (forall ((i Int))
            (=>
              (and (<= 0 i) (< i (length a s1)))
              (= (get a s1 i) (get a s2 i)))))
        (infix_eqeq a s1 s2)))))

;; infix =='spec
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni)) (=> (infix_eqeq a s1 s2) (= s1 s2)))))

;; infix ->
(declare-fun infix_mngt (ty
  ty) ty)

;; infix @
(declare-fun infix_at (ty
  ty
  uni
  uni) uni)

;; infix @_sort
(assert
  (forall ((a ty) (b ty))
    (forall ((x uni) (x1 uni)) (sort b (infix_at b a x x1)))))

;; create
(declare-fun create (ty
  Int
  uni) uni)

;; create_sort
(assert
  (forall ((a ty))
    (forall ((x Int) (x1 uni)) (sort (seq1 a) (create a x x1)))))

;; t2tb
(declare-fun t2tb2 ((Array Int uint8)) uni)

;; t2tb_sort
(assert
  (forall ((x (Array Int uint8))) (sort (infix_mngt int uint81) (t2tb2 x))))

;; tb2t
(declare-fun tb2t2 (uni) (Array Int uint8))

;; BridgeL
(assert
  (forall ((i (Array Int uint8)))
    (! (= (tb2t2 (t2tb2 i)) i) :pattern ((t2tb2 i)) )))

;; BridgeR
(assert
  (forall ((j uni))
    (! (=> (sort (infix_mngt int uint81) j) (= (t2tb2 (tb2t2 j)) j)) :pattern (
    (t2tb2
      (tb2t2 j))) )))

;; create'spec
(assert
  (forall ((len Int) (f (Array Int uint8)))
    (=> (<= 0 len) (= (length1 (tb2t (create uint81 len (t2tb2 f)))) len))))

;; create'spec
(assert
  (forall ((a ty))
    (forall ((len Int) (f uni))
      (=> (<= 0 len) (= (length a (create a len f)) len)))))

;; t2tb
(declare-fun t2tb3 (Int) uni)

;; t2tb_sort
(assert (forall ((x Int)) (sort int (t2tb3 x))))

;; tb2t
(declare-fun tb2t3 (uni) Int)

;; BridgeL
(assert (forall ((i Int)) (! (= (tb2t3 (t2tb3 i)) i) :pattern ((t2tb3 i)) )))

;; BridgeR
(assert
  (forall ((j uni))
    (! (= (t2tb3 (tb2t3 j)) j) :pattern ((t2tb3 (tb2t3 j))) )))

;; create'spec
(assert
  (forall ((a ty))
    (forall ((len Int) (f uni))
      (=>
        (<= 0 len)
        (forall ((i Int))
          (=>
            (and (<= 0 i) (< i len))
            (= (get a (create a len f) i) (infix_at a int f (t2tb3 i)))))))))

;; empty
(declare-fun empty (ty) uni)

;; empty_sort
(assert (forall ((a ty)) (sort (seq1 a) (empty a))))

;; empty'def
(assert (= (length1 (tb2t (empty uint81))) 0))

;; empty'def
(assert (forall ((a ty)) (= (length a (empty a)) 0)))

;; set
(declare-fun set (ty
  uni
  Int
  uni) uni)

;; set_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int) (x2 uni)) (sort (seq1 a) (set a x x1 x2)))))

;; set
(declare-fun set1 ((seq uint8)
  Int
  uint8) (seq uint8))

;; result
(declare-fun result (ty
  uni
  Int
  uni) uni)

;; result_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int) (x2 uni))
      (sort (infix_mngt int a) (result a x x1 x2)))))

;; result'def
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (v uni) (j Int))
      (=>
        (sort a v)
        (= (infix_at a int (result a s i v) (t2tb3 j)) (ite (= j i)
                                                         v
                                                         (get a s j)))))))

;; set'def
(assert
  (forall ((s (seq uint8)) (i Int) (v uint8))
    (=>
      (and (<= 0 i) (< i (length1 s)))
      (= (set1 s i v) (tb2t
                        (create
                          uint81
                          (length1 s)
                          (result uint81 (t2tb s) i (t2tb1 v))))))))

;; set'def
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (v uni))
      (=>
        (and (<= 0 i) (< i (length a s)))
        (= (set a s i v) (create a (length a s) (result a s i v)))))))

;; set'spec
(assert
  (forall ((s (seq uint8)) (i Int) (v uint8))
    (=>
      (and (<= 0 i) (< i (length1 s)))
      (= (length1 (set1 s i v)) (length1 s)))))

;; set'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (v uni))
      (=>
        (and (<= 0 i) (< i (length a s)))
        (= (length a (set a s i v)) (length a s))))))

;; set'spec
(assert
  (forall ((s (seq uint8)) (i Int) (v uint8))
    (=>
      (and (<= 0 i) (< i (length1 s)))
      (= (tb2t1 (get uint81 (t2tb (set1 s i v)) i)) v))))

;; set'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (v uni))
      (=>
        (sort a v)
        (=> (and (<= 0 i) (< i (length a s))) (= (get a (set a s i v) i) v))))))

;; set'spec
(assert
  (forall ((s (seq uint8)) (i Int) (v uint8))
    (=>
      (and (<= 0 i) (< i (length1 s)))
      (forall ((j Int))
        (=>
          (and (and (<= 0 j) (< j (length1 s))) (not (= j i)))
          (= (tb2t1 (get uint81 (t2tb (set1 s i v)) j)) (tb2t1
                                                          (get
                                                            uint81
                                                            (t2tb s)
                                                            j))))))))

;; set'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (v uni))
      (=>
        (and (<= 0 i) (< i (length a s)))
        (forall ((j Int))
          (=>
            (and (and (<= 0 j) (< j (length a s))) (not (= j i)))
            (= (get a (set a s i v) j) (get a s j))))))))

;; mixfix [<-]
(declare-fun mixfix_lblsmnrb (ty
  uni
  Int
  uni) uni)

;; mixfix [<-]_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int) (x2 uni))
      (sort (seq1 a) (mixfix_lblsmnrb a x x1 x2)))))

;; mixfix [<-]'def
(assert
  (forall ((s (seq uint8)) (i Int) (v uint8))
    (=>
      (and (<= 0 i) (< i (length1 s)))
      (= (tb2t (mixfix_lblsmnrb uint81 (t2tb s) i (t2tb1 v))) (set1 s i v)))))

;; mixfix [<-]'def
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (v uni))
      (=>
        (and (<= 0 i) (< i (length a s)))
        (= (mixfix_lblsmnrb a s i v) (set a s i v))))))

;; singleton
(declare-fun singleton1 (ty
  uni) uni)

;; singleton_sort
(assert
  (forall ((a ty)) (forall ((x uni)) (sort (seq1 a) (singleton1 a x)))))

;; result
(declare-fun result1 (ty
  uni) uni)

;; result_sort
(assert
  (forall ((a ty))
    (forall ((x uni)) (sort (infix_mngt int a) (result1 a x)))))

;; result'def
(assert
  (forall ((a ty))
    (forall ((v uni) (us Int))
      (=> (sort a v) (= (infix_at a int (result1 a v) (t2tb3 us)) v)))))

;; singleton'def
(assert
  (forall ((a ty))
    (forall ((v uni)) (= (singleton1 a v) (create a 1 (result1 a v))))))

;; singleton'spec
(assert
  (forall ((v uint8)) (= (length1 (tb2t (singleton1 uint81 (t2tb1 v)))) 1)))

;; singleton'spec
(assert
  (forall ((a ty)) (forall ((v uni)) (= (length a (singleton1 a v)) 1))))

;; singleton'spec
(assert
  (forall ((a ty))
    (forall ((v uni)) (=> (sort a v) (= (get a (singleton1 a v) 0) v)))))

;; cons
(declare-fun cons (ty
  uni
  uni) uni)

;; cons_sort
(assert
  (forall ((a ty)) (forall ((x uni) (x1 uni)) (sort (seq1 a) (cons a x x1)))))

;; result
(declare-fun result2 (ty
  uni
  uni) uni)

;; result_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (infix_mngt int a) (result2 a x x1)))))

;; result'def
(assert
  (forall ((a ty))
    (forall ((x uni) (s uni) (i Int))
      (=>
        (sort a x)
        (= (infix_at a int (result2 a x s) (t2tb3 i)) (ite (= i 0)
                                                        x
                                                        (get a s (- i 1))))))))

;; cons'def
(assert
  (forall ((x uint8) (s (seq uint8)))
    (= (tb2t (cons uint81 (t2tb1 x) (t2tb s))) (tb2t
                                                 (create
                                                   uint81
                                                   (+ 1 (length1 s))
                                                   (result2
                                                     uint81
                                                     (t2tb1 x)
                                                     (t2tb s)))))))

;; cons'def
(assert
  (forall ((a ty))
    (forall ((x uni) (s uni))
      (= (cons a x s) (create a (+ 1 (length a s)) (result2 a x s))))))

;; cons'spec
(assert
  (forall ((x uint8) (s (seq uint8)))
    (= (length1 (tb2t (cons uint81 (t2tb1 x) (t2tb s)))) (+ 1 (length1 s)))))

;; cons'spec
(assert
  (forall ((a ty))
    (forall ((x uni) (s uni)) (= (length a (cons a x s)) (+ 1 (length a s))))))

;; cons'spec
(assert
  (forall ((a ty))
    (forall ((x uni) (s uni)) (=> (sort a x) (= (get a (cons a x s) 0) x)))))

;; cons'spec
(assert
  (forall ((x uint8) (s (seq uint8)))
    (forall ((i Int))
      (=>
        (and (< 0 i) (<= i (length1 s)))
        (= (tb2t1 (get uint81 (cons uint81 (t2tb1 x) (t2tb s)) i)) (tb2t1
                                                                    (get
                                                                    uint81
                                                                    (t2tb s)
                                                                    (- i 1))))))))

;; cons'spec
(assert
  (forall ((a ty))
    (forall ((x uni) (s uni))
      (forall ((i Int))
        (=>
          (and (< 0 i) (<= i (length a s)))
          (= (get a (cons a x s) i) (get a s (- i 1))))))))

;; snoc
(declare-fun snoc (ty
  uni
  uni) uni)

;; snoc_sort
(assert
  (forall ((a ty)) (forall ((x uni) (x1 uni)) (sort (seq1 a) (snoc a x x1)))))

;; result
(declare-fun result3 (ty
  uni
  uni) uni)

;; result_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (infix_mngt int a) (result3 a x x1)))))

;; result'def
(assert
  (forall ((s (seq uint8)) (x uint8) (i Int))
    (= (tb2t1
         (infix_at uint81 int (result3 uint81 (t2tb s) (t2tb1 x)) (t2tb3 i))) 
    (ite (= i (length1 s))
      x
      (tb2t1 (get uint81 (t2tb s) i))))))

;; result'def
(assert
  (forall ((a ty))
    (forall ((s uni) (x uni) (i Int))
      (=>
        (sort a x)
        (= (infix_at a int (result3 a s x) (t2tb3 i)) (ite (= i (length a s))
                                                        x
                                                        (get a s i)))))))

;; snoc'def
(assert
  (forall ((s (seq uint8)) (x uint8))
    (= (tb2t (snoc uint81 (t2tb s) (t2tb1 x))) (tb2t
                                                 (create
                                                   uint81
                                                   (+ 1 (length1 s))
                                                   (result3
                                                     uint81
                                                     (t2tb s)
                                                     (t2tb1 x)))))))

;; snoc'def
(assert
  (forall ((a ty))
    (forall ((s uni) (x uni))
      (= (snoc a s x) (create a (+ 1 (length a s)) (result3 a s x))))))

;; snoc'spec
(assert
  (forall ((s (seq uint8)) (x uint8))
    (= (length1 (tb2t (snoc uint81 (t2tb s) (t2tb1 x)))) (+ 1 (length1 s)))))

;; snoc'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (x uni)) (= (length a (snoc a s x)) (+ 1 (length a s))))))

;; snoc'spec
(assert
  (forall ((s (seq uint8)) (x uint8))
    (= (tb2t1 (get uint81 (snoc uint81 (t2tb s) (t2tb1 x)) (length1 s))) x)))

;; snoc'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (x uni))
      (=> (sort a x) (= (get a (snoc a s x) (length a s)) x)))))

;; snoc'spec
(assert
  (forall ((s (seq uint8)) (x uint8))
    (forall ((i Int))
      (=>
        (and (<= 0 i) (< i (length1 s)))
        (= (tb2t1 (get uint81 (snoc uint81 (t2tb s) (t2tb1 x)) i)) (tb2t1
                                                                    (get
                                                                    uint81
                                                                    (t2tb s)
                                                                    i)))))))

;; snoc'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (x uni))
      (forall ((i Int))
        (=>
          (and (<= 0 i) (< i (length a s)))
          (= (get a (snoc a s x) i) (get a s i)))))))

;; mixfix [..]
(declare-fun mixfix_lbdtdtrb (ty
  uni
  Int
  Int) uni)

;; mixfix [..]_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int) (x2 Int))
      (sort (seq1 a) (mixfix_lbdtdtrb a x x1 x2)))))

;; result
(declare-fun result4 (ty
  uni
  Int) uni)

;; result_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int)) (sort (infix_mngt int a) (result4 a x x1)))))

;; result'def
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (k Int))
      (= (infix_at a int (result4 a s i) (t2tb3 k)) (get a s (+ i k))))))

;; mixfix [..]'def
(assert
  (forall ((s (seq uint8)) (i Int) (j Int))
    (=>
      (and (<= 0 i) (and (<= i j) (<= j (length1 s))))
      (= (tb2t (mixfix_lbdtdtrb uint81 (t2tb s) i j)) (tb2t
                                                        (create
                                                          uint81
                                                          (- j i)
                                                          (result4
                                                            uint81
                                                            (t2tb s)
                                                            i)))))))

;; mixfix [..]'def
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (j Int))
      (=>
        (and (<= 0 i) (and (<= i j) (<= j (length a s))))
        (= (mixfix_lbdtdtrb a s i j) (create a (- j i) (result4 a s i)))))))

;; mixfix [..]'spec
(assert
  (forall ((s (seq uint8)) (i Int) (j Int))
    (=>
      (and (<= 0 i) (and (<= i j) (<= j (length1 s))))
      (= (length1 (tb2t (mixfix_lbdtdtrb uint81 (t2tb s) i j))) (- j i)))))

;; mixfix [..]'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (j Int))
      (=>
        (and (<= 0 i) (and (<= i j) (<= j (length a s))))
        (= (length a (mixfix_lbdtdtrb a s i j)) (- j i))))))

;; mixfix [..]'spec
(assert
  (forall ((s (seq uint8)) (i Int) (j Int))
    (=>
      (and (<= 0 i) (and (<= i j) (<= j (length1 s))))
      (forall ((k Int))
        (=>
          (and (<= 0 k) (< k (- j i)))
          (= (tb2t1 (get uint81 (mixfix_lbdtdtrb uint81 (t2tb s) i j) k)) 
          (tb2t1
            (get uint81 (t2tb s) (+ i k)))))))))

;; mixfix [..]'spec
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int) (j Int))
      (=>
        (and (<= 0 i) (and (<= i j) (<= j (length a s))))
        (forall ((k Int))
          (=>
            (and (<= 0 k) (< k (- j i)))
            (= (get a (mixfix_lbdtdtrb a s i j) k) (get a s (+ i k)))))))))

;; mixfix [_..]
(declare-fun mixfix_lb_dtdtrb (ty
  uni
  Int) uni)

;; mixfix [_..]_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int)) (sort (seq1 a) (mixfix_lb_dtdtrb a x x1)))))

;; mixfix [_..]'def
(assert
  (forall ((s (seq uint8)) (i Int))
    (=>
      (and (<= 0 i) (<= i (length1 s)))
      (= (tb2t (mixfix_lb_dtdtrb uint81 (t2tb s) i)) (tb2t
                                                       (mixfix_lbdtdtrb
                                                         uint81
                                                         (t2tb s)
                                                         i
                                                         (length1 s)))))))

;; mixfix [_..]'def
(assert
  (forall ((a ty))
    (forall ((s uni) (i Int))
      (=>
        (and (<= 0 i) (<= i (length a s)))
        (= (mixfix_lb_dtdtrb a s i) (mixfix_lbdtdtrb a s i (length a s)))))))

;; mixfix [.._]
(declare-fun mixfix_lbdtdt_rb (ty
  uni
  Int) uni)

;; mixfix [.._]_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 Int)) (sort (seq1 a) (mixfix_lbdtdt_rb a x x1)))))

;; mixfix [.._]'def
(assert
  (forall ((s (seq uint8)) (j Int))
    (=>
      (and (<= 0 j) (<= j (length1 s)))
      (= (tb2t (mixfix_lbdtdt_rb uint81 (t2tb s) j)) (tb2t
                                                       (mixfix_lbdtdtrb
                                                         uint81
                                                         (t2tb s)
                                                         0
                                                         j))))))

;; mixfix [.._]'def
(assert
  (forall ((a ty))
    (forall ((s uni) (j Int))
      (=>
        (and (<= 0 j) (<= j (length a s)))
        (= (mixfix_lbdtdt_rb a s j) (mixfix_lbdtdtrb a s 0 j))))))

;; infix ++
(declare-fun infix_plpl (ty
  uni
  uni) uni)

;; infix ++_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (seq1 a) (infix_plpl a x x1)))))

;; result
(declare-fun result5 (ty
  uni
  uni
  Int) uni)

;; result_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni) (x2 Int))
      (sort (infix_mngt int a) (result5 a x x1 x2)))))

;; result'def
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni) (l Int) (i Int))
      (= (infix_at a int (result5 a s1 s2 l) (t2tb3 i)) (ite (< i l)
                                                          (get a s1 i)
                                                          (get a s2 (- i l)))))))

;; infix ++'def
(assert
  (forall ((s1 (seq uint8)) (s2 (seq uint8)))
    (let ((l (length1 s1)))
      (= (tb2t (infix_plpl uint81 (t2tb s1) (t2tb s2))) (tb2t
                                                          (create
                                                            uint81
                                                            (+ l (length1 s2))
                                                            (result5
                                                              uint81
                                                              (t2tb s1)
                                                              (t2tb s2)
                                                              l)))))))

;; infix ++'def
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (let ((l (length a s1)))
        (= (infix_plpl a s1 s2) (create
                                  a
                                  (+ l (length a s2))
                                  (result5 a s1 s2 l)))))))

;; infix ++'spec
(assert
  (forall ((s1 (seq uint8)) (s2 (seq uint8)))
    (= (length1 (tb2t (infix_plpl uint81 (t2tb s1) (t2tb s2)))) (+ (length1
                                                                    s1) 
    (length1
      s2)))))

;; infix ++'spec
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (= (length a (infix_plpl a s1 s2)) (+ (length a s1) (length a s2))))))

;; infix ++'spec
(assert
  (forall ((s1 (seq uint8)) (s2 (seq uint8)))
    (forall ((i Int))
      (=>
        (and (<= 0 i) (< i (length1 s1)))
        (= (tb2t1 (get uint81 (infix_plpl uint81 (t2tb s1) (t2tb s2)) i)) 
        (tb2t1
          (get uint81 (t2tb s1) i)))))))

;; infix ++'spec
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (forall ((i Int))
        (=>
          (and (<= 0 i) (< i (length a s1)))
          (= (get a (infix_plpl a s1 s2) i) (get a s1 i)))))))

;; infix ++'spec
(assert
  (forall ((s1 (seq uint8)) (s2 (seq uint8)))
    (forall ((i Int))
      (=>
        (and
          (<= (length1 s1) i)
          (< i (length1 (tb2t (infix_plpl uint81 (t2tb s1) (t2tb s2))))))
        (= (tb2t1 (get uint81 (infix_plpl uint81 (t2tb s1) (t2tb s2)) i)) 
        (tb2t1
          (get uint81 (t2tb s2) (- i (length1 s1)))))))))

;; infix ++'spec
(assert
  (forall ((a ty))
    (forall ((s1 uni) (s2 uni))
      (forall ((i Int))
        (=>
          (and (<= (length a s1) i) (< i (length a (infix_plpl a s1 s2))))
          (= (get a (infix_plpl a s1 s2) i) (get a s2 (- i (length a s1)))))))))

;; abs
(declare-fun abs1 (Int) Int)

;; abs'def
(assert (forall ((x Int)) (ite (<= 0 x) (= (abs1 x) x) (= (abs1 x) (- x)))))

;; Abs_le
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= (- y) x))))

;; Abs_le
(assert (forall ((x Int) (y Int)) (=> (<= (abs1 x) y) (<= x y))))

;; Abs_le
(assert
  (forall ((x Int) (y Int)) (=> (and (<= (- y) x) (<= x y)) (<= (abs1 x) y))))

;; Abs_pos
(assert (forall ((x Int)) (<= 0 (abs1 x))))

;; div
(declare-fun div1 (Int
  Int) Int)

;; mod
(declare-fun mod1 (Int
  Int) Int)

;; Div_mod
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (= x (+ (* y (div1 x y)) (mod1 x y))))))

;; Div_bound
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; Div_bound
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= (div1 x y) x))))

;; Mod_bound
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (- (abs1 y)) (mod1 x y)))))

;; Mod_bound
(assert
  (forall ((x Int) (y Int)) (=> (not (= y 0)) (< (mod1 x y) (abs1 y)))))

;; Div_sign_pos
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< 0 y)) (<= 0 (div1 x y)))))

;; Div_sign_neg
(assert
  (forall ((x Int) (y Int)) (=> (and (<= x 0) (< 0 y)) (<= (div1 x y) 0))))

;; Mod_sign_pos
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= 0 x) (not (= y 0))) (<= 0 (mod1 x y)))))

;; Mod_sign_neg
(assert
  (forall ((x Int) (y Int))
    (=> (and (<= x 0) (not (= y 0))) (<= (mod1 x y) 0))))

;; Rounds_toward_zero
(assert
  (forall ((x Int) (y Int))
    (=> (not (= y 0)) (<= (abs1 (* (div1 x y) y)) (abs1 x)))))

;; Div_1
(assert (forall ((x Int)) (= (div1 x 1) x)))

;; Mod_1
(assert (forall ((x Int)) (= (mod1 x 1) 0)))

;; Div_inf
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (div1 x y) 0))))

;; Mod_inf
(assert
  (forall ((x Int) (y Int)) (=> (and (<= 0 x) (< x y)) (= (mod1 x y) x))))

;; Div_mult
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (div1 (+ (* x y) z) x) (+ y (div1 z x)))) :pattern ((div1
                                                                  (+ (* x y) z)
                                                                  x)) )))

;; Mod_mult
(assert
  (forall ((x Int) (y Int) (z Int))
    (! (=>
         (and (< 0 x) (and (<= 0 y) (<= 0 z)))
         (= (mod1 (+ (* x y) z) x) (mod1 z x))) :pattern ((mod1
                                                            (+ (* x y) z)
                                                            x)) )))

(declare-sort int32 0)

;; int32
(declare-fun int321 () ty)

;; int32'int
(declare-fun int32qtint (int32) Int)

;; int32'axiom
(assert
  (forall ((i int32))
    (and (<= (- 2147483648) (int32qtint i)) (<= (int32qtint i) 2147483647))))

;; in_bounds
(declare-fun in_bounds (Int) Bool)

;; in_bounds'def
(assert
  (forall ((n Int))
    (= (in_bounds n) (and (<= (- 2147483648) n) (<= n 2147483647)))))

;; to_int_in_bounds
(assert (forall ((n int32)) (in_bounds (int32qtint n))))

;; extensionality
(assert
  (forall ((x int32) (y int32))
    (=> (= (int32qtint x) (int32qtint y)) (= x y))))

(declare-sort uint64 0)

;; uint64
(declare-fun uint641 () ty)

;; uint64'int
(declare-fun uint64qtint (uint64) Int)

;; uint64'axiom
(assert
  (forall ((i uint64))
    (and (<= 0 (uint64qtint i)) (<= (uint64qtint i) 18446744073709551615))))

;; in_bounds
(declare-fun in_bounds1 (Int) Bool)

;; in_bounds'def
(assert
  (forall ((n Int))
    (= (in_bounds1 n) (and (<= 0 n) (<= n 18446744073709551615)))))

;; to_int_in_bounds
(assert (forall ((n uint64)) (in_bounds1 (uint64qtint n))))

;; extensionality
(assert
  (forall ((x uint64) (y uint64))
    (=> (= (uint64qtint x) (uint64qtint y)) (= x y))))

;; zero_unsigned
(declare-fun zero_unsigned () uint64)

;; zero_unsigned_is_zero
(assert (= (uint64qtint zero_unsigned) 0))

;; ref
(declare-fun ref (ty) ty)

;; ref'mk
(declare-fun refqtmk (ty
  uni) uni)

;; ref'mk_sort
(assert (forall ((a ty)) (forall ((x uni)) (sort (ref a) (refqtmk a x)))))

;; contents
(declare-fun contents (ty
  uni) uni)

;; contents_sort
(assert (forall ((a ty)) (forall ((x uni)) (sort a (contents a x)))))

;; contents'def
(assert
  (forall ((a ty))
    (forall ((u uni)) (=> (sort a u) (= (contents a (refqtmk a u)) u)))))

;; ref_inversion
(assert
  (forall ((a ty))
    (forall ((u uni)) (=> (sort (ref a) u) (= u (refqtmk a (contents a u)))))))

(declare-sort int8 0)

;; int8
(declare-fun int81 () ty)

;; int8'int
(declare-fun int8qtint (int8) Int)

;; int8'axiom
(assert
  (forall ((i int8)) (and (<= (- 128) (int8qtint i)) (<= (int8qtint i) 127))))

;; in_bounds
(declare-fun in_bounds2 (Int) Bool)

;; in_bounds'def
(assert
  (forall ((n Int)) (= (in_bounds2 n) (and (<= (- 128) n) (<= n 127)))))

;; to_int_in_bounds
(assert (forall ((n int8)) (in_bounds2 (int8qtint n))))

;; extensionality
(assert
  (forall ((x int8) (y int8)) (=> (= (int8qtint x) (int8qtint y)) (= x y))))

(declare-sort int16 0)

;; int16
(declare-fun int161 () ty)

;; int16'int
(declare-fun int16qtint (int16) Int)

;; int16'axiom
(assert
  (forall ((i int16))
    (and (<= (- 32768) (int16qtint i)) (<= (int16qtint i) 32767))))

;; in_bounds
(declare-fun in_bounds3 (Int) Bool)

;; in_bounds'def
(assert
  (forall ((n Int)) (= (in_bounds3 n) (and (<= (- 32768) n) (<= n 32767)))))

;; to_int_in_bounds
(assert (forall ((n int16)) (in_bounds3 (int16qtint n))))

;; extensionality
(assert
  (forall ((x int16) (y int16))
    (=> (= (int16qtint x) (int16qtint y)) (= x y))))

(declare-sort int64 0)

;; int64
(declare-fun int641 () ty)

;; int64'int
(declare-fun int64qtint (int64) Int)

;; int64'axiom
(assert
  (forall ((i int64))
    (and
      (<= (- 9223372036854775808) (int64qtint i))
      (<= (int64qtint i) 9223372036854775807))))

;; in_bounds
(declare-fun in_bounds4 (Int) Bool)

;; in_bounds'def
(assert
  (forall ((n Int))
    (=
      (in_bounds4 n)
      (and (<= (- 9223372036854775808) n) (<= n 9223372036854775807)))))

;; to_int_in_bounds
(assert (forall ((n int64)) (in_bounds4 (int64qtint n))))

;; extensionality
(assert
  (forall ((x int64) (y int64))
    (=> (= (int64qtint x) (int64qtint y)) (= x y))))

;; uint8'int
(declare-fun uint8qtint (uint8) Int)

;; uint8'axiom
(assert
  (forall ((i uint8)) (and (<= 0 (uint8qtint i)) (<= (uint8qtint i) 255))))

;; in_bounds
(declare-fun in_bounds5 (Int) Bool)

;; in_bounds'def
(assert (forall ((n Int)) (= (in_bounds5 n) (and (<= 0 n) (<= n 255)))))

;; to_int_in_bounds
(assert (forall ((n uint8)) (in_bounds5 (uint8qtint n))))

;; extensionality
(assert
  (forall ((x uint8) (y uint8))
    (=> (= (uint8qtint x) (uint8qtint y)) (= x y))))

(declare-sort uint16 0)

;; uint16
(declare-fun uint161 () ty)

;; uint16'int
(declare-fun uint16qtint (uint16) Int)

;; uint16'axiom
(assert
  (forall ((i uint16))
    (and (<= 0 (uint16qtint i)) (<= (uint16qtint i) 65535))))

;; in_bounds
(declare-fun in_bounds6 (Int) Bool)

;; in_bounds'def
(assert (forall ((n Int)) (= (in_bounds6 n) (and (<= 0 n) (<= n 65535)))))

;; to_int_in_bounds
(assert (forall ((n uint16)) (in_bounds6 (uint16qtint n))))

;; extensionality
(assert
  (forall ((x uint16) (y uint16))
    (=> (= (uint16qtint x) (uint16qtint y)) (= x y))))

(declare-sort uint32 0)

;; uint32
(declare-fun uint321 () ty)

;; uint32'int
(declare-fun uint32qtint (uint32) Int)

;; uint32'axiom
(assert
  (forall ((i uint32))
    (and (<= 0 (uint32qtint i)) (<= (uint32qtint i) 4294967295))))

;; in_bounds
(declare-fun in_bounds7 (Int) Bool)

;; in_bounds'def
(assert
  (forall ((n Int)) (= (in_bounds7 n) (and (<= 0 n) (<= n 4294967295)))))

;; to_int_in_bounds
(assert (forall ((n uint32)) (in_bounds7 (uint32qtint n))))

;; extensionality
(assert
  (forall ((x uint32) (y uint32))
    (=> (= (uint32qtint x) (uint32qtint y)) (= x y))))

;; zero_unsigned
(declare-fun zero_unsigned1 () uint32)

;; zero_unsigned_is_zero
(assert (= (uint32qtint zero_unsigned1) 0))

;; concat
(declare-fun concat1 (string
  string) string)

;; concat_assoc
(assert
  (forall ((s1 string) (s2 string) (s3 string))
    (= (concat1 (concat1 s1 s2) s3) (concat1 s1 (concat1 s2 s3)))))

;; rliteral
(declare-fun rliteral () string)

;; rliteral_axiom
(assert true)

;; concat_empty
(assert (forall ((s string)) (= (concat1 s rliteral) (concat1 rliteral s))))

;; concat_empty
(assert (forall ((s string)) (= (concat1 rliteral s) s)))

;; length
(declare-fun length2 (string) Int)

;; length_empty
(assert (= (length2 rliteral) 0))

;; length_concat
(assert
  (forall ((s1 string) (s2 string))
    (= (length2 (concat1 s1 s2)) (+ (length2 s1) (length2 s2)))))

;; lt
(declare-fun lt (string
  string) Bool)

;; lt_empty
(assert (forall ((s string)) (=> (not (= s rliteral)) (lt rliteral s))))

;; lt_not_com
(assert (forall ((s1 string) (s2 string)) (=> (lt s1 s2) (not (lt s2 s1)))))

;; lt_ref
(assert (forall ((s1 string)) (not (lt s1 s1))))

;; lt_trans
(assert
  (forall ((s1 string) (s2 string) (s3 string))
    (=> (and (lt s1 s2) (lt s2 s3)) (lt s1 s3))))

;; le
(declare-fun le (string
  string) Bool)

;; le_empty
(assert (forall ((s string)) (le rliteral s)))

;; le_ref
(assert (forall ((s1 string)) (le s1 s1)))

;; lt_le
(assert (forall ((s1 string) (s2 string)) (=> (lt s1 s2) (le s1 s2))))

;; lt_le_eq
(assert
  (forall ((s1 string) (s2 string))
    (=> (le s1 s2) (or (lt s1 s2) (= s1 s2)))))

;; le_trans
(assert
  (forall ((s1 string) (s2 string) (s3 string))
    (=> (and (le s1 s2) (le s2 s3)) (le s1 s3))))

;; s_at
(declare-fun s_at (string
  Int) string)

;; at_out_of_range
(assert (forall ((s string) (i Int)) (=> (< i 0) (= (s_at s i) rliteral))))

;; at_out_of_range
(assert
  (forall ((s string) (i Int))
    (=> (<= (length2 s) i) (= (s_at s i) rliteral))))

;; at_empty
(assert (forall ((i Int)) (= (s_at rliteral i) rliteral)))

;; at_length
(assert
  (forall ((s string) (i Int))
    (=> (and (<= 0 i) (< i (length2 s))) (= (length2 (s_at s i)) 1))))

;; at_length
(assert
  (forall ((s string) (i Int))
    (=> (not (<= 0 i)) (= (length2 (s_at s i)) 0))))

;; at_length
(assert
  (forall ((s string) (i Int))
    (=> (not (< i (length2 s))) (= (length2 (s_at s i)) 0))))

;; concat_at
(assert
  (forall ((s1 string) (s2 string))
    (forall ((i Int))
      (=>
        (and (<= 0 i) (< i (length2 s1)))
        (= (s_at (concat1 s1 s2) i) (s_at s1 i))))))

;; concat_at
(assert
  (forall ((s1 string) (s2 string))
    (let ((s (concat1 s1 s2)))
      (forall ((i Int))
        (=>
          (and (<= (length2 s1) i) (< i (length2 s)))
          (= (s_at s i) (s_at s2 (- i (length2 s1)))))))))

;; substring
(declare-fun substring (string
  Int
  Int) string)

;; substring_out_of_range
(assert
  (forall ((s string) (i Int) (x Int))
    (=> (< i 0) (= (substring s i x) rliteral))))

;; substring_out_of_range
(assert
  (forall ((s string) (i Int) (x Int))
    (=> (<= (length2 s) i) (= (substring s i x) rliteral))))

;; substring_of_length_zero_or_less
(assert
  (forall ((s string) (i Int) (x Int))
    (=> (<= x 0) (= (substring s i x) rliteral))))

;; substring_of_empty
(assert (forall ((i Int) (x Int)) (= (substring rliteral i x) rliteral)))

;; substring_smaller
(assert
  (forall ((s string) (i Int) (x Int))
    (<= (length2 (substring s i x)) (length2 s))))

;; substring_smaller_x
(assert
  (forall ((s string) (i Int) (x Int))
    (=> (<= 0 x) (<= (length2 (substring s i x)) x))))

;; substring_length
(assert
  (forall ((s string) (i Int) (x Int))
    (=>
      (and (<= 0 x) (and (<= 0 i) (< i (length2 s))))
      (=>
        (< (length2 s) (+ i x))
        (= (length2 (substring s i x)) (- (length2 s) i))))))

;; substring_length
(assert
  (forall ((s string) (i Int) (x Int))
    (=>
      (and (<= 0 x) (and (<= 0 i) (< i (length2 s))))
      (=> (not (< (length2 s) (+ i x))) (= (length2 (substring s i x)) x)))))

;; substring_at
(assert (forall ((s string) (i Int)) (= (s_at s i) (substring s i 1))))

;; substring_substring
(assert
  (forall ((s string) (ofs Int) (len Int) (ofsqt Int) (lenqt Int))
    (=>
      (and (<= 0 ofs) (<= ofs (length2 s)))
      (=>
        (<= 0 len)
        (=>
          (<= (+ ofs len) (length2 s))
          (=>
            (and (<= 0 ofsqt) (<= ofsqt len))
            (=>
              (<= 0 lenqt)
              (=>
                (<= (+ ofsqt lenqt) len)
                (= (substring (substring s ofs len) ofsqt lenqt) (substring
                                                                   s
                                                                   (+ ofs ofsqt)
                                                                   lenqt))))))))))

;; concat_substring
(assert
  (forall ((s string) (ofs Int) (len Int) (lenqt Int))
    (=>
      (and (<= 0 ofs) (<= ofs (length2 s)))
      (=>
        (<= 0 len)
        (=>
          (<= (+ ofs len) (length2 s))
          (=>
            (<= 0 lenqt)
            (=>
              (and
                (<= 0 (+ (+ ofs len) lenqt))
                (<= (+ (+ ofs len) lenqt) (length2 s)))
              (= (concat1
                   (substring s ofs len)
                   (substring s (+ ofs len) lenqt)) (substring
                                                      s
                                                      ofs
                                                      (+ len lenqt))))))))))

;; prefixof
(declare-fun prefixof (string
  string) Bool)

;; prefixof_substring
(assert
  (forall ((s1 string) (s2 string))
    (=> (prefixof s1 s2) (= s1 (substring s2 0 (length2 s1))))))

;; prefixof_substring
(assert
  (forall ((s1 string) (s2 string))
    (=> (= s1 (substring s2 0 (length2 s1))) (prefixof s1 s2))))

;; prefixof_concat
(assert (forall ((s1 string) (s2 string)) (prefixof s1 (concat1 s1 s2))))

;; prefixof_empty
(assert (forall ((s2 string)) (prefixof rliteral s2)))

;; prefixof_empty2
(assert
  (forall ((s1 string))
    (=> (not (= s1 rliteral)) (not (prefixof s1 rliteral)))))

;; suffixof
(declare-fun suffixof (string
  string) Bool)

;; suffixof_substring
(assert
  (forall ((s1 string) (s2 string))
    (=>
      (suffixof s1 s2)
      (= s1 (substring s2 (- (length2 s2) (length2 s1)) (length2 s1))))))

;; suffixof_substring
(assert
  (forall ((s1 string) (s2 string))
    (=>
      (= s1 (substring s2 (- (length2 s2) (length2 s1)) (length2 s1)))
      (suffixof s1 s2))))

;; suffixof_concat
(assert (forall ((s1 string) (s2 string)) (suffixof s2 (concat1 s1 s2))))

;; suffixof_empty
(assert (forall ((s2 string)) (suffixof rliteral s2)))

;; suffixof_empty2
(assert
  (forall ((s1 string))
    (=> (not (= s1 rliteral)) (not (suffixof s1 rliteral)))))

;; contains
(declare-fun contains (string
  string) Bool)

;; contains_prefixof
(assert
  (forall ((s1 string) (s2 string)) (=> (prefixof s1 s2) (contains s2 s1))))

;; contains_suffixof
(assert
  (forall ((s1 string) (s2 string)) (=> (suffixof s1 s2) (contains s2 s1))))

;; contains_empty
(assert (forall ((s2 string)) (=> (contains rliteral s2) (= s2 rliteral))))

;; contains_empty
(assert (forall ((s2 string)) (=> (= s2 rliteral) (contains rliteral s2))))

;; contains_empty2
(assert (forall ((s1 string)) (contains s1 rliteral)))

;; contains_substring
(assert
  (forall ((s1 string) (s2 string) (i Int))
    (=> (= (substring s1 i (length2 s2)) s2) (contains s1 s2))))

;; contains_concat
(assert (forall ((s1 string) (s2 string)) (contains (concat1 s1 s2) s1)))

;; contains_concat
(assert (forall ((s1 string) (s2 string)) (contains (concat1 s1 s2) s2)))

;; contains_at
(assert
  (forall ((s1 string) (s2 string) (i Int))
    (=> (= (s_at s1 i) s2) (contains s1 s2))))

;; indexof
(declare-fun indexof (string
  string
  Int) Int)

;; indexof_empty
(assert
  (forall ((s string) (i Int))
    (=> (and (<= 0 i) (<= i (length2 s))) (= (indexof s rliteral i) i))))

;; indexof_empty1
(assert
  (forall ((s string) (i Int))
    (or (= (indexof rliteral s i) (- 1)) (= s rliteral))))

;; indexof_empty1
(assert
  (forall ((s string) (i Int))
    (let ((j (indexof rliteral s i))) (or (= j (- 1)) (= i j)))))

;; indexof_empty1
(assert
  (forall ((s string) (i Int))
    (let ((j (indexof rliteral s i))) (or (= j (- 1)) (= j 0)))))

;; indexof_contains
(assert
  (forall ((s1 string) (s2 string))
    (=> (contains s1 s2) (<= 0 (indexof s1 s2 0)))))

;; indexof_contains
(assert
  (forall ((s1 string) (s2 string))
    (=> (contains s1 s2) (<= (indexof s1 s2 0) (length2 s1)))))

;; indexof_contains
(assert
  (forall ((s1 string) (s2 string))
    (=>
      (contains s1 s2)
      (= (substring s1 (indexof s1 s2 0) (length2 s2)) s2))))

;; contains_indexof
(assert
  (forall ((s1 string) (s2 string) (i Int))
    (=> (<= 0 (indexof s1 s2 i)) (contains s1 s2))))

;; not_contains_indexof
(assert
  (forall ((s1 string) (s2 string) (i Int))
    (=> (not (contains s1 s2)) (= (indexof s1 s2 i) (- 1)))))

;; substring_indexof
(assert
  (forall ((s1 string) (s2 string) (i Int))
    (let ((j (indexof s1 s2 i)))
      (=> (<= 0 j) (= (substring s1 j (length2 s2)) s2)))))

;; indexof_out_of_range
(assert
  (forall ((i Int) (s1 string) (s2 string))
    (=> (not (<= 0 i)) (= (indexof s1 s2 i) (- 1)))))

;; indexof_out_of_range
(assert
  (forall ((i Int) (s1 string) (s2 string))
    (=> (not (<= i (length2 s1))) (= (indexof s1 s2 i) (- 1)))))

;; indexof_in_range
(assert
  (forall ((s1 string) (s2 string) (i Int))
    (let ((j (indexof s1 s2 i)))
      (=> (and (<= 0 i) (<= i (length2 s1))) (or (= j (- 1)) (<= i j))))))

;; indexof_in_range
(assert
  (forall ((s1 string) (s2 string) (i Int))
    (let ((j (indexof s1 s2 i)))
      (=>
        (and (<= 0 i) (<= i (length2 s1)))
        (or (= j (- 1)) (<= j (length2 s1)))))))

;; indexof_contains_substring
(assert
  (forall ((s1 string) (s2 string) (i Int))
    (=>
      (and
        (and (<= 0 i) (<= i (length2 s1)))
        (contains (substring s1 i (- (length2 s1) i)) s2))
      (<= i (indexof s1 s2 i)))))

;; indexof_contains_substring
(assert
  (forall ((s1 string) (s2 string) (i Int))
    (=>
      (and
        (and (<= 0 i) (<= i (length2 s1)))
        (contains (substring s1 i (- (length2 s1) i)) s2))
      (<= (indexof s1 s2 i) (length2 s1)))))

;; replace
(declare-fun replace (string
  string
  string) string)

;; replace_empty
(assert
  (forall ((s1 string) (s3 string))
    (= (replace s1 rliteral s3) (concat1 s3 s1))))

;; replace_not_contains
(assert
  (forall ((s1 string) (s2 string) (s3 string))
    (=> (not (contains s1 s2)) (= (replace s1 s2 s3) s1))))

;; replace_empty2
(assert
  (forall ((s2 string) (s3 string))
    (=> (= s2 rliteral) (= (replace rliteral s2 s3) s3))))

;; replace_empty2
(assert
  (forall ((s2 string) (s3 string))
    (=> (not (= s2 rliteral)) (= (replace rliteral s2 s3) rliteral))))

;; replace_substring_indexof
(assert
  (forall ((s1 string) (s2 string) (s3 string))
    (let ((j (indexof s1 s2 0)))
      (= (replace s1 s2 s3) (ite (< j 0)
                              s1
                              (concat1
                                (concat1 (substring s1 0 j) s3)
                                (substring
                                  s1
                                  (+ j (length2 s2))
                                  (- (- (length2 s1) j) (length2 s2)))))))))

;; replaceall
(declare-fun replaceall (string
  string
  string) string)

;; replaceall_empty1
(assert
  (forall ((s1 string) (s3 string)) (= (replaceall s1 rliteral s3) s1)))

;; not_contains_replaceall
(assert
  (forall ((s1 string) (s2 string) (s3 string))
    (=> (not (contains s1 s2)) (= (replaceall s1 s2 s3) s1))))

;; to_int
(declare-fun to_int1 (string) Int)

;; to_int_gt_minus_1
(assert (forall ((s string)) (<= (- 1) (to_int1 s))))

;; to_int_empty
(assert (= (to_int1 rliteral) (- 1)))

;; is_digit
(declare-fun is_digit (string) Bool)

;; is_digit'def
(assert
  (forall ((s string))
    (=
      (is_digit s)
      (and (and (<= 0 (to_int1 s)) (<= (to_int1 s) 9)) (= (length2 s) 1)))))

;; from_int
(declare-fun from_int (Int) string)

;; from_int_negative
(assert (forall ((i Int)) (=> (< i 0) (= (from_int i) rliteral))))

;; from_int_negative
(assert (forall ((i Int)) (=> (= (from_int i) rliteral) (< i 0))))

;; from_int_to_int
(assert (forall ((i Int)) (=> (<= 0 i) (= (to_int1 (from_int i)) i))))

;; from_int_to_int
(assert
  (forall ((i Int)) (=> (not (<= 0 i)) (= (to_int1 (from_int i)) (- 1)))))

(declare-sort char1 0)

;; char
(declare-fun char2 () ty)

;; contents
(declare-fun contents1 (char1) string)

;; char'invariant
(assert
  (forall ((self char1))
    (! (= (length2 (contents1 self)) 1) :pattern ((contents1 self)) )))

;; char_eq
(assert
  (forall ((c1 char1) (c2 char1))
    (=> (= (contents1 c1) (contents1 c2)) (= c1 c2))))

;; code
(declare-fun code (char1) Int)

;; code
(assert (forall ((c char1)) (<= 0 (code c))))

;; code
(assert (forall ((c char1)) (< (code c) 256)))

;; chr
(declare-fun chr (Int) char1)

;; code_chr
(assert
  (forall ((n Int)) (=> (and (<= 0 n) (< n 256)) (= (code (chr n)) n))))

;; chr_code
(assert (forall ((c char1)) (= (chr (code c)) c)))

;; get
(declare-fun get1 (string
  Int) char1)

;; get
(assert
  (forall ((s string) (i Int))
    (=>
      (and (<= 0 i) (< i (length2 s)))
      (= (contents1 (get1 s i)) (s_at s i)))))

;; substring_get
(assert
  (forall ((s string) (ofs Int) (len Int) (i Int))
    (=>
      (and (<= 0 ofs) (<= ofs (length2 s)))
      (=>
        (<= 0 len)
        (=>
          (<= (+ ofs len) (length2 s))
          (=>
            (and (<= 0 i) (< i len))
            (= (get1 (substring s ofs len) i) (get1 s (+ ofs i)))))))))

;; concat_first
(assert
  (forall ((s1 string) (s2 string))
    (forall ((i Int))
      (=>
        (and (<= 0 i) (< i (length2 s1)))
        (= (get1 (concat1 s1 s2) i) (get1 s1 i))))))

;; concat_second
(assert
  (forall ((s1 string) (s2 string))
    (forall ((i Int))
      (=>
        (and (<= (length2 s1) i) (< i (+ (length2 s1) (length2 s2))))
        (= (get1 (concat1 s1 s2) i) (get1 s2 (- i (length2 s1))))))))

;; eq_string
(declare-fun eq_string (string
  string) Bool)

;; eq_string'def
(assert
  (forall ((s1 string) (s2 string))
    (=
      (eq_string s1 s2)
      (and
        (= (length2 s1) (length2 s2))
        (forall ((i Int))
          (=> (and (<= 0 i) (< i (length2 s1))) (= (get1 s1 i) (get1 s2 i))))))))

;; extensionality
(assert (forall ((s1 string) (s2 string)) (=> (eq_string s1 s2) (= s1 s2))))

;; make
(declare-fun make (Int
  char1) string)

;; make_length
(assert
  (forall ((size Int) (v char1))
    (=> (<= 0 size) (= (length2 (make size v)) size))))

;; make_contents
(assert
  (forall ((size Int) (v char1))
    (=>
      (<= 0 size)
      (forall ((i Int))
        (=> (and (<= 0 i) (< i size)) (= (get1 (make size v) i) v))))))

(declare-sort single 0)

;; single
(declare-fun single1 () ty)

(declare-sort mode 0)

;; mode
(declare-fun mode1 () ty)

;; NearestTiesToEven
(declare-fun NearestTiesToEven () mode)

;; ToZero
(declare-fun ToZero () mode)

;; Up
(declare-fun Up () mode)

;; Down
(declare-fun Down () mode)

;; NearestTiesToAway
(declare-fun NearestTiesToAway () mode)

;; match_mode
(declare-fun match_mode (ty
  mode
  uni
  uni
  uni
  uni
  uni) uni)

;; match_mode_sort
(assert
  (forall ((a ty))
    (forall ((x mode) (x1 uni) (x2 uni) (x3 uni) (x4 uni) (x5 uni))
      (sort a (match_mode a x x1 x2 x3 x4 x5)))))

;; match_mode_NearestTiesToEven
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
      (=> (sort a z) (= (match_mode a NearestTiesToEven z z1 z2 z3 z4) z)))))

;; match_mode_ToZero
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
      (=> (sort a z1) (= (match_mode a ToZero z z1 z2 z3 z4) z1)))))

;; match_mode_Up
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
      (=> (sort a z2) (= (match_mode a Up z z1 z2 z3 z4) z2)))))

;; match_mode_Down
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
      (=> (sort a z3) (= (match_mode a Down z z1 z2 z3 z4) z3)))))

;; match_mode_NearestTiesToAway
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
      (=> (sort a z4) (= (match_mode a NearestTiesToAway z z1 z2 z3 z4) z4)))))

;; index_mode
(declare-fun index_mode (mode) Int)

;; index_mode_NearestTiesToEven
(assert (= (index_mode NearestTiesToEven) 0))

;; index_mode_ToZero
(assert (= (index_mode ToZero) 1))

;; index_mode_Up
(assert (= (index_mode Up) 2))

;; index_mode_Down
(assert (= (index_mode Down) 3))

;; index_mode_NearestTiesToAway
(assert (= (index_mode NearestTiesToAway) 4))

;; mode_inversion
(assert
  (forall ((u mode))
    (or
      (or (or (or (= u NearestTiesToEven) (= u ToZero)) (= u Up)) (= u Down))
      (= u NearestTiesToAway))))

;; add_div
(assert
  (forall ((x Real) (y Real) (z Real))
    (=> (not (= z 0.0)) (= (/ (+ x y) z) (+ (/ x z) (/ y z))))))

;; sub_div
(assert
  (forall ((x Real) (y Real) (z Real))
    (=> (not (= z 0.0)) (= (/ (- x y) z) (- (/ x z) (/ y z))))))

;; neg_div
(assert
  (forall ((x Real) (y Real))
    (=> (not (= y 0.0)) (= (/ (- x) y) (- (/ x y))))))

;; assoc_mul_div
(assert
  (forall ((x Real) (y Real) (z Real))
    (=> (not (= z 0.0)) (= (/ (* x y) z) (* x (/ y z))))))

;; assoc_div_mul
(assert
  (forall ((x Real) (y Real) (z Real))
    (=>
      (and (not (= y 0.0)) (not (= z 0.0)))
      (= (/ (/ x y) z) (/ x (* y z))))))

;; assoc_div_div
(assert
  (forall ((x Real) (y Real) (z Real))
    (=>
      (and (not (= y 0.0)) (not (= z 0.0)))
      (= (/ x (/ y z)) (/ (* x z) y)))))

;; CompatOrderMult
(assert
  (forall ((x Real) (y Real) (z Real))
    (=> (<= x y) (=> (<= 0.0 z) (<= (* x z) (* y z))))))

;; Abs_le
(assert
  (forall ((x Real) (y Real))
    (=> (<= (ite (>= x 0.0) x (- x)) y) (<= (- y) x))))

;; Abs_le
(assert
  (forall ((x Real) (y Real)) (=> (<= (ite (>= x 0.0) x (- x)) y) (<= x y))))

;; Abs_le
(assert
  (forall ((x Real) (y Real))
    (=> (and (<= (- y) x) (<= x y)) (<= (ite (>= x 0.0) x (- x)) y))))

;; round
(declare-fun round (mode
  Real) Real)

;; value
(declare-fun value (single) Real)

;; exact
(declare-fun exact (single) Real)

;; model
(declare-fun model1 (single) Real)

;; round_error
(declare-fun round_error (single) Real)

;; round_error'def
(assert
  (forall ((x single))
    (= (round_error x) (ite (>= (- (value x) (exact x)) 0.0) (- (value x) 
    (exact
      x)) (- (- (value x) (exact x)))))))

;; total_error
(declare-fun total_error (single) Real)

;; total_error'def
(assert
  (forall ((x single))
    (= (total_error x) (ite (>= (- (value x) (model1 x)) 0.0) (- (value x) 
    (model1
      x)) (- (- (value x) (model1 x)))))))

;; no_overflow
(declare-fun no_overflow (mode
  Real) Bool)

;; no_overflow'def
(assert
  (forall ((m mode) (x Real))
    (=
      (no_overflow m x)
      (<= (ite (>= (round m x) 0.0) (round m x) (- (round m x))) (* 33554430.0 10141204801825835211973625643008.0)))))

;; Bounded_real_no_overflow
(assert
  (forall ((m mode) (x Real))
    (=>
      (<= (ite (>= x 0.0) x (- x)) (* 33554430.0 10141204801825835211973625643008.0))
      (no_overflow m x))))

;; Round_monotonic
(assert
  (forall ((m mode) (x Real) (y Real))
    (=> (<= x y) (<= (round m x) (round m y)))))

;; Round_idempotent
(assert
  (forall ((m1 mode) (m2 mode) (x Real))
    (= (round m1 (round m2 x)) (round m2 x))))

;; Round_value
(assert (forall ((m mode) (x single)) (= (round m (value x)) (value x))))

;; Bounded_value
(assert
  (forall ((x single))
    (<= (ite (>= (value x) 0.0) (value x) (- (value x))) (* 33554430.0 10141204801825835211973625643008.0))))

;; Exact_rounding_for_integers
(assert
  (forall ((m mode) (i Int))
    (=>
      (and (<= (- 16777216) i) (<= i 16777216))
      (= (round m (to_real i)) (to_real i)))))

;; Round_down_le
(assert (forall ((x Real)) (<= (round Down x) x)))

;; Round_up_ge
(assert (forall ((x Real)) (<= x (round Up x))))

;; Round_down_neg
(assert (forall ((x Real)) (= (round Down (- x)) (- (round Up x)))))

;; Round_up_neg
(assert (forall ((x Real)) (= (round Up (- x)) (- (round Down x)))))

;; round_logic
(declare-fun round_logic (mode
  Real) single)

;; Round_logic_def
(assert
  (forall ((m mode) (x Real))
    (=> (no_overflow m x) (= (value (round_logic m x)) (round m x)))))

;; of_real_post
(declare-fun of_real_post (mode
  Real
  single) Bool)

;; of_real_post'def
(assert
  (forall ((m mode) (x Real) (res single))
    (=
      (of_real_post m x res)
      (and
        (= (value res) (round m x))
        (and (= (exact res) x) (= (model1 res) x))))))

;; add_post
(declare-fun add_post (mode
  single
  single
  single) Bool)

;; add_post'def
(assert
  (forall ((m mode) (x single) (y single) (res single))
    (=
      (add_post m x y res)
      (and
        (= (value res) (round m (+ (value x) (value y))))
        (and
          (= (exact res) (+ (exact x) (exact y)))
          (= (model1 res) (+ (model1 x) (model1 y))))))))

;; sub_post
(declare-fun sub_post (mode
  single
  single
  single) Bool)

;; sub_post'def
(assert
  (forall ((m mode) (x single) (y single) (res single))
    (=
      (sub_post m x y res)
      (and
        (= (value res) (round m (- (value x) (value y))))
        (and
          (= (exact res) (- (exact x) (exact y)))
          (= (model1 res) (- (model1 x) (model1 y))))))))

;; mul_post
(declare-fun mul_post (mode
  single
  single
  single) Bool)

;; mul_post'def
(assert
  (forall ((m mode) (x single) (y single) (res single))
    (=
      (mul_post m x y res)
      (and
        (= (value res) (round m (* (value x) (value y))))
        (and
          (= (exact res) (* (exact x) (exact y)))
          (= (model1 res) (* (model1 x) (model1 y))))))))

;; div_post
(declare-fun div_post (mode
  single
  single
  single) Bool)

;; div_post'def
(assert
  (forall ((m mode) (x single) (y single) (res single))
    (=
      (div_post m x y res)
      (and
        (= (value res) (round m (/ (value x) (value y))))
        (and
          (= (exact res) (/ (exact x) (exact y)))
          (= (model1 res) (/ (model1 x) (model1 y))))))))

;; neg_post
(declare-fun neg_post (single
  single) Bool)

;; neg_post'def
(assert
  (forall ((x single) (res single))
    (=
      (neg_post x res)
      (and
        (= (value res) (- (value x)))
        (and (= (exact res) (- (exact x))) (= (model1 res) (- (model1 x))))))))

;; lt
(declare-fun lt1 (single
  single) Bool)

;; lt'def
(assert
  (forall ((x single) (y single)) (= (lt1 x y) (< (value x) (value y)))))

;; gt
(declare-fun gt (single
  single) Bool)

;; gt'def
(assert
  (forall ((x single) (y single)) (= (gt x y) (< (value y) (value x)))))

(declare-sort double 0)

;; double
(declare-fun double1 () ty)

;; round
(declare-fun round1 (mode
  Real) Real)

;; value
(declare-fun value1 (double) Real)

;; exact
(declare-fun exact1 (double) Real)

;; model
(declare-fun model2 (double) Real)

;; round_error
(declare-fun round_error1 (double) Real)

;; round_error'def
(assert
  (forall ((x double))
    (= (round_error1 x) (ite (>= (- (value1 x) (exact1 x)) 0.0) (- (value1 x) 
    (exact1
      x)) (- (- (value1 x) (exact1 x)))))))

;; total_error
(declare-fun total_error1 (double) Real)

;; total_error'def
(assert
  (forall ((x double))
    (= (total_error1 x) (ite (>= (- (value1 x) (model2 x)) 0.0) (- (value1 x) 
    (model2
      x)) (- (- (value1 x) (model2 x)))))))

;; no_overflow
(declare-fun no_overflow1 (mode
  Real) Bool)

;; no_overflow'def
(assert
  (forall ((m mode) (x Real))
    (=
      (no_overflow1 m x)
      (<= (ite (>= (round1 m x) 0.0) (round1 m x) (- (round1 m x))) (* 9007199254740991.0 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848.0)))))

;; Bounded_real_no_overflow
(assert
  (forall ((m mode) (x Real))
    (=>
      (<= (ite (>= x 0.0) x (- x)) (* 9007199254740991.0 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848.0))
      (no_overflow1 m x))))

;; Round_monotonic
(assert
  (forall ((m mode) (x Real) (y Real))
    (=> (<= x y) (<= (round1 m x) (round1 m y)))))

;; Round_idempotent
(assert
  (forall ((m1 mode) (m2 mode) (x Real))
    (= (round1 m1 (round1 m2 x)) (round1 m2 x))))

;; Round_value
(assert (forall ((m mode) (x double)) (= (round1 m (value1 x)) (value1 x))))

;; Bounded_value
(assert
  (forall ((x double))
    (<= (ite (>= (value1 x) 0.0) (value1 x) (- (value1 x))) (* 9007199254740991.0 19958403095347198116563727130368385660674512604354575415025472424372118918689640657849579654926357010893424468441924952439724379883935936607391717982848314203200056729510856765175377214443629871826533567445439239933308104551208703888888552684480441575071209068757560416423584952303440099278848.0))))

;; Exact_rounding_for_integers
(assert
  (forall ((m mode) (i Int))
    (=>
      (and (<= (- 9007199254740992) i) (<= i 9007199254740992))
      (= (round1 m (to_real i)) (to_real i)))))

;; Round_down_le
(assert (forall ((x Real)) (<= (round1 Down x) x)))

;; Round_up_ge
(assert (forall ((x Real)) (<= x (round1 Up x))))

;; Round_down_neg
(assert (forall ((x Real)) (= (round1 Down (- x)) (- (round1 Up x)))))

;; Round_up_neg
(assert (forall ((x Real)) (= (round1 Up (- x)) (- (round1 Down x)))))

;; round_logic
(declare-fun round_logic1 (mode
  Real) double)

;; Round_logic_def
(assert
  (forall ((m mode) (x Real))
    (=> (no_overflow1 m x) (= (value1 (round_logic1 m x)) (round1 m x)))))

;; of_real_post
(declare-fun of_real_post1 (mode
  Real
  double) Bool)

;; of_real_post'def
(assert
  (forall ((m mode) (x Real) (res double))
    (=
      (of_real_post1 m x res)
      (and
        (= (value1 res) (round1 m x))
        (and (= (exact1 res) x) (= (model2 res) x))))))

;; add_post
(declare-fun add_post1 (mode
  double
  double
  double) Bool)

;; add_post'def
(assert
  (forall ((m mode) (x double) (y double) (res double))
    (=
      (add_post1 m x y res)
      (and
        (= (value1 res) (round1 m (+ (value1 x) (value1 y))))
        (and
          (= (exact1 res) (+ (exact1 x) (exact1 y)))
          (= (model2 res) (+ (model2 x) (model2 y))))))))

;; sub_post
(declare-fun sub_post1 (mode
  double
  double
  double) Bool)

;; sub_post'def
(assert
  (forall ((m mode) (x double) (y double) (res double))
    (=
      (sub_post1 m x y res)
      (and
        (= (value1 res) (round1 m (- (value1 x) (value1 y))))
        (and
          (= (exact1 res) (- (exact1 x) (exact1 y)))
          (= (model2 res) (- (model2 x) (model2 y))))))))

;; mul_post
(declare-fun mul_post1 (mode
  double
  double
  double) Bool)

;; mul_post'def
(assert
  (forall ((m mode) (x double) (y double) (res double))
    (=
      (mul_post1 m x y res)
      (and
        (= (value1 res) (round1 m (* (value1 x) (value1 y))))
        (and
          (= (exact1 res) (* (exact1 x) (exact1 y)))
          (= (model2 res) (* (model2 x) (model2 y))))))))

;; div_post
(declare-fun div_post1 (mode
  double
  double
  double) Bool)

;; div_post'def
(assert
  (forall ((m mode) (x double) (y double) (res double))
    (=
      (div_post1 m x y res)
      (and
        (= (value1 res) (round1 m (/ (value1 x) (value1 y))))
        (and
          (= (exact1 res) (/ (exact1 x) (exact1 y)))
          (= (model2 res) (/ (model2 x) (model2 y))))))))

;; neg_post
(declare-fun neg_post1 (double
  double) Bool)

;; neg_post'def
(assert
  (forall ((x double) (res double))
    (=
      (neg_post1 x res)
      (and
        (= (value1 res) (- (value1 x)))
        (and (= (exact1 res) (- (exact1 x))) (= (model2 res) (- (model2 x))))))))

;; lt
(declare-fun lt2 (double
  double) Bool)

;; lt'def
(assert
  (forall ((x double) (y double)) (= (lt2 x y) (< (value1 x) (value1 y)))))

;; gt
(declare-fun gt1 (double
  double) Bool)

;; gt'def
(assert
  (forall ((x double) (y double)) (= (gt1 x y) (< (value1 y) (value1 x)))))

(declare-sort opaque_ptr 0)

;; opaque_ptr
(declare-fun opaque_ptr1 () ty)

;; slice
(declare-fun slice (ty) ty)

;; borrowed
(declare-fun borrowed (ty) ty)

;; borrowed'mk
(declare-fun borrowedqtmk (ty
  uni
  uni) uni)

;; borrowed'mk_sort
(assert
  (forall ((a ty))
    (forall ((x uni) (x1 uni)) (sort (borrowed a) (borrowedqtmk a x x1)))))

;; current
(declare-fun current (ty
  uni) uni)

;; current_sort
(assert (forall ((a ty)) (forall ((x uni)) (sort a (current a x)))))

;; current'def
(assert
  (forall ((a ty))
    (forall ((u uni) (u1 uni))
      (=> (sort a u) (= (current a (borrowedqtmk a u u1)) u)))))

;; final
(declare-fun final (ty
  uni) uni)

;; final_sort
(assert (forall ((a ty)) (forall ((x uni)) (sort a (final a x)))))

;; final'def
(assert
  (forall ((a ty))
    (forall ((u uni) (u1 uni))
      (=> (sort a u1) (= (final a (borrowedqtmk a u u1)) u1)))))

;; borrowed_inversion
(assert
  (forall ((a ty))
    (forall ((u uni))
      (=>
        (sort (borrowed a) u)
        (= u (borrowedqtmk a (current a u) (final a u)))))))

(declare-sort creusotcontracts_std1_vec_vec 1)

;; creusotcontracts_std1_vec_vec
(declare-fun creusotcontracts_std1_vec_vec1 (ty) ty)

(declare-sort lib_decision_decisions 0)

;; lib_decision_decisions
(declare-fun lib_decision_decisions1 () ty)

;; Lib_Decision_Decisions
(declare-fun Lib_Decision_Decisions ((creusotcontracts_std1_vec_vec uint64)) lib_decision_decisions)

;; Lib_Decision_Decisions_proj_1
(declare-fun Lib_Decision_Decisions_proj_1 (lib_decision_decisions) (creusotcontracts_std1_vec_vec uint64))

;; Lib_Decision_Decisions_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec uint64)))
    (= (Lib_Decision_Decisions_proj_1 (Lib_Decision_Decisions u)) u)))

;; lib_decision_decisions_inversion
(assert
  (forall ((u lib_decision_decisions))
    (= u (Lib_Decision_Decisions (Lib_Decision_Decisions_proj_1 u)))))

;; lib_decision_decisions_Decisions_lit_order
(declare-fun lib_decision_decisions_Decisions_lit_order (lib_decision_decisions) (creusotcontracts_std1_vec_vec uint64))

;; lib_decision_decisions_Decisions_lit_order_acc
(assert
  (forall ((a (creusotcontracts_std1_vec_vec uint64)))
    (= (lib_decision_decisions_Decisions_lit_order
         (Lib_Decision_Decisions a)) a)))

(declare-sort lib_lit_lit 0)

;; lib_lit_lit
(declare-fun lib_lit_lit1 () ty)

;; Lib_Lit_Lit
(declare-fun Lib_Lit_Lit (uint64
  Bool) lib_lit_lit)

;; Lib_Lit_Lit_proj_1
(declare-fun Lib_Lit_Lit_proj_1 (lib_lit_lit) uint64)

;; Lib_Lit_Lit_proj_1'def
(assert
  (forall ((u uint64) (u1 Bool))
    (= (Lib_Lit_Lit_proj_1 (Lib_Lit_Lit u u1)) u)))

;; Lib_Lit_Lit_proj_2
(declare-fun Lib_Lit_Lit_proj_2 (lib_lit_lit) Bool)

;; Lib_Lit_Lit_proj_2'def
(assert
  (forall ((u uint64) (u1 Bool))
    (= (Lib_Lit_Lit_proj_2 (Lib_Lit_Lit u u1)) u1)))

;; lib_lit_lit_inversion
(assert
  (forall ((u lib_lit_lit))
    (= u (Lib_Lit_Lit (Lib_Lit_Lit_proj_1 u) (Lib_Lit_Lit_proj_2 u)))))

;; lib_lit_lit_Lit_idx
(declare-fun lib_lit_lit_Lit_idx (lib_lit_lit) uint64)

;; lib_lit_lit_Lit_idx_acc
(assert
  (forall ((a uint64) (b Bool))
    (= (lib_lit_lit_Lit_idx (Lib_Lit_Lit a b)) a)))

;; lib_lit_lit_Lit_polarity
(declare-fun lib_lit_lit_Lit_polarity (lib_lit_lit) Bool)

;; lib_lit_lit_Lit_polarity_acc
(assert
  (forall ((a uint64) (b Bool))
    (= (lib_lit_lit_Lit_polarity (Lib_Lit_Lit a b)) b)))

(declare-sort lib_clause_clause 0)

;; lib_clause_clause
(declare-fun lib_clause_clause1 () ty)

;; Lib_Clause_Clause
(declare-fun Lib_Clause_Clause ((creusotcontracts_std1_vec_vec lib_lit_lit)) lib_clause_clause)

;; Lib_Clause_Clause_proj_1
(declare-fun Lib_Clause_Clause_proj_1 (lib_clause_clause) (creusotcontracts_std1_vec_vec lib_lit_lit))

;; Lib_Clause_Clause_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec lib_lit_lit)))
    (= (Lib_Clause_Clause_proj_1 (Lib_Clause_Clause u)) u)))

;; lib_clause_clause_inversion
(assert
  (forall ((u lib_clause_clause))
    (= u (Lib_Clause_Clause (Lib_Clause_Clause_proj_1 u)))))

;; lib_clause_clause_Clause_rest
(declare-fun lib_clause_clause_Clause_rest (lib_clause_clause) (creusotcontracts_std1_vec_vec lib_lit_lit))

;; lib_clause_clause_Clause_rest_acc
(assert
  (forall ((a (creusotcontracts_std1_vec_vec lib_lit_lit)))
    (= (lib_clause_clause_Clause_rest (Lib_Clause_Clause a)) a)))

(declare-sort lib_formula_formula 0)

;; lib_formula_formula
(declare-fun lib_formula_formula1 () ty)

;; Lib_Formula_Formula
(declare-fun Lib_Formula_Formula ((creusotcontracts_std1_vec_vec lib_clause_clause)
  uint64) lib_formula_formula)

;; Lib_Formula_Formula_proj_1
(declare-fun Lib_Formula_Formula_proj_1 (lib_formula_formula) (creusotcontracts_std1_vec_vec lib_clause_clause))

;; Lib_Formula_Formula_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec lib_clause_clause)) (u1 uint64))
    (= (Lib_Formula_Formula_proj_1 (Lib_Formula_Formula u u1)) u)))

;; Lib_Formula_Formula_proj_2
(declare-fun Lib_Formula_Formula_proj_2 (lib_formula_formula) uint64)

;; Lib_Formula_Formula_proj_2'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec lib_clause_clause)) (u1 uint64))
    (= (Lib_Formula_Formula_proj_2 (Lib_Formula_Formula u u1)) u1)))

;; lib_formula_formula_inversion
(assert
  (forall ((u lib_formula_formula))
    (= u (Lib_Formula_Formula
           (Lib_Formula_Formula_proj_1 u)
           (Lib_Formula_Formula_proj_2 u)))))

;; lib_formula_formula_Formula_clauses
(declare-fun lib_formula_formula_Formula_clauses (lib_formula_formula) (creusotcontracts_std1_vec_vec lib_clause_clause))

;; lib_formula_formula_Formula_clauses_acc
(assert
  (forall ((a (creusotcontracts_std1_vec_vec lib_clause_clause)) (b uint64))
    (= (lib_formula_formula_Formula_clauses (Lib_Formula_Formula a b)) a)))

;; lib_formula_formula_Formula_num_vars
(declare-fun lib_formula_formula_Formula_num_vars (lib_formula_formula) uint64)

;; lib_formula_formula_Formula_num_vars_acc
(assert
  (forall ((a (creusotcontracts_std1_vec_vec lib_clause_clause)) (b uint64))
    (= (lib_formula_formula_Formula_num_vars (Lib_Formula_Formula a b)) b)))

(declare-sort lib_assignments_assignments 0)

;; lib_assignments_assignments
(declare-fun lib_assignments_assignments1 () ty)

;; Lib_Assignments_Assignments
(declare-fun Lib_Assignments_Assignments ((creusotcontracts_std1_vec_vec uint8)
  uint64) lib_assignments_assignments)

;; Lib_Assignments_Assignments_proj_1
(declare-fun Lib_Assignments_Assignments_proj_1 (lib_assignments_assignments) (creusotcontracts_std1_vec_vec uint8))

;; Lib_Assignments_Assignments_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec uint8)) (u1 uint64))
    (= (Lib_Assignments_Assignments_proj_1
         (Lib_Assignments_Assignments u u1)) u)))

;; Lib_Assignments_Assignments_proj_2
(declare-fun Lib_Assignments_Assignments_proj_2 (lib_assignments_assignments) uint64)

;; Lib_Assignments_Assignments_proj_2'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec uint8)) (u1 uint64))
    (= (Lib_Assignments_Assignments_proj_2
         (Lib_Assignments_Assignments u u1)) u1)))

;; lib_assignments_assignments_inversion
(assert
  (forall ((u lib_assignments_assignments))
    (= u (Lib_Assignments_Assignments
           (Lib_Assignments_Assignments_proj_1 u)
           (Lib_Assignments_Assignments_proj_2 u)))))

;; lib_assignments_assignments_Assignments_0
(declare-fun lib_assignments_assignments_Assignments_0 (lib_assignments_assignments) (creusotcontracts_std1_vec_vec uint8))

;; lib_assignments_assignments_Assignments_0_acc
(assert
  (forall ((a (creusotcontracts_std1_vec_vec uint8)) (b uint64))
    (= (lib_assignments_assignments_Assignments_0
         (Lib_Assignments_Assignments a b)) a)))

;; lib_assignments_assignments_Assignments_1
(declare-fun lib_assignments_assignments_Assignments_1 (lib_assignments_assignments) uint64)

;; lib_assignments_assignments_Assignments_1_acc
(assert
  (forall ((a (creusotcontracts_std1_vec_vec uint8)) (b uint64))
    (= (lib_assignments_assignments_Assignments_1
         (Lib_Assignments_Assignments a b)) b)))

;; core_option_option
(declare-fun core_option_option (ty) ty)

;; Core_Option_Option_None
(declare-fun Core_Option_Option_None (ty) uni)

;; Core_Option_Option_None_sort
(assert
  (forall ((t ty)) (sort (core_option_option t) (Core_Option_Option_None t))))

;; Core_Option_Option_Some
(declare-fun Core_Option_Option_Some (ty
  uni) uni)

;; Core_Option_Option_Some_sort
(assert
  (forall ((t ty))
    (forall ((x uni))
      (sort (core_option_option t) (Core_Option_Option_Some t x)))))

;; match_core_option_option
(declare-fun match_core_option_option (ty
  ty
  uni
  uni
  uni) uni)

;; match_core_option_option_sort
(assert
  (forall ((t ty) (a ty))
    (forall ((x uni) (x1 uni) (x2 uni))
      (sort a (match_core_option_option a t x x1 x2)))))

;; match_core_option_option_Core_Option_Option_None
(assert
  (forall ((t ty) (a ty))
    (forall ((z uni) (z1 uni))
      (=>
        (sort a z)
        (= (match_core_option_option a t (Core_Option_Option_None t) z z1) z)))))

;; match_core_option_option_Core_Option_Option_Some
(assert
  (forall ((t ty) (a ty))
    (forall ((z uni) (z1 uni) (u uni))
      (=>
        (sort a z1)
        (= (match_core_option_option a t (Core_Option_Option_Some t u) z z1) z1)))))

;; index_core_option_option
(declare-fun index_core_option_option (ty
  uni) Int)

;; index_core_option_option_Core_Option_Option_None
(assert
  (forall ((t ty))
    (= (index_core_option_option t (Core_Option_Option_None t)) 0)))

;; index_core_option_option_Core_Option_Option_Some
(assert
  (forall ((t ty))
    (forall ((u uni))
      (! (= (index_core_option_option t (Core_Option_Option_Some t u)) 1) :pattern (
      (Core_Option_Option_Some
        t
        u)) ))))

;; Core_Option_Option_Some_proj_1
(declare-fun Core_Option_Option_Some_proj_1 (ty
  uni) uni)

;; Core_Option_Option_Some_proj_1_sort
(assert
  (forall ((t ty))
    (forall ((x uni)) (sort t (Core_Option_Option_Some_proj_1 t x)))))

;; Core_Option_Option_Some_proj_1'def
(assert
  (forall ((t ty))
    (forall ((u uni))
      (=>
        (sort t u)
        (= (Core_Option_Option_Some_proj_1 t (Core_Option_Option_Some t u)) u)))))

;; core_option_option_inversion
(assert
  (forall ((t ty))
    (forall ((u uni))
      (=>
        (sort (core_option_option t) u)
        (or
          (= u (Core_Option_Option_None t))
          (= u (Core_Option_Option_Some
                 t
                 (Core_Option_Option_Some_proj_1 t u))))))))

;; core_option_option_Some_0
(declare-fun core_option_option_Some_0 (ty
  uni) uni)

;; core_option_option_Some_0_sort
(assert
  (forall ((t ty))
    (forall ((x uni)) (sort t (core_option_option_Some_0 t x)))))

;; core_option_option_Some_0_acc
(assert
  (forall ((t ty))
    (forall ((a uni))
      (=>
        (sort t a)
        (= (core_option_option_Some_0 t (Core_Option_Option_Some t a)) a)))))

(declare-sort lib_trail_reason 0)

;; lib_trail_reason
(declare-fun lib_trail_reason1 () ty)

;; Lib_Trail_Reason_Undefined
(declare-fun Lib_Trail_Reason_Undefined () lib_trail_reason)

;; Lib_Trail_Reason_Decision
(declare-fun Lib_Trail_Reason_Decision () lib_trail_reason)

;; Lib_Trail_Reason_Unit
(declare-fun Lib_Trail_Reason_Unit () lib_trail_reason)

;; Lib_Trail_Reason_Long
(declare-fun Lib_Trail_Reason_Long (uint64) lib_trail_reason)

;; match_lib_trail_reason
(declare-fun match_lib_trail_reason (ty
  lib_trail_reason
  uni
  uni
  uni
  uni) uni)

;; match_lib_trail_reason_sort
(assert
  (forall ((a ty))
    (forall ((x lib_trail_reason) (x1 uni) (x2 uni) (x3 uni) (x4 uni))
      (sort a (match_lib_trail_reason a x x1 x2 x3 x4)))))

;; match_lib_trail_reason_Lib_Trail_Reason_Undefined
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z)
        (= (match_lib_trail_reason a Lib_Trail_Reason_Undefined z z1 z2 z3) z)))))

;; match_lib_trail_reason_Lib_Trail_Reason_Decision
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z1)
        (= (match_lib_trail_reason a Lib_Trail_Reason_Decision z z1 z2 z3) z1)))))

;; match_lib_trail_reason_Lib_Trail_Reason_Unit
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z2)
        (= (match_lib_trail_reason a Lib_Trail_Reason_Unit z z1 z2 z3) z2)))))

;; match_lib_trail_reason_Lib_Trail_Reason_Long
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (u uint64))
      (=>
        (sort a z3)
        (= (match_lib_trail_reason a (Lib_Trail_Reason_Long u) z z1 z2 z3) z3)))))

;; index_lib_trail_reason
(declare-fun index_lib_trail_reason (lib_trail_reason) Int)

;; index_lib_trail_reason_Lib_Trail_Reason_Undefined
(assert (= (index_lib_trail_reason Lib_Trail_Reason_Undefined) 0))

;; index_lib_trail_reason_Lib_Trail_Reason_Decision
(assert (= (index_lib_trail_reason Lib_Trail_Reason_Decision) 1))

;; index_lib_trail_reason_Lib_Trail_Reason_Unit
(assert (= (index_lib_trail_reason Lib_Trail_Reason_Unit) 2))

;; index_lib_trail_reason_Lib_Trail_Reason_Long
(assert
  (forall ((u uint64))
    (! (= (index_lib_trail_reason (Lib_Trail_Reason_Long u)) 3) :pattern (
    (Lib_Trail_Reason_Long
      u)) )))

;; Lib_Trail_Reason_Long_proj_1
(declare-fun Lib_Trail_Reason_Long_proj_1 (lib_trail_reason) uint64)

;; Lib_Trail_Reason_Long_proj_1'def
(assert
  (forall ((u uint64))
    (= (Lib_Trail_Reason_Long_proj_1 (Lib_Trail_Reason_Long u)) u)))

;; lib_trail_reason_inversion
(assert
  (forall ((u lib_trail_reason))
    (or
      (or
        (or (= u Lib_Trail_Reason_Undefined) (= u Lib_Trail_Reason_Decision))
        (= u Lib_Trail_Reason_Unit))
      (= u (Lib_Trail_Reason_Long (Lib_Trail_Reason_Long_proj_1 u))))))

(declare-sort lib_clause_clausestate 0)

;; lib_clause_clausestate
(declare-fun lib_clause_clausestate1 () ty)

;; Lib_Clause_ClauseState_Sat
(declare-fun Lib_Clause_ClauseState_Sat () lib_clause_clausestate)

;; Lib_Clause_ClauseState_Unsat
(declare-fun Lib_Clause_ClauseState_Unsat () lib_clause_clausestate)

;; Lib_Clause_ClauseState_Unit
(declare-fun Lib_Clause_ClauseState_Unit () lib_clause_clausestate)

;; Lib_Clause_ClauseState_Unknown
(declare-fun Lib_Clause_ClauseState_Unknown () lib_clause_clausestate)

;; match_lib_clause_clausestate
(declare-fun match_lib_clause_clausestate (ty
  lib_clause_clausestate
  uni
  uni
  uni
  uni) uni)

;; match_lib_clause_clausestate_sort
(assert
  (forall ((a ty))
    (forall ((x lib_clause_clausestate) (x1 uni) (x2 uni) (x3 uni) (x4 uni))
      (sort a (match_lib_clause_clausestate a x x1 x2 x3 x4)))))

;; match_lib_clause_clausestate_Lib_Clause_ClauseState_Sat
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z)
        (= (match_lib_clause_clausestate
             a
             Lib_Clause_ClauseState_Sat
             z
             z1
             z2
             z3) z)))))

;; match_lib_clause_clausestate_Lib_Clause_ClauseState_Unsat
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z1)
        (= (match_lib_clause_clausestate
             a
             Lib_Clause_ClauseState_Unsat
             z
             z1
             z2
             z3) z1)))))

;; match_lib_clause_clausestate_Lib_Clause_ClauseState_Unit
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z2)
        (= (match_lib_clause_clausestate
             a
             Lib_Clause_ClauseState_Unit
             z
             z1
             z2
             z3) z2)))))

;; match_lib_clause_clausestate_Lib_Clause_ClauseState_Unknown
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni) (z3 uni))
      (=>
        (sort a z3)
        (= (match_lib_clause_clausestate
             a
             Lib_Clause_ClauseState_Unknown
             z
             z1
             z2
             z3) z3)))))

;; index_lib_clause_clausestate
(declare-fun index_lib_clause_clausestate (lib_clause_clausestate) Int)

;; index_lib_clause_clausestate_Lib_Clause_ClauseState_Sat
(assert (= (index_lib_clause_clausestate Lib_Clause_ClauseState_Sat) 0))

;; index_lib_clause_clausestate_Lib_Clause_ClauseState_Unsat
(assert (= (index_lib_clause_clausestate Lib_Clause_ClauseState_Unsat) 1))

;; index_lib_clause_clausestate_Lib_Clause_ClauseState_Unit
(assert (= (index_lib_clause_clausestate Lib_Clause_ClauseState_Unit) 2))

;; index_lib_clause_clausestate_Lib_Clause_ClauseState_Unknown
(assert (= (index_lib_clause_clausestate Lib_Clause_ClauseState_Unknown) 3))

;; lib_clause_clausestate_inversion
(assert
  (forall ((u lib_clause_clausestate))
    (or
      (or
        (or
          (= u Lib_Clause_ClauseState_Sat)
          (= u Lib_Clause_ClauseState_Unsat))
        (= u Lib_Clause_ClauseState_Unit))
      (= u Lib_Clause_ClauseState_Unknown))))

(declare-sort tuple2 2)

;; tuple2
(declare-fun tuple21 (ty
  ty) ty)

;; Tuple2
(declare-fun Tuple2 (ty
  ty
  uni
  uni) uni)

;; Tuple2_sort
(assert
  (forall ((a ty) (a1 ty))
    (forall ((x uni) (x1 uni)) (sort (tuple21 a1 a) (Tuple2 a1 a x x1)))))

;; Tuple2_proj_1
(declare-fun Tuple2_proj_1 (ty
  ty
  uni) uni)

;; Tuple2_proj_1_sort
(assert
  (forall ((a ty) (a1 ty))
    (forall ((x uni)) (sort a1 (Tuple2_proj_1 a1 a x)))))

;; Tuple2_proj_1'def
(assert
  (forall ((a ty) (a1 ty))
    (forall ((u uni) (u1 uni))
      (=> (sort a1 u) (= (Tuple2_proj_1 a1 a (Tuple2 a1 a u u1)) u)))))

;; Tuple2_proj_2
(declare-fun Tuple2_proj_2 (ty
  ty
  uni) uni)

;; Tuple2_proj_2_sort
(assert
  (forall ((a ty) (a1 ty))
    (forall ((x uni)) (sort a (Tuple2_proj_2 a1 a x)))))

;; Tuple2_proj_2'def
(assert
  (forall ((a ty) (a1 ty))
    (forall ((u uni) (u1 uni))
      (=> (sort a u1) (= (Tuple2_proj_2 a1 a (Tuple2 a1 a u u1)) u1)))))

;; tuple2_inversion
(assert
  (forall ((a ty) (a1 ty))
    (forall ((u uni))
      (=>
        (sort (tuple21 a1 a) u)
        (= u (Tuple2 a1 a (Tuple2_proj_1 a1 a u) (Tuple2_proj_2 a1 a u)))))))

(declare-sort lib_trail_trail 0)

;; lib_trail_trail
(declare-fun lib_trail_trail1 () ty)

;; Lib_Trail_Trail
(declare-fun Lib_Trail_Trail ((creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit))
  (creusotcontracts_std1_vec_vec (tuple2 uint64
  lib_trail_reason))) lib_trail_trail)

;; Lib_Trail_Trail_proj_1
(declare-fun Lib_Trail_Trail_proj_1 (lib_trail_trail) (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit)))

;; Lib_Trail_Trail_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit))) (u1 (creusotcontracts_std1_vec_vec (tuple2 uint64 lib_trail_reason))))
    (= (Lib_Trail_Trail_proj_1 (Lib_Trail_Trail u u1)) u)))

;; Lib_Trail_Trail_proj_2
(declare-fun Lib_Trail_Trail_proj_2 (lib_trail_trail) (creusotcontracts_std1_vec_vec (tuple2 uint64
  lib_trail_reason)))

;; Lib_Trail_Trail_proj_2'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit))) (u1 (creusotcontracts_std1_vec_vec (tuple2 uint64 lib_trail_reason))))
    (= (Lib_Trail_Trail_proj_2 (Lib_Trail_Trail u u1)) u1)))

;; lib_trail_trail_inversion
(assert
  (forall ((u lib_trail_trail))
    (= u (Lib_Trail_Trail
           (Lib_Trail_Trail_proj_1 u)
           (Lib_Trail_Trail_proj_2 u)))))

;; lib_trail_trail_Trail_trail
(declare-fun lib_trail_trail_Trail_trail (lib_trail_trail) (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit)))

;; lib_trail_trail_Trail_trail_acc
(assert
  (forall ((a (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit))) (b (creusotcontracts_std1_vec_vec (tuple2 uint64 lib_trail_reason))))
    (= (lib_trail_trail_Trail_trail (Lib_Trail_Trail a b)) a)))

;; lib_trail_trail_Trail_vardata
(declare-fun lib_trail_trail_Trail_vardata (lib_trail_trail) (creusotcontracts_std1_vec_vec (tuple2 uint64
  lib_trail_reason)))

;; lib_trail_trail_Trail_vardata_acc
(assert
  (forall ((a (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_lit_lit))) (b (creusotcontracts_std1_vec_vec (tuple2 uint64 lib_trail_reason))))
    (= (lib_trail_trail_Trail_vardata (Lib_Trail_Trail a b)) b)))

;; creusotcontracts_logic_ghost_ghost
(declare-fun creusotcontracts_logic_ghost_ghost (ty) ty)

;; CreusotContracts_Logic_Ghost_Ghost
(declare-fun CreusotContracts_Logic_Ghost_Ghost (ty
  opaque_ptr) uni)

;; CreusotContracts_Logic_Ghost_Ghost_sort
(assert
  (forall ((t ty))
    (forall ((x opaque_ptr))
      (sort
        (creusotcontracts_logic_ghost_ghost t)
        (CreusotContracts_Logic_Ghost_Ghost t x)))))

;; CreusotContracts_Logic_Ghost_Ghost_proj_1
(declare-fun CreusotContracts_Logic_Ghost_Ghost_proj_1 (ty
  uni) opaque_ptr)

;; CreusotContracts_Logic_Ghost_Ghost_proj_1'def
(assert
  (forall ((t ty))
    (forall ((u opaque_ptr))
      (= (CreusotContracts_Logic_Ghost_Ghost_proj_1
           t
           (CreusotContracts_Logic_Ghost_Ghost t u)) u))))

;; creusotcontracts_logic_ghost_ghost_inversion
(assert
  (forall ((t ty))
    (forall ((u uni))
      (=>
        (sort (creusotcontracts_logic_ghost_ghost t) u)
        (= u (CreusotContracts_Logic_Ghost_Ghost
               t
               (CreusotContracts_Logic_Ghost_Ghost_proj_1 t u)))))))

(declare-sort lib_formula_satstate 0)

;; lib_formula_satstate
(declare-fun lib_formula_satstate1 () ty)

;; Lib_Formula_SatState_Unknown
(declare-fun Lib_Formula_SatState_Unknown () lib_formula_satstate)

;; Lib_Formula_SatState_Sat
(declare-fun Lib_Formula_SatState_Sat () lib_formula_satstate)

;; Lib_Formula_SatState_Unsat
(declare-fun Lib_Formula_SatState_Unsat () lib_formula_satstate)

;; match_lib_formula_satstate
(declare-fun match_lib_formula_satstate (ty
  lib_formula_satstate
  uni
  uni
  uni) uni)

;; match_lib_formula_satstate_sort
(assert
  (forall ((a ty))
    (forall ((x lib_formula_satstate) (x1 uni) (x2 uni) (x3 uni))
      (sort a (match_lib_formula_satstate a x x1 x2 x3)))))

;; match_lib_formula_satstate_Lib_Formula_SatState_Unknown
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni))
      (=>
        (sort a z)
        (= (match_lib_formula_satstate
             a
             Lib_Formula_SatState_Unknown
             z
             z1
             z2) z)))))

;; match_lib_formula_satstate_Lib_Formula_SatState_Sat
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni))
      (=>
        (sort a z1)
        (= (match_lib_formula_satstate a Lib_Formula_SatState_Sat z z1 z2) z1)))))

;; match_lib_formula_satstate_Lib_Formula_SatState_Unsat
(assert
  (forall ((a ty))
    (forall ((z uni) (z1 uni) (z2 uni))
      (=>
        (sort a z2)
        (= (match_lib_formula_satstate a Lib_Formula_SatState_Unsat z z1 z2) z2)))))

;; index_lib_formula_satstate
(declare-fun index_lib_formula_satstate (lib_formula_satstate) Int)

;; index_lib_formula_satstate_Lib_Formula_SatState_Unknown
(assert (= (index_lib_formula_satstate Lib_Formula_SatState_Unknown) 0))

;; index_lib_formula_satstate_Lib_Formula_SatState_Sat
(assert (= (index_lib_formula_satstate Lib_Formula_SatState_Sat) 1))

;; index_lib_formula_satstate_Lib_Formula_SatState_Unsat
(assert (= (index_lib_formula_satstate Lib_Formula_SatState_Unsat) 2))

;; lib_formula_satstate_inversion
(assert
  (forall ((u lib_formula_satstate))
    (or
      (or (= u Lib_Formula_SatState_Unknown) (= u Lib_Formula_SatState_Sat))
      (= u Lib_Formula_SatState_Unsat))))

(declare-sort lib_watches_watcher 0)

;; lib_watches_watcher
(declare-fun lib_watches_watcher1 () ty)

;; Lib_Watches_Watcher
(declare-fun Lib_Watches_Watcher (uint64) lib_watches_watcher)

;; Lib_Watches_Watcher_proj_1
(declare-fun Lib_Watches_Watcher_proj_1 (lib_watches_watcher) uint64)

;; Lib_Watches_Watcher_proj_1'def
(assert
  (forall ((u uint64))
    (= (Lib_Watches_Watcher_proj_1 (Lib_Watches_Watcher u)) u)))

;; lib_watches_watcher_inversion
(assert
  (forall ((u lib_watches_watcher))
    (= u (Lib_Watches_Watcher (Lib_Watches_Watcher_proj_1 u)))))

;; lib_watches_watcher_Watcher_cref
(declare-fun lib_watches_watcher_Watcher_cref (lib_watches_watcher) uint64)

;; lib_watches_watcher_Watcher_cref_acc
(assert
  (forall ((a uint64))
    (= (lib_watches_watcher_Watcher_cref (Lib_Watches_Watcher a)) a)))

(declare-sort lib_watches_watches 0)

;; lib_watches_watches
(declare-fun lib_watches_watches1 () ty)

;; Lib_Watches_Watches
(declare-fun Lib_Watches_Watches ((creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_watches_watcher))) lib_watches_watches)

;; Lib_Watches_Watches_proj_1
(declare-fun Lib_Watches_Watches_proj_1 (lib_watches_watches) (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_watches_watcher)))

;; Lib_Watches_Watches_proj_1'def
(assert
  (forall ((u (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_watches_watcher))))
    (= (Lib_Watches_Watches_proj_1 (Lib_Watches_Watches u)) u)))

;; lib_watches_watches_inversion
(assert
  (forall ((u lib_watches_watches))
    (= u (Lib_Watches_Watches (Lib_Watches_Watches_proj_1 u)))))

;; lib_watches_watches_Watches_watches
(declare-fun lib_watches_watches_Watches_watches (lib_watches_watches) (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_watches_watcher)))

;; lib_watches_watches_Watches_watches_acc
(assert
  (forall ((a (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec lib_watches_watcher))))
    (= (lib_watches_watches_Watches_watches (Lib_Watches_Watches a)) a)))

;; invariant'
(declare-fun invariantqt (lib_lit_lit
  Int) Bool)

;; invariant''def
(assert
  (forall ((self lib_lit_lit) (n Int))
    (= (invariantqt self n) (< (uint64qtint (lib_lit_lit_Lit_idx self)) n))))

;; model
(declare-fun model3 ((creusotcontracts_std1_vec_vec lib_lit_lit)) (seq lib_lit_lit))

;; model
(declare-fun model4 (lib_clause_clause) (seq lib_lit_lit))

;; model'def
(assert
  (forall ((self lib_clause_clause))
    (= (model4 self) (model3 (lib_clause_clause_Clause_rest self)))))

;; no_duplicate_indexes
(declare-fun no_duplicate_indexes (lib_clause_clause) Bool)

;; t2tb
(declare-fun t2tb4 (lib_lit_lit) uni)

;; t2tb_sort
(assert (forall ((x lib_lit_lit)) (sort lib_lit_lit1 (t2tb4 x))))

;; tb2t
(declare-fun tb2t4 (uni) lib_lit_lit)

;; BridgeL
(assert
  (forall ((i lib_lit_lit))
    (! (= (tb2t4 (t2tb4 i)) i) :pattern ((t2tb4 i)) )))

;; BridgeR
(assert
  (forall ((j uni))
    (! (=> (sort lib_lit_lit1 j) (= (t2tb4 (tb2t4 j)) j)) :pattern ((t2tb4
                                                                    (tb2t4 j))) )))

;; t2tb
(declare-fun t2tb5 ((seq lib_lit_lit)) uni)

;; t2tb_sort
(assert
  (forall ((x (seq lib_lit_lit))) (sort (seq1 lib_lit_lit1) (t2tb5 x))))

;; tb2t
(declare-fun tb2t5 (uni) (seq lib_lit_lit))

;; BridgeL
(assert
  (forall ((i (seq lib_lit_lit)))
    (! (= (tb2t5 (t2tb5 i)) i) :pattern ((t2tb5 i)) )))

;; BridgeR
(assert
  (forall ((j uni))
    (! (= (t2tb5 (tb2t5 j)) j) :pattern ((t2tb5 (tb2t5 j))) )))

;; no_duplicate_indexes'def
(assert
  (forall ((self lib_clause_clause))
    (=
      (no_duplicate_indexes self)
      (forall ((k Int))
        (forall ((j Int))
          (=>
            (and
              (<= 0 j)
              (and (< j (length lib_lit_lit1 (t2tb5 (model4 self)))) (< k j)))
            (not
              (= (uint64qtint
                   (lib_lit_lit_Lit_idx
                     (tb2t4 (get lib_lit_lit1 (t2tb5 (model4 self)) k)))) 
              (uint64qtint
                (lib_lit_lit_Lit_idx
                  (tb2t4 (get lib_lit_lit1 (t2tb5 (model4 self)) j))))))))))))

;; vars_in_range
(declare-fun vars_in_range (lib_clause_clause
  Int) Bool)

;; vars_in_range'def
(assert
  (forall ((self lib_clause_clause) (n Int))
    (=
      (vars_in_range self n)
      (forall ((i Int))
        (=>
          (and (<= 0 i) (< i (length lib_lit_lit1 (t2tb5 (model4 self)))))
          (invariantqt (tb2t4 (get lib_lit_lit1 (t2tb5 (model4 self)) i)) n))))))

;; invariant'
(declare-fun invariantqt1 (lib_clause_clause
  Int) Bool)

;; invariant''def
(assert
  (forall ((self lib_clause_clause) (n Int))
    (=
      (invariantqt1 self n)
      (and (vars_in_range self n) (no_duplicate_indexes self)))))

;; unsat_inner
(declare-fun unsat_inner (lib_lit_lit
  (seq uint8)) Bool)

;; unsat_inner'def
(assert
  (forall ((self lib_lit_lit) (a (seq uint8)))
    (ite (= (lib_lit_lit_Lit_polarity self) true)
      (=
        (unsat_inner self a)
        (= (uint8qtint
             (tb2t1
               (get uint81 (t2tb a) (uint64qtint (lib_lit_lit_Lit_idx self))))) 0))
      (=
        (unsat_inner self a)
        (= (uint8qtint
             (tb2t1
               (get uint81 (t2tb a) (uint64qtint (lib_lit_lit_Lit_idx self))))) 1)))))

;; unsat_inner
(declare-fun unsat_inner1 (lib_clause_clause
  (seq uint8)) Bool)

;; unsat_inner'def
(assert
  (forall ((self lib_clause_clause) (a (seq uint8)))
    (=
      (unsat_inner1 self a)
      (forall ((i Int))
        (=>
          (and (<= 0 i) (< i (length lib_lit_lit1 (t2tb5 (model4 self)))))
          (unsat_inner (tb2t4 (get lib_lit_lit1 (t2tb5 (model4 self)) i)) a))))))

;; sat_inner
(declare-fun sat_inner (lib_lit_lit
  (seq uint8)) Bool)

;; sat_inner'def
(assert
  (forall ((self lib_lit_lit) (a (seq uint8)))
    (ite (= (lib_lit_lit_Lit_polarity self) true)
      (=
        (sat_inner self a)
        (= (uint8qtint
             (tb2t1
               (get uint81 (t2tb a) (uint64qtint (lib_lit_lit_Lit_idx self))))) 1))
      (=
        (sat_inner self a)
        (= (uint8qtint
             (tb2t1
               (get uint81 (t2tb a) (uint64qtint (lib_lit_lit_Lit_idx self))))) 0)))))

;; sat_inner
(declare-fun sat_inner1 (lib_clause_clause
  (seq uint8)) Bool)

;; sat_inner'def
(assert
  (forall ((self lib_clause_clause) (a (seq uint8)))
    (=
      (sat_inner1 self a)
      (exists ((i Int))
        (and
          (<= 0 i)
          (and
            (< i (length lib_lit_lit1 (t2tb5 (model4 self))))
            (sat_inner (tb2t4 (get lib_lit_lit1 (t2tb5 (model4 self)) i)) a)))))))

;; unset
(declare-fun unset (uint8) Bool)

;; unset'def
(assert
  (forall ((v uint8)) (ite (<= 2 (uint8qtint v)) (unset v) (not (unset v)))))

;; complete_inner
(declare-fun complete_inner ((seq uint8)) Bool)

;; complete_inner'def
(assert
  (forall ((a (seq uint8)))
    (=
      (complete_inner a)
      (forall ((i Int))
        (=>
          (and (<= 0 i) (< i (length1 a)))
          (not (unset (tb2t1 (get uint81 (t2tb a) i)))))))))

;; compatible_inner
(declare-fun compatible_inner ((seq uint8)
  (seq uint8)) Bool)

;; compatible_inner'def
(assert
  (forall ((a (seq uint8)) (a2 (seq uint8)))
    (=
      (compatible_inner a a2)
      (and
        (= (length1 a) (length1 a2))
        (forall ((i Int))
          (=>
            (and (<= 0 i) (< i (length1 a)))
            (or
              (unset (tb2t1 (get uint81 (t2tb a) i)))
              (= (tb2t1 (get uint81 (t2tb a) i)) (tb2t1
                                                   (get uint81 (t2tb a2) i))))))))))

;; compatible_complete_inner
(declare-fun compatible_complete_inner ((seq uint8)
  (seq uint8)) Bool)

;; compatible_complete_inner'def
(assert
  (forall ((a (seq uint8)) (a2 (seq uint8)))
    (=
      (compatible_complete_inner a a2)
      (and (compatible_inner a a2) (complete_inner a2)))))

;; model
(declare-fun model5 ((creusotcontracts_std1_vec_vec lib_clause_clause)) (seq lib_clause_clause))

;; invariant'
(declare-fun invariantqt2 (lib_formula_formula) Bool)

;; t2tb
(declare-fun t2tb6 (lib_clause_clause) uni)

;; t2tb_sort
(assert (forall ((x lib_clause_clause)) (sort lib_clause_clause1 (t2tb6 x))))

;; tb2t
(declare-fun tb2t6 (uni) lib_clause_clause)

;; BridgeL
(assert
  (forall ((i lib_clause_clause))
    (! (= (tb2t6 (t2tb6 i)) i) :pattern ((t2tb6 i)) )))

;; BridgeR
(assert
  (forall ((j uni))
    (! (=> (sort lib_clause_clause1 j) (= (t2tb6 (tb2t6 j)) j)) :pattern (
    (t2tb6
      (tb2t6 j))) )))

;; t2tb
(declare-fun t2tb7 ((seq lib_clause_clause)) uni)

;; t2tb_sort
(assert
  (forall ((x (seq lib_clause_clause)))
    (sort (seq1 lib_clause_clause1) (t2tb7 x))))

;; tb2t
(declare-fun tb2t7 (uni) (seq lib_clause_clause))

;; BridgeL
(assert
  (forall ((i (seq lib_clause_clause)))
    (! (= (tb2t7 (t2tb7 i)) i) :pattern ((t2tb7 i)) )))

;; BridgeR
(assert
  (forall ((j uni))
    (! (= (t2tb7 (tb2t7 j)) j) :pattern ((t2tb7 (tb2t7 j))) )))

;; invariant''def
(assert
  (forall ((self lib_formula_formula))
    (=
      (invariantqt2 self)
      (forall ((i Int))
        (=>
          (and
            (<= 0 i)
            (< i (length
                   lib_clause_clause1
                   (t2tb7
                     (model5 (lib_formula_formula_Formula_clauses self))))))
          (invariantqt1
            (tb2t6
              (get
                lib_clause_clause1
                (t2tb7 (model5 (lib_formula_formula_Formula_clauses self)))
                i))
            (uint64qtint (lib_formula_formula_Formula_num_vars self))))))))

;; unsat_inner
(declare-fun unsat_inner2 (lib_formula_formula
  (seq uint8)) Bool)

;; unsat_inner'def
(assert
  (forall ((self lib_formula_formula) (a (seq uint8)))
    (=
      (unsat_inner2 self a)
      (exists ((i Int))
        (and
          (<= 0 i)
          (and
            (< i (length
                   lib_clause_clause1
                   (t2tb7
                     (model5 (lib_formula_formula_Formula_clauses self)))))
            (unsat_inner1
              (tb2t6
                (get
                  lib_clause_clause1
                  (t2tb7 (model5 (lib_formula_formula_Formula_clauses self)))
                  i))
              a)))))))

;; sat_inner
(declare-fun sat_inner2 (lib_formula_formula
  (seq uint8)) Bool)

;; sat_inner'def
(assert
  (forall ((self lib_formula_formula) (a (seq uint8)))
    (=
      (sat_inner2 self a)
      (forall ((i Int))
        (=>
          (and
            (<= 0 i)
            (< i (length
                   lib_clause_clause1
                   (t2tb7
                     (model5 (lib_formula_formula_Formula_clauses self))))))
          (sat_inner1
            (tb2t6
              (get
                lib_clause_clause1
                (t2tb7 (model5 (lib_formula_formula_Formula_clauses self)))
                i))
            a))))))

;; eventually_sat_complete_inner
(declare-fun eventually_sat_complete_inner (lib_formula_formula
  (seq uint8)) Bool)

;; eventually_sat_complete_inner'def
(assert
  (forall ((self lib_formula_formula) (a (seq uint8)))
    (=
      (eventually_sat_complete_inner self a)
      (exists ((a2 (seq uint8)))
        (and
          (= (length1 a2) (uint64qtint
                            (lib_formula_formula_Formula_num_vars self)))
          (and (compatible_complete_inner a a2) (sat_inner2 self a2)))))))

;; assignments_invariant
(declare-fun assignments_invariant ((seq uint8)
  lib_formula_formula) Bool)

;; assignments_invariant'def
(assert
  (forall ((a (seq uint8)) (f lib_formula_formula))
    (=
      (assignments_invariant a f)
      (= (uint64qtint (lib_formula_formula_Formula_num_vars f)) (length1 a)))))

;; lemma_not_sat_formula_implies_unsat_formula_spec
(assert
  (forall ((f lib_formula_formula) (a (seq uint8)))
    (=>
      (unsat_inner2 f a)
      (=>
        (assignments_invariant a f)
        (=> (invariantqt2 f) (not (eventually_sat_complete_inner f a)))))))

;; flip_v
(declare-fun flip_v (uint8) uint8)

;; rliteral
(declare-fun rliteral1 () uint8)

;; rliteral_axiom
(assert (= (uint8qtint rliteral1) 1))

;; rliteral
(declare-fun rliteral2 () uint8)

;; rliteral_axiom
(assert (= (uint8qtint rliteral2) 0))

;; flip_v'def
(assert
  (forall ((v uint8))
    (ite (= (uint8qtint v) 0)
      (= (flip_v v) rliteral1)
      (ite (= (uint8qtint v) 1) (= (flip_v v) rliteral2) (= (flip_v v) v)))))

;; f
(declare-fun f () lib_formula_formula)

;; a
(declare-fun a () (seq uint8))

;; ix
(declare-fun ix () Int)

;; v
(declare-fun v () uint8)

;; Requires
(assert (not (eventually_sat_complete_inner f (set1 a ix (flip_v v)))))

;; Requires
(assert (eventually_sat_complete_inner f a))

;; H
(assert (<= 0 ix))

;; H
(assert (< ix (length1 a)))

;; Requires
(assert
  (= (uint64qtint (lib_formula_formula_Formula_num_vars f)) (length1 a)))

;; Goal lemma_unit_forces'vc
;; File "/Users/sarek/sat/mlcfgs/lib.mlcfg", line 2832, characters 25-42
(assert
  (not
  (exists ((a2 (seq uint8)))
    (and
      (= (length1 a2) (uint64qtint (lib_formula_formula_Formula_num_vars f)))
      (and (compatible_complete_inner (set1 a ix v) a2) (sat_inner2 f a2))))))

(check-sat)
(get-info :reason-unknown)
