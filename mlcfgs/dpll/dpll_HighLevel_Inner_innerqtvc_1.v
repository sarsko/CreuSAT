(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require Reals.Rbasic_fun.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require real.Real.
Require real.Abs.
Require real.FromInt.
Require floating_point.Rounding.
Require floating_point.SingleFormat.
Require floating_point.DoubleFormat.
Require floating_point.Single.
Require floating_point.Double.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom int32 : Type.
Parameter int32_WhyType : WhyType int32.
Existing Instance int32_WhyType.

Parameter int32'int: int32 -> Numbers.BinNums.Z.

Axiom int32'axiom :
  forall (i:int32),
  ((-2147483648%Z)%Z <= (int32'int i))%Z /\ ((int32'int i) <= 2147483647%Z)%Z.

(* Why3 assumption *)
Definition in_bounds (n:Numbers.BinNums.Z) : Prop :=
  ((-2147483648%Z)%Z <= n)%Z /\ (n <= 2147483647%Z)%Z.

Axiom to_int_in_bounds : forall (n:int32), in_bounds (int32'int n).

Axiom extensionality :
  forall (x:int32) (y:int32), ((int32'int x) = (int32'int y)) -> (x = y).

Axiom int64 : Type.
Parameter int64_WhyType : WhyType int64.
Existing Instance int64_WhyType.

Parameter int64'int: int64 -> Numbers.BinNums.Z.

Axiom int64'axiom :
  forall (i:int64),
  ((-9223372036854775808%Z)%Z <= (int64'int i))%Z /\
  ((int64'int i) <= 9223372036854775807%Z)%Z.

(* Why3 assumption *)
Definition in_bounds1 (n:Numbers.BinNums.Z) : Prop :=
  ((-9223372036854775808%Z)%Z <= n)%Z /\ (n <= 9223372036854775807%Z)%Z.

Axiom to_int_in_bounds1 : forall (n:int64), in_bounds1 (int64'int n).

Axiom extensionality1 :
  forall (x:int64) (y:int64), ((int64'int x) = (int64'int y)) -> (x = y).

Axiom uint32 : Type.
Parameter uint32_WhyType : WhyType uint32.
Existing Instance uint32_WhyType.

Parameter uint32'int: uint32 -> Numbers.BinNums.Z.

Axiom uint32'axiom :
  forall (i:uint32),
  (0%Z <= (uint32'int i))%Z /\ ((uint32'int i) <= 4294967295%Z)%Z.

(* Why3 assumption *)
Definition in_bounds2 (n:Numbers.BinNums.Z) : Prop :=
  (0%Z <= n)%Z /\ (n <= 4294967295%Z)%Z.

Axiom to_int_in_bounds2 : forall (n:uint32), in_bounds2 (uint32'int n).

Axiom extensionality2 :
  forall (x:uint32) (y:uint32), ((uint32'int x) = (uint32'int y)) -> (x = y).

Parameter zero_unsigned: uint32.

Axiom zero_unsigned_is_zero : ((uint32'int zero_unsigned) = 0%Z).

Axiom uint64 : Type.
Parameter uint64_WhyType : WhyType uint64.
Existing Instance uint64_WhyType.

Parameter uint64'int: uint64 -> Numbers.BinNums.Z.

Axiom uint64'axiom :
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\ ((uint64'int i) <= 18446744073709551615%Z)%Z.

(* Why3 assumption *)
Definition in_bounds3 (n:Numbers.BinNums.Z) : Prop :=
  (0%Z <= n)%Z /\ (n <= 18446744073709551615%Z)%Z.

Axiom to_int_in_bounds3 : forall (n:uint64), in_bounds3 (uint64'int n).

Axiom extensionality3 :
  forall (x:uint64) (y:uint64), ((uint64'int x) = (uint64'int y)) -> (x = y).

Parameter zero_unsigned1: uint64.

Axiom zero_unsigned_is_zero1 : ((uint64'int zero_unsigned1) = 0%Z).

Parameter concat: BuiltIn.string -> BuiltIn.string -> BuiltIn.string.

Axiom concat_assoc :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ((concat (concat s1 s2) s3) = (concat s1 (concat s2 s3))).

Parameter rliteral: BuiltIn.string.

Axiom rliteral_axiom : True.

Axiom concat_empty :
  forall (s:BuiltIn.string),
  ((concat s rliteral) = (concat rliteral s)) /\ ((concat rliteral s) = s).

Parameter length: BuiltIn.string -> Numbers.BinNums.Z.

Axiom length_empty : ((length rliteral) = 0%Z).

Axiom length_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  ((length (concat s1 s2)) = ((length s1) + (length s2))%Z).

Parameter lt: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom lt_empty :
  forall (s:BuiltIn.string), ~ (s = rliteral) -> lt rliteral s.

Axiom lt_not_com :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), lt s1 s2 -> ~ lt s2 s1.

Axiom lt_ref : forall (s1:BuiltIn.string), ~ lt s1 s1.

Axiom lt_trans :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  lt s1 s2 /\ lt s2 s3 -> lt s1 s3.

Parameter le: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom le_empty : forall (s:BuiltIn.string), le rliteral s.

Axiom le_ref : forall (s1:BuiltIn.string), le s1 s1.

Axiom lt_le :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), lt s1 s2 -> le s1 s2.

Axiom lt_le_eq :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), le s1 s2 ->
  lt s1 s2 \/ (s1 = s2).

Axiom le_trans :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  le s1 s2 /\ le s2 s3 -> le s1 s3.

Parameter s_at: BuiltIn.string -> Numbers.BinNums.Z -> BuiltIn.string.

Axiom at_out_of_range :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length s) <= i)%Z -> ((s_at s i) = rliteral).

Axiom at_empty :
  forall (i:Numbers.BinNums.Z), ((s_at rliteral i) = rliteral).

Axiom at_length :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := s_at s i in
  ((0%Z <= i)%Z /\ (i < (length s))%Z -> ((length j) = 1%Z)) /\
  (~ ((0%Z <= i)%Z /\ (i < (length s))%Z) -> ((length j) = 0%Z)).

Axiom concat_at :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  let s := concat s1 s2 in
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i < (length s1))%Z -> ((s_at s i) = (s_at s1 i))) /\
  (((length s1) <= i)%Z /\ (i < (length s))%Z ->
   ((s_at s i) = (s_at s2 (i - (length s1))%Z))).

Parameter substring:
  BuiltIn.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> BuiltIn.string.

Axiom substring_out_of_range :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length s) <= i)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_length_zero_or_less :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (x <= 0%Z)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_empty :
  forall (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((substring rliteral i x) = rliteral).

Axiom substring_smaller :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((length (substring s i x)) <= (length s))%Z.

Axiom substring_smaller_x :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z -> ((length (substring s i x)) <= x)%Z.

Axiom substring_length :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z /\ (0%Z <= i)%Z /\ (i < (length s))%Z ->
  (((length s) < (i + x)%Z)%Z ->
   ((length (substring s i x)) = ((length s) - i)%Z)) /\
  (~ ((length s) < (i + x)%Z)%Z -> ((length (substring s i x)) = x)).

Axiom substring_at :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((s_at s i) = (substring s i 1%Z)).

Axiom substring_substring :
  forall (s:BuiltIn.string) (ofs:Numbers.BinNums.Z) (len:Numbers.BinNums.Z)
    (ofs':Numbers.BinNums.Z) (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length s))%Z -> (0%Z <= ofs')%Z /\ (ofs' <= len)%Z ->
  (0%Z <= len')%Z -> ((ofs' + len')%Z <= len)%Z ->
  ((substring (substring s ofs len) ofs' len') =
   (substring s (ofs + ofs')%Z len')).

Axiom concat_substring :
  forall (s:BuiltIn.string) (ofs:Numbers.BinNums.Z) (len:Numbers.BinNums.Z)
    (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length s))%Z -> (0%Z <= len')%Z ->
  (0%Z <= ((ofs + len)%Z + len')%Z)%Z /\
  (((ofs + len)%Z + len')%Z <= (length s))%Z ->
  ((concat (substring s ofs len) (substring s (ofs + len)%Z len')) =
   (substring s ofs (len + len')%Z)).

Parameter prefixof: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom prefixof_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  prefixof s1 s2 <-> (s1 = (substring s2 0%Z (length s1))).

Axiom prefixof_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), prefixof s1 (concat s1 s2).

Axiom prefixof_empty : forall (s2:BuiltIn.string), prefixof rliteral s2.

Axiom prefixof_empty2 :
  forall (s1:BuiltIn.string), ~ (s1 = rliteral) -> ~ prefixof s1 rliteral.

Parameter suffixof: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom suffixof_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  suffixof s1 s2 <->
  (s1 = (substring s2 ((length s2) - (length s1))%Z (length s1))).

Axiom suffixof_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), suffixof s2 (concat s1 s2).

Axiom suffixof_empty : forall (s2:BuiltIn.string), suffixof rliteral s2.

Axiom suffixof_empty2 :
  forall (s1:BuiltIn.string), ~ (s1 = rliteral) -> ~ suffixof s1 rliteral.

Parameter contains: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom contains_prefixof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), prefixof s1 s2 ->
  contains s2 s1.

Axiom contains_suffixof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), suffixof s1 s2 ->
  contains s2 s1.

Axiom contains_empty :
  forall (s2:BuiltIn.string), contains rliteral s2 <-> (s2 = rliteral).

Axiom contains_empty2 : forall (s1:BuiltIn.string), contains s1 rliteral.

Axiom contains_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((substring s1 i (length s2)) = s2) -> contains s1 s2.

Axiom contains_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  contains (concat s1 s2) s1 /\ contains (concat s1 s2) s2.

Axiom contains_at :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((s_at s1 i) = s2) -> contains s1 s2.

Parameter indexof:
  BuiltIn.string -> BuiltIn.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom indexof_empty :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z -> ((indexof s rliteral i) = i).

Axiom indexof_empty1 :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof rliteral s i in
  (j = (-1%Z)%Z) \/ (s = rliteral) /\ (i = j) /\ (j = 0%Z).

Axiom indexof_contains :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  let j := indexof s1 s2 0%Z in
  contains s1 s2 ->
  ((0%Z <= j)%Z /\ (j <= (length s1))%Z) /\
  ((substring s1 j (length s2)) = s2).

Axiom contains_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= (indexof s1 s2 i))%Z -> contains s1 s2.

Axiom not_contains_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ~ contains s1 s2 -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom substring_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= j)%Z -> ((substring s1 j (length s2)) = s2).

Axiom indexof_out_of_range :
  forall (i:Numbers.BinNums.Z) (s1:BuiltIn.string) (s2:BuiltIn.string),
  ~ ((0%Z <= i)%Z /\ (i <= (length s1))%Z) -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom indexof_in_range :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= i)%Z /\ (i <= (length s1))%Z ->
  (j = (-1%Z)%Z) \/ (i <= j)%Z /\ (j <= (length s1))%Z.

Axiom indexof_contains_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i <= (length s1))%Z) /\
  contains (substring s1 i ((length s1) - i)%Z) s2 ->
  (i <= (indexof s1 s2 i))%Z /\ ((indexof s1 s2 i) <= (length s1))%Z.

Parameter replace:
  BuiltIn.string -> BuiltIn.string -> BuiltIn.string -> BuiltIn.string.

Axiom replace_empty :
  forall (s1:BuiltIn.string) (s3:BuiltIn.string),
  ((replace s1 rliteral s3) = (concat s3 s1)).

Axiom replace_not_contains :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ~ contains s1 s2 -> ((replace s1 s2 s3) = s1).

Axiom replace_empty2 :
  forall (s2:BuiltIn.string) (s3:BuiltIn.string),
  let s4 := replace rliteral s2 s3 in
  ((s2 = rliteral) -> (s4 = s3)) /\ (~ (s2 = rliteral) -> (s4 = rliteral)).

Axiom replace_substring_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  let j := indexof s1 s2 0%Z in
  ((j < 0%Z)%Z -> ((replace s1 s2 s3) = s1)) /\
  (~ (j < 0%Z)%Z ->
   ((replace s1 s2 s3) =
    (concat (concat (substring s1 0%Z j) s3)
     (substring s1 (j + (length s2))%Z (((length s1) - j)%Z - (length s2))%Z)))).

Parameter replaceall:
  BuiltIn.string -> BuiltIn.string -> BuiltIn.string -> BuiltIn.string.

Axiom replaceall_empty1 :
  forall (s1:BuiltIn.string) (s3:BuiltIn.string),
  ((replaceall s1 rliteral s3) = s1).

Axiom not_contains_replaceall :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ~ contains s1 s2 -> ((replaceall s1 s2 s3) = s1).

Parameter to_int: BuiltIn.string -> Numbers.BinNums.Z.

Axiom to_int_gt_minus_1 :
  forall (s:BuiltIn.string), ((-1%Z)%Z <= (to_int s))%Z.

Axiom to_int_empty : ((to_int rliteral) = (-1%Z)%Z).

(* Why3 assumption *)
Definition is_digit (s:BuiltIn.string) : Prop :=
  ((0%Z <= (to_int s))%Z /\ ((to_int s) <= 9%Z)%Z) /\ ((length s) = 1%Z).

Parameter from_int: Numbers.BinNums.Z -> BuiltIn.string.

Axiom from_int_negative :
  forall (i:Numbers.BinNums.Z), (i < 0%Z)%Z <-> ((from_int i) = rliteral).

Axiom from_int_to_int :
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z -> ((to_int (from_int i)) = i)) /\
  (~ (0%Z <= i)%Z -> ((to_int (from_int i)) = (-1%Z)%Z)).

Axiom char : Type.
Parameter char_WhyType : WhyType char.
Existing Instance char_WhyType.

Parameter contents1: char -> BuiltIn.string.

Axiom char'invariant : forall (self:char), ((length (contents1 self)) = 1%Z).

Axiom char_eq :
  forall (c1:char) (c2:char), ((contents1 c1) = (contents1 c2)) -> (c1 = c2).

Parameter code: char -> Numbers.BinNums.Z.

Axiom code1 : forall (c:char), (0%Z <= (code c))%Z /\ ((code c) < 256%Z)%Z.

Parameter chr: Numbers.BinNums.Z -> char.

Axiom code_chr :
  forall (n:Numbers.BinNums.Z), (0%Z <= n)%Z /\ (n < 256%Z)%Z ->
  ((code (chr n)) = n).

Axiom chr_code : forall (c:char), ((chr (code c)) = c).

Parameter get: BuiltIn.string -> Numbers.BinNums.Z -> char.

Axiom get1 :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length s))%Z -> ((contents1 (get s i)) = (s_at s i)).

Axiom substring_get :
  forall (s:BuiltIn.string) (ofs:Numbers.BinNums.Z) (len:Numbers.BinNums.Z)
    (i:Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length s))%Z -> (0%Z <= i)%Z /\ (i < len)%Z ->
  ((get (substring s ofs len) i) = (get s (ofs + i)%Z)).

Axiom concat_first :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
  ((get (concat s1 s2) i) = (get s1 i)).

Axiom concat_second :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  forall (i:Numbers.BinNums.Z),
  ((length s1) <= i)%Z /\ (i < ((length s1) + (length s2))%Z)%Z ->
  ((get (concat s1 s2) i) = (get s2 (i - (length s1))%Z)).

(* Why3 assumption *)
Definition eq_string (s1:BuiltIn.string) (s2:BuiltIn.string) : Prop :=
  ((length s1) = (length s2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
   ((get s1 i) = (get s2 i))).

Axiom extensionality4 :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), eq_string s1 s2 ->
  (s1 = s2).

Parameter make: Numbers.BinNums.Z -> char -> BuiltIn.string.

Axiom make_length :
  forall (size:Numbers.BinNums.Z) (v:char), (0%Z <= size)%Z ->
  ((length (make size v)) = size).

Axiom make_contents :
  forall (size:Numbers.BinNums.Z) (v:char), (0%Z <= size)%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < size)%Z ->
  ((get (make size v) i) = v).

(* Why3 assumption *)
Definition usize := uint64.

(* Why3 assumption *)
Definition isize := int64.

Axiom opaque_ptr : Type.
Parameter opaque_ptr_WhyType : WhyType opaque_ptr.
Existing Instance opaque_ptr_WhyType.

(* Why3 assumption *)
Inductive borrowed (a:Type) :=
  | borrowed'mk : a -> a -> borrowed a.
Axiom borrowed_WhyType : forall (a:Type) {a_WT:WhyType a},
  WhyType (borrowed a).
Existing Instance borrowed_WhyType.
Arguments borrowed'mk {a}.

(* Why3 assumption *)
Definition final {a:Type} {a_WT:WhyType a} (v:borrowed a) : a :=
  match v with
  | borrowed'mk x x1 => x1
  end.

(* Why3 assumption *)
Definition current {a:Type} {a_WT:WhyType a} (v:borrowed a) : a :=
  match v with
  | borrowed'mk x x1 => x
  end.

(* Why3 assumption *)
Inductive highlevel_ghost
  (t:Type) :=
  | HighLevel_Ghost : opaque_ptr -> highlevel_ghost t.
Axiom highlevel_ghost_WhyType : forall (t:Type) {t_WT:WhyType t},
  WhyType (highlevel_ghost t).
Existing Instance highlevel_ghost_WhyType.
Arguments HighLevel_Ghost {t}.

(* Why3 assumption *)
Inductive highlevel_lit :=
  | HighLevel_Lit : uint64 -> Init.Datatypes.bool -> highlevel_lit.
Axiom highlevel_lit_WhyType : WhyType highlevel_lit.
Existing Instance highlevel_lit_WhyType.

Parameter highlevel_lit_Lit_idx: highlevel_lit -> uint64.

Axiom highlevel_lit_Lit_idx_acc :
  forall (a:uint64) (b:Init.Datatypes.bool),
  ((highlevel_lit_Lit_idx (HighLevel_Lit a b)) = a).

Parameter highlevel_lit_Lit_polarity: highlevel_lit -> Init.Datatypes.bool.

Axiom highlevel_lit_Lit_polarity_acc :
  forall (a:uint64) (b:Init.Datatypes.bool),
  ((highlevel_lit_Lit_polarity (HighLevel_Lit a b)) = b).

(* Why3 assumption *)
Inductive highlevel_satstate :=
  | HighLevel_SatState_Unknown : highlevel_satstate
  | HighLevel_SatState_Sat : highlevel_satstate
  | HighLevel_SatState_Unsat : highlevel_satstate.
Axiom highlevel_satstate_WhyType : WhyType highlevel_satstate.
Existing Instance highlevel_satstate_WhyType.

(* Why3 assumption *)
Inductive highlevel_assignedstate :=
  | HighLevel_AssignedState_Unset : highlevel_assignedstate
  | HighLevel_AssignedState_Positive : highlevel_assignedstate
  | HighLevel_AssignedState_Negative : highlevel_assignedstate.
Axiom highlevel_assignedstate_WhyType : WhyType highlevel_assignedstate.
Existing Instance highlevel_assignedstate_WhyType.

(* Why3 assumption *)
Inductive core_marker_phantomdata
  (t:Type) :=
  | Core_Marker_PhantomData : core_marker_phantomdata t.
Axiom core_marker_phantomdata_WhyType : forall (t:Type) {t_WT:WhyType t},
  WhyType (core_marker_phantomdata t).
Existing Instance core_marker_phantomdata_WhyType.
Arguments Core_Marker_PhantomData {t}.

(* Why3 assumption *)
Inductive core_ptr_unique_unique
  (t:Type) :=
  | Core_Ptr_Unique_Unique : opaque_ptr -> core_marker_phantomdata t ->
      core_ptr_unique_unique t.
Axiom core_ptr_unique_unique_WhyType : forall (t:Type) {t_WT:WhyType t},
  WhyType (core_ptr_unique_unique t).
Existing Instance core_ptr_unique_unique_WhyType.
Arguments Core_Ptr_Unique_Unique {t}.

(* Why3 assumption *)
Inductive alloc_rawvec_rawvec (t:Type)
  (a:Type) :=
  | Alloc_RawVec_RawVec : core_ptr_unique_unique t -> uint64 -> a ->
      alloc_rawvec_rawvec t a.
Axiom alloc_rawvec_rawvec_WhyType : forall (t:Type) {t_WT:WhyType t}
  (a:Type) {a_WT:WhyType a}, WhyType (alloc_rawvec_rawvec t a).
Existing Instance alloc_rawvec_rawvec_WhyType.
Arguments Alloc_RawVec_RawVec {t} {a}.

(* Why3 assumption *)
Inductive alloc_vec_vec (t:Type)
  (a:Type) :=
  | Alloc_Vec_Vec : alloc_rawvec_rawvec t a -> uint64 -> alloc_vec_vec t a.
Axiom alloc_vec_vec_WhyType : forall (t:Type) {t_WT:WhyType t}
  (a:Type) {a_WT:WhyType a}, WhyType (alloc_vec_vec t a).
Existing Instance alloc_vec_vec_WhyType.
Arguments Alloc_Vec_Vec {t} {a}.

(* Why3 assumption *)
Inductive alloc_alloc_global :=
  | Alloc_Alloc_Global : alloc_alloc_global.
Axiom alloc_alloc_global_WhyType : WhyType alloc_alloc_global.
Existing Instance alloc_alloc_global_WhyType.

(* Why3 assumption *)
Inductive creusotcontracts_std1_vec_vec
  (t:Type) :=
  | CreusotContracts_Std1_Vec_Vec : alloc_vec_vec t alloc_alloc_global ->
      creusotcontracts_std1_vec_vec t.
Axiom creusotcontracts_std1_vec_vec_WhyType : forall
  (t:Type) {t_WT:WhyType t}, WhyType (creusotcontracts_std1_vec_vec t).
Existing Instance creusotcontracts_std1_vec_vec_WhyType.
Arguments CreusotContracts_Std1_Vec_Vec {t}.

(* Why3 assumption *)
Inductive highlevel_assignments :=
  | HighLevel_Assignments : creusotcontracts_std1_vec_vec
                            highlevel_assignedstate ->
      highlevel_assignments.
Axiom highlevel_assignments_WhyType : WhyType highlevel_assignments.
Existing Instance highlevel_assignments_WhyType.

Parameter highlevel_assignments_Assignments_0:
  highlevel_assignments ->
  creusotcontracts_std1_vec_vec highlevel_assignedstate.

Axiom highlevel_assignments_Assignments_0_acc :
  forall (a:creusotcontracts_std1_vec_vec highlevel_assignedstate),
  ((highlevel_assignments_Assignments_0 (HighLevel_Assignments a)) = a).

(* Why3 assumption *)
Inductive highlevel_clause :=
  | HighLevel_Clause : creusotcontracts_std1_vec_vec highlevel_lit ->
      highlevel_clause.
Axiom highlevel_clause_WhyType : WhyType highlevel_clause.
Existing Instance highlevel_clause_WhyType.

Parameter highlevel_clause_Clause_0:
  highlevel_clause -> creusotcontracts_std1_vec_vec highlevel_lit.

Axiom highlevel_clause_Clause_0_acc :
  forall (a:creusotcontracts_std1_vec_vec highlevel_lit),
  ((highlevel_clause_Clause_0 (HighLevel_Clause a)) = a).

(* Why3 assumption *)
Inductive highlevel_formula :=
  | HighLevel_Formula : creusotcontracts_std1_vec_vec highlevel_clause ->
      uint64 -> highlevel_formula.
Axiom highlevel_formula_WhyType : WhyType highlevel_formula.
Existing Instance highlevel_formula_WhyType.

Parameter highlevel_formula_Formula_clauses:
  highlevel_formula -> creusotcontracts_std1_vec_vec highlevel_clause.

Axiom highlevel_formula_Formula_clauses_acc :
  forall (a:creusotcontracts_std1_vec_vec highlevel_clause) (b:uint64),
  ((highlevel_formula_Formula_clauses (HighLevel_Formula a b)) = a).

Parameter highlevel_formula_Formula_num_vars: highlevel_formula -> uint64.

Axiom highlevel_formula_Formula_num_vars_acc :
  forall (a:creusotcontracts_std1_vec_vec highlevel_clause) (b:uint64),
  ((highlevel_formula_Formula_num_vars (HighLevel_Formula a b)) = b).

(* Why3 assumption *)
Inductive highlevel_worklist :=
  | HighLevel_Worklist : creusotcontracts_std1_vec_vec highlevel_lit ->
      highlevel_worklist.
Axiom highlevel_worklist_WhyType : WhyType highlevel_worklist.
Existing Instance highlevel_worklist_WhyType.

Parameter highlevel_worklist_Worklist_0:
  highlevel_worklist -> creusotcontracts_std1_vec_vec highlevel_lit.

Axiom highlevel_worklist_Worklist_0_acc :
  forall (a:creusotcontracts_std1_vec_vec highlevel_lit),
  ((highlevel_worklist_Worklist_0 (HighLevel_Worklist a)) = a).

(* Why3 assumption *)
Inductive core_option_option
  (t:Type) :=
  | Core_Option_Option_None : core_option_option t
  | Core_Option_Option_Some : t -> core_option_option t.
Axiom core_option_option_WhyType : forall (t:Type) {t_WT:WhyType t},
  WhyType (core_option_option t).
Existing Instance core_option_option_WhyType.
Arguments Core_Option_Option_None {t}.
Arguments Core_Option_Option_Some {t}.

Parameter core_option_option_Some_0:
  forall {t:Type} {t_WT:WhyType t}, core_option_option t -> t.

Axiom core_option_option_Some_0_acc :
  forall {t:Type} {t_WT:WhyType t},
  forall (a:t), ((core_option_option_Some_0 (Core_Option_Option_Some a)) = a).

Axiom seq : forall (a:Type), Type.
Parameter seq_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (seq a).
Existing Instance seq_WhyType.

Parameter length1:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z.

Axiom length_nonnegative :
  forall {a:Type} {a_WT:WhyType a}, forall (s:seq a), (0%Z <= (length1 s))%Z.

Parameter get2:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Prop.

Axiom infix_eqeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  (infix_eqeq s1 s2 <->
   ((length1 s1) = (length1 s2)) /\
   (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length1 s1))%Z ->
    ((get2 s1 i) = (get2 s2 i)))) /\
  (infix_eqeq s1 s2 -> (s1 = s2)).

Parameter create:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z ->
  (Numbers.BinNums.Z -> a) -> seq a.

Axiom create'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z ->
  ((length1 (create len f)) = len) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < len)%Z ->
   ((get2 (create len f) i) = (f i))).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, seq a.

Axiom empty'def :
  forall {a:Type} {a_WT:WhyType a}, ((length1 (empty : seq a)) = 0%Z).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Parameter result:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a ->
  Numbers.BinNums.Z -> a.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a) (j:Numbers.BinNums.Z),
  ((j = i) -> ((result s i v j) = v)) /\
  (~ (j = i) -> ((result s i v j) = (get2 s j))).

Axiom set'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length1 s))%Z ->
  ((set s i v) = (create (length1 s) (result s i v))).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length1 s))%Z ->
  ((length1 (set s i v)) = (length1 s)) /\
  ((get2 (set s i v) i) = v) /\
  (forall (j:Numbers.BinNums.Z),
   ((0%Z <= j)%Z /\ (j < (length1 s))%Z) /\ ~ (j = i) ->
   ((get2 (set s i v) j) = (get2 s j))).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Axiom mixfix_lblsmnrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length1 s))%Z ->
  ((mixfix_lblsmnrb s i v) = (set s i v)).

(* Why3 assumption *)
Definition singleton {a:Type} {a_WT:WhyType a} (v:a) : seq a :=
  create 1%Z (fun (us:Numbers.BinNums.Z) => v).

Axiom singleton'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a),
  ((length1 (singleton v)) = 1%Z) /\ ((get2 (singleton v) 0%Z) = v).

Parameter result1:
  forall {a:Type} {a_WT:WhyType a}, a -> seq a -> Numbers.BinNums.Z -> a.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((result1 x s i) = x)) /\
  (~ (i = 0%Z) -> ((result1 x s i) = (get2 s (i - 1%Z)%Z))).

(* Why3 assumption *)
Definition cons {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : seq a :=
  create (1%Z + (length1 s))%Z (result1 x s).

Axiom cons'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a),
  ((length1 (cons x s)) = (1%Z + (length1 s))%Z) /\
  ((get2 (cons x s) 0%Z) = x) /\
  (forall (i:Numbers.BinNums.Z), (0%Z < i)%Z /\ (i <= (length1 s))%Z ->
   ((get2 (cons x s) i) = (get2 s (i - 1%Z)%Z))).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, seq a -> a -> Numbers.BinNums.Z -> a.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a) (i:Numbers.BinNums.Z),
  ((i = (length1 s)) -> ((result2 s x i) = x)) /\
  (~ (i = (length1 s)) -> ((result2 s x i) = (get2 s i))).

(* Why3 assumption *)
Definition snoc {a:Type} {a_WT:WhyType a} (s:seq a) (x:a) : seq a :=
  create (1%Z + (length1 s))%Z (result2 s x).

Axiom snoc'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a),
  ((length1 (snoc s x)) = (1%Z + (length1 s))%Z) /\
  ((get2 (snoc s x) (length1 s)) = x) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length1 s))%Z ->
   ((get2 (snoc s x) i) = (get2 s i))).

Parameter mixfix_lbdtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length1 s))%Z ->
  ((mixfix_lbdtdtrb s i j) =
   (create (j - i)%Z (fun (k:Numbers.BinNums.Z) => get2 s (i + k)%Z))).

Axiom mixfix_lbdtdtrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length1 s))%Z ->
  ((length1 (mixfix_lbdtdtrb s i j)) = (j - i)%Z) /\
  (forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < (j - i)%Z)%Z ->
   ((get2 (mixfix_lbdtdtrb s i j) k) = (get2 s (i + k)%Z))).

Parameter mixfix_lb_dtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lb_dtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length1 s))%Z ->
  ((mixfix_lb_dtdtrb s i) = (mixfix_lbdtdtrb s i (length1 s))).

Parameter mixfix_lbdtdt_rb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdt_rb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j <= (length1 s))%Z ->
  ((mixfix_lbdtdt_rb s j) = (mixfix_lbdtdtrb s 0%Z j)).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> a.

Axiom result'def3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a) (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((i < l)%Z -> ((result3 s1 s2 l i) = (get2 s1 i))) /\
  (~ (i < l)%Z -> ((result3 s1 s2 l i) = (get2 s2 (i - l)%Z))).

(* Why3 assumption *)
Definition infix_plpl {a:Type} {a_WT:WhyType a} (s1:seq a) (s2:seq a) : seq a :=
  let l := length1 s1 in create (l + (length1 s2))%Z (result3 s1 s2 l).

Axiom infix_plpl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  ((length1 (infix_plpl s1 s2)) = ((length1 s1) + (length1 s2))%Z) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length1 s1))%Z ->
   ((get2 (infix_plpl s1 s2) i) = (get2 s1 i))) /\
  (forall (i:Numbers.BinNums.Z),
   ((length1 s1) <= i)%Z /\ (i < (length1 (infix_plpl s1 s2)))%Z ->
   ((get2 (infix_plpl s1 s2) i) = (get2 s2 (i - (length1 s1))%Z))).

Parameter model:
  creusotcontracts_std1_vec_vec highlevel_lit -> seq highlevel_lit.

(* Why3 assumption *)
Definition vars_in_range (n:Numbers.BinNums.Z) (c:highlevel_clause) : Prop :=
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) < (length1 (model (highlevel_clause_Clause_0 c))))%Z ->
  (0%Z <=
   (uint64'int
    (highlevel_lit_Lit_idx
     (get2 (model (highlevel_clause_Clause_0 c)) (uint64'int i)))))%Z /\
  ((uint64'int
    (highlevel_lit_Lit_idx
     (get2 (model (highlevel_clause_Clause_0 c)) (uint64'int i))))
   < n)%Z.

Parameter model1:
  creusotcontracts_std1_vec_vec highlevel_clause -> seq highlevel_clause.

(* Why3 assumption *)
Definition formula_invariant (f:highlevel_formula) : Prop :=
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) <
   (length1 (model1 (highlevel_formula_Formula_clauses f))))%Z ->
  vars_in_range (uint64'int (highlevel_formula_Formula_num_vars f))
  (get2 (model1 (highlevel_formula_Formula_clauses f)) (uint64'int i)).

Parameter model2:
  creusotcontracts_std1_vec_vec highlevel_assignedstate ->
  seq highlevel_assignedstate.

(* Why3 assumption *)
Definition not_sat_clause (a:highlevel_assignments) (c:highlevel_clause) :
    Prop :=
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) < (length1 (model (highlevel_clause_Clause_0 c))))%Z ->
  match get2 (model2 (highlevel_assignments_Assignments_0 a))
        (uint64'int
         (highlevel_lit_Lit_idx
          (get2 (model (highlevel_clause_Clause_0 c)) (uint64'int i)))) with
  | HighLevel_AssignedState_Positive =>
      ~ ((highlevel_lit_Lit_polarity
          (get2 (model (highlevel_clause_Clause_0 c)) (uint64'int i)))
         = Init.Datatypes.true)
  | HighLevel_AssignedState_Negative =>
      ((highlevel_lit_Lit_polarity
        (get2 (model (highlevel_clause_Clause_0 c)) (uint64'int i)))
       = Init.Datatypes.true)
  | HighLevel_AssignedState_Unset => False
  end.

(* Why3 assumption *)
Definition not_sat_formula (a:highlevel_assignments) (f:highlevel_formula) :
    Prop :=
  exists i:uint64,
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) <
   (length1 (model1 (highlevel_formula_Formula_clauses f))))%Z /\
  not_sat_clause a
  (get2 (model1 (highlevel_formula_Formula_clauses f)) (uint64'int i)).

(* Why3 assumption *)
Definition sat_clause (a:highlevel_assignments) (c:highlevel_clause) : Prop :=
  exists i:uint64,
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) < (length1 (model (highlevel_clause_Clause_0 c))))%Z /\
  match get2 (model2 (highlevel_assignments_Assignments_0 a))
        (uint64'int
         (highlevel_lit_Lit_idx
          (get2 (model (highlevel_clause_Clause_0 c)) (uint64'int i)))) with
  | HighLevel_AssignedState_Positive =>
      ((highlevel_lit_Lit_polarity
        (get2 (model (highlevel_clause_Clause_0 c)) (uint64'int i)))
       = Init.Datatypes.true)
  | HighLevel_AssignedState_Negative =>
      ~ ((highlevel_lit_Lit_polarity
          (get2 (model (highlevel_clause_Clause_0 c)) (uint64'int i)))
         = Init.Datatypes.true)
  | HighLevel_AssignedState_Unset =>
      ~ ((highlevel_lit_Lit_polarity
          (get2 (model (highlevel_clause_Clause_0 c)) (uint64'int i)))
         = Init.Datatypes.true) /\
      ((highlevel_lit_Lit_polarity
        (get2 (model (highlevel_clause_Clause_0 c)) (uint64'int i)))
       = Init.Datatypes.true)
  end.

(* Why3 assumption *)
Definition sat_formula (a:highlevel_assignments) (f:highlevel_formula) : Prop :=
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) <
   (length1 (model1 (highlevel_formula_Formula_clauses f))))%Z ->
  sat_clause a
  (get2 (model1 (highlevel_formula_Formula_clauses f)) (uint64'int i)).

(* Why3 assumption *)
Definition compatible_complete (a:highlevel_assignments)
    (a2:highlevel_assignments) : Prop :=
  ((length1 (model2 (highlevel_assignments_Assignments_0 a))) =
   (length1 (model2 (highlevel_assignments_Assignments_0 a2)))) /\
  (forall (i:uint64),
   (0%Z <= (uint64'int i))%Z /\
   ((uint64'int i) <
    (length1 (model2 (highlevel_assignments_Assignments_0 a))))%Z ->
   ((get2 (model2 (highlevel_assignments_Assignments_0 a)) (uint64'int i)) =
    HighLevel_AssignedState_Unset) /\
   (((get2 (model2 (highlevel_assignments_Assignments_0 a2)) (uint64'int i))
     = HighLevel_AssignedState_Negative) \/
    ((get2 (model2 (highlevel_assignments_Assignments_0 a2)) (uint64'int i))
     = HighLevel_AssignedState_Positive)) \/
   ((get2 (model2 (highlevel_assignments_Assignments_0 a)) (uint64'int i)) =
    (get2 (model2 (highlevel_assignments_Assignments_0 a2)) (uint64'int i)))).

(* Why3 assumption *)
Definition compatible (a:highlevel_assignments) (a2:highlevel_assignments) :
    Prop :=
  ((length1 (model2 (highlevel_assignments_Assignments_0 a))) =
   (length1 (model2 (highlevel_assignments_Assignments_0 a2)))) /\
  (forall (i:uint64),
   (0%Z <= (uint64'int i))%Z /\
   ((uint64'int i) <
    (length1 (model2 (highlevel_assignments_Assignments_0 a))))%Z ->
   ((get2 (model2 (highlevel_assignments_Assignments_0 a)) (uint64'int i)) =
    HighLevel_AssignedState_Unset) \/
   ((get2 (model2 (highlevel_assignments_Assignments_0 a)) (uint64'int i)) =
    (get2 (model2 (highlevel_assignments_Assignments_0 a2)) (uint64'int i)))).

(* Why3 assumption *)
Definition assignments_invariant (f:highlevel_formula)
    (a:highlevel_assignments) : Prop :=
  ((uint64'int (highlevel_formula_Formula_num_vars f)) =
   (length1 (model2 (highlevel_assignments_Assignments_0 a)))).

Parameter resolve: highlevel_assignments -> Prop.

Parameter resolve1: highlevel_worklist -> Prop.

Parameter resolve2: Init.Datatypes.unit -> Prop.

(* Why3 assumption *)
Definition resolve3 (self:borrowed highlevel_worklist) : Prop :=
  ((final self) = (current self)).

(* Why3 assumption *)
Definition resolve4 (self:borrowed highlevel_assignments) : Prop :=
  ((final self) = (current self)).

Parameter resolve5: highlevel_formula -> Prop.

Parameter unassigned_count_internal:
  highlevel_assignments -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom def :
  forall (a:highlevel_assignments) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((unassigned_count_internal a i) = 0%Z)) /\
  (~ (i = 0%Z) ->
   ((unassigned_count_internal a i) =
    match get2 (model2 (highlevel_assignments_Assignments_0 a)) i with
    | HighLevel_AssignedState_Unset =>
        (1%Z + (unassigned_count_internal a (i - 1%Z)%Z))%Z
    | _ => unassigned_count_internal a (i - 1%Z)%Z
    end)).

Axiom unassigned_count_internal_spec : True.

(* Why3 assumption *)
Definition unassigned_count (a:highlevel_assignments) : Numbers.BinNums.Z :=
  unassigned_count_internal a
  ((length1 (model2 (highlevel_assignments_Assignments_0 a))) - 1%Z)%Z.

Parameter f: highlevel_formula.

Parameter a: borrowed highlevel_assignments.

Parameter w: borrowed highlevel_worklist.

Axiom Requires : assignments_invariant f (current a).

Axiom Requires1 :
  forall (i:uint64),
  ((0%Z < (uint64'int i))%Z \/ (0%Z = (uint64'int i))) /\
  ((uint64'int i) <
   (length1 (model1 (highlevel_formula_Formula_clauses f))))%Z ->
  forall (i1:uint64),
  ((0%Z < (uint64'int i1))%Z \/ (0%Z = (uint64'int i1))) /\
  ((uint64'int i1) <
   (length1
    (model
     (highlevel_clause_Clause_0
      (get2 (model1 (highlevel_formula_Formula_clauses f)) (uint64'int i))))))%Z ->
  ((0%Z <
    (uint64'int
     (highlevel_lit_Lit_idx
      (get2
       (model
        (highlevel_clause_Clause_0
         (get2 (model1 (highlevel_formula_Formula_clauses f)) (uint64'int i))))
       (uint64'int i1)))))%Z \/
   (0%Z =
    (uint64'int
     (highlevel_lit_Lit_idx
      (get2
       (model
        (highlevel_clause_Clause_0
         (get2 (model1 (highlevel_formula_Formula_clauses f)) (uint64'int i))))
       (uint64'int i1)))))) /\
  ((uint64'int
    (highlevel_lit_Lit_idx
     (get2
      (model
       (highlevel_clause_Clause_0
        (get2 (model1 (highlevel_formula_Formula_clauses f)) (uint64'int i))))
      (uint64'int i1))))
   < (uint64'int (highlevel_formula_Formula_num_vars f)))%Z.

Parameter o: Init.Datatypes.bool.

Parameter o1: highlevel_formula.

Parameter o2: borrowed highlevel_assignments.

Parameter o3: borrowed highlevel_worklist.

Parameter o4: Init.Datatypes.bool.

Parameter o5: highlevel_formula.

Parameter o6: alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Parameter o7: Init.Datatypes.bool.

Parameter o8: highlevel_formula.

Parameter o9: alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Parameter o10: alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Parameter o11: alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Parameter o12: alloc_vec_vec highlevel_lit alloc_alloc_global.

Parameter o13: alloc_vec_vec highlevel_lit alloc_alloc_global.

Parameter o14: alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Parameter o15: alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Parameter o16: alloc_vec_vec highlevel_lit alloc_alloc_global.

Parameter o17: alloc_vec_vec highlevel_lit alloc_alloc_global.

Parameter o18: highlevel_formula.

Parameter o19: borrowed highlevel_assignments.

Parameter o20: borrowed highlevel_assignments.

Parameter o21: borrowed highlevel_worklist.

Parameter o22: borrowed highlevel_worklist.

Parameter o23: Init.Datatypes.bool.

Parameter o24: highlevel_formula.

Parameter o25: borrowed highlevel_assignments.

Parameter o26: borrowed highlevel_assignments.

Parameter o27: borrowed highlevel_worklist.

Parameter o28: borrowed highlevel_worklist.

Parameter o29: highlevel_formula.

Parameter o30: borrowed highlevel_assignments.

Parameter o31: borrowed highlevel_assignments.

Parameter o32: borrowed highlevel_worklist.

Parameter o33: borrowed highlevel_worklist.

Parameter o34: highlevel_formula.

Parameter o35: borrowed highlevel_assignments.

Parameter o36: borrowed highlevel_assignments.

Parameter o37: borrowed highlevel_worklist.

Parameter o38: borrowed highlevel_worklist.

Parameter f_1: highlevel_formula.

Axiom H : (f_1 = f).

Parameter a_2: borrowed highlevel_assignments.

Axiom H1 : (a_2 = a).

Parameter w_3: borrowed highlevel_worklist.

Axiom H2 : (w_3 = w).

Parameter us6: highlevel_formula.

Axiom H3 : (us6 = f_1).

Parameter us7: alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Axiom H4 :
  ((HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us7)) =
   (current a_2)).

Parameter us5: Init.Datatypes.bool.

Axiom Ensures :
  (us5 = Init.Datatypes.true) ->
  ~ not_sat_formula
    (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us7)) us6.

Axiom Ensures1 :
  (us5 = Init.Datatypes.true) <->
  sat_formula (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us7)) us6.

Axiom H5 : (us5 = Init.Datatypes.false).

Axiom Assume : resolve2 Init.Datatypes.tt.

Parameter us11: highlevel_formula.

Axiom H6 : (us11 = f_1).

Parameter us12: alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Axiom H7 :
  ((HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us12)) =
   (current a_2)).

Parameter us10: Init.Datatypes.bool.

Axiom Ensures2 :
  (us10 = Init.Datatypes.true) ->
  ~ sat_formula (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us12))
    us11.

Axiom Ensures3 :
  (us10 = Init.Datatypes.true) <->
  not_sat_formula
  (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us12)) us11.

Axiom H8 : (us10 = Init.Datatypes.false).

Axiom Assume1 : resolve2 Init.Datatypes.tt.

Parameter us15: alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Axiom H9 :
  ((HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us15)) =
   (current a_2)).

Parameter a_cloned_14:
  alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Axiom Ensures4 :
  ((length1
    (model2
     (highlevel_assignments_Assignments_0
      (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us15)))))
   =
   (length1
    (model2
     (highlevel_assignments_Assignments_0
      (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned_14)))))).

Axiom Ensures5 :
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) <
   (length1
    (model2
     (highlevel_assignments_Assignments_0
      (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us15))))))%Z ->
  ((get2
    (model2
     (highlevel_assignments_Assignments_0
      (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us15))))
    (uint64'int i))
   =
   (get2
    (model2
     (highlevel_assignments_Assignments_0
      (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned_14))))
    (uint64'int i))).

Parameter us17: alloc_vec_vec highlevel_lit alloc_alloc_global.

Axiom H10 :
  ((HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec us17)) = (current w_3)).

Parameter w_cloned_16: alloc_vec_vec highlevel_lit alloc_alloc_global.

Axiom Ensures6 :
  ((length1
    (model
     (highlevel_worklist_Worklist_0
      (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec us17)))))
   =
   (length1
    (model
     (highlevel_worklist_Worklist_0
      (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned_16)))))).

Axiom Ensures7 :
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) <
   (length1
    (model
     (highlevel_worklist_Worklist_0
      (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec us17))))))%Z ->
  ((get2
    (model
     (highlevel_worklist_Worklist_0
      (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec us17))))
    (uint64'int i))
   =
   (get2
    (model
     (highlevel_worklist_Worklist_0
      (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned_16))))
    (uint64'int i))).

Parameter us19: alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Axiom H11 :
  ((HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us19)) =
   (current a_2)).

Axiom Assume2 : resolve4 a_2.

Parameter a_cloned2_18:
  alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Axiom Ensures8 :
  ((length1
    (model2
     (highlevel_assignments_Assignments_0
      (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us19)))))
   =
   (length1
    (model2
     (highlevel_assignments_Assignments_0
      (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned2_18)))))).

Axiom Ensures9 :
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) <
   (length1
    (model2
     (highlevel_assignments_Assignments_0
      (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us19))))))%Z ->
  ((get2
    (model2
     (highlevel_assignments_Assignments_0
      (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec us19))))
    (uint64'int i))
   =
   (get2
    (model2
     (highlevel_assignments_Assignments_0
      (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned2_18))))
    (uint64'int i))).

Parameter us21: alloc_vec_vec highlevel_lit alloc_alloc_global.

Axiom H12 :
  ((HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec us21)) = (current w_3)).

Axiom Assume3 : resolve3 w_3.

Parameter w_cloned2_20: alloc_vec_vec highlevel_lit alloc_alloc_global.

Axiom Ensures10 :
  ((length1
    (model
     (highlevel_worklist_Worklist_0
      (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec us21)))))
   =
   (length1
    (model
     (highlevel_worklist_Worklist_0
      (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned2_20)))))).

Axiom Ensures11 :
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) <
   (length1
    (model
     (highlevel_worklist_Worklist_0
      (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec us21))))))%Z ->
  ((get2
    (model
     (highlevel_worklist_Worklist_0
      (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec us21))))
    (uint64'int i))
   =
   (get2
    (model
     (highlevel_worklist_Worklist_0
      (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned2_20))))
    (uint64'int i))).

Parameter us23: highlevel_formula.

Axiom H13 : (us23 = f_1).

Parameter us25: borrowed highlevel_assignments.

Axiom Ensures12 :
  ((current us25) =
   (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned2_18))).

Parameter a_cloned2_181:
  alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Axiom H14 :
  ((HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned2_181)) =
   (final us25)).

Parameter us24: borrowed highlevel_assignments.

Axiom Ensures13 : ((current us24) = (current us25)).

Parameter us251: borrowed highlevel_assignments.

Axiom H15 : (us251 = (borrowed'mk (final us24) (final us25))).

Axiom Assume4 : resolve4 us251.

Parameter us27: borrowed highlevel_worklist.

Axiom Ensures14 :
  ((current us27) =
   (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned2_20))).

Parameter w_cloned2_201: alloc_vec_vec highlevel_lit alloc_alloc_global.

Axiom H16 :
  ((HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned2_201)) =
   (final us27)).

Parameter us26: borrowed highlevel_worklist.

Axiom Ensures15 : ((current us26) = (current us27)).

Parameter us271: borrowed highlevel_worklist.

Axiom H17 : (us271 = (borrowed'mk (final us26) (final us27))).

Axiom Assume5 : resolve3 us271.

Axiom Ensures16 :
  ((unassigned_count (final us24)) < (unassigned_count (current us24)))%Z \/
  ((unassigned_count (current us24)) = 0%Z).

Axiom Ensures17 : compatible (current us24) (final us24).

Axiom Ensures18 : assignments_invariant us23 (final us24).

Axiom Ensures19 : (0%Z <= 0%Z)%Z.

Parameter us29: highlevel_formula.

Axiom H18 : (us29 = f_1).

Parameter us31: borrowed highlevel_assignments.

Axiom Ensures20 :
  ((current us31) =
   (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned2_181))).

Parameter a_cloned2_182:
  alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Axiom H19 :
  ((HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned2_182)) =
   (final us31)).

Parameter us30: borrowed highlevel_assignments.

Axiom Ensures21 : ((current us30) = (current us31)).

Parameter us311: borrowed highlevel_assignments.

Axiom H20 : (us311 = (borrowed'mk (final us30) (final us31))).

Axiom Assume6 : resolve4 us311.

Parameter us33: borrowed highlevel_worklist.

Axiom Ensures22 :
  ((current us33) =
   (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned2_201))).

Parameter w_cloned2_202: alloc_vec_vec highlevel_lit alloc_alloc_global.

Axiom H21 :
  ((HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned2_202)) =
   (final us33)).

Parameter us32: borrowed highlevel_worklist.

Axiom Ensures23 : ((current us32) = (current us33)).

Parameter us331: borrowed highlevel_worklist.

Axiom H22 : (us331 = (borrowed'mk (final us32) (final us33))).

Axiom Assume7 : resolve3 us331.

Axiom Ensures24 : assignments_invariant us29 (final us30).

Parameter us28: Init.Datatypes.bool.

Axiom Ensures25 :
  (us28 = Init.Datatypes.true) ->
  exists a2:highlevel_assignments,
  compatible (current us30) a2 /\ sat_formula a2 us29.

Axiom Ensures26 :
  (us28 = Init.Datatypes.false) ->
  exists a2:highlevel_assignments,
  compatible (current us30) a2 /\ not_sat_formula a2 us29.

Axiom Ensures27 :
  (us28 = Init.Datatypes.false) ->
  exists a2:highlevel_assignments,
  compatible (current us30) a2 /\ ~ sat_formula a2 us29.

Axiom Ensures28 :
  (us28 = Init.Datatypes.false) -> ~ sat_formula (current us30) us29.

Axiom Ensures29 :
  (us28 = Init.Datatypes.false) -> forall (a2:highlevel_assignments),
  compatible_complete (current us30) a2 -> not_sat_formula a2 us29.

Axiom H23 : (us28 = Init.Datatypes.false).

Parameter us37: highlevel_formula.

Axiom H24 : (us37 = f_1).

Parameter us39: borrowed highlevel_assignments.

Axiom Ensures30 :
  ((current us39) =
   (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned_14))).

Parameter a_cloned_141:
  alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Axiom H25 :
  ((HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned_141)) =
   (final us39)).

Parameter us38: borrowed highlevel_assignments.

Axiom Ensures31 : ((current us38) = (current us39)).

Parameter us391: borrowed highlevel_assignments.

Axiom H26 : (us391 = (borrowed'mk (final us38) (final us39))).

Axiom Assume8 : resolve4 us391.

Parameter us41: borrowed highlevel_worklist.

Axiom Ensures32 :
  ((current us41) =
   (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned_16))).

Parameter w_cloned_161: alloc_vec_vec highlevel_lit alloc_alloc_global.

Axiom H27 :
  ((HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned_161)) =
   (final us41)).

Parameter us40: borrowed highlevel_worklist.

Axiom Ensures33 : ((current us40) = (current us41)).

Parameter us411: borrowed highlevel_worklist.

Axiom H28 : (us411 = (borrowed'mk (final us40) (final us41))).

Axiom Assume9 : resolve3 us411.

Axiom Ensures34 :
  ((unassigned_count (final us38)) < (unassigned_count (current us38)))%Z \/
  ((unassigned_count (current us38)) = 0%Z).

Axiom Ensures35 : compatible (current us38) (final us38).

Axiom Ensures36 : assignments_invariant us37 (final us38).

Axiom Ensures37 : (0%Z <= 0%Z)%Z.

Parameter us42: highlevel_formula.

Axiom H29 : (us42 = f_1).

Axiom Assume10 : resolve5 f_1.

Parameter us44: borrowed highlevel_assignments.

Axiom Ensures38 :
  ((current us44) =
   (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned_141))).

Parameter a_cloned_142:
  alloc_vec_vec highlevel_assignedstate alloc_alloc_global.

Axiom H30 :
  ((HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned_142)) =
   (final us44)).

Parameter us43: borrowed highlevel_assignments.

Axiom Ensures39 : ((current us43) = (current us44)).

Parameter us441: borrowed highlevel_assignments.

Axiom H31 : (us441 = (borrowed'mk (final us43) (final us44))).

Axiom Assume11 : resolve4 us441.

Parameter us46: borrowed highlevel_worklist.

Axiom Ensures40 :
  ((current us46) =
   (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned_161))).

Parameter w_cloned_162: alloc_vec_vec highlevel_lit alloc_alloc_global.

Axiom H32 :
  ((HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned_162)) =
   (final us46)).

Parameter us45: borrowed highlevel_worklist.

Axiom Ensures41 : ((current us45) = (current us46)).

Parameter us461: borrowed highlevel_worklist.

Axiom H33 : (us461 = (borrowed'mk (final us45) (final us46))).

Axiom Assume12 : resolve3 us461.

Axiom Ensures42 : assignments_invariant us42 (final us43).

Parameter us0: Init.Datatypes.bool.

Axiom Ensures43 :
  (us0 = Init.Datatypes.true) ->
  exists a2:highlevel_assignments,
  compatible (current us43) a2 /\ sat_formula a2 us42.

Axiom Ensures44 :
  (us0 = Init.Datatypes.false) ->
  exists a2:highlevel_assignments,
  compatible (current us43) a2 /\ not_sat_formula a2 us42.

Axiom Ensures45 :
  (us0 = Init.Datatypes.false) ->
  exists a2:highlevel_assignments,
  compatible (current us43) a2 /\ ~ sat_formula a2 us42.

Axiom Ensures46 :
  (us0 = Init.Datatypes.false) -> ~ sat_formula (current us43) us42.

Axiom Ensures47 :
  (us0 = Init.Datatypes.false) -> forall (a2:highlevel_assignments),
  compatible_complete (current us43) a2 -> not_sat_formula a2 us42.

Axiom Assume13 :
  resolve1 (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned2_202)).

Axiom Assume14 :
  resolve
  (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned2_182)).

Axiom Assume15 :
  resolve1 (HighLevel_Worklist (CreusotContracts_Std1_Vec_Vec w_cloned_162)).

Axiom Assume16 :
  resolve
  (HighLevel_Assignments (CreusotContracts_Std1_Vec_Vec a_cloned_142)).

Axiom Ensures48 : assignments_invariant f (final a).

Axiom Ensures49 :
  (us0 = Init.Datatypes.true) ->
  exists a2:highlevel_assignments,
  compatible (current a) a2 /\ sat_formula a2 f.

Axiom Ensures50 :
  (us0 = Init.Datatypes.false) ->
  exists a2:highlevel_assignments,
  compatible (current a) a2 /\ not_sat_formula a2 f.

Axiom Ensures51 :
  (us0 = Init.Datatypes.false) ->
  exists a2:highlevel_assignments,
  compatible (current a) a2 /\ ~ sat_formula a2 f.

Axiom Ensures52 :
  (us0 = Init.Datatypes.false) -> ~ sat_formula (current a) f.

Axiom H34 : (us0 = Init.Datatypes.false).

Parameter a2: highlevel_assignments.

Axiom H35 : compatible_complete (current a) a2.

(* Why3 goal *)
Theorem inner'vc : not_sat_formula a2 f.
Proof.


Qed.

