(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require Reals.Rbasic_fun.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require real.Real.
Require real.Abs.
Require real.FromInt.
Require floating_point.Rounding.
Require floating_point.SingleFormat.
Require floating_point.DoubleFormat.
Require floating_point.Single.
Require floating_point.Double.

Axiom uint64 : Type.
Parameter uint64_WhyType : WhyType uint64.
Existing Instance uint64_WhyType.

Parameter uint64'int: uint64 -> Numbers.BinNums.Z.

Axiom uint64'axiom :
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\ ((uint64'int i) <= 18446744073709551615%Z)%Z.

(* Why3 assumption *)
Definition in_bounds (n:Numbers.BinNums.Z) : Prop :=
  (0%Z <= n)%Z /\ (n <= 18446744073709551615%Z)%Z.

Axiom to_int_in_bounds : forall (n:uint64), in_bounds (uint64'int n).

Axiom extensionality :
  forall (x:uint64) (y:uint64), ((uint64'int x) = (uint64'int y)) -> (x = y).

Parameter zero_unsigned: uint64.

Axiom zero_unsigned_is_zero : ((uint64'int zero_unsigned) = 0%Z).

Axiom seq : forall (a:Type), Type.
Parameter seq_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (seq a).
Existing Instance seq_WhyType.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z.

Axiom length_nonnegative :
  forall {a:Type} {a_WT:WhyType a}, forall (s:seq a), (0%Z <= (length s))%Z.

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Prop.

Axiom infix_eqeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  (infix_eqeq s1 s2 <->
   ((length s1) = (length s2)) /\
   (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
    ((get s1 i) = (get s2 i)))) /\
  (infix_eqeq s1 s2 -> (s1 = s2)).

Parameter create:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z ->
  (Numbers.BinNums.Z -> a) -> seq a.

Axiom create'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z ->
  ((length (create len f)) = len) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < len)%Z ->
   ((get (create len f) i) = (f i))).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, seq a.

Axiom empty'def :
  forall {a:Type} {a_WT:WhyType a}, ((length (empty : seq a)) = 0%Z).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Parameter result:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a ->
  Numbers.BinNums.Z -> a.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a) (j:Numbers.BinNums.Z),
  ((j = i) -> ((result s i v j) = v)) /\
  (~ (j = i) -> ((result s i v j) = (get s j))).

Axiom set'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((set s i v) = (create (length s) (result s i v))).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((length (set s i v)) = (length s)) /\
  ((get (set s i v) i) = v) /\
  (forall (j:Numbers.BinNums.Z),
   ((0%Z <= j)%Z /\ (j < (length s))%Z) /\ ~ (j = i) ->
   ((get (set s i v) j) = (get s j))).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Axiom mixfix_lblsmnrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((mixfix_lblsmnrb s i v) = (set s i v)).

(* Why3 assumption *)
Definition singleton {a:Type} {a_WT:WhyType a} (v:a) : seq a :=
  create 1%Z (fun (us:Numbers.BinNums.Z) => v).

Axiom singleton'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a),
  ((length (singleton v)) = 1%Z) /\ ((get (singleton v) 0%Z) = v).

Parameter result1:
  forall {a:Type} {a_WT:WhyType a}, a -> seq a -> Numbers.BinNums.Z -> a.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((result1 x s i) = x)) /\
  (~ (i = 0%Z) -> ((result1 x s i) = (get s (i - 1%Z)%Z))).

(* Why3 assumption *)
Definition cons {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : seq a :=
  create (1%Z + (length s))%Z (result1 x s).

Axiom cons'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a),
  ((length (cons x s)) = (1%Z + (length s))%Z) /\
  ((get (cons x s) 0%Z) = x) /\
  (forall (i:Numbers.BinNums.Z), (0%Z < i)%Z /\ (i <= (length s))%Z ->
   ((get (cons x s) i) = (get s (i - 1%Z)%Z))).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, seq a -> a -> Numbers.BinNums.Z -> a.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a) (i:Numbers.BinNums.Z),
  ((i = (length s)) -> ((result2 s x i) = x)) /\
  (~ (i = (length s)) -> ((result2 s x i) = (get s i))).

(* Why3 assumption *)
Definition snoc {a:Type} {a_WT:WhyType a} (s:seq a) (x:a) : seq a :=
  create (1%Z + (length s))%Z (result2 s x).

Axiom snoc'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a),
  ((length (snoc s x)) = (1%Z + (length s))%Z) /\
  ((get (snoc s x) (length s)) = x) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s))%Z ->
   ((get (snoc s x) i) = (get s i))).

Parameter mixfix_lbdtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdtrb s i j) =
   (create (j - i)%Z (fun (k:Numbers.BinNums.Z) => get s (i + k)%Z))).

Axiom mixfix_lbdtdtrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((length (mixfix_lbdtdtrb s i j)) = (j - i)%Z) /\
  (forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < (j - i)%Z)%Z ->
   ((get (mixfix_lbdtdtrb s i j) k) = (get s (i + k)%Z))).

Parameter mixfix_lb_dtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lb_dtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z ->
  ((mixfix_lb_dtdtrb s i) = (mixfix_lbdtdtrb s i (length s))).

Parameter mixfix_lbdtdt_rb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdt_rb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdt_rb s j) = (mixfix_lbdtdtrb s 0%Z j)).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> a.

Axiom result'def3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a) (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((i < l)%Z -> ((result3 s1 s2 l i) = (get s1 i))) /\
  (~ (i < l)%Z -> ((result3 s1 s2 l i) = (get s2 (i - l)%Z))).

(* Why3 assumption *)
Definition infix_plpl {a:Type} {a_WT:WhyType a} (s1:seq a) (s2:seq a) : seq a :=
  let l := length s1 in create (l + (length s2))%Z (result3 s1 s2 l).

Axiom infix_plpl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  ((length (infix_plpl s1 s2)) = ((length s1) + (length s2))%Z) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
   ((get (infix_plpl s1 s2) i) = (get s1 i))) /\
  (forall (i:Numbers.BinNums.Z),
   ((length s1) <= i)%Z /\ (i < (length (infix_plpl s1 s2)))%Z ->
   ((get (infix_plpl s1 s2) i) = (get s2 (i - (length s1))%Z))).

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom int32 : Type.
Parameter int32_WhyType : WhyType int32.
Existing Instance int32_WhyType.

Parameter int32'int: int32 -> Numbers.BinNums.Z.

Axiom int32'axiom :
  forall (i:int32),
  ((-2147483648%Z)%Z <= (int32'int i))%Z /\ ((int32'int i) <= 2147483647%Z)%Z.

(* Why3 assumption *)
Definition in_bounds1 (n:Numbers.BinNums.Z) : Prop :=
  ((-2147483648%Z)%Z <= n)%Z /\ (n <= 2147483647%Z)%Z.

Axiom to_int_in_bounds1 : forall (n:int32), in_bounds1 (int32'int n).

Axiom extensionality1 :
  forall (x:int32) (y:int32), ((int32'int x) = (int32'int y)) -> (x = y).

Axiom int64 : Type.
Parameter int64_WhyType : WhyType int64.
Existing Instance int64_WhyType.

Parameter int64'int: int64 -> Numbers.BinNums.Z.

Axiom int64'axiom :
  forall (i:int64),
  ((-9223372036854775808%Z)%Z <= (int64'int i))%Z /\
  ((int64'int i) <= 9223372036854775807%Z)%Z.

(* Why3 assumption *)
Definition in_bounds2 (n:Numbers.BinNums.Z) : Prop :=
  ((-9223372036854775808%Z)%Z <= n)%Z /\ (n <= 9223372036854775807%Z)%Z.

Axiom to_int_in_bounds2 : forall (n:int64), in_bounds2 (int64'int n).

Axiom extensionality2 :
  forall (x:int64) (y:int64), ((int64'int x) = (int64'int y)) -> (x = y).

Axiom uint32 : Type.
Parameter uint32_WhyType : WhyType uint32.
Existing Instance uint32_WhyType.

Parameter uint32'int: uint32 -> Numbers.BinNums.Z.

Axiom uint32'axiom :
  forall (i:uint32),
  (0%Z <= (uint32'int i))%Z /\ ((uint32'int i) <= 4294967295%Z)%Z.

(* Why3 assumption *)
Definition in_bounds3 (n:Numbers.BinNums.Z) : Prop :=
  (0%Z <= n)%Z /\ (n <= 4294967295%Z)%Z.

Axiom to_int_in_bounds3 : forall (n:uint32), in_bounds3 (uint32'int n).

Axiom extensionality3 :
  forall (x:uint32) (y:uint32), ((uint32'int x) = (uint32'int y)) -> (x = y).

Parameter zero_unsigned1: uint32.

Axiom zero_unsigned_is_zero1 : ((uint32'int zero_unsigned1) = 0%Z).

Parameter concat: BuiltIn.string -> BuiltIn.string -> BuiltIn.string.

Axiom concat_assoc :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ((concat (concat s1 s2) s3) = (concat s1 (concat s2 s3))).

Parameter rliteral: BuiltIn.string.

Axiom rliteral_axiom : True.

Axiom concat_empty :
  forall (s:BuiltIn.string),
  ((concat s rliteral) = (concat rliteral s)) /\ ((concat rliteral s) = s).

Parameter length1: BuiltIn.string -> Numbers.BinNums.Z.

Axiom length_empty : ((length1 rliteral) = 0%Z).

Axiom length_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  ((length1 (concat s1 s2)) = ((length1 s1) + (length1 s2))%Z).

Parameter lt: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom lt_empty :
  forall (s:BuiltIn.string), ~ (s = rliteral) -> lt rliteral s.

Axiom lt_not_com :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), lt s1 s2 -> ~ lt s2 s1.

Axiom lt_ref : forall (s1:BuiltIn.string), ~ lt s1 s1.

Axiom lt_trans :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  lt s1 s2 /\ lt s2 s3 -> lt s1 s3.

Parameter le: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom le_empty : forall (s:BuiltIn.string), le rliteral s.

Axiom le_ref : forall (s1:BuiltIn.string), le s1 s1.

Axiom lt_le :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), lt s1 s2 -> le s1 s2.

Axiom lt_le_eq :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), le s1 s2 ->
  lt s1 s2 \/ (s1 = s2).

Axiom le_trans :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  le s1 s2 /\ le s2 s3 -> le s1 s3.

Parameter s_at: BuiltIn.string -> Numbers.BinNums.Z -> BuiltIn.string.

Axiom at_out_of_range :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length1 s) <= i)%Z -> ((s_at s i) = rliteral).

Axiom at_empty :
  forall (i:Numbers.BinNums.Z), ((s_at rliteral i) = rliteral).

Axiom at_length :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := s_at s i in
  ((0%Z <= i)%Z /\ (i < (length1 s))%Z -> ((length1 j) = 1%Z)) /\
  (~ ((0%Z <= i)%Z /\ (i < (length1 s))%Z) -> ((length1 j) = 0%Z)).

Axiom concat_at :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  let s := concat s1 s2 in
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i < (length1 s1))%Z -> ((s_at s i) = (s_at s1 i))) /\
  (((length1 s1) <= i)%Z /\ (i < (length1 s))%Z ->
   ((s_at s i) = (s_at s2 (i - (length1 s1))%Z))).

Parameter substring:
  BuiltIn.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> BuiltIn.string.

Axiom substring_out_of_range :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length1 s) <= i)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_length_zero_or_less :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (x <= 0%Z)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_empty :
  forall (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((substring rliteral i x) = rliteral).

Axiom substring_smaller :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((length1 (substring s i x)) <= (length1 s))%Z.

Axiom substring_smaller_x :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z -> ((length1 (substring s i x)) <= x)%Z.

Axiom substring_length :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z /\ (0%Z <= i)%Z /\ (i < (length1 s))%Z ->
  (((length1 s) < (i + x)%Z)%Z ->
   ((length1 (substring s i x)) = ((length1 s) - i)%Z)) /\
  (~ ((length1 s) < (i + x)%Z)%Z -> ((length1 (substring s i x)) = x)).

Axiom substring_at :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((s_at s i) = (substring s i 1%Z)).

Axiom substring_substring :
  forall (s:BuiltIn.string) (ofs:Numbers.BinNums.Z) (len:Numbers.BinNums.Z)
    (ofs':Numbers.BinNums.Z) (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length1 s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length1 s))%Z -> (0%Z <= ofs')%Z /\ (ofs' <= len)%Z ->
  (0%Z <= len')%Z -> ((ofs' + len')%Z <= len)%Z ->
  ((substring (substring s ofs len) ofs' len') =
   (substring s (ofs + ofs')%Z len')).

Axiom concat_substring :
  forall (s:BuiltIn.string) (ofs:Numbers.BinNums.Z) (len:Numbers.BinNums.Z)
    (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length1 s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length1 s))%Z -> (0%Z <= len')%Z ->
  (0%Z <= ((ofs + len)%Z + len')%Z)%Z /\
  (((ofs + len)%Z + len')%Z <= (length1 s))%Z ->
  ((concat (substring s ofs len) (substring s (ofs + len)%Z len')) =
   (substring s ofs (len + len')%Z)).

Parameter prefixof: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom prefixof_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  prefixof s1 s2 <-> (s1 = (substring s2 0%Z (length1 s1))).

Axiom prefixof_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), prefixof s1 (concat s1 s2).

Axiom prefixof_empty : forall (s2:BuiltIn.string), prefixof rliteral s2.

Axiom prefixof_empty2 :
  forall (s1:BuiltIn.string), ~ (s1 = rliteral) -> ~ prefixof s1 rliteral.

Parameter suffixof: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom suffixof_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  suffixof s1 s2 <->
  (s1 = (substring s2 ((length1 s2) - (length1 s1))%Z (length1 s1))).

Axiom suffixof_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), suffixof s2 (concat s1 s2).

Axiom suffixof_empty : forall (s2:BuiltIn.string), suffixof rliteral s2.

Axiom suffixof_empty2 :
  forall (s1:BuiltIn.string), ~ (s1 = rliteral) -> ~ suffixof s1 rliteral.

Parameter contains: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom contains_prefixof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), prefixof s1 s2 ->
  contains s2 s1.

Axiom contains_suffixof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), suffixof s1 s2 ->
  contains s2 s1.

Axiom contains_empty :
  forall (s2:BuiltIn.string), contains rliteral s2 <-> (s2 = rliteral).

Axiom contains_empty2 : forall (s1:BuiltIn.string), contains s1 rliteral.

Axiom contains_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((substring s1 i (length1 s2)) = s2) -> contains s1 s2.

Axiom contains_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  contains (concat s1 s2) s1 /\ contains (concat s1 s2) s2.

Axiom contains_at :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((s_at s1 i) = s2) -> contains s1 s2.

Parameter indexof:
  BuiltIn.string -> BuiltIn.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom indexof_empty :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length1 s))%Z -> ((indexof s rliteral i) = i).

Axiom indexof_empty1 :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof rliteral s i in
  (j = (-1%Z)%Z) \/ (s = rliteral) /\ (i = j) /\ (j = 0%Z).

Axiom indexof_contains :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  let j := indexof s1 s2 0%Z in
  contains s1 s2 ->
  ((0%Z <= j)%Z /\ (j <= (length1 s1))%Z) /\
  ((substring s1 j (length1 s2)) = s2).

Axiom contains_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= (indexof s1 s2 i))%Z -> contains s1 s2.

Axiom not_contains_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ~ contains s1 s2 -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom substring_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= j)%Z -> ((substring s1 j (length1 s2)) = s2).

Axiom indexof_out_of_range :
  forall (i:Numbers.BinNums.Z) (s1:BuiltIn.string) (s2:BuiltIn.string),
  ~ ((0%Z <= i)%Z /\ (i <= (length1 s1))%Z) -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom indexof_in_range :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= i)%Z /\ (i <= (length1 s1))%Z ->
  (j = (-1%Z)%Z) \/ (i <= j)%Z /\ (j <= (length1 s1))%Z.

Axiom indexof_contains_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i <= (length1 s1))%Z) /\
  contains (substring s1 i ((length1 s1) - i)%Z) s2 ->
  (i <= (indexof s1 s2 i))%Z /\ ((indexof s1 s2 i) <= (length1 s1))%Z.

Parameter replace:
  BuiltIn.string -> BuiltIn.string -> BuiltIn.string -> BuiltIn.string.

Axiom replace_empty :
  forall (s1:BuiltIn.string) (s3:BuiltIn.string),
  ((replace s1 rliteral s3) = (concat s3 s1)).

Axiom replace_not_contains :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ~ contains s1 s2 -> ((replace s1 s2 s3) = s1).

Axiom replace_empty2 :
  forall (s2:BuiltIn.string) (s3:BuiltIn.string),
  let s4 := replace rliteral s2 s3 in
  ((s2 = rliteral) -> (s4 = s3)) /\ (~ (s2 = rliteral) -> (s4 = rliteral)).

Axiom replace_substring_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  let j := indexof s1 s2 0%Z in
  ((j < 0%Z)%Z -> ((replace s1 s2 s3) = s1)) /\
  (~ (j < 0%Z)%Z ->
   ((replace s1 s2 s3) =
    (concat (concat (substring s1 0%Z j) s3)
     (substring s1 (j + (length1 s2))%Z
      (((length1 s1) - j)%Z - (length1 s2))%Z)))).

Parameter replaceall:
  BuiltIn.string -> BuiltIn.string -> BuiltIn.string -> BuiltIn.string.

Axiom replaceall_empty1 :
  forall (s1:BuiltIn.string) (s3:BuiltIn.string),
  ((replaceall s1 rliteral s3) = s1).

Axiom not_contains_replaceall :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ~ contains s1 s2 -> ((replaceall s1 s2 s3) = s1).

Parameter to_int: BuiltIn.string -> Numbers.BinNums.Z.

Axiom to_int_gt_minus_1 :
  forall (s:BuiltIn.string), ((-1%Z)%Z <= (to_int s))%Z.

Axiom to_int_empty : ((to_int rliteral) = (-1%Z)%Z).

(* Why3 assumption *)
Definition is_digit (s:BuiltIn.string) : Prop :=
  ((0%Z <= (to_int s))%Z /\ ((to_int s) <= 9%Z)%Z) /\ ((length1 s) = 1%Z).

Parameter from_int: Numbers.BinNums.Z -> BuiltIn.string.

Axiom from_int_negative :
  forall (i:Numbers.BinNums.Z), (i < 0%Z)%Z <-> ((from_int i) = rliteral).

Axiom from_int_to_int :
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z -> ((to_int (from_int i)) = i)) /\
  (~ (0%Z <= i)%Z -> ((to_int (from_int i)) = (-1%Z)%Z)).

Axiom char : Type.
Parameter char_WhyType : WhyType char.
Existing Instance char_WhyType.

Parameter contents1: char -> BuiltIn.string.

Axiom char'invariant :
  forall (self:char), ((length1 (contents1 self)) = 1%Z).

Axiom char_eq :
  forall (c1:char) (c2:char), ((contents1 c1) = (contents1 c2)) -> (c1 = c2).

Parameter code: char -> Numbers.BinNums.Z.

Axiom code1 : forall (c:char), (0%Z <= (code c))%Z /\ ((code c) < 256%Z)%Z.

Parameter chr: Numbers.BinNums.Z -> char.

Axiom code_chr :
  forall (n:Numbers.BinNums.Z), (0%Z <= n)%Z /\ (n < 256%Z)%Z ->
  ((code (chr n)) = n).

Axiom chr_code : forall (c:char), ((chr (code c)) = c).

Parameter get1: BuiltIn.string -> Numbers.BinNums.Z -> char.

Axiom get2 :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length1 s))%Z ->
  ((contents1 (get1 s i)) = (s_at s i)).

Axiom substring_get :
  forall (s:BuiltIn.string) (ofs:Numbers.BinNums.Z) (len:Numbers.BinNums.Z)
    (i:Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length1 s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length1 s))%Z -> (0%Z <= i)%Z /\ (i < len)%Z ->
  ((get1 (substring s ofs len) i) = (get1 s (ofs + i)%Z)).

Axiom concat_first :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length1 s1))%Z ->
  ((get1 (concat s1 s2) i) = (get1 s1 i)).

Axiom concat_second :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  forall (i:Numbers.BinNums.Z),
  ((length1 s1) <= i)%Z /\ (i < ((length1 s1) + (length1 s2))%Z)%Z ->
  ((get1 (concat s1 s2) i) = (get1 s2 (i - (length1 s1))%Z)).

(* Why3 assumption *)
Definition eq_string (s1:BuiltIn.string) (s2:BuiltIn.string) : Prop :=
  ((length1 s1) = (length1 s2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length1 s1))%Z ->
   ((get1 s1 i) = (get1 s2 i))).

Axiom extensionality4 :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), eq_string s1 s2 ->
  (s1 = s2).

Parameter make: Numbers.BinNums.Z -> char -> BuiltIn.string.

Axiom make_length :
  forall (size:Numbers.BinNums.Z) (v:char), (0%Z <= size)%Z ->
  ((length1 (make size v)) = size).

Axiom make_contents :
  forall (size:Numbers.BinNums.Z) (v:char), (0%Z <= size)%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < size)%Z ->
  ((get1 (make size v) i) = v).

(* Why3 assumption *)
Definition usize := uint64.

(* Why3 assumption *)
Definition isize := int64.

Axiom opaque_ptr : Type.
Parameter opaque_ptr_WhyType : WhyType opaque_ptr.
Existing Instance opaque_ptr_WhyType.

(* Why3 assumption *)
Inductive borrowed (a:Type) :=
  | borrowed'mk : a -> a -> borrowed a.
Axiom borrowed_WhyType : forall (a:Type) {a_WT:WhyType a},
  WhyType (borrowed a).
Existing Instance borrowed_WhyType.
Arguments borrowed'mk {a}.

(* Why3 assumption *)
Definition final {a:Type} {a_WT:WhyType a} (v:borrowed a) : a :=
  match v with
  | borrowed'mk x x1 => x1
  end.

(* Why3 assumption *)
Definition current {a:Type} {a_WT:WhyType a} (v:borrowed a) : a :=
  match v with
  | borrowed'mk x x1 => x
  end.

(* Why3 assumption *)
Inductive solverdpllwithproofs_satstate :=
  | SolverDpllWithproofs_SatState_Unknown : solverdpllwithproofs_satstate
  | SolverDpllWithproofs_SatState_Sat : solverdpllwithproofs_satstate
  | SolverDpllWithproofs_SatState_Unsat : solverdpllwithproofs_satstate.
Axiom solverdpllwithproofs_satstate_WhyType : WhyType solverdpllwithproofs_satstate.
Existing Instance solverdpllwithproofs_satstate_WhyType.

(* Why3 assumption *)
Inductive solverdpllwithproofs_ghost
  (t:Type) :=
  | SolverDpllWithproofs_Ghost : opaque_ptr -> solverdpllwithproofs_ghost t.
Axiom solverdpllwithproofs_ghost_WhyType : forall (t:Type) {t_WT:WhyType t},
  WhyType (solverdpllwithproofs_ghost t).
Existing Instance solverdpllwithproofs_ghost_WhyType.
Arguments SolverDpllWithproofs_Ghost {t}.

(* Why3 assumption *)
Inductive solverdpllwithproofs_lit :=
  | SolverDpllWithproofs_Lit : uint64 -> Init.Datatypes.bool ->
      solverdpllwithproofs_lit.
Axiom solverdpllwithproofs_lit_WhyType : WhyType solverdpllwithproofs_lit.
Existing Instance solverdpllwithproofs_lit_WhyType.

Parameter solverdpllwithproofs_lit_Lit_idx:
  solverdpllwithproofs_lit -> uint64.

Axiom solverdpllwithproofs_lit_Lit_idx_acc :
  forall (a:uint64) (b:Init.Datatypes.bool),
  ((solverdpllwithproofs_lit_Lit_idx (SolverDpllWithproofs_Lit a b)) = a).

Parameter solverdpllwithproofs_lit_Lit_polarity:
  solverdpllwithproofs_lit -> Init.Datatypes.bool.

Axiom solverdpllwithproofs_lit_Lit_polarity_acc :
  forall (a:uint64) (b:Init.Datatypes.bool),
  ((solverdpllwithproofs_lit_Lit_polarity (SolverDpllWithproofs_Lit a b)) =
   b).

(* Why3 assumption *)
Inductive core_marker_phantomdata
  (t:Type) :=
  | Core_Marker_PhantomData : core_marker_phantomdata t.
Axiom core_marker_phantomdata_WhyType : forall (t:Type) {t_WT:WhyType t},
  WhyType (core_marker_phantomdata t).
Existing Instance core_marker_phantomdata_WhyType.
Arguments Core_Marker_PhantomData {t}.

(* Why3 assumption *)
Inductive core_ptr_unique_unique
  (t:Type) :=
  | Core_Ptr_Unique_Unique : opaque_ptr -> core_marker_phantomdata t ->
      core_ptr_unique_unique t.
Axiom core_ptr_unique_unique_WhyType : forall (t:Type) {t_WT:WhyType t},
  WhyType (core_ptr_unique_unique t).
Existing Instance core_ptr_unique_unique_WhyType.
Arguments Core_Ptr_Unique_Unique {t}.

(* Why3 assumption *)
Inductive alloc_rawvec_rawvec (t:Type)
  (a:Type) :=
  | Alloc_RawVec_RawVec : core_ptr_unique_unique t -> uint64 -> a ->
      alloc_rawvec_rawvec t a.
Axiom alloc_rawvec_rawvec_WhyType : forall (t:Type) {t_WT:WhyType t}
  (a:Type) {a_WT:WhyType a}, WhyType (alloc_rawvec_rawvec t a).
Existing Instance alloc_rawvec_rawvec_WhyType.
Arguments Alloc_RawVec_RawVec {t} {a}.

(* Why3 assumption *)
Inductive alloc_vec_vec (t:Type)
  (a:Type) :=
  | Alloc_Vec_Vec : alloc_rawvec_rawvec t a -> uint64 -> alloc_vec_vec t a.
Axiom alloc_vec_vec_WhyType : forall (t:Type) {t_WT:WhyType t}
  (a:Type) {a_WT:WhyType a}, WhyType (alloc_vec_vec t a).
Existing Instance alloc_vec_vec_WhyType.
Arguments Alloc_Vec_Vec {t} {a}.

(* Why3 assumption *)
Inductive alloc_alloc_global :=
  | Alloc_Alloc_Global : alloc_alloc_global.
Axiom alloc_alloc_global_WhyType : WhyType alloc_alloc_global.
Existing Instance alloc_alloc_global_WhyType.

(* Why3 assumption *)
Inductive creusotcontracts_std1_vec_vec
  (t:Type) :=
  | CreusotContracts_Std1_Vec_Vec : alloc_vec_vec t alloc_alloc_global ->
      creusotcontracts_std1_vec_vec t.
Axiom creusotcontracts_std1_vec_vec_WhyType : forall
  (t:Type) {t_WT:WhyType t}, WhyType (creusotcontracts_std1_vec_vec t).
Existing Instance creusotcontracts_std1_vec_vec_WhyType.
Arguments CreusotContracts_Std1_Vec_Vec {t}.

(* Why3 assumption *)
Inductive solverdpllwithproofs_clause :=
  | SolverDpllWithproofs_Clause : creusotcontracts_std1_vec_vec
                                  solverdpllwithproofs_lit ->
      solverdpllwithproofs_clause.
Axiom solverdpllwithproofs_clause_WhyType : WhyType solverdpllwithproofs_clause.
Existing Instance solverdpllwithproofs_clause_WhyType.

Parameter solverdpllwithproofs_clause_Clause_0:
  solverdpllwithproofs_clause ->
  creusotcontracts_std1_vec_vec solverdpllwithproofs_lit.

Axiom solverdpllwithproofs_clause_Clause_0_acc :
  forall (a:creusotcontracts_std1_vec_vec solverdpllwithproofs_lit),
  ((solverdpllwithproofs_clause_Clause_0 (SolverDpllWithproofs_Clause a)) =
   a).

(* Why3 assumption *)
Inductive solverdpllwithproofs_formula :=
  | SolverDpllWithproofs_Formula : creusotcontracts_std1_vec_vec
                                   solverdpllwithproofs_clause ->
      uint64 -> solverdpllwithproofs_formula.
Axiom solverdpllwithproofs_formula_WhyType : WhyType solverdpllwithproofs_formula.
Existing Instance solverdpllwithproofs_formula_WhyType.

Parameter solverdpllwithproofs_formula_Formula_clauses:
  solverdpllwithproofs_formula ->
  creusotcontracts_std1_vec_vec solverdpllwithproofs_clause.

Axiom solverdpllwithproofs_formula_Formula_clauses_acc :
  forall (a:creusotcontracts_std1_vec_vec solverdpllwithproofs_clause)
    (b:uint64),
  ((solverdpllwithproofs_formula_Formula_clauses
    (SolverDpllWithproofs_Formula a b))
   = a).

Parameter solverdpllwithproofs_formula_Formula_num_vars:
  solverdpllwithproofs_formula -> uint64.

Axiom solverdpllwithproofs_formula_Formula_num_vars_acc :
  forall (a:creusotcontracts_std1_vec_vec solverdpllwithproofs_clause)
    (b:uint64),
  ((solverdpllwithproofs_formula_Formula_num_vars
    (SolverDpllWithproofs_Formula a b))
   = b).

(* Why3 assumption *)
Inductive core_option_option
  (t:Type) :=
  | Core_Option_Option_None : core_option_option t
  | Core_Option_Option_Some : t -> core_option_option t.
Axiom core_option_option_WhyType : forall (t:Type) {t_WT:WhyType t},
  WhyType (core_option_option t).
Existing Instance core_option_option_WhyType.
Arguments Core_Option_Option_None {t}.
Arguments Core_Option_Option_Some {t}.

Parameter core_option_option_Some_0:
  forall {t:Type} {t_WT:WhyType t}, core_option_option t -> t.

Axiom core_option_option_Some_0_acc :
  forall {t:Type} {t_WT:WhyType t},
  forall (a:t), ((core_option_option_Some_0 (Core_Option_Option_Some a)) = a).

(* Why3 assumption *)
Inductive solverdpllwithproofs_assignments :=
  | SolverDpllWithproofs_Assignments : creusotcontracts_std1_vec_vec
                                       (core_option_option
                                        Init.Datatypes.bool) ->
      solverdpllwithproofs_assignments.
Axiom solverdpllwithproofs_assignments_WhyType : WhyType solverdpllwithproofs_assignments.
Existing Instance solverdpllwithproofs_assignments_WhyType.

Parameter solverdpllwithproofs_assignments_Assignments_0:
  solverdpllwithproofs_assignments ->
  creusotcontracts_std1_vec_vec (core_option_option Init.Datatypes.bool).

Axiom solverdpllwithproofs_assignments_Assignments_0_acc :
  forall (a:
          creusotcontracts_std1_vec_vec
          (core_option_option Init.Datatypes.bool)),
  ((solverdpllwithproofs_assignments_Assignments_0
    (SolverDpllWithproofs_Assignments a))
   = a).

(* Why3 assumption *)
Inductive solverdpllwithproofs_worklist :=
  | SolverDpllWithproofs_Worklist : creusotcontracts_std1_vec_vec
                                    solverdpllwithproofs_lit ->
      solverdpllwithproofs_worklist.
Axiom solverdpllwithproofs_worklist_WhyType : WhyType solverdpllwithproofs_worklist.
Existing Instance solverdpllwithproofs_worklist_WhyType.

Parameter solverdpllwithproofs_worklist_Worklist_0:
  solverdpllwithproofs_worklist ->
  creusotcontracts_std1_vec_vec solverdpllwithproofs_lit.

Axiom solverdpllwithproofs_worklist_Worklist_0_acc :
  forall (a:creusotcontracts_std1_vec_vec solverdpllwithproofs_lit),
  ((solverdpllwithproofs_worklist_Worklist_0
    (SolverDpllWithproofs_Worklist a))
   = a).

Parameter model:
  creusotcontracts_std1_vec_vec solverdpllwithproofs_lit ->
  seq solverdpllwithproofs_lit.

(* Why3 assumption *)
Definition vars_in_range (n:Numbers.BinNums.Z)
    (c:solverdpllwithproofs_clause) : Prop :=
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) <
   (length (model (solverdpllwithproofs_clause_Clause_0 c))))%Z ->
  (0%Z <=
   (uint64'int
    (solverdpllwithproofs_lit_Lit_idx
     (get (model (solverdpllwithproofs_clause_Clause_0 c)) (uint64'int i)))))%Z /\
  ((uint64'int
    (solverdpllwithproofs_lit_Lit_idx
     (get (model (solverdpllwithproofs_clause_Clause_0 c)) (uint64'int i))))
   < n)%Z.

Parameter model1:
  creusotcontracts_std1_vec_vec solverdpllwithproofs_clause ->
  seq solverdpllwithproofs_clause.

(* Why3 assumption *)
Definition formula_invariant (f:solverdpllwithproofs_formula) : Prop :=
  forall (i:uint64),
  (0%Z <= (uint64'int i))%Z /\
  ((uint64'int i) <
   (length (model1 (solverdpllwithproofs_formula_Formula_clauses f))))%Z ->
  vars_in_range
  (uint64'int (solverdpllwithproofs_formula_Formula_num_vars f))
  (get (model1 (solverdpllwithproofs_formula_Formula_clauses f))
   (uint64'int i)).

Parameter model2:
  creusotcontracts_std1_vec_vec (core_option_option Init.Datatypes.bool) ->
  seq (core_option_option Init.Datatypes.bool).

(* Why3 assumption *)
Definition resolve (self:borrowed (core_option_option Init.Datatypes.bool)) :
    Prop :=
  ((final self) = (current self)).

Parameter resolve1: core_option_option Init.Datatypes.bool -> Prop.

(* Why3 assumption *)
Definition modelty := seq (core_option_option Init.Datatypes.bool).

(* Why3 assumption *)
Definition resolve2 (self:borrowed solverdpllwithproofs_assignments) : Prop :=
  ((final self) = (current self)).

(* Why3 assumption *)
Definition modelty1 := seq solverdpllwithproofs_lit.

Parameter resolve3: Init.Datatypes.bool -> Prop.

Parameter resolve4: uint64 -> Prop.

(* Why3 assumption *)
Definition resolve5 (self:borrowed solverdpllwithproofs_worklist) : Prop :=
  ((final self) = (current self)).

Parameter resolve6: solverdpllwithproofs_formula -> Prop.

(* Why3 assumption *)
Definition model3
    (self:borrowed (creusotcontracts_std1_vec_vec solverdpllwithproofs_lit)) :
    seq solverdpllwithproofs_lit :=
  model (current self).

(* Why3 assumption *)
Definition modelty2 := seq solverdpllwithproofs_lit.

(* Why3 assumption *)
Definition model4
    (self:
     borrowed
     (creusotcontracts_std1_vec_vec (core_option_option Init.Datatypes.bool))) :
    seq (core_option_option Init.Datatypes.bool) :=
  model2 (current self).

(* Why3 assumption *)
Definition modelty3 := seq (core_option_option Init.Datatypes.bool).

Parameter usf: solverdpllwithproofs_formula.

Parameter w: borrowed solverdpllwithproofs_worklist.

Parameter a: borrowed solverdpllwithproofs_assignments.

Parameter idx: uint64.

Parameter polarity: Init.Datatypes.bool.

Axiom Requires :
  ((uint64'int idx) <
   (length
    (model2 (solverdpllwithproofs_assignments_Assignments_0 (current a)))))%Z.

Axiom Requires1 : formula_invariant usf.

Parameter o: solverdpllwithproofs_formula.

Parameter o1: borrowed solverdpllwithproofs_worklist.

Parameter o2: borrowed solverdpllwithproofs_assignments.

Parameter o3: uint64.

Parameter o4: Init.Datatypes.bool.

Parameter o5:
  borrowed (creusotcontracts_std1_vec_vec solverdpllwithproofs_lit).

Parameter o6: solverdpllwithproofs_lit.

Parameter o7: uint64.

Parameter o8: Init.Datatypes.bool.

Parameter o9: core_option_option Init.Datatypes.bool.

Parameter o10: Init.Datatypes.bool.

Parameter o11: borrowed (core_option_option Init.Datatypes.bool).

Parameter o12:
  borrowed
  (creusotcontracts_std1_vec_vec (core_option_option Init.Datatypes.bool)).

Parameter o13: uint64.

Parameter usf_1: solverdpllwithproofs_formula.

Axiom H : (usf_1 = usf).

Parameter w_2: borrowed solverdpllwithproofs_worklist.

Axiom H1 : (w_2 = w).

Parameter a_3: borrowed solverdpllwithproofs_assignments.

Axiom H2 : (a_3 = a).

Parameter idx_4: uint64.

Axiom H3 : (idx_4 = idx).

Parameter polarity_5: Init.Datatypes.bool.

Axiom H4 : (polarity_5 = polarity).

Axiom Assume : resolve6 usf_1.

Parameter us7:
  borrowed (creusotcontracts_std1_vec_vec solverdpllwithproofs_lit).

Axiom Ensures :
  ((current us7) = (solverdpllwithproofs_worklist_Worklist_0 (current w_2))).

Parameter o14: alloc_vec_vec solverdpllwithproofs_lit alloc_alloc_global.

Axiom H5 :
  match current w_2 with
  | SolverDpllWithproofs_Worklist x =>
      ((CreusotContracts_Std1_Vec_Vec o14) = (final us7))
  end.

Parameter w_21: borrowed solverdpllwithproofs_worklist.

Axiom H6 :
  (w_21 =
   (borrowed'mk
    (SolverDpllWithproofs_Worklist (CreusotContracts_Std1_Vec_Vec o14))
    (final w_2))).

Axiom Assume1 : resolve5 w_21.

Axiom Assume2 : resolve4 o7.

Parameter us9: uint64.

Axiom H7 : (us9 = idx_4).

Axiom Assume3 : resolve3 o8.

Parameter us10: Init.Datatypes.bool.

Axiom H8 : (us10 = polarity_5).

Parameter us8: solverdpllwithproofs_lit.

Axiom H9 : (us8 = (SolverDpllWithproofs_Lit us9 us10)).

Axiom Ensures1 : ((model (final us7)) = (snoc (model3 us7) us8)).

Axiom Assume4 : resolve3 o10.

Parameter us12: Init.Datatypes.bool.

Axiom H10 : (us12 = polarity_5).

Axiom Assume5 : resolve3 polarity_5.

Parameter us11: core_option_option Init.Datatypes.bool.

Axiom H11 : (us11 = (Core_Option_Option_Some us12)).

Parameter us14:
  borrowed
  (creusotcontracts_std1_vec_vec (core_option_option Init.Datatypes.bool)).

Axiom Ensures2 :
  ((current us14) =
   (solverdpllwithproofs_assignments_Assignments_0 (current a_3))).

Parameter o15:
  alloc_vec_vec (core_option_option Init.Datatypes.bool) alloc_alloc_global.

Axiom H12 :
  match current a_3 with
  | SolverDpllWithproofs_Assignments x =>
      ((CreusotContracts_Std1_Vec_Vec o15) = (final us14))
  end.

Parameter a_31: borrowed solverdpllwithproofs_assignments.

Axiom H13 :
  (a_31 =
   (borrowed'mk
    (SolverDpllWithproofs_Assignments (CreusotContracts_Std1_Vec_Vec o15))
    (final a_3))).

Axiom Assume6 : resolve2 a_31.

Axiom Assume7 : resolve4 o13.

Parameter us15: uint64.

Axiom H14 : (us15 = idx_4).

Axiom Assume8 : resolve4 idx_4.

Axiom Ensures3 :
  ((length (model2 (current us14))) = (length (model2 (final us14)))).

Axiom Ensures4 :
  forall (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j < (length (model2 (final us14))))%Z ->
  ~ (j = (uint64'int us15)) ->
  ((get (model2 (final us14)) j) = (get (model2 (current us14)) j)).

Parameter us13: borrowed (core_option_option Init.Datatypes.bool).

Axiom Ensures5 :
  ((final us13) = (get (model2 (final us14)) (uint64'int us15))).

Axiom Ensures6 : ((current us13) = (get (model4 us14) (uint64'int us15))).

Axiom Assume9 : resolve1 (current us13).

Parameter us131: borrowed (core_option_option Init.Datatypes.bool).

Axiom H15 : (us131 = (borrowed'mk us11 (final us13))).

Axiom Assume10 : resolve us131.

(* Why3 goal *)
Theorem add_to_worklist'vc :
  ((length
    (model2 (solverdpllwithproofs_assignments_Assignments_0 (current a))))
   =
   (length
    (model2 (solverdpllwithproofs_assignments_Assignments_0 (final a))))).
Proof.


Qed.

