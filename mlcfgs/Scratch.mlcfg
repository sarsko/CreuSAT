
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module Scratch_Assignments_Assignments_Type
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_assignments  =
    | C_Assignments (Alloc_Vec_Vec_Type.t_vec uint8 (Alloc_Alloc_Global_Type.t_global))
    
  let function assignments_0 (self : t_assignments) : Alloc_Vec_Vec_Type.t_vec uint8 (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Assignments a -> a
      end
end
module Core_Num_Impl11_Max_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.Int
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module CreusotContracts_Std1_Vec_Impl0_View_Stub
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function view (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_View_Interface
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function view (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  axiom view_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . Seq.length (view self) <= UIntSize.to_int Max0.mAX'
end
module CreusotContracts_Std1_Vec_Impl0_View
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function view (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val view (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    ensures { result = view self }
    
  axiom view_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . Seq.length (view self) <= UIntSize.to_int Max0.mAX'
end
module Scratch_Assignments_Impl0_View_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  function view [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    
end
module Scratch_Assignments_Impl0_View_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  function view [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    
end
module Scratch_Assignments_Impl0_View
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View0 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  function view [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    
   =
    [#"../Scratch/src/assignments.rs" 19 4 19 12] View0.view (Scratch_Assignments_Assignments_Type.assignments_0 self)
  val view [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    ensures { result = view self }
    
end
module Scratch_Logic_Unset_Stub
  use prelude.Int
  use prelude.UInt8
  predicate unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8)
end
module Scratch_Logic_Unset_Interface
  use prelude.Int
  use prelude.UInt8
  predicate unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8)
end
module Scratch_Logic_Unset
  use prelude.Int
  use prelude.UInt8
  predicate unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8) =
    [#"../Scratch/src/logic.rs" 19 4 25 5] if UInt8.to_int v >= 2 then true else false
  val unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8) : bool
    ensures { result = unset v }
    
end
module Scratch_Assignments_CompatibleInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Scratch_Assignments_CompatibleInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Scratch_Assignments_CompatibleInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  clone Scratch_Logic_Unset_Stub as Unset0
  predicate compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8) =
    [#"../Scratch/src/assignments.rs" 28 8 29 43] Seq.length a = Seq.length a2 /\ (forall i : int . 0 <= i /\ i < Seq.length a -> Unset0.unset (Seq.get a i) \/ Seq.get a i = Seq.get a2 i)
  val compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8) : bool
    ensures { result = compatible_inner a a2 }
    
end
module Scratch_Assignments_CompleteInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8)
end
module Scratch_Assignments_CompleteInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8)
end
module Scratch_Assignments_CompleteInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  clone Scratch_Logic_Unset_Stub as Unset0
  predicate complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8) =
    [#"../Scratch/src/assignments.rs" 35 4 37 5] forall i : int . 0 <= i /\ i < Seq.length a -> not Unset0.unset (Seq.get a i)
  val complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8) : bool
    ensures { result = complete_inner a }
    
end
module Scratch_Assignments_CompatibleCompleteInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Assignments_CompatibleCompleteInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Assignments_CompatibleCompleteInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  clone Scratch_Assignments_CompleteInner_Stub as CompleteInner0
  clone Scratch_Assignments_CompatibleInner_Stub as CompatibleInner0
  predicate compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
   =
    [#"../Scratch/src/assignments.rs" 42 4 42 49] CompatibleInner0.compatible_inner a a2 /\ CompleteInner0.complete_inner a2
  val compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8) : bool
    ensures { result = compatible_complete_inner a a2 }
    
end
module Scratch_Lit_Lit_Type
  use prelude.Int
  use prelude.UIntSize
  type t_lit  =
    | C_Lit usize bool
    
  let function lit_idx (self : t_lit) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Lit a _ -> a
      end
  let function lit_polarity (self : t_lit) : bool = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Lit _ a -> a
      end
end
module Scratch_Clause_Clause_Type
  use prelude.Int
  use prelude.UInt32
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_clause  =
    | C_Clause bool uint32 usize (Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global))
    
  let function clause_deleted (self : t_clause) : bool = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause a _ _ _ -> a
      end
  let function clause_lbd (self : t_clause) : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause _ a _ _ -> a
      end
  let function clause_search (self : t_clause) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause _ _ a _ -> a
      end
  let function clause_lits (self : t_clause) : Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause _ _ _ a -> a
      end
end
module Scratch_Formula_Formula_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_formula  =
    | C_Formula (Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global)) usize
    
  let function formula_num_vars (self : t_formula) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Formula _ a -> a
      end
  let function formula_clauses (self : t_formula) : Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Formula a _ -> a
      end
end
module Scratch_Assignments_Impl1_Invariant_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Assignments_Impl1_Invariant_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Assignments_Impl1_Invariant
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/assignments.rs" 49 8 52 9] UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars f) = Seq.length (View0.view self) /\ (forall i : int . 0 <= i /\ i < Seq.length (View0.view self) -> UInt8.to_int (Seq.get (View0.view self) i) <= 3)
  val invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = invariant' self f }
    
end
module Scratch_Assignments_Impl1_Complete_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Assignments_Impl1_Complete_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Assignments_Impl1_Complete
  use prelude.Int
  use seq.Seq
  clone Scratch_Logic_Unset_Stub as Unset0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  predicate complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/assignments.rs" 57 8 59 9] forall i : int . 0 <= i /\ i < Seq.length (View0.view self) -> not Unset0.unset (Seq.get (View0.view self) i)
  val complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = complete self }
    
end
module Core_Clone_Impls_Impl19_Clone_Interface
  use prelude.Borrow
  val clone' (self : bool) : bool
    ensures { result = self }
    
end
module Core_Clone_Impls_Impl8_Clone_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  val clone' (self : uint32) : uint32
    ensures { result = self }
    
end
module Core_Clone_Impls_Impl5_Clone_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  val clone' (self : usize) : usize
    ensures { result = self }
    
end
module Alloc_Vec_Impl11_Clone_Interface
  type t
  type a
  use prelude.Borrow
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  val clone' (self : Alloc_Vec_Vec_Type.t_vec t a) : Alloc_Vec_Vec_Type.t_vec t a
    ensures { result = self }
    
end
module Scratch_Clause_Impl3_Clone_Interface
  use prelude.Borrow
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  val clone' [#"../Scratch/src/clause.rs" 6 9 6 14] (self : Scratch_Clause_Clause_Type.t_clause) : Scratch_Clause_Clause_Type.t_clause
    ensures { [#"../Scratch/src/clause.rs" 6 9 6 14] result = self }
    
end
module Scratch_Clause_Impl3_Clone
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  use prelude.UIntSize
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Alloc_Vec_Impl11_Clone_Interface as Clone3 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global
  clone Core_Clone_Impls_Impl5_Clone_Interface as Clone2
  clone Core_Clone_Impls_Impl8_Clone_Interface as Clone1
  clone Core_Clone_Impls_Impl19_Clone_Interface as Clone0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  let rec cfg clone' [#"../Scratch/src/clause.rs" 6 9 6 14] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Clause_Clause_Type.t_clause) : Scratch_Clause_Clause_Type.t_clause
    ensures { [#"../Scratch/src/clause.rs" 6 9 6 14] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Clause_Clause_Type.t_clause;
  var self_1 : Scratch_Clause_Clause_Type.t_clause;
  var _3 : bool;
  var _4 : bool;
  var _5 : uint32;
  var _6 : uint32;
  var _7 : usize;
  var _8 : usize;
  var _9 : Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global);
  var _10 : Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- Scratch_Clause_Clause_Type.clause_deleted self_1;
    _3 <- ([#"../Scratch/src/clause.rs" 8 4 8 21] Clone0.clone' _4);
    goto BB1
  }
  BB1 {
    _6 <- Scratch_Clause_Clause_Type.clause_lbd self_1;
    _5 <- ([#"../Scratch/src/clause.rs" 9 4 9 16] Clone1.clone' _6);
    goto BB2
  }
  BB2 {
    _8 <- Scratch_Clause_Clause_Type.clause_search self_1;
    _7 <- ([#"../Scratch/src/clause.rs" 10 4 10 21] Clone2.clone' _8);
    goto BB3
  }
  BB3 {
    _10 <- Scratch_Clause_Clause_Type.clause_lits self_1;
    _9 <- ([#"../Scratch/src/clause.rs" 11 4 11 22] Clone3.clone' _10);
    goto BB4
  }
  BB4 {
    _0 <- Scratch_Clause_Clause_Type.C_Clause _3 _5 _7 _9;
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Scratch_Clause_Impl0_View_Stub
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  function view [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Clause_Impl0_View_Interface
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  function view [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Clause_Impl0_View
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View0 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  function view [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    
   =
    [#"../Scratch/src/clause.rs" 18 4 18 12] View0.view (Scratch_Clause_Clause_Type.clause_lits self)
  val view [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    ensures { result = view self }
    
end
module Scratch_Lit_Impl2_IndexLogic_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
end
module Scratch_Lit_Impl2_IndexLogic_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
end
module Scratch_Lit_Impl2_IndexLogic
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
   =
    [#"../Scratch/src/lit.rs" 51 8 51 31] UIntSize.to_int (Scratch_Lit_Lit_Type.lit_idx self)
  val index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
    ensures { result = index_logic self }
    
end
module Scratch_Lit_Impl3_Invariant_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int)
end
module Scratch_Lit_Impl3_Invariant_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int)
end
module Scratch_Lit_Impl3_Invariant
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int) =
    [#"../Scratch/src/lit.rs" 102 20 102 42] IndexLogic0.index_logic self < n
  val invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int) : bool
    ensures { result = invariant' self n }
    
end
module Scratch_Clause_VarsInRangeInner_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_VarsInRangeInner_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_VarsInRangeInner
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_Invariant_Stub as Invariant0
  predicate vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
   =
    [#"../Scratch/src/clause.rs" 26 4 29 5] forall i : int . 0 <= i /\ i < Seq.length s -> Invariant0.invariant' (Seq.get s i) n
  val vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int) : bool
    ensures { result = vars_in_range_inner s n }
    
end
module Scratch_Clause_NoDuplicateIndexesInner_Stub
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Clause_NoDuplicateIndexesInner_Interface
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Clause_NoDuplicateIndexesInner
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
   =
    [#"../Scratch/src/clause.rs" 46 4 49 5] forall k : int . forall j : int . 0 <= j /\ j < Seq.length s /\ 0 <= k /\ k < j -> not IndexLogic0.index_logic (Seq.get s k) = IndexLogic0.index_logic (Seq.get s j)
  val no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) : bool
    ensures { result = no_duplicate_indexes_inner s }
    
end
module Scratch_Clause_InvariantInternal_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_InvariantInternal_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_InvariantInternal
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_NoDuplicateIndexesInner_Stub as NoDuplicateIndexesInner0
  clone Scratch_Clause_VarsInRangeInner_Stub as VarsInRangeInner0
  predicate invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
   =
    [#"../Scratch/src/clause.rs" 34 4 34 62] VarsInRangeInner0.vars_in_range_inner s n /\ NoDuplicateIndexesInner0.no_duplicate_indexes_inner s
  val invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int) : bool
    ensures { result = invariant_internal s n }
    
end
module Scratch_Lit_Impl2_IsPositiveLogic_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    
end
module Scratch_Lit_Impl2_IsPositiveLogic_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    
end
module Scratch_Lit_Impl2_IsPositiveLogic
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    
   =
    [#"../Scratch/src/lit.rs" 57 20 57 33] Scratch_Lit_Lit_Type.lit_polarity self
  val is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    ensures { result = is_positive_logic self }
    
end
module Scratch_Lit_Impl3_SatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_SatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_SatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  predicate sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) =
    [#"../Scratch/src/lit.rs" 108 12 111 13] if IsPositiveLogic0.is_positive_logic self then
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 1
    else
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 0
    
  val sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) : bool
    ensures { result = sat_inner self a }
    
end
module Scratch_Clause_Impl2_SatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_SatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_SatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 163 8 166 9] exists i : int . 0 <= i /\ i < Seq.length (View0.view self) /\ SatInner0.sat_inner (Seq.get (View0.view self) i) a
  val sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = sat_inner self a }
    
end
module Scratch_Formula_FormulaSatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8)
    
end
module Scratch_Formula_FormulaSatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8)
    
end
module Scratch_Formula_FormulaSatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  predicate formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 34 4 37 5] forall i : int . 0 <= i /\ i < Seq.length (let (a, _) = f in a) -> SatInner0.sat_inner (Seq.get (let (a, _) = f in a) i) a
  val formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8) : bool
    ensures { result = formula_sat_inner f a }
    
end
module Scratch_Formula_EventuallySatComplete_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_EventuallySatComplete_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_EventuallySatComplete
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_FormulaSatInner_Stub as FormulaSatInner0
  clone Scratch_Assignments_CompleteInner_Stub as CompleteInner0
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/formula.rs" 42 4 44 5] exists a2 : Seq.seq uint8 . Seq.length a2 = (let (_, a) = f in a) /\ CompleteInner0.complete_inner a2 /\ FormulaSatInner0.formula_sat_inner f a2
  val eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = eventually_sat_complete f }
    
end
module Scratch_Clause_EquisatExtensionInner_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_EquisatExtensionInner_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_EquisatExtensionInner
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_EventuallySatComplete_Stub as EventuallySatComplete0
  predicate equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/clause.rs" 39 4 41 5] EventuallySatComplete0.eventually_sat_complete f -> EventuallySatComplete0.eventually_sat_complete (Seq.snoc (let (a, _) = f in a) c, let (_, a) = f in a)
  val equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = equisat_extension_inner c f }
    
end
module Scratch_Lit_Impl3_UnsatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  predicate unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
   =
    [#"../Scratch/src/lit.rs" 118 12 121 13] if IsPositiveLogic0.is_positive_logic self then
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 0
    else
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 1
    
  val unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) : bool
    ensures { result = unsat_inner self a }
    
end
module Scratch_Clause_Impl1_PostUnitInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_PostUnitInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_PostUnitInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsatInner_Stub as UnsatInner0
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 61 8 65 9] exists i : int . 0 <= i /\ i < Seq.length (View0.view self) /\ SatInner0.sat_inner (Seq.get (View0.view self) i) a /\ (forall j : int . 0 <= j /\ j < Seq.length (View0.view self) /\ j <> i -> UnsatInner0.unsat_inner (Seq.get (View0.view self) j) a)
  val post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = post_unit_inner self a }
    
end
module Scratch_Lit_Impl3_UnsetInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsetInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsetInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
   =
    [#"../Scratch/src/lit.rs" 127 20 127 47] UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) >= 2
  val unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) : bool
    ensures { result = unset_inner self a }
    
end
module Scratch_Clause_Impl1_NoUnsetInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_NoUnsetInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_NoUnsetInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsetInner_Stub as UnsetInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 70 8 72 9] forall j : int . 0 <= j /\ j < Seq.length (View0.view self) -> not UnsetInner0.unset_inner (Seq.get (View0.view self) j) a
  val no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = no_unset_inner self a }
    
end
module Scratch_Clause_Impl1_PostUnit_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl1_PostUnit_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl1_PostUnit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl1_PostUnitInner_Stub as PostUnitInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  predicate post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 77 20 77 44] PostUnitInner0.post_unit_inner self (View0.view a)
  val post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = post_unit self a }
    
end
module Scratch_Clause_Impl1_EqAssnInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_EqAssnInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_EqAssnInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 82 8 85 9] forall i : int . 0 <= i /\ i < Seq.length (View0.view self) -> Seq.get a (IndexLogic0.index_logic (Seq.get (View0.view self) i)) = Seq.get a2 (IndexLogic0.index_logic (Seq.get (View0.view self) i))
  val eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8) : bool
    ensures { result = eq_assn_inner self a a2 }
    
end
module Scratch_Formula_Impl0_View_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  function view [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    
end
module Scratch_Formula_Impl0_View_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  function view [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    
end
module Scratch_Formula_Impl0_View
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  function view [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    
   =
    [#"../Scratch/src/formula.rs" 20 8 20 69] (View0.view (Scratch_Formula_Formula_Type.formula_clauses self), UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self))
  val view [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    ensures { result = view self }
    
end
module Scratch_Clause_Impl2_EquisatExtension_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_EquisatExtension_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_EquisatExtension
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_EquisatExtensionInner_Stub as EquisatExtensionInner0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_View_Stub as View0
  predicate equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/clause.rs" 92 20 92 53] EquisatExtensionInner0.equisat_extension_inner self (View0.view f)
  val equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = equisat_extension self f }
    
end
module Scratch_Clause_Impl2_SameIdxSamePolarityExcept_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int)
    
end
module Scratch_Clause_Impl2_SameIdxSamePolarityExcept_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int)
    
end
module Scratch_Clause_Impl2_SameIdxSamePolarityExcept
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int)
    
   =
    [#"../Scratch/src/clause.rs" 97 8 102 9] forall j : int . forall i : int . 0 <= i /\ i < Seq.length (View0.view self) /\ 0 <= j /\ j < Seq.length (View0.view other) -> IndexLogic0.index_logic (Seq.get (View0.view self) i) <> exception' /\ IndexLogic0.index_logic (Seq.get (View0.view self) i) = IndexLogic0.index_logic (Seq.get (View0.view other) j) -> IsPositiveLogic0.is_positive_logic (Seq.get (View0.view self) i) = IsPositiveLogic0.is_positive_logic (Seq.get (View0.view other) j)
  val same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int) : bool
    ensures { result = same_idx_same_polarity_except self other exception' }
    
end
module Scratch_Lit_Impl3_LitIn_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIn_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIn
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
   =
    [#"../Scratch/src/lit.rs" 89 8 89 76] exists i : int . 0 <= i /\ i < Seq.length (View0.view c) /\ Seq.get (View0.view c) i = self
  val lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = lit_in self c }
    
end
module Scratch_Lit_Impl3_IsOpp_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Lit_Impl3_IsOpp_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Lit_Impl3_IsOpp
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit)
    
   =
    [#"../Scratch/src/lit.rs" 78 12 78 102] IndexLogic0.index_logic self = IndexLogic0.index_logic o /\ IsPositiveLogic0.is_positive_logic self <> IsPositiveLogic0.is_positive_logic o
  val is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit) : bool
    ensures { result = is_opp self o }
    
end
module Scratch_Clause_Impl2_ResolventOf_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int)
    
end
module Scratch_Clause_Impl2_ResolventOf_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int)
    
end
module Scratch_Clause_Impl2_ResolventOf
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_IsOpp_Stub as IsOpp0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Lit_Impl3_LitIn_Stub as LitIn0
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int)
    
   =
    [#"../Scratch/src/clause.rs" 107 8 114 9] (forall i : int . 0 <= i /\ i < Seq.length (View0.view c) /\ i <> m -> LitIn0.lit_in (Seq.get (View0.view c) i) self) /\ (forall i : int . 0 <= i /\ i < Seq.length (View0.view c2) /\ i <> k -> LitIn0.lit_in (Seq.get (View0.view c2) i) self) /\ (forall i : int . 0 <= i /\ i < Seq.length (View0.view self) -> LitIn0.lit_in (Seq.get (View0.view self) i) c \/ LitIn0.lit_in (Seq.get (View0.view self) i) c2) /\ not LitIn0.lit_in (Seq.get (View0.view c) m) self /\ not LitIn0.lit_in (Seq.get (View0.view c2) k) self /\ IsOpp0.is_opp (Seq.get (View0.view c2) k) (Seq.get (View0.view c) m)
  val resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int) : bool
    ensures { result = resolvent_of self c c2 k m }
    
end
module Scratch_Clause_Impl2_InFormula_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_InFormula_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_InFormula
  use prelude.Int
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/clause.rs" 119 8 122 9] exists i : int . 0 <= i /\ i < Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses f)) /\ Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses f)) i = self
  val in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = in_formula self f }
    
end
module Scratch_Clause_Impl2_InFormulaInner_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_Impl2_InFormulaInner_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_Impl2_InFormulaInner
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/clause.rs" 127 8 129 9] exists i : int . 0 <= i /\ i < Seq.length (let (a, _) = f in a) /\ Seq.get (let (a, _) = f in a) i = self
  val in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = in_formula_inner self f }
    
end
module Scratch_Clause_Impl2_VarsInRange_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
    
end
module Scratch_Clause_Impl2_VarsInRange_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
    
end
module Scratch_Clause_Impl2_VarsInRange
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_VarsInRangeInner_Stub as VarsInRangeInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
    
   =
    [#"../Scratch/src/clause.rs" 183 20 183 49] VarsInRangeInner0.vars_in_range_inner (View0.view self) n
  val vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int) : bool
    ensures { result = vars_in_range self n }
    
end
module Scratch_Clause_Impl2_UnitInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnitInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnitInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsetInner_Stub as UnsetInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  clone Scratch_Clause_Impl2_VarsInRange_Stub as VarsInRange0
  predicate unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 134 8 141 9] VarsInRange0.vars_in_range self (Seq.length a) /\ not SatInner0.sat_inner self a /\ (exists i : int . 0 <= i /\ i < Seq.length (View0.view self) /\ UnsetInner0.unset_inner (Seq.get (View0.view self) i) a /\ (forall j : int . 0 <= j /\ j < Seq.length (View0.view self) /\ j <> i -> not UnsetInner0.unset_inner (Seq.get (View0.view self) j) a))
  val unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = unit_inner self a }
    
end
module Scratch_Clause_Impl2_Unit_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unit_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_UnitInner_Stub as UnitInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  predicate unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 145 20 145 39] UnitInner0.unit_inner self (View0.view a)
  val unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unit self a }
    
end
module Scratch_Clause_Impl2_UnsatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnsatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnsatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsatInner_Stub as UnsatInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 150 8 153 9] forall i : int . 0 <= i /\ i < Seq.length (View0.view self) -> UnsatInner0.unsat_inner (Seq.get (View0.view self) i) a
  val unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = unsat_inner self a }
    
end
module Scratch_Clause_Impl2_Unsat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unsat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unsat
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_UnsatInner_Stub as UnsatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  predicate unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 158 20 158 40] UnsatInner0.unsat_inner self (View0.view a)
  val unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unsat self a }
    
end
module Scratch_Clause_Impl2_Sat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Sat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Sat
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  predicate sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 172 12 172 30] SatInner0.sat_inner self (View0.view a)
  val sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = sat self a }
    
end
module Scratch_Clause_Impl2_Unknown_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unknown_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unknown
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  predicate unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 178 8 178 38] not Sat0.sat self a /\ not Unsat0.unsat self a
  val unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unknown self a }
    
end
module Scratch_Clause_Impl2_NoDuplicateIndexes_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_NoDuplicateIndexes_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_NoDuplicateIndexes
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_NoDuplicateIndexesInner_Stub as NoDuplicateIndexesInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause)
   =
    [#"../Scratch/src/clause.rs" 188 20 188 53] NoDuplicateIndexesInner0.no_duplicate_indexes_inner (View0.view self)
  val no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = no_duplicate_indexes self }
    
end
module Scratch_Clause_Impl2_SearchIdxInRange_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_SearchIdxInRange_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_SearchIdxInRange
  use prelude.UIntSize
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause)
   =
    [#"../Scratch/src/clause.rs" 193 20 193 68] 2 <= UIntSize.to_int (Scratch_Clause_Clause_Type.clause_search self) /\ UIntSize.to_int (Scratch_Clause_Clause_Type.clause_search self) <= Seq.length (View0.view self)
  val search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = search_idx_in_range self }
    
end
module Scratch_Clause_Impl2_Invariant_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
end
module Scratch_Clause_Impl2_Invariant_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
end
module Scratch_Clause_Impl2_Invariant
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_InvariantInternal_Stub as InvariantInternal0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
   =
    [#"../Scratch/src/clause.rs" 198 20 198 48] InvariantInternal0.invariant_internal (View0.view self) n
  val invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int) : bool
    ensures { result = invariant' self n }
    
end
module Scratch_Lit_IdxInLogic_Stub
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_IdxInLogic_Interface
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_IdxInLogic
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
   =
    [#"../Scratch/src/lit.rs" 40 4 43 5] exists i : int . 0 <= i /\ i < Seq.length c /\ IndexLogic0.index_logic (Seq.get c i) = idx
  val idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) : bool
    ensures { result = idx_in_logic idx c }
    
end
module Scratch_Clause_Impl2_ClauseIsSeen_Stub
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global))
    
end
module Scratch_Clause_Impl2_ClauseIsSeen_Interface
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global))
    
end
module Scratch_Clause_Impl2_ClauseIsSeen
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Lit_IdxInLogic_Stub as IdxInLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View1
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View0 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global))
    
   =
    [#"../Scratch/src/clause.rs" 203 8 206 9] forall idx : int . 0 <= idx /\ idx < Seq.length (View0.view seen) -> Seq.get (View0.view seen) idx = IdxInLogic0.idx_in_logic idx (View1.view self)
  val clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = clause_is_seen self seen }
    
end
module Scratch_Clause_Impl2_Equals_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Clause_Impl2_Equals_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Clause_Impl2_Equals
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause)
    
   =
    [#"../Scratch/src/clause.rs" 211 8 215 9] Seq.length (View0.view self) = Seq.length (View0.view o) /\ (forall j : int . 0 <= j /\ j < Seq.length (View0.view self) -> Seq.get (View0.view self) j = Seq.get (View0.view o) j)
  val equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = equals self o }
    
end
module Scratch_Formula_FormulaInvariant_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_FormulaInvariant_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_FormulaInvariant
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  clone Scratch_Clause_Impl2_Invariant_Stub as Invariant0
  predicate formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/formula.rs" 26 4 29 5] forall i : int . 0 <= i /\ i < Seq.length (let (a, _) = f in a) -> Invariant0.invariant' (Seq.get (let (a, _) = f in a) i) (let (_, a) = f in a) /\ Seq.length (View0.view (Seq.get (let (a, _) = f in a) i)) > 0
  val formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = formula_invariant f }
    
end
module Scratch_Formula_Equisat_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_Equisat_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_Equisat
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_EventuallySatComplete_Stub as EventuallySatComplete0
  predicate equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/formula.rs" 50 8 50 64] EventuallySatComplete0.eventually_sat_complete f = EventuallySatComplete0.eventually_sat_complete o
  val equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = equisat f o }
    
end
module Scratch_Formula_Impl1_SatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_SatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_SatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 108 8 111 9] forall i : int . 0 <= i /\ i < Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses self)) -> SatInner0.sat_inner (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses self)) i) a
  val sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = sat_inner self a }
    
end
module Scratch_Formula_Impl1_EventuallySatComplete_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_EventuallySatComplete_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_EventuallySatComplete
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use prelude.UIntSize
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner_Stub as SatInner0
  clone Scratch_Assignments_CompleteInner_Stub as CompleteInner0
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/formula.rs" 58 8 60 9] exists a2 : Seq.seq uint8 . Seq.length a2 = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self) /\ CompleteInner0.complete_inner a2 /\ SatInner0.sat_inner self a2
  val eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = eventually_sat_complete self }
    
end
module Scratch_Formula_Impl1_Equisat_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_Equisat_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_Equisat
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_EventuallySatComplete_Stub as EventuallySatComplete0
  predicate equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/formula.rs" 65 8 65 69] EventuallySatComplete0.eventually_sat_complete self = EventuallySatComplete0.eventually_sat_complete o
  val equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = equisat self o }
    
end
module Scratch_Formula_Impl1_InvariantMirror_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_InvariantMirror_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_InvariantMirror
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Clause_Impl0_View_Stub as View1
  clone Scratch_Clause_Impl2_Invariant_Stub as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula) =
    [#"../Scratch/src/formula.rs" 78 12 82 45] (forall i : int . 0 <= i /\ i < Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses self)) -> Invariant0.invariant' (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses self)) i) (UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self))) /\ (forall i : int . 0 <= i /\ i < Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses self)) -> Seq.length (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses self)) i)) >= 1)
  val invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = invariant_mirror self }
    
end
module Scratch_Formula_Impl1_Invariant_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_Invariant_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula)
  axiom invariant'_spec : forall self : Scratch_Formula_Formula_Type.t_formula . [#"../Scratch/src/formula.rs" 70 14 70 47] invariant' self = InvariantMirror0.invariant_mirror self
end
module Scratch_Formula_Impl1_Invariant
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_FormulaInvariant_Stub as FormulaInvariant0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_View_Stub as View0
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula) =
    [#"../Scratch/src/formula.rs" 72 20 72 44] FormulaInvariant0.formula_invariant (View0.view self)
  val invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = invariant' self }
    
  axiom invariant'_spec : forall self : Scratch_Formula_Formula_Type.t_formula . [#"../Scratch/src/formula.rs" 70 14 70 47] invariant' self = InvariantMirror0.invariant_mirror self
end
module Scratch_Formula_Impl1_Invariant_Impl
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl3_Invariant as Invariant1 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_VarsInRangeInner as VarsInRangeInner0 with
    predicate Invariant0.invariant' = Invariant1.invariant'
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_View as View3 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Clause_InvariantInternal as InvariantInternal0 with
    predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
    predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View as View2 with
    function View0.view = View3.view,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_Invariant as Invariant0 with
    function View0.view = View2.view,
    predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone CreusotContracts_Std1_Vec_Impl0_View as View1 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Formula_FormulaInvariant as FormulaInvariant0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    function View0.view = View2.view
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_View as View0 with
    function View0.view = View1.view,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Formula_Impl1_InvariantMirror as InvariantMirror0 with
    function View0.view = View1.view,
    predicate Invariant0.invariant' = Invariant0.invariant',
    function View1.view = View2.view,
    val Max0.mAX' = Max0.mAX'
  let rec Snapshot predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula)
    ensures { [#"../Scratch/src/formula.rs" 70 14 70 47] result = InvariantMirror0.invariant_mirror self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/formula.rs" 72 20 72 44] let a' = View0.view self in FormulaInvariant0.formula_invariant a'
end
module Scratch_Formula_Impl1_EventuallySatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use prelude.UIntSize
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner_Stub as SatInner0
  clone Scratch_Assignments_CompatibleInner_Stub as CompatibleInner0
  predicate eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 89 8 91 9] exists a2 : Seq.seq uint8 . Seq.length a2 = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self) /\ CompatibleInner0.compatible_inner a a2 /\ SatInner0.sat_inner self a2
  val eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = eventually_sat_inner self a }
    
end
module Scratch_Formula_Impl1_EventuallySatCompleteInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatCompleteInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatCompleteInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use prelude.UIntSize
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner_Stub as SatInner0
  clone Scratch_Assignments_CompatibleCompleteInner_Stub as CompatibleCompleteInner0
  predicate eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 96 8 98 9] exists a2 : Seq.seq uint8 . Seq.length a2 = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self) /\ CompatibleCompleteInner0.compatible_complete_inner a a2 /\ SatInner0.sat_inner self a2
  val eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = eventually_sat_complete_inner self a }
    
end
module Scratch_Formula_Impl1_EventuallySat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_EventuallySat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_EventuallySat
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_EventuallySatInner_Stub as EventuallySatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  predicate eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/formula.rs" 103 20 103 49] EventuallySatInner0.eventually_sat_inner self (View0.view a)
  val eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = eventually_sat self a }
    
end
module Scratch_Formula_Impl1_Sat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Sat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Sat
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_FormulaSatInner_Stub as FormulaSatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View1
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_View_Stub as View0
  predicate sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/formula.rs" 116 20 116 48] FormulaSatInner0.formula_sat_inner (View0.view self) (View1.view a)
  val sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = sat self a }
    
end
module Scratch_Formula_Impl1_UnsatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_UnsatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_UnsatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Clause_Impl2_UnsatInner_Stub as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 121 8 124 9] exists i : int . 0 <= i /\ i < Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses self)) /\ UnsatInner0.unsat_inner (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses self)) i) a
  val unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = unsat_inner self a }
    
end
module Scratch_Formula_Impl1_Unsat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Unsat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Unsat
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_UnsatInner_Stub as UnsatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  predicate unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/formula.rs" 129 20 129 40] UnsatInner0.unsat_inner self (View0.view a)
  val unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unsat self a }
    
end
module Scratch_Formula_Impl1_NotSatisfiable_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_NotSatisfiable_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_NotSatisfiable
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_EquisatExtension_Stub as EquisatExtension0
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula)
   =
    [#"../Scratch/src/formula.rs" 134 8 134 82] exists c : Scratch_Clause_Clause_Type.t_clause . Seq.length (View0.view c) = 0 /\ EquisatExtension0.equisat_extension c self
  val not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = not_satisfiable self }
    
end
module Scratch_Lit_Impl4_Clone_Interface
  use prelude.Borrow
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  val clone' [#"../Scratch/src/lit.rs" 10 9 10 14] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { [#"../Scratch/src/lit.rs" 10 9 10 14] result = self }
    
end
module Scratch_Lit_Impl4_Clone
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  clone Core_Clone_Impls_Impl19_Clone_Interface as Clone1
  clone Core_Clone_Impls_Impl5_Clone_Interface as Clone0
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  let rec cfg clone' [#"../Scratch/src/lit.rs" 10 9 10 14] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { [#"../Scratch/src/lit.rs" 10 9 10 14] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Lit_Lit_Type.t_lit;
  var self_1 : Scratch_Lit_Lit_Type.t_lit;
  var _3 : usize;
  var _4 : usize;
  var _5 : bool;
  var _6 : bool;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- Scratch_Lit_Lit_Type.lit_idx self_1;
    _3 <- ([#"../Scratch/src/lit.rs" 12 4 12 18] Clone0.clone' _4);
    goto BB1
  }
  BB1 {
    _6 <- Scratch_Lit_Lit_Type.lit_polarity self_1;
    _5 <- ([#"../Scratch/src/lit.rs" 13 4 13 22] Clone1.clone' _6);
    goto BB2
  }
  BB2 {
    _0 <- Scratch_Lit_Lit_Type.C_Lit _3 _5;
    return _0
  }
  
end
module Scratch_Lit_Impl0_View_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function view [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl0_View_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function view [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl0_View
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function view [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
   =
    [#"../Scratch/src/lit.rs" 22 8 22 12] self
  val view [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { result = view self }
    
end
module Scratch_Lit_Impl1_DeepModel_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl1_DeepModel_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl1_DeepModel
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
   =
    [#"../Scratch/src/lit.rs" 32 8 32 12] self
  val deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { result = deep_model self }
    
end
module Scratch_Lit_Impl2_ToWatchidxLogic_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToWatchidxLogic_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToWatchidxLogic
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  function to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
   =
    [#"../Scratch/src/lit.rs" 63 8 63 91] IndexLogic0.index_logic self * 2 + (if IsPositiveLogic0.is_positive_logic self then
      0
    else
      1
    )
  val to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    ensures { result = to_watchidx_logic self }
    
end
module Scratch_Lit_Impl2_ToNegWatchidxLogic_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToNegWatchidxLogic_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToNegWatchidxLogic
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  function to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
   =
    [#"../Scratch/src/lit.rs" 69 8 69 91] IndexLogic0.index_logic self * 2 + (if IsPositiveLogic0.is_positive_logic self then
      1
    else
      0
    )
  val to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    ensures { result = to_neg_watchidx_logic self }
    
end
module Scratch_Lit_Impl3_LitInInternal_Stub
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_Impl3_LitInInternal_Interface
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_Impl3_LitInInternal
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
   =
    [#"../Scratch/src/lit.rs" 84 8 84 74] exists i : int . 0 <= i /\ i < Seq.length c /\ Seq.get c i = self
  val lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) : bool
    ensures { result = lit_in_internal self c }
    
end
module Scratch_Lit_Impl3_LitIdxIn_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIdxIn_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIdxIn
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  predicate lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
   =
    [#"../Scratch/src/lit.rs" 94 8 97 9] exists i : int . 0 <= i /\ i < Seq.length (View0.view c) /\ IndexLogic0.index_logic (Seq.get (View0.view c) i) = IndexLogic0.index_logic self
  val lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = lit_idx_in self c }
    
end
module Scratch_Lit_Impl3_Sat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Sat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Sat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  predicate sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/lit.rs" 132 20 132 38] SatInner0.sat_inner self (View0.view a)
  val sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = sat self a }
    
end
module Scratch_Lit_Impl3_Unset_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unset_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unset
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsetInner_Stub as UnsetInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  predicate unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/lit.rs" 137 20 137 40] UnsetInner0.unset_inner self (View0.view a)
  val unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unset self a }
    
end
module Scratch_Lit_Impl3_Unsat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unsat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unsat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsatInner_Stub as UnsatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View_Stub as View0
  predicate unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/lit.rs" 142 20 142 40] UnsatInner0.unsat_inner self (View0.view a)
  val unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unsat self a }
    
end
module CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub
  type t
  use seq.Seq
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t)
end
module CreusotContracts_Logic_Seq_Impl0_PermutationOf_Interface
  type t
  use seq.Seq
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t)
end
module CreusotContracts_Logic_Seq_Impl0_PermutationOf
  type t
  use seq.Seq
  use seq.Permut
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t) =
    Permut.permut self o 0 (Seq.length self)
  val permutation_of (self : Seq.seq t) (o : Seq.seq t) : bool
    ensures { result = permutation_of self o }
    
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
  axiom lemma_clause_permuted_maintains_sat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a) -> ([#"../Scratch/src/scratch.rs" 25 0 25 67] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (View0.view c2) (View0.view c) -> Sat0.sat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
   =
    [#"../Scratch/src/scratch.rs" 23 0 23 8] ()
  val lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a}
    ensures { result = lemma_clause_permuted_maintains_sat c a }
    
  axiom lemma_clause_permuted_maintains_sat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a) -> ([#"../Scratch/src/scratch.rs" 25 0 25 67] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (View0.view c2) (View0.view c) -> Sat0.sat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat_Impl
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic as IsPositiveLogic0
  clone Scratch_Lit_Impl3_SatInner as SatInner1 with
    function IsPositiveLogic0.is_positive_logic = IsPositiveLogic0.is_positive_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_View as View3 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_View as View2 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View as View0 with
    function View0.view = View2.view,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_SatInner as SatInner0 with
    function View0.view = View0.view,
    predicate SatInner0.sat_inner = SatInner1.sat_inner
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View as View1 with
    function View0.view = View3.view,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  clone Scratch_Clause_Impl2_Sat as Sat0 with
    function View0.view = View1.view,
    predicate SatInner0.sat_inner = SatInner0.sat_inner
  let rec Snapshot function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a}
    ensures { [#"../Scratch/src/scratch.rs" 25 0 25 67] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (View0.view c2) (View0.view c) -> Sat0.sat c2 a }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/scratch.rs" 23 0 23 8] ()
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
  axiom lemma_clause_permuted_maintains_unsat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a) -> ([#"../Scratch/src/scratch.rs" 30 0 30 69] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (View0.view c2) (View0.view c) -> Unsat0.unsat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View_Stub as View0
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
   =
    [#"../Scratch/src/scratch.rs" 28 0 28 8] ()
  val lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a}
    ensures { result = lemma_clause_permuted_maintains_unsat c a }
    
  axiom lemma_clause_permuted_maintains_unsat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a) -> ([#"../Scratch/src/scratch.rs" 30 0 30 69] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (View0.view c2) (View0.view c) -> Unsat0.unsat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat_Impl
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic as IsPositiveLogic0
  clone Scratch_Lit_Impl3_UnsatInner as UnsatInner1 with
    function IsPositiveLogic0.is_positive_logic = IsPositiveLogic0.is_positive_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_View as View3 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_View as View2 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View as View0 with
    function View0.view = View2.view,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_UnsatInner as UnsatInner0 with
    function View0.view = View0.view,
    predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View as View1 with
    function View0.view = View3.view,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  clone Scratch_Clause_Impl2_Unsat as Unsat0 with
    function View0.view = View1.view,
    predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  let rec Snapshot function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a}
    ensures { [#"../Scratch/src/scratch.rs" 30 0 30 69] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (View0.view c2) (View0.view c) -> Unsat0.unsat c2 a }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/scratch.rs" 28 0 28 8] ()
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
     ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Model_View_ViewTy_Type
  type self
  type ViewTy
end
module CreusotContracts_Model_View_View_Stub
  type self
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = self
  function view (self : self) : ViewTy0.ViewTy
end
module CreusotContracts_Model_View_View_Interface
  type self
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = self
  function view (self : self) : ViewTy0.ViewTy
end
module CreusotContracts_Model_View_View
  type self
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = self
  function view (self : self) : ViewTy0.ViewTy
  val view (self : self) : ViewTy0.ViewTy
    ensures { result = view self }
    
end
module CreusotContracts_Model_Impl3_View_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  function view (self : borrowed t) : ViewTy0.ViewTy
end
module CreusotContracts_Model_Impl3_View_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  function view (self : borrowed t) : ViewTy0.ViewTy
end
module CreusotContracts_Model_Impl3_View
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  clone CreusotContracts_Model_View_View_Stub as View0 with
    type self = t,
    type ViewTy0.ViewTy = ViewTy0.ViewTy
  function view (self : borrowed t) : ViewTy0.ViewTy =
    View0.view ( * self)
  val view (self : borrowed t) : ViewTy0.ViewTy
    ensures { result = view self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub
  type self
  type t
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ViewTy0.ViewTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ViewTy0.ViewTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds
  type self
  type t
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ViewTy0.ViewTy)
  val in_bounds (self : self) (seq : ViewTy0.ViewTy) : bool
    ensures { result = in_bounds self seq }
    
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  predicate has_value (self : self) (seq : ViewTy0.ViewTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  predicate has_value (self : self) (seq : ViewTy0.ViewTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  predicate has_value (self : self) (seq : ViewTy0.ViewTy) (out : Output0.output)
  val has_value (self : self) (seq : ViewTy0.ViewTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub
  type self
  type t
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ViewTy0.ViewTy) (fin : ViewTy0.ViewTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ViewTy0.ViewTy) (fin : ViewTy0.ViewTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Model_View_ViewTy_Type as ViewTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ViewTy0.ViewTy) (fin : ViewTy0.ViewTy)
    
  val resolve_elswhere (self : self) (old' : ViewTy0.ViewTy) (fin : ViewTy0.ViewTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Alloc_Vec_Impl14_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub as ResolveElswhere0 with
    type self = i,
    type t = slice t,
    type ViewTy0.ViewTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View1 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ViewTy0.ViewTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ViewTy0.ViewTy = Seq.seq t
  clone CreusotContracts_Model_Impl3_View_Stub as View0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ViewTy0.ViewTy = Seq.seq t
  val index_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {InBounds0.in_bounds index (View0.view self)}
    ensures { HasValue0.has_value index (View0.view self) ( * result) }
    ensures { HasValue0.has_value index (View1.view ( ^ self)) ( ^ result) }
    ensures { ResolveElswhere0.resolve_elswhere index (View0.view self) (View1.view ( ^ self)) }
    ensures { Seq.length (View1.view ( ^ self)) = Seq.length (View0.view self) }
    
end
module CreusotContracts_Std1_Slice_Impl0_View_Stub
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function view (self : slice t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_View_Interface
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function view (self : slice t) : Seq.seq t
  axiom view_spec : forall self : slice t . view self = Slice.id self && Seq.length (view self) <= UIntSize.to_int Max0.mAX'
end
module CreusotContracts_Std1_Slice_Impl0_View
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function view (self : slice t) : Seq.seq t
  val view (self : slice t) : Seq.seq t
    ensures { result = view self }
    
  axiom view_spec : forall self : slice t . view self = Slice.id self && Seq.length (view self) <= UIntSize.to_int Max0.mAX'
end
module Alloc_Vec_Impl10_DerefMut_Interface
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View3 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_Impl0_View_Stub as View2 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_View_Stub as View1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ViewTy0.ViewTy = Seq.seq t
  clone CreusotContracts_Model_Impl3_View_Stub as View0 with
    type t = slice t,
    type ViewTy0.ViewTy = Seq.seq t
  val deref_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) : borrowed (slice t)
    ensures { View0.view result = View1.view self }
    ensures { View2.view ( ^ result) = View3.view ( ^ self) }
    
end
module Core_Slice_Impl0_Swap_Interface
  type t
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use seq.Permut
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_View_Stub as View1 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_View_Stub as View0 with
    type t = slice t,
    type ViewTy0.ViewTy = Seq.seq t
  val swap (self : borrowed (slice t)) (a : usize) (b : usize) : ()
    requires {UIntSize.to_int a < Seq.length (View0.view self)}
    requires {UIntSize.to_int b < Seq.length (View0.view self)}
    ensures { Permut.exchange (View1.view ( ^ self)) (View0.view self) (UIntSize.to_int a) (UIntSize.to_int b) }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    UIntSize.to_int self < Seq.length seq
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    Seq.get seq (UIntSize.to_int self) = out
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Scratch_Scratch_Swap_Interface
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use seq.Permut
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Formula_Impl1_Equisat_Stub as Equisat0
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  clone Scratch_Assignments_Impl0_View_Stub as View2
  clone Scratch_Clause_Impl0_View_Stub as View1
  clone CreusotContracts_Std1_Vec_Impl0_View_Stub as View0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Formula_Impl1_Invariant_Stub as Invariant0 with
    predicate InvariantMirror0.invariant_mirror = InvariantMirror0.invariant_mirror,
    axiom .
  val swap [#"../Scratch/src/scratch.rs" 43 0 43 83] (f : borrowed (Scratch_Formula_Formula_Type.t_formula)) (cref : usize) (j : usize) (k : usize) (assignments : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( * f)}
    requires {[#"../Scratch/src/scratch.rs" 34 11 34 40] Seq.length (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) >= 2}
    requires {[#"../Scratch/src/scratch.rs" 35 11 35 35] UIntSize.to_int cref < Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f)))}
    requires {[#"../Scratch/src/scratch.rs" 36 11 36 40] Seq.length (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int j}
    requires {[#"../Scratch/src/scratch.rs" 37 11 37 40] Seq.length (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int k}
    requires {[#"../Scratch/src/scratch.rs" 38 0 38 59] not SatInner0.sat_inner (Seq.get (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) 0) (View2.view assignments)}
    ensures { [#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( ^ f) }
    ensures { [#"../Scratch/src/scratch.rs" 39 0 39 72] Permut.exchange (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) (UIntSize.to_int cref))) (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) (UIntSize.to_int j) (UIntSize.to_int k) }
    ensures { [#"../Scratch/src/scratch.rs" 40 10 40 39] UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( * f)) = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( ^ f)) }
    ensures { [#"../Scratch/src/scratch.rs" 41 10 41 49] Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) = Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) }
    ensures { [#"../Scratch/src/scratch.rs" 42 10 42 23] Equisat0.equisat ( * f) ( ^ f) }
    
end
module Scratch_Scratch_Swap
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Snapshot
  use prelude.Slice
  use seq.Seq
  use seq.Permut
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl3_Invariant as Invariant2 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_VarsInRangeInner as VarsInRangeInner0 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone Scratch_Lit_Impl2_IsPositiveLogic as IsPositiveLogic0
  clone Scratch_Lit_Impl3_SatInner as SatInner0 with
    function IsPositiveLogic0.is_positive_logic = IsPositiveLogic0.is_positive_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  clone CreusotContracts_Std1_Vec_Impl0_View as View4 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_View as View1 with
    function View0.view = View4.view,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_SatInner as SatInner2 with
    function View0.view = View1.view,
    predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Scratch_Logic_Unset as Unset0
  clone Scratch_Clause_InvariantInternal as InvariantInternal0 with
    predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
    predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_View as View0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner as SatInner1 with
    function View0.view = View0.view,
    predicate SatInner0.sat_inner = SatInner2.sat_inner,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Assignments_CompleteInner as CompleteInner0 with
    predicate Unset0.unset = Unset0.unset
  clone Scratch_Clause_Impl2_Invariant as Invariant1 with
    function View0.view = View1.view,
    predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_View as View9 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_View as View8 with
    type t = Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global),
    type ViewTy0.ViewTy = Seq.seq (Scratch_Lit_Lit_Type.t_lit),
    function View0.view = View4.view
  clone CreusotContracts_Model_Impl3_View as View7 with
    type t = slice (Scratch_Lit_Lit_Type.t_lit),
    type ViewTy0.ViewTy = Seq.seq (Scratch_Lit_Lit_Type.t_lit),
    function View0.view = View9.view
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone CreusotContracts_Model_Impl3_View as View6 with
    type t = Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global),
    type ViewTy0.ViewTy = Seq.seq (Scratch_Clause_Clause_Type.t_clause),
    function View0.view = View0.view
  clone Scratch_Formula_Impl1_EventuallySatComplete as EventuallySatComplete0 with
    predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
    predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_View as View5 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Formula_FormulaInvariant as FormulaInvariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    function View0.view = View1.view
  clone Scratch_Formula_Impl0_View as View3 with
    function View0.view = View0.view,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Formula_Impl1_InvariantMirror as InvariantMirror0 with
    function View0.view = View0.view,
    predicate Invariant0.invariant' = Invariant1.invariant',
    function View1.view = View1.view,
    val Max0.mAX' = Max0.mAX'
  clone Core_Slice_Impl0_Swap_Interface as Swap0 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    function View0.view = View7.view,
    function View1.view = View9.view,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = slice (Scratch_Lit_Lit_Type.t_lit)
  clone Alloc_Vec_Impl10_DerefMut_Interface as DerefMut0 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    function View0.view = View7.view,
    function View1.view = View8.view,
    function View2.view = View9.view,
    function View3.view = View4.view,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function View0.view = View6.view,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function View1.view = View0.view,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = Scratch_Clause_Clause_Type.t_clause,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Formula_Formula_Type.t_formula
  clone Scratch_Formula_Impl1_Equisat as Equisat0 with
    predicate EventuallySatComplete0.eventually_sat_complete = EventuallySatComplete0.eventually_sat_complete
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_View as View2 with
    function View0.view = View5.view,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Formula_Impl1_Invariant as Invariant0 with
    predicate InvariantMirror0.invariant_mirror = InvariantMirror0.invariant_mirror,
    function View0.view = View3.view,
    predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
    axiom .
  let rec cfg swap [#"../Scratch/src/scratch.rs" 43 0 43 83] [@cfg:stackify] [@cfg:subregion_analysis] (f : borrowed (Scratch_Formula_Formula_Type.t_formula)) (cref : usize) (j : usize) (k : usize) (assignments : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( * f)}
    requires {[#"../Scratch/src/scratch.rs" 34 11 34 40] Seq.length (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) >= 2}
    requires {[#"../Scratch/src/scratch.rs" 35 11 35 35] UIntSize.to_int cref < Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f)))}
    requires {[#"../Scratch/src/scratch.rs" 36 11 36 40] Seq.length (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int j}
    requires {[#"../Scratch/src/scratch.rs" 37 11 37 40] Seq.length (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int k}
    requires {[#"../Scratch/src/scratch.rs" 38 0 38 59] not SatInner0.sat_inner (Seq.get (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) 0) (View2.view assignments)}
    ensures { [#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( ^ f) }
    ensures { [#"../Scratch/src/scratch.rs" 39 0 39 72] Permut.exchange (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) (UIntSize.to_int cref))) (View1.view (Seq.get (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) (UIntSize.to_int j) (UIntSize.to_int k) }
    ensures { [#"../Scratch/src/scratch.rs" 40 10 40 39] UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( * f)) = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( ^ f)) }
    ensures { [#"../Scratch/src/scratch.rs" 41 10 41 49] Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( * f))) = Seq.length (View0.view (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) }
    ensures { [#"../Scratch/src/scratch.rs" 42 10 42 23] Equisat0.equisat ( * f) ( ^ f) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var f_1 : borrowed (Scratch_Formula_Formula_Type.t_formula);
  var cref_2 : usize;
  var j_3 : usize;
  var k_4 : usize;
  var assignments_5 : Scratch_Assignments_Assignments_Type.t_assignments;
  var old_f_17 : Snapshot.Snapshot_ty (borrowed (Scratch_Formula_Formula_Type.t_formula));
  var _19 : ();
  var _20 : ();
  var _21 : borrowed (slice (Scratch_Lit_Lit_Type.t_lit));
  var _22 : borrowed (slice (Scratch_Lit_Lit_Type.t_lit));
  var _23 : borrowed (Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global));
  var _24 : borrowed (Scratch_Clause_Clause_Type.t_clause);
  var _25 : borrowed (Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global));
  var _26 : usize;
  var _27 : usize;
  var _28 : usize;
  var _29 : ();
  {
    f_1 <- f;
    cref_2 <- cref;
    j_3 <- j;
    k_4 <- k;
    assignments_5 <- assignments;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _19 <- ();
    old_f_17 <- ([#"../Scratch/src/scratch.rs" 44 37 44 49] Snapshot.new f_1);
    goto BB2
  }
  BB2 {
    _25 <- borrow_mut (Scratch_Formula_Formula_Type.formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Scratch_Formula_Formula_Type.C_Formula a b =  * f_1 in Scratch_Formula_Formula_Type.C_Formula ( ^ _25) b) };
    assume { Resolve0.resolve f_1 };
    _26 <- cref_2;
    _24 <- ([#"../Scratch/src/scratch.rs" 46 4 46 19] IndexMut0.index_mut _25 _26);
    goto BB3
  }
  BB3 {
    _23 <- borrow_mut (Scratch_Clause_Clause_Type.clause_lits ( * _24));
    _24 <- { _24 with current = (let Scratch_Clause_Clause_Type.C_Clause a b c d =  * _24 in Scratch_Clause_Clause_Type.C_Clause a b c ( ^ _23)) };
    assume { Resolve1.resolve _24 };
    _22 <- ([#"../Scratch/src/scratch.rs" 46 4 46 35] DerefMut0.deref_mut _23);
    goto BB4
  }
  BB4 {
    _21 <- borrow_mut ( * _22);
    _22 <- { _22 with current = ( ^ _21) };
    assume { Resolve2.resolve _22 };
    _27 <- j_3;
    _28 <- k_4;
    _20 <- ([#"../Scratch/src/scratch.rs" 46 4 46 35] Swap0.swap _21 _27 _28);
    goto BB5
  }
  BB5 {
    assert { [#"../Scratch/src/scratch.rs" 48 18 48 38]  ^ f_1 =  ^ Snapshot.inner old_f_17 };
    _29 <- ();
    _0 <- ();
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Scratch_Logic_Pos_Stub
  use prelude.Int
  use prelude.UInt8
  function pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8
end
module Scratch_Logic_Pos_Interface
  use prelude.Int
  use prelude.UInt8
  function pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8
end
module Scratch_Logic_Pos
  use prelude.Int
  use prelude.UInt8
  function pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8 =
    [#"../Scratch/src/logic.rs" 9 4 9 7] (1 : uint8)
  val pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8
    ensures { result = pos _1' }
    
end
module Scratch_Logic_Neg_Stub
  use prelude.Int
  use prelude.UInt8
  function neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8
end
module Scratch_Logic_Neg_Interface
  use prelude.Int
  use prelude.UInt8
  function neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8
end
module Scratch_Logic_Neg
  use prelude.Int
  use prelude.UInt8
  function neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8 =
    [#"../Scratch/src/logic.rs" 14 4 14 7] (0 : uint8)
  val neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8
    ensures { result = neg _1' }
    
end
module Scratch_Logic_BoolToAssignedstate_Stub
  use prelude.UInt8
  use prelude.Int
  function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
end
module Scratch_Logic_BoolToAssignedstate_Interface
  use prelude.UInt8
  use prelude.Int
  function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
  axiom bool_to_assignedstate_spec : forall b : bool . ([#"../Scratch/src/logic.rs" 31 0 31 31] not b -> UInt8.to_int (bool_to_assignedstate b) = 0) && ([#"../Scratch/src/logic.rs" 30 0 30 30] b -> UInt8.to_int (bool_to_assignedstate b) = 1)
end
module Scratch_Logic_BoolToAssignedstate
  use prelude.UInt8
  use prelude.Int
  function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8 =
    [#"../Scratch/src/logic.rs" 29 0 29 8] if b then (1 : uint8) else (0 : uint8)
  val bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
    ensures { result = bool_to_assignedstate b }
    
  axiom bool_to_assignedstate_spec : forall b : bool . ([#"../Scratch/src/logic.rs" 31 0 31 31] not b -> UInt8.to_int (bool_to_assignedstate b) = 0) && ([#"../Scratch/src/logic.rs" 30 0 30 30] b -> UInt8.to_int (bool_to_assignedstate b) = 1)
end
module Scratch_Logic_BoolToAssignedstate_Impl
  use prelude.UInt8
  use prelude.Int
  let rec Snapshot function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
    ensures { [#"../Scratch/src/logic.rs" 30 0 30 30] b -> UInt8.to_int result = 1 }
    ensures { [#"../Scratch/src/logic.rs" 31 0 31 31] not b -> UInt8.to_int result = 0 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/logic.rs" 29 0 29 8] if b then (1 : uint8) else (0 : uint8)
end
module Scratch_Logic_FlipV_Stub
  use prelude.Int
  use prelude.UInt8
  function flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8
end
module Scratch_Logic_FlipV_Interface
  use prelude.Int
  use prelude.UInt8
  function flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8
end
module Scratch_Logic_FlipV
  use prelude.Int
  use prelude.UInt8
  function flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8 =
    [#"../Scratch/src/logic.rs" 42 4 50 5] if UInt8.to_int v = 0 then
      (1 : uint8)
    else
      if UInt8.to_int v = 1 then (0 : uint8) else v
    
  val flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8
    ensures { result = flip_v v }
    
end
module Scratch_Assignments_Impl0
  
end
module Scratch_Clause_Impl0
  
end
module Scratch_Formula_Impl0
  
end
module Scratch_Lit_Impl0
  
end
module Scratch_Clause_Impl3
  use prelude.Borrow
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  goal clone'_refn : [#"../Scratch/src/clause.rs" 6 9 6 14] forall self : Scratch_Clause_Clause_Type.t_clause . forall result : Scratch_Clause_Clause_Type.t_clause . result = self -> result = self
end
module Scratch_Lit_Impl4
  use prelude.Borrow
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  goal clone'_refn : [#"../Scratch/src/lit.rs" 10 9 10 14] forall self : Scratch_Lit_Lit_Type.t_lit . forall result : Scratch_Lit_Lit_Type.t_lit . result = self -> result = self
end
module Scratch_Lit_Impl5
  
end
module Scratch_Lit_Impl1
  
end
