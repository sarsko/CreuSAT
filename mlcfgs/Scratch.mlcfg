
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module Scratch_Assignments_Assignments_Type
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_assignments  =
    | C_Assignments (Alloc_Vec_Vec_Type.t_vec uint8 (Alloc_Alloc_Global_Type.t_global))
    
  let function assignments_0 (self : t_assignments) : Alloc_Vec_Vec_Type.t_vec uint8 (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Assignments a -> a
      end
end
module Core_Num_Impl11_Max_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.Int
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX'
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX'
end
module Scratch_Assignments_Impl0_ShallowModel_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  function shallow_model [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    
end
module Scratch_Assignments_Impl0_ShallowModel_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  function shallow_model [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    
end
module Scratch_Assignments_Impl0_ShallowModel
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  function shallow_model [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    
   =
    [#"../Scratch/src/assignments.rs" 19 4 19 12] ShallowModel0.shallow_model (Scratch_Assignments_Assignments_Type.assignments_0 self)
  val shallow_model [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    ensures { result = shallow_model self }
    
end
module Scratch_Logic_Unset_Stub
  use prelude.Int
  use prelude.UInt8
  predicate unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8)
end
module Scratch_Logic_Unset_Interface
  use prelude.Int
  use prelude.UInt8
  predicate unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8)
end
module Scratch_Logic_Unset
  use prelude.Int
  use prelude.UInt8
  predicate unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8) =
    [#"../Scratch/src/logic.rs" 19 4 25 5] if UInt8.to_int v >= 2 then true else false
  val unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8) : bool
    ensures { result = unset v }
    
end
module Scratch_Assignments_CompatibleInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Scratch_Assignments_CompatibleInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Scratch_Assignments_CompatibleInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  clone Scratch_Logic_Unset_Stub as Unset0
  predicate compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8) =
    [#"../Scratch/src/assignments.rs" 28 8 29 43] Seq.length a = Seq.length a2 /\ (forall i : int . 0 <= i /\ i < Seq.length a -> Unset0.unset (Seq.get a i) \/ Seq.get a i = Seq.get a2 i)
  val compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8) : bool
    ensures { result = compatible_inner a a2 }
    
end
module Scratch_Assignments_CompleteInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8)
end
module Scratch_Assignments_CompleteInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8)
end
module Scratch_Assignments_CompleteInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  clone Scratch_Logic_Unset_Stub as Unset0
  predicate complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8) =
    [#"../Scratch/src/assignments.rs" 35 4 37 5] forall i : int . 0 <= i /\ i < Seq.length a -> not Unset0.unset (Seq.get a i)
  val complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8) : bool
    ensures { result = complete_inner a }
    
end
module Scratch_Assignments_CompatibleCompleteInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Assignments_CompatibleCompleteInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Assignments_CompatibleCompleteInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  clone Scratch_Assignments_CompleteInner_Stub as CompleteInner0
  clone Scratch_Assignments_CompatibleInner_Stub as CompatibleInner0
  predicate compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
   =
    [#"../Scratch/src/assignments.rs" 42 4 42 49] CompatibleInner0.compatible_inner a a2 /\ CompleteInner0.complete_inner a2
  val compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8) : bool
    ensures { result = compatible_complete_inner a a2 }
    
end
module Scratch_Lit_Lit_Type
  use prelude.Int
  use prelude.UIntSize
  type t_lit  =
    | C_Lit usize bool
    
  let function lit_idx (self : t_lit) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Lit a _ -> a
      end
  let function lit_polarity (self : t_lit) : bool = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Lit _ a -> a
      end
end
module Scratch_Clause_Clause_Type
  use prelude.Int
  use prelude.UInt32
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_clause  =
    | C_Clause bool uint32 usize (Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global))
    
  let function clause_deleted (self : t_clause) : bool = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause a _ _ _ -> a
      end
  let function clause_lbd (self : t_clause) : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause _ a _ _ -> a
      end
  let function clause_search (self : t_clause) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause _ _ a _ -> a
      end
  let function clause_lits (self : t_clause) : Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause _ _ _ a -> a
      end
end
module Scratch_Formula_Formula_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_formula  =
    | C_Formula (Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global)) usize
    
  let function formula_num_vars (self : t_formula) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Formula _ a -> a
      end
  let function formula_clauses (self : t_formula) : Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Formula a _ -> a
      end
end
module Scratch_Assignments_Impl1_Invariant_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Assignments_Impl1_Invariant_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Assignments_Impl1_Invariant
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/assignments.rs" 49 8 52 9] UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars f) = Seq.length (ShallowModel0.shallow_model self) /\ (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> UInt8.to_int (Seq.get (ShallowModel0.shallow_model self) i) <= 3)
  val invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = invariant' self f }
    
end
module Scratch_Assignments_Impl1_Complete_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Assignments_Impl1_Complete_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Assignments_Impl1_Complete
  use prelude.Int
  use seq.Seq
  clone Scratch_Logic_Unset_Stub as Unset0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/assignments.rs" 57 8 59 9] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> not Unset0.unset (Seq.get (ShallowModel0.shallow_model self) i)
  val complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = complete self }
    
end
module Core_Clone_Impls_Impl19_Clone_Interface
  use prelude.Borrow
  val clone' (self : bool) : bool
    ensures { result = self }
    
end
module Core_Clone_Impls_Impl8_Clone_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  val clone' (self : uint32) : uint32
    ensures { result = self }
    
end
module Core_Clone_Impls_Impl5_Clone_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  val clone' (self : usize) : usize
    ensures { result = self }
    
end
module Alloc_Vec_Impl11_Clone_Interface
  type t
  type a
  use prelude.Borrow
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  val clone' (self : Alloc_Vec_Vec_Type.t_vec t a) : Alloc_Vec_Vec_Type.t_vec t a
    ensures { result = self }
    
end
module Scratch_Clause_Impl3_Clone_Interface
  use prelude.Borrow
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  val clone' [#"../Scratch/src/clause.rs" 6 9 6 14] (self : Scratch_Clause_Clause_Type.t_clause) : Scratch_Clause_Clause_Type.t_clause
    ensures { [#"../Scratch/src/clause.rs" 6 9 6 14] result = self }
    
end
module Scratch_Clause_Impl3_Clone
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Alloc_Vec_Impl11_Clone_Interface as Clone3 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global
  clone Core_Clone_Impls_Impl5_Clone_Interface as Clone2
  clone Core_Clone_Impls_Impl8_Clone_Interface as Clone1
  clone Core_Clone_Impls_Impl19_Clone_Interface as Clone0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  let rec cfg clone' [#"../Scratch/src/clause.rs" 6 9 6 14] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Clause_Clause_Type.t_clause) : Scratch_Clause_Clause_Type.t_clause
    ensures { [#"../Scratch/src/clause.rs" 6 9 6 14] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Clause_Clause_Type.t_clause;
  var self_1 : Scratch_Clause_Clause_Type.t_clause;
  var _3 : bool;
  var _4 : bool;
  var _5 : uint32;
  var _6 : uint32;
  var _7 : usize;
  var _8 : usize;
  var _9 : Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global);
  var _10 : Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- Scratch_Clause_Clause_Type.clause_deleted self_1;
    _3 <- ([#"../Scratch/src/clause.rs" 8 4 8 21] Clone0.clone' _4);
    goto BB1
  }
  BB1 {
    _6 <- Scratch_Clause_Clause_Type.clause_lbd self_1;
    _5 <- ([#"../Scratch/src/clause.rs" 9 4 9 16] Clone1.clone' _6);
    goto BB2
  }
  BB2 {
    _8 <- Scratch_Clause_Clause_Type.clause_search self_1;
    _7 <- ([#"../Scratch/src/clause.rs" 10 4 10 21] Clone2.clone' _8);
    goto BB3
  }
  BB3 {
    _10 <- Scratch_Clause_Clause_Type.clause_lits self_1;
    _9 <- ([#"../Scratch/src/clause.rs" 11 4 11 22] Clone3.clone' _10);
    goto BB4
  }
  BB4 {
    _0 <- Scratch_Clause_Clause_Type.C_Clause _3 _5 _7 _9;
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Scratch_Clause_Impl0_ShallowModel_Stub
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  function shallow_model [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Clause_Impl0_ShallowModel_Interface
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  function shallow_model [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Clause_Impl0_ShallowModel
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  function shallow_model [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    
   =
    [#"../Scratch/src/clause.rs" 18 4 18 12] ShallowModel0.shallow_model (Scratch_Clause_Clause_Type.clause_lits self)
  val shallow_model [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    ensures { result = shallow_model self }
    
end
module Scratch_Lit_Impl2_IndexLogic_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
end
module Scratch_Lit_Impl2_IndexLogic_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
end
module Scratch_Lit_Impl2_IndexLogic
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
   =
    [#"../Scratch/src/lit.rs" 51 8 51 31] UIntSize.to_int (Scratch_Lit_Lit_Type.lit_idx self)
  val index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
    ensures { result = index_logic self }
    
end
module Scratch_Lit_Impl3_Invariant_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int)
end
module Scratch_Lit_Impl3_Invariant_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int)
end
module Scratch_Lit_Impl3_Invariant
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int) =
    [#"../Scratch/src/lit.rs" 102 20 102 42] IndexLogic0.index_logic self < n
  val invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int) : bool
    ensures { result = invariant' self n }
    
end
module Scratch_Clause_VarsInRangeInner_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_VarsInRangeInner_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_VarsInRangeInner
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_Invariant_Stub as Invariant0
  predicate vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
   =
    [#"../Scratch/src/clause.rs" 26 4 29 5] forall i : int . 0 <= i /\ i < Seq.length s -> Invariant0.invariant' (Seq.get s i) n
  val vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int) : bool
    ensures { result = vars_in_range_inner s n }
    
end
module Scratch_Clause_NoDuplicateIndexesInner_Stub
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Clause_NoDuplicateIndexesInner_Interface
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Clause_NoDuplicateIndexesInner
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
   =
    [#"../Scratch/src/clause.rs" 46 4 49 5] forall k : int . forall j : int . 0 <= j /\ j < Seq.length s /\ 0 <= k /\ k < j -> not IndexLogic0.index_logic (Seq.get s k) = IndexLogic0.index_logic (Seq.get s j)
  val no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) : bool
    ensures { result = no_duplicate_indexes_inner s }
    
end
module Scratch_Clause_InvariantInternal_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_InvariantInternal_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_InvariantInternal
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_NoDuplicateIndexesInner_Stub as NoDuplicateIndexesInner0
  clone Scratch_Clause_VarsInRangeInner_Stub as VarsInRangeInner0
  predicate invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
   =
    [#"../Scratch/src/clause.rs" 34 4 34 62] VarsInRangeInner0.vars_in_range_inner s n /\ NoDuplicateIndexesInner0.no_duplicate_indexes_inner s
  val invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int) : bool
    ensures { result = invariant_internal s n }
    
end
module Scratch_Lit_Impl2_IsPositiveLogic_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    
end
module Scratch_Lit_Impl2_IsPositiveLogic_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    
end
module Scratch_Lit_Impl2_IsPositiveLogic
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    
   =
    [#"../Scratch/src/lit.rs" 57 20 57 33] Scratch_Lit_Lit_Type.lit_polarity self
  val is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    ensures { result = is_positive_logic self }
    
end
module Scratch_Lit_Impl3_SatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_SatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_SatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  predicate sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) =
    [#"../Scratch/src/lit.rs" 108 12 111 13] if IsPositiveLogic0.is_positive_logic self then
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 1
    else
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 0
    
  val sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) : bool
    ensures { result = sat_inner self a }
    
end
module Scratch_Clause_Impl2_SatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_SatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_SatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 163 8 166 9] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) /\ SatInner0.sat_inner (Seq.get (ShallowModel0.shallow_model self) i) a
  val sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = sat_inner self a }
    
end
module Scratch_Formula_FormulaSatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8)
    
end
module Scratch_Formula_FormulaSatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8)
    
end
module Scratch_Formula_FormulaSatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  predicate formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 34 4 37 5] forall i : int . 0 <= i /\ i < Seq.length (let (a, _) = f in a) -> SatInner0.sat_inner (Seq.get (let (a, _) = f in a) i) a
  val formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8) : bool
    ensures { result = formula_sat_inner f a }
    
end
module Scratch_Formula_EventuallySatComplete_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_EventuallySatComplete_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_EventuallySatComplete
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_FormulaSatInner_Stub as FormulaSatInner0
  clone Scratch_Assignments_CompleteInner_Stub as CompleteInner0
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/formula.rs" 42 4 44 5] exists a2 : Seq.seq uint8 . Seq.length a2 = (let (_, a) = f in a) /\ CompleteInner0.complete_inner a2 /\ FormulaSatInner0.formula_sat_inner f a2
  val eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = eventually_sat_complete f }
    
end
module Scratch_Clause_EquisatExtensionInner_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_EquisatExtensionInner_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_EquisatExtensionInner
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_EventuallySatComplete_Stub as EventuallySatComplete0
  predicate equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/clause.rs" 39 4 41 5] EventuallySatComplete0.eventually_sat_complete f -> EventuallySatComplete0.eventually_sat_complete (Seq.snoc (let (a, _) = f in a) c, let (_, a) = f in a)
  val equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = equisat_extension_inner c f }
    
end
module Scratch_Lit_Impl3_UnsatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  predicate unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
   =
    [#"../Scratch/src/lit.rs" 118 12 121 13] if IsPositiveLogic0.is_positive_logic self then
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 0
    else
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 1
    
  val unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) : bool
    ensures { result = unsat_inner self a }
    
end
module Scratch_Clause_Impl1_PostUnitInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_PostUnitInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_PostUnitInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsatInner_Stub as UnsatInner0
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 61 8 65 9] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) /\ SatInner0.sat_inner (Seq.get (ShallowModel0.shallow_model self) i) a /\ (forall j : int . 0 <= j /\ j < Seq.length (ShallowModel0.shallow_model self) /\ j <> i -> UnsatInner0.unsat_inner (Seq.get (ShallowModel0.shallow_model self) j) a)
  val post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = post_unit_inner self a }
    
end
module Scratch_Lit_Impl3_UnsetInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsetInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsetInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
   =
    [#"../Scratch/src/lit.rs" 127 20 127 47] UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) >= 2
  val unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) : bool
    ensures { result = unset_inner self a }
    
end
module Scratch_Clause_Impl1_NoUnsetInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_NoUnsetInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_NoUnsetInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsetInner_Stub as UnsetInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 70 8 72 9] forall j : int . 0 <= j /\ j < Seq.length (ShallowModel0.shallow_model self) -> not UnsetInner0.unset_inner (Seq.get (ShallowModel0.shallow_model self) j) a
  val no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = no_unset_inner self a }
    
end
module Scratch_Clause_Impl1_PostUnit_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl1_PostUnit_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl1_PostUnit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl1_PostUnitInner_Stub as PostUnitInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 77 20 77 44] PostUnitInner0.post_unit_inner self (ShallowModel0.shallow_model a)
  val post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = post_unit self a }
    
end
module Scratch_Clause_Impl1_EqAssnInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_EqAssnInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_EqAssnInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 82 8 85 9] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> Seq.get a (IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model self) i)) = Seq.get a2 (IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model self) i))
  val eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8) : bool
    ensures { result = eq_assn_inner self a a2 }
    
end
module Scratch_Formula_Impl0_ShallowModel_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  function shallow_model [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    
end
module Scratch_Formula_Impl0_ShallowModel_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  function shallow_model [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    
end
module Scratch_Formula_Impl0_ShallowModel
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  function shallow_model [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    
   =
    [#"../Scratch/src/formula.rs" 20 8 20 69] (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self), UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self))
  val shallow_model [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    ensures { result = shallow_model self }
    
end
module Scratch_Clause_Impl2_EquisatExtension_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_EquisatExtension_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_EquisatExtension
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_EquisatExtensionInner_Stub as EquisatExtensionInner0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_ShallowModel_Stub as ShallowModel0
  predicate equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/clause.rs" 92 20 92 53] EquisatExtensionInner0.equisat_extension_inner self (ShallowModel0.shallow_model f)
  val equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = equisat_extension self f }
    
end
module Scratch_Clause_Impl2_SameIdxSamePolarityExcept_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int)
    
end
module Scratch_Clause_Impl2_SameIdxSamePolarityExcept_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int)
    
end
module Scratch_Clause_Impl2_SameIdxSamePolarityExcept
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int)
    
   =
    [#"../Scratch/src/clause.rs" 97 8 102 9] forall j : int . forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) /\ 0 <= j /\ j < Seq.length (ShallowModel0.shallow_model other) -> IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model self) i) <> exception' /\ IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model self) i) = IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model other) j) -> IsPositiveLogic0.is_positive_logic (Seq.get (ShallowModel0.shallow_model self) i) = IsPositiveLogic0.is_positive_logic (Seq.get (ShallowModel0.shallow_model other) j)
  val same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int) : bool
    ensures { result = same_idx_same_polarity_except self other exception' }
    
end
module Scratch_Lit_Impl3_LitIn_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIn_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIn
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
   =
    [#"../Scratch/src/lit.rs" 89 8 89 76] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model c) /\ Seq.get (ShallowModel0.shallow_model c) i = self
  val lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = lit_in self c }
    
end
module Scratch_Lit_Impl3_IsOpp_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Lit_Impl3_IsOpp_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Lit_Impl3_IsOpp
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit)
    
   =
    [#"../Scratch/src/lit.rs" 78 12 78 102] IndexLogic0.index_logic self = IndexLogic0.index_logic o /\ IsPositiveLogic0.is_positive_logic self <> IsPositiveLogic0.is_positive_logic o
  val is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit) : bool
    ensures { result = is_opp self o }
    
end
module Scratch_Clause_Impl2_ResolventOf_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int)
    
end
module Scratch_Clause_Impl2_ResolventOf_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int)
    
end
module Scratch_Clause_Impl2_ResolventOf
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_IsOpp_Stub as IsOpp0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Lit_Impl3_LitIn_Stub as LitIn0
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int)
    
   =
    [#"../Scratch/src/clause.rs" 107 8 114 9] (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model c) /\ i <> m -> LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model c) i) self) /\ (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model c2) /\ i <> k -> LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model c2) i) self) /\ (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model self) i) c \/ LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model self) i) c2) /\ not LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model c) m) self /\ not LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model c2) k) self /\ IsOpp0.is_opp (Seq.get (ShallowModel0.shallow_model c2) k) (Seq.get (ShallowModel0.shallow_model c) m)
  val resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int) : bool
    ensures { result = resolvent_of self c c2 k m }
    
end
module Scratch_Clause_Impl2_InFormula_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_InFormula_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_InFormula
  use prelude.Int
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/clause.rs" 119 8 122 9] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses f)) /\ Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses f)) i = self
  val in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = in_formula self f }
    
end
module Scratch_Clause_Impl2_InFormulaInner_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_Impl2_InFormulaInner_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_Impl2_InFormulaInner
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/clause.rs" 127 8 129 9] exists i : int . 0 <= i /\ i < Seq.length (let (a, _) = f in a) /\ Seq.get (let (a, _) = f in a) i = self
  val in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = in_formula_inner self f }
    
end
module Scratch_Clause_Impl2_VarsInRange_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
    
end
module Scratch_Clause_Impl2_VarsInRange_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
    
end
module Scratch_Clause_Impl2_VarsInRange
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_VarsInRangeInner_Stub as VarsInRangeInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
    
   =
    [#"../Scratch/src/clause.rs" 183 20 183 49] VarsInRangeInner0.vars_in_range_inner (ShallowModel0.shallow_model self) n
  val vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int) : bool
    ensures { result = vars_in_range self n }
    
end
module Scratch_Clause_Impl2_UnitInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnitInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnitInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsetInner_Stub as UnsetInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  clone Scratch_Clause_Impl2_VarsInRange_Stub as VarsInRange0
  predicate unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 134 8 141 9] VarsInRange0.vars_in_range self (Seq.length a) /\ not SatInner0.sat_inner self a /\ (exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) /\ UnsetInner0.unset_inner (Seq.get (ShallowModel0.shallow_model self) i) a /\ (forall j : int . 0 <= j /\ j < Seq.length (ShallowModel0.shallow_model self) /\ j <> i -> not UnsetInner0.unset_inner (Seq.get (ShallowModel0.shallow_model self) j) a))
  val unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = unit_inner self a }
    
end
module Scratch_Clause_Impl2_Unit_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unit_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_UnitInner_Stub as UnitInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 145 20 145 39] UnitInner0.unit_inner self (ShallowModel0.shallow_model a)
  val unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unit self a }
    
end
module Scratch_Clause_Impl2_UnsatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnsatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnsatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsatInner_Stub as UnsatInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 150 8 153 9] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> UnsatInner0.unsat_inner (Seq.get (ShallowModel0.shallow_model self) i) a
  val unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = unsat_inner self a }
    
end
module Scratch_Clause_Impl2_Unsat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unsat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unsat
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_UnsatInner_Stub as UnsatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 158 20 158 40] UnsatInner0.unsat_inner self (ShallowModel0.shallow_model a)
  val unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unsat self a }
    
end
module Scratch_Clause_Impl2_Sat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Sat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Sat
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 172 12 172 30] SatInner0.sat_inner self (ShallowModel0.shallow_model a)
  val sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = sat self a }
    
end
module Scratch_Clause_Impl2_Unknown_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unknown_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unknown
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  predicate unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 178 8 178 38] not Sat0.sat self a /\ not Unsat0.unsat self a
  val unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unknown self a }
    
end
module Scratch_Clause_Impl2_NoDuplicateIndexes_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_NoDuplicateIndexes_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_NoDuplicateIndexes
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_NoDuplicateIndexesInner_Stub as NoDuplicateIndexesInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause)
   =
    [#"../Scratch/src/clause.rs" 188 20 188 53] NoDuplicateIndexesInner0.no_duplicate_indexes_inner (ShallowModel0.shallow_model self)
  val no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = no_duplicate_indexes self }
    
end
module Scratch_Clause_Impl2_SearchIdxInRange_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_SearchIdxInRange_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_SearchIdxInRange
  use prelude.UIntSize
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause)
   =
    [#"../Scratch/src/clause.rs" 193 20 193 68] 2 <= UIntSize.to_int (Scratch_Clause_Clause_Type.clause_search self) /\ UIntSize.to_int (Scratch_Clause_Clause_Type.clause_search self) <= Seq.length (ShallowModel0.shallow_model self)
  val search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = search_idx_in_range self }
    
end
module Scratch_Clause_Impl2_Invariant_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
end
module Scratch_Clause_Impl2_Invariant_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
end
module Scratch_Clause_Impl2_Invariant
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_InvariantInternal_Stub as InvariantInternal0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
   =
    [#"../Scratch/src/clause.rs" 198 20 198 48] InvariantInternal0.invariant_internal (ShallowModel0.shallow_model self) n
  val invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int) : bool
    ensures { result = invariant' self n }
    
end
module Scratch_Lit_IdxInLogic_Stub
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_IdxInLogic_Interface
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_IdxInLogic
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
   =
    [#"../Scratch/src/lit.rs" 40 4 43 5] exists i : int . 0 <= i /\ i < Seq.length c /\ IndexLogic0.index_logic (Seq.get c i) = idx
  val idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) : bool
    ensures { result = idx_in_logic idx c }
    
end
module Scratch_Clause_Impl2_ClauseIsSeen_Stub
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global))
    
end
module Scratch_Clause_Impl2_ClauseIsSeen_Interface
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global))
    
end
module Scratch_Clause_Impl2_ClauseIsSeen
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Lit_IdxInLogic_Stub as IdxInLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel1
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global))
    
   =
    [#"../Scratch/src/clause.rs" 203 8 206 9] forall idx : int . 0 <= idx /\ idx < Seq.length (ShallowModel0.shallow_model seen) -> Seq.get (ShallowModel0.shallow_model seen) idx = IdxInLogic0.idx_in_logic idx (ShallowModel1.shallow_model self)
  val clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = clause_is_seen self seen }
    
end
module Scratch_Clause_Impl2_Equals_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Clause_Impl2_Equals_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Clause_Impl2_Equals
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause)
    
   =
    [#"../Scratch/src/clause.rs" 211 8 215 9] Seq.length (ShallowModel0.shallow_model self) = Seq.length (ShallowModel0.shallow_model o) /\ (forall j : int . 0 <= j /\ j < Seq.length (ShallowModel0.shallow_model self) -> Seq.get (ShallowModel0.shallow_model self) j = Seq.get (ShallowModel0.shallow_model o) j)
  val equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = equals self o }
    
end
module Scratch_Formula_FormulaInvariant_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_FormulaInvariant_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_FormulaInvariant
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Invariant_Stub as Invariant0
  predicate formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/formula.rs" 26 4 29 5] forall i : int . 0 <= i /\ i < Seq.length (let (a, _) = f in a) -> Invariant0.invariant' (Seq.get (let (a, _) = f in a) i) (let (_, a) = f in a) /\ Seq.length (ShallowModel0.shallow_model (Seq.get (let (a, _) = f in a) i)) > 0
  val formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = formula_invariant f }
    
end
module Scratch_Formula_Equisat_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_Equisat_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_Equisat
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_EventuallySatComplete_Stub as EventuallySatComplete0
  predicate equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/formula.rs" 50 8 50 64] EventuallySatComplete0.eventually_sat_complete f = EventuallySatComplete0.eventually_sat_complete o
  val equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = equisat f o }
    
end
module Scratch_Formula_Impl1_SatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_SatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_SatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 108 8 111 9] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) -> SatInner0.sat_inner (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) i) a
  val sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = sat_inner self a }
    
end
module Scratch_Formula_Impl1_EventuallySatComplete_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_EventuallySatComplete_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_EventuallySatComplete
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use prelude.UIntSize
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner_Stub as SatInner0
  clone Scratch_Assignments_CompleteInner_Stub as CompleteInner0
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/formula.rs" 58 8 60 9] exists a2 : Seq.seq uint8 . Seq.length a2 = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self) /\ CompleteInner0.complete_inner a2 /\ SatInner0.sat_inner self a2
  val eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = eventually_sat_complete self }
    
end
module Scratch_Formula_Impl1_Equisat_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_Equisat_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_Equisat
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_EventuallySatComplete_Stub as EventuallySatComplete0
  predicate equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/formula.rs" 65 8 65 69] EventuallySatComplete0.eventually_sat_complete self = EventuallySatComplete0.eventually_sat_complete o
  val equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = equisat self o }
    
end
module Scratch_Formula_Impl1_InvariantMirror_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_InvariantMirror_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_InvariantMirror
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel1
  clone Scratch_Clause_Impl2_Invariant_Stub as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula) =
    [#"../Scratch/src/formula.rs" 78 12 82 45] (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) -> Invariant0.invariant' (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) i) (UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self))) /\ (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) -> Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) i)) >= 1)
  val invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = invariant_mirror self }
    
end
module Scratch_Formula_Impl1_Invariant_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_Invariant_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula)
  axiom invariant'_spec : forall self : Scratch_Formula_Formula_Type.t_formula . [#"../Scratch/src/formula.rs" 70 14 70 47] invariant' self = InvariantMirror0.invariant_mirror self
end
module Scratch_Formula_Impl1_Invariant
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_FormulaInvariant_Stub as FormulaInvariant0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula) =
    [#"../Scratch/src/formula.rs" 72 20 72 44] FormulaInvariant0.formula_invariant (ShallowModel0.shallow_model self)
  val invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = invariant' self }
    
  axiom invariant'_spec : forall self : Scratch_Formula_Formula_Type.t_formula . [#"../Scratch/src/formula.rs" 70 14 70 47] invariant' self = InvariantMirror0.invariant_mirror self
end
module Scratch_Formula_Impl1_Invariant_Impl
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl3_Invariant as Invariant1 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_VarsInRangeInner as VarsInRangeInner0 with
    predicate Invariant0.invariant' = Invariant1.invariant'
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel3 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Clause_InvariantInternal as InvariantInternal0 with
    predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
    predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel as ShallowModel2 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Formula_FormulaInvariant as FormulaInvariant0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_ShallowModel as ShallowModel0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Formula_Impl1_InvariantMirror as InvariantMirror0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec ghost predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula)
    ensures { [#"../Scratch/src/formula.rs" 70 14 70 47] result = InvariantMirror0.invariant_mirror self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/formula.rs" 72 20 72 44] let a' = ShallowModel0.shallow_model self in FormulaInvariant0.formula_invariant a'
end
module Scratch_Formula_Impl1_EventuallySatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use prelude.UIntSize
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner_Stub as SatInner0
  clone Scratch_Assignments_CompatibleInner_Stub as CompatibleInner0
  predicate eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 89 8 91 9] exists a2 : Seq.seq uint8 . Seq.length a2 = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self) /\ CompatibleInner0.compatible_inner a a2 /\ SatInner0.sat_inner self a2
  val eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = eventually_sat_inner self a }
    
end
module Scratch_Formula_Impl1_EventuallySatCompleteInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatCompleteInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatCompleteInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use prelude.UIntSize
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner_Stub as SatInner0
  clone Scratch_Assignments_CompatibleCompleteInner_Stub as CompatibleCompleteInner0
  predicate eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 96 8 98 9] exists a2 : Seq.seq uint8 . Seq.length a2 = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self) /\ CompatibleCompleteInner0.compatible_complete_inner a a2 /\ SatInner0.sat_inner self a2
  val eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = eventually_sat_complete_inner self a }
    
end
module Scratch_Formula_Impl1_EventuallySat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_EventuallySat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_EventuallySat
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_EventuallySatInner_Stub as EventuallySatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/formula.rs" 103 20 103 49] EventuallySatInner0.eventually_sat_inner self (ShallowModel0.shallow_model a)
  val eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = eventually_sat self a }
    
end
module Scratch_Formula_Impl1_Sat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Sat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Sat
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_FormulaSatInner_Stub as FormulaSatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel1
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_ShallowModel_Stub as ShallowModel0
  predicate sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/formula.rs" 116 20 116 48] FormulaSatInner0.formula_sat_inner (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model a)
  val sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = sat self a }
    
end
module Scratch_Formula_Impl1_UnsatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_UnsatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_UnsatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Clause_Impl2_UnsatInner_Stub as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 121 8 124 9] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) /\ UnsatInner0.unsat_inner (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) i) a
  val unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = unsat_inner self a }
    
end
module Scratch_Formula_Impl1_Unsat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Unsat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Unsat
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_UnsatInner_Stub as UnsatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/formula.rs" 129 20 129 40] UnsatInner0.unsat_inner self (ShallowModel0.shallow_model a)
  val unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unsat self a }
    
end
module Scratch_Formula_Impl1_NotSatisfiable_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_NotSatisfiable_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_NotSatisfiable
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_EquisatExtension_Stub as EquisatExtension0
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula)
   =
    [#"../Scratch/src/formula.rs" 134 8 134 82] exists c : Scratch_Clause_Clause_Type.t_clause . Seq.length (ShallowModel0.shallow_model c) = 0 /\ EquisatExtension0.equisat_extension c self
  val not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = not_satisfiable self }
    
end
module Scratch_Lit_Impl4_Clone_Interface
  use prelude.Borrow
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  val clone' [#"../Scratch/src/lit.rs" 10 9 10 14] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { [#"../Scratch/src/lit.rs" 10 9 10 14] result = self }
    
end
module Scratch_Lit_Impl4_Clone
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  clone Core_Clone_Impls_Impl19_Clone_Interface as Clone1
  clone Core_Clone_Impls_Impl5_Clone_Interface as Clone0
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  let rec cfg clone' [#"../Scratch/src/lit.rs" 10 9 10 14] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { [#"../Scratch/src/lit.rs" 10 9 10 14] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Lit_Lit_Type.t_lit;
  var self_1 : Scratch_Lit_Lit_Type.t_lit;
  var _3 : usize;
  var _4 : usize;
  var _5 : bool;
  var _6 : bool;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- Scratch_Lit_Lit_Type.lit_idx self_1;
    _3 <- ([#"../Scratch/src/lit.rs" 12 4 12 18] Clone0.clone' _4);
    goto BB1
  }
  BB1 {
    _6 <- Scratch_Lit_Lit_Type.lit_polarity self_1;
    _5 <- ([#"../Scratch/src/lit.rs" 13 4 13 22] Clone1.clone' _6);
    goto BB2
  }
  BB2 {
    _0 <- Scratch_Lit_Lit_Type.C_Lit _3 _5;
    return _0
  }
  
end
module Scratch_Lit_Impl0_ShallowModel_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function shallow_model [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl0_ShallowModel_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function shallow_model [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl0_ShallowModel
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function shallow_model [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
   =
    [#"../Scratch/src/lit.rs" 22 8 22 12] self
  val shallow_model [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { result = shallow_model self }
    
end
module Scratch_Lit_Impl1_DeepModel_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl1_DeepModel_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl1_DeepModel
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
   =
    [#"../Scratch/src/lit.rs" 32 8 32 12] self
  val deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { result = deep_model self }
    
end
module Scratch_Lit_Impl2_ToWatchidxLogic_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToWatchidxLogic_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToWatchidxLogic
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  function to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
   =
    [#"../Scratch/src/lit.rs" 63 8 63 91] IndexLogic0.index_logic self * 2 + (if IsPositiveLogic0.is_positive_logic self then
      0
    else
      1
    )
  val to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    ensures { result = to_watchidx_logic self }
    
end
module Scratch_Lit_Impl2_ToNegWatchidxLogic_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToNegWatchidxLogic_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToNegWatchidxLogic
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  function to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
   =
    [#"../Scratch/src/lit.rs" 69 8 69 91] IndexLogic0.index_logic self * 2 + (if IsPositiveLogic0.is_positive_logic self then
      1
    else
      0
    )
  val to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    ensures { result = to_neg_watchidx_logic self }
    
end
module Scratch_Lit_Impl3_LitInInternal_Stub
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_Impl3_LitInInternal_Interface
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_Impl3_LitInInternal
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
   =
    [#"../Scratch/src/lit.rs" 84 8 84 74] exists i : int . 0 <= i /\ i < Seq.length c /\ Seq.get c i = self
  val lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) : bool
    ensures { result = lit_in_internal self c }
    
end
module Scratch_Lit_Impl3_LitIdxIn_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIdxIn_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIdxIn
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
   =
    [#"../Scratch/src/lit.rs" 94 8 97 9] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model c) /\ IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model c) i) = IndexLogic0.index_logic self
  val lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = lit_idx_in self c }
    
end
module Scratch_Lit_Impl3_Sat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Sat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Sat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/lit.rs" 132 20 132 38] SatInner0.sat_inner self (ShallowModel0.shallow_model a)
  val sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = sat self a }
    
end
module Scratch_Lit_Impl3_Unset_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unset_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unset
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsetInner_Stub as UnsetInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/lit.rs" 137 20 137 40] UnsetInner0.unset_inner self (ShallowModel0.shallow_model a)
  val unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unset self a }
    
end
module Scratch_Lit_Impl3_Unsat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unsat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unsat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsatInner_Stub as UnsatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/lit.rs" 142 20 142 40] UnsatInner0.unsat_inner self (ShallowModel0.shallow_model a)
  val unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unsat self a }
    
end
module CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub
  type t
  use seq.Seq
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t)
end
module CreusotContracts_Logic_Seq_Impl0_PermutationOf_Interface
  type t
  use seq.Seq
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t)
end
module CreusotContracts_Logic_Seq_Impl0_PermutationOf
  type t
  use seq.Seq
  use seq.Permut
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t) =
    Permut.permut self o 0 (Seq.length self)
  val permutation_of (self : Seq.seq t) (o : Seq.seq t) : bool
    ensures { result = permutation_of self o }
    
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
  axiom lemma_clause_permuted_maintains_sat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a) -> ([#"../Scratch/src/scratch.rs" 25 0 25 67] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Sat0.sat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
   =
    [#"../Scratch/src/scratch.rs" 23 0 23 8] ()
  val lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a}
    ensures { result = lemma_clause_permuted_maintains_sat c a }
    
  axiom lemma_clause_permuted_maintains_sat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a) -> ([#"../Scratch/src/scratch.rs" 25 0 25 67] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Sat0.sat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat_Impl
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic as IsPositiveLogic0
  clone Scratch_Lit_Impl3_SatInner as SatInner1 with
    function IsPositiveLogic0.is_positive_logic = IsPositiveLogic0.is_positive_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel3 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel2 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel as ShallowModel0 with
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_SatInner as SatInner0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate SatInner0.sat_inner = SatInner1.sat_inner
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel as ShallowModel1 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  clone Scratch_Clause_Impl2_Sat as Sat0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate SatInner0.sat_inner = SatInner0.sat_inner
  let rec ghost function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a}
    ensures { [#"../Scratch/src/scratch.rs" 25 0 25 67] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Sat0.sat c2 a }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/scratch.rs" 23 0 23 8] ()
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
  axiom lemma_clause_permuted_maintains_unsat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a) -> ([#"../Scratch/src/scratch.rs" 30 0 30 69] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Unsat0.unsat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
   =
    [#"../Scratch/src/scratch.rs" 28 0 28 8] ()
  val lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a}
    ensures { result = lemma_clause_permuted_maintains_unsat c a }
    
  axiom lemma_clause_permuted_maintains_unsat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a) -> ([#"../Scratch/src/scratch.rs" 30 0 30 69] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Unsat0.unsat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat_Impl
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic as IsPositiveLogic0
  clone Scratch_Lit_Impl3_UnsatInner as UnsatInner1 with
    function IsPositiveLogic0.is_positive_logic = IsPositiveLogic0.is_positive_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel3 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel2 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel as ShallowModel0 with
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_UnsatInner as UnsatInner0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel as ShallowModel1 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  clone Scratch_Clause_Impl2_Unsat as Unsat0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  let rec ghost function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a}
    ensures { [#"../Scratch/src/scratch.rs" 30 0 30 69] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Unsat0.unsat c2 a }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/scratch.rs" 28 0 28 8] ()
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
     ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl3_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Alloc_Vec_Impl14_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub as ResolveElswhere0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { HasValue0.has_value index (ShallowModel0.shallow_model self) ( * result) }
    ensures { HasValue0.has_value index (ShallowModel1.shallow_model ( ^ self)) ( ^ result) }
    ensures { ResolveElswhere0.resolve_elswhere index (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model ( ^ self)) }
    ensures { Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) }
    
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : slice t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : slice t) : Seq.seq t
  axiom shallow_model_spec : forall self : slice t . shallow_model self = Slice.id self && Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX'
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : slice t) : Seq.seq t
  val shallow_model (self : slice t) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : slice t . shallow_model self = Slice.id self && Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX'
end
module Alloc_Vec_Impl10_DerefMut_Interface
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel3 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel2 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val deref_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) : borrowed (slice t)
    ensures { ShallowModel0.shallow_model result = ShallowModel1.shallow_model self }
    ensures { ShallowModel2.shallow_model ( ^ result) = ShallowModel3.shallow_model ( ^ self) }
    
end
module Core_Slice_Impl0_Swap_Interface
  type t
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use seq.Permut
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val swap (self : borrowed (slice t)) (a : usize) (b : usize) : ()
    requires {UIntSize.to_int a < Seq.length (ShallowModel0.shallow_model self)}
    requires {UIntSize.to_int b < Seq.length (ShallowModel0.shallow_model self)}
    ensures { Permut.exchange (ShallowModel1.shallow_model ( ^ self)) (ShallowModel0.shallow_model self) (UIntSize.to_int a) (UIntSize.to_int b) }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    UIntSize.to_int self < Seq.length seq
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    Seq.get seq (UIntSize.to_int self) = out
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Scratch_Scratch_Swap_Interface
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use seq.Permut
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Formula_Impl1_Equisat_Stub as Equisat0
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel2
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel1
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Formula_Impl1_Invariant_Stub as Invariant0 with
    predicate InvariantMirror0.invariant_mirror = InvariantMirror0.invariant_mirror,
    axiom .
  val swap [#"../Scratch/src/scratch.rs" 43 0 43 83] (f : borrowed (Scratch_Formula_Formula_Type.t_formula)) (cref : usize) (j : usize) (k : usize) (assignments : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( * f)}
    requires {[#"../Scratch/src/scratch.rs" 34 11 34 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) >= 2}
    requires {[#"../Scratch/src/scratch.rs" 35 11 35 35] UIntSize.to_int cref < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f)))}
    requires {[#"../Scratch/src/scratch.rs" 36 11 36 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int j}
    requires {[#"../Scratch/src/scratch.rs" 37 11 37 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int k}
    requires {[#"../Scratch/src/scratch.rs" 38 0 38 59] not SatInner0.sat_inner (Seq.get (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) 0) (ShallowModel2.shallow_model assignments)}
    ensures { [#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( ^ f) }
    ensures { [#"../Scratch/src/scratch.rs" 39 0 39 72] Permut.exchange (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) (UIntSize.to_int cref))) (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) (UIntSize.to_int j) (UIntSize.to_int k) }
    ensures { [#"../Scratch/src/scratch.rs" 40 10 40 39] UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( * f)) = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( ^ f)) }
    ensures { [#"../Scratch/src/scratch.rs" 41 10 41 49] Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) = Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) }
    ensures { [#"../Scratch/src/scratch.rs" 42 10 42 23] Equisat0.equisat ( * f) ( ^ f) }
    
end
module Scratch_Scratch_Swap
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use prelude.Slice
  use seq.Seq
  use seq.Permut
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl3_Invariant as Invariant2 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_VarsInRangeInner as VarsInRangeInner0 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone Scratch_Lit_Impl2_IsPositiveLogic as IsPositiveLogic0
  clone Scratch_Lit_Impl3_SatInner as SatInner0 with
    function IsPositiveLogic0.is_positive_logic = IsPositiveLogic0.is_positive_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel4 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel as ShallowModel1 with
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_SatInner as SatInner2 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Scratch_Logic_Unset as Unset0
  clone Scratch_Clause_InvariantInternal as InvariantInternal0 with
    predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
    predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner as SatInner1 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate SatInner0.sat_inner = SatInner2.sat_inner,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Assignments_CompleteInner as CompleteInner0 with
    predicate Unset0.unset = Unset0.unset
  clone Scratch_Clause_Impl2_Invariant as Invariant1 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel9 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel8 with
    type t = Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (Scratch_Lit_Lit_Type.t_lit),
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel7 with
    type t = slice (Scratch_Lit_Lit_Type.t_lit),
    type ShallowModelTy0.shallowModelTy = Seq.seq (Scratch_Lit_Lit_Type.t_lit),
    function ShallowModel0.shallow_model = ShallowModel9.shallow_model
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel6 with
    type t = Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (Scratch_Clause_Clause_Type.t_clause),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Scratch_Formula_Impl1_EventuallySatComplete as EventuallySatComplete0 with
    predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
    predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel5 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Formula_FormulaInvariant as FormulaInvariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Scratch_Formula_Impl0_ShallowModel as ShallowModel3 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Formula_Impl1_InvariantMirror as InvariantMirror0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Invariant0.invariant' = Invariant1.invariant',
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Core_Slice_Impl0_Swap_Interface as Swap0 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel9.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = slice (Scratch_Lit_Lit_Type.t_lit)
  clone Alloc_Vec_Impl10_DerefMut_Interface as DerefMut0 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel8.shallow_model,
    function ShallowModel2.shallow_model = ShallowModel9.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    type Output0.output = Scratch_Clause_Clause_Type.t_clause,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Formula_Formula_Type.t_formula
  clone Scratch_Formula_Impl1_Equisat as Equisat0 with
    predicate EventuallySatComplete0.eventually_sat_complete = EventuallySatComplete0.eventually_sat_complete
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel as ShallowModel2 with
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Formula_Impl1_Invariant as Invariant0 with
    predicate InvariantMirror0.invariant_mirror = InvariantMirror0.invariant_mirror,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
    axiom .
  let rec cfg swap [#"../Scratch/src/scratch.rs" 43 0 43 83] [@cfg:stackify] [@cfg:subregion_analysis] (f : borrowed (Scratch_Formula_Formula_Type.t_formula)) (cref : usize) (j : usize) (k : usize) (assignments : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( * f)}
    requires {[#"../Scratch/src/scratch.rs" 34 11 34 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) >= 2}
    requires {[#"../Scratch/src/scratch.rs" 35 11 35 35] UIntSize.to_int cref < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f)))}
    requires {[#"../Scratch/src/scratch.rs" 36 11 36 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int j}
    requires {[#"../Scratch/src/scratch.rs" 37 11 37 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int k}
    requires {[#"../Scratch/src/scratch.rs" 38 0 38 59] not SatInner0.sat_inner (Seq.get (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) 0) (ShallowModel2.shallow_model assignments)}
    ensures { [#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( ^ f) }
    ensures { [#"../Scratch/src/scratch.rs" 39 0 39 72] Permut.exchange (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) (UIntSize.to_int cref))) (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) (UIntSize.to_int j) (UIntSize.to_int k) }
    ensures { [#"../Scratch/src/scratch.rs" 40 10 40 39] UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( * f)) = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( ^ f)) }
    ensures { [#"../Scratch/src/scratch.rs" 41 10 41 49] Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) = Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) }
    ensures { [#"../Scratch/src/scratch.rs" 42 10 42 23] Equisat0.equisat ( * f) ( ^ f) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var f_1 : borrowed (Scratch_Formula_Formula_Type.t_formula);
  var cref_2 : usize;
  var j_3 : usize;
  var k_4 : usize;
  var assignments_5 : Scratch_Assignments_Assignments_Type.t_assignments;
  var old_f_17 : Ghost.ghost_ty (borrowed (Scratch_Formula_Formula_Type.t_formula));
  var _19 : ();
  var _20 : ();
  var _21 : borrowed (slice (Scratch_Lit_Lit_Type.t_lit));
  var _22 : borrowed (slice (Scratch_Lit_Lit_Type.t_lit));
  var _23 : borrowed (Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global));
  var _24 : borrowed (Scratch_Clause_Clause_Type.t_clause);
  var _25 : borrowed (Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global));
  var _26 : usize;
  var _27 : usize;
  var _28 : usize;
  var _29 : ();
  {
    f_1 <- f;
    cref_2 <- cref;
    j_3 <- j;
    k_4 <- k;
    assignments_5 <- assignments;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    _19 <- ();
    old_f_17 <- ([#"../Scratch/src/scratch.rs" 44 37 44 49] Ghost.new f_1);
    goto BB2
  }
  BB2 {
    _25 <- borrow_mut (Scratch_Formula_Formula_Type.formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Scratch_Formula_Formula_Type.C_Formula a b =  * f_1 in Scratch_Formula_Formula_Type.C_Formula ( ^ _25) b) };
    assume { Resolve0.resolve f_1 };
    _26 <- cref_2;
    _24 <- ([#"../Scratch/src/scratch.rs" 46 4 46 19] IndexMut0.index_mut _25 _26);
    goto BB3
  }
  BB3 {
    _23 <- borrow_mut (Scratch_Clause_Clause_Type.clause_lits ( * _24));
    _24 <- { _24 with current = (let Scratch_Clause_Clause_Type.C_Clause a b c d =  * _24 in Scratch_Clause_Clause_Type.C_Clause a b c ( ^ _23)) };
    assume { Resolve1.resolve _24 };
    _22 <- ([#"../Scratch/src/scratch.rs" 46 4 46 35] DerefMut0.deref_mut _23);
    goto BB4
  }
  BB4 {
    _21 <- borrow_mut ( * _22);
    _22 <- { _22 with current = ( ^ _21) };
    assume { Resolve2.resolve _22 };
    _27 <- j_3;
    _28 <- k_4;
    _20 <- ([#"../Scratch/src/scratch.rs" 46 4 46 35] Swap0.swap _21 _27 _28);
    goto BB5
  }
  BB5 {
    assert { [#"../Scratch/src/scratch.rs" 48 18 48 38]  ^ f_1 =  ^ Ghost.inner old_f_17 };
    _29 <- ();
    _0 <- ();
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Scratch_Restart_Ema_Type
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  type t_ema  =
    | C_EMA Float64.t Float64.t Float64.t usize usize
    
  let function ema_wait (self : t_ema) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_EMA _ _ _ a _ -> a
      end
  let function ema_period (self : t_ema) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_EMA _ _ _ _ a -> a
      end
  let function ema_beta (self : t_ema) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_EMA _ _ a _ _ -> a
      end
  let function ema_value (self : t_ema) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_EMA a _ _ _ _ -> a
      end
  let function ema_alpha (self : t_ema) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_EMA _ a _ _ _ -> a
      end
end
module Scratch_Restart_Impl0_Invariant_Stub
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 22 4 22 30] (self : Scratch_Restart_Ema_Type.t_ema)
    
end
module Scratch_Restart_Impl0_Invariant_Interface
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 22 4 22 30] (self : Scratch_Restart_Ema_Type.t_ema)
    
end
module Scratch_Restart_Impl0_Invariant
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 22 4 22 30] (self : Scratch_Restart_Ema_Type.t_ema)
    
   =
    [#"../Scratch/src/restart.rs" 24 12 25 35] Scratch_Restart_Ema_Type.ema_wait self > (0 : usize) /\ Scratch_Restart_Ema_Type.ema_period self > (0 : usize)
  val invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 22 4 22 30] (self : Scratch_Restart_Ema_Type.t_ema) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Invariant_Invariant_Stub
  type self
  predicate invariant' (self : self)
end
module CreusotContracts_Invariant_Invariant_Invariant_Interface
  type self
  predicate invariant' (self : self)
end
module CreusotContracts_Invariant_Invariant_Invariant
  type self
  predicate invariant' (self : self) =
    true
  val invariant' (self : self) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Impl1_Invariant_Stub
  type t
  use prelude.Borrow
  predicate invariant' (self : borrowed t)
end
module CreusotContracts_Invariant_Impl1_Invariant_Interface
  type t
  use prelude.Borrow
  predicate invariant' (self : borrowed t)
end
module CreusotContracts_Invariant_Impl1_Invariant
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = t
  predicate invariant' (self : borrowed t) =
    Invariant0.invariant' ( * self)
  val invariant' (self : borrowed t) : bool
    ensures { result = invariant' self }
    
end
module Scratch_Restart_Impl1_Update_Interface
  use prelude.Borrow
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Ema_Type.t_ema
  val update [#"../Scratch/src/restart.rs" 31 4 31 35] (self : borrowed (Scratch_Restart_Ema_Type.t_ema)) (next : Float64.t) : ()
    requires {[#"../Scratch/src/restart.rs" 31 19 31 23] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 31 19 31 23] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl1_Update
  use prelude.Borrow
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float32
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Ema_Type.t_ema
  clone Scratch_Restart_Impl0_Invariant as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Ema_Type.t_ema,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg update [#"../Scratch/src/restart.rs" 31 4 31 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Ema_Type.t_ema)) (next : Float64.t) : ()
    requires {[#"../Scratch/src/restart.rs" 31 19 31 23] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 31 19 31 23] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Restart_Ema_Type.t_ema);
  var next_2 : Float64.t;
  var _3 : Float64.t;
  var _4 : Float64.t;
  var _5 : Float64.t;
  var _6 : Float64.t;
  var _7 : Float64.t;
  var _8 : bool;
  var _9 : Float64.t;
  var _10 : Float64.t;
  var _11 : bool;
  var _12 : usize;
  var _13 : ();
  var _14 : bool;
  var _15 : usize;
  var _16 : usize;
  var _17 : bool;
  var _18 : usize;
  var _19 : bool;
  var _20 : Float64.t;
  var _21 : Float64.t;
  var _22 : Float64.t;
  {
    self_1 <- self;
    next_2 <- next;
    goto BB0
  }
  BB0 {
    _4 <- Scratch_Restart_Ema_Type.ema_beta ( * self_1);
    _6 <- next_2;
    _7 <- Scratch_Restart_Ema_Type.ema_value ( * self_1);
    _5 <- ([#"../Scratch/src/restart.rs" 32 34 32 53] _6 .- _7);
    _3 <- ([#"../Scratch/src/restart.rs" 32 22 32 53] _4 .* _5);
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA ([#"../Scratch/src/restart.rs" 32 8 32 53] Scratch_Restart_Ema_Type.ema_value ( * self_1) .+ _3) b c d e) };
    _9 <- Scratch_Restart_Ema_Type.ema_beta ( * self_1);
    _10 <- Scratch_Restart_Ema_Type.ema_alpha ( * self_1);
    _8 <- ([#"../Scratch/src/restart.rs" 34 11 34 33] _9 .> _10);
    switch (_8)
      | False -> goto BB12
      | True -> goto BB1
      end
  }
  BB1 {
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA a b c ([#"../Scratch/src/restart.rs" 35 12 35 26] Scratch_Restart_Ema_Type.ema_wait ( * self_1) - ([#"../Scratch/src/restart.rs" 35 25 35 26] (1 : usize))) e) };
    _12 <- Scratch_Restart_Ema_Type.ema_wait ( * self_1);
    _11 <- ([#"../Scratch/src/restart.rs" 36 15 36 29] _12 = ([#"../Scratch/src/restart.rs" 36 28 36 29] (0 : usize)));
    switch (_11)
      | False -> goto BB10
      | True -> goto BB2
      end
  }
  BB2 {
    _15 <- Scratch_Restart_Ema_Type.ema_period ( * self_1);
    _17 <- ([#"../Scratch/src/restart.rs" 37 33 37 47] ([#"../Scratch/src/restart.rs" 37 46 37 47] (2 : usize)) = ([#"../Scratch/src/restart.rs" 37 33 37 47] (0 : usize)));
    assert { [#"../Scratch/src/restart.rs" 37 33 37 47] not _17 };
    goto BB3
  }
  BB3 {
    _16 <- ([#"../Scratch/src/restart.rs" 37 33 37 47] ([#"../Scratch/src/restart.rs" 37 33 37 43] (18446744073709551615 : usize)) / ([#"../Scratch/src/restart.rs" 37 46 37 47] (2 : usize)));
    _14 <- ([#"../Scratch/src/restart.rs" 37 19 37 47] _15 < _16);
    switch (_14)
      | False -> goto BB5
      | True -> goto BB4
      end
  }
  BB4 {
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA a b c d ([#"../Scratch/src/restart.rs" 38 20 38 36] Scratch_Restart_Ema_Type.ema_period ( * self_1) * ([#"../Scratch/src/restart.rs" 38 35 38 36] (2 : usize)))) };
    _13 <- ();
    goto BB6
  }
  BB5 {
    _13 <- ();
    goto BB6
  }
  BB6 {
    _18 <- Scratch_Restart_Ema_Type.ema_period ( * self_1);
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA a b c _18 e) };
    _18 <- any usize;
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA a b ([#"../Scratch/src/restart.rs" 41 16 41 32] Scratch_Restart_Ema_Type.ema_beta ( * self_1) .* ([#"../Scratch/src/restart.rs" 41 29 41 32] 0.5000000000000000000000000000000000000000000000000000000000000000)) d e) };
    _20 <- Scratch_Restart_Ema_Type.ema_beta ( * self_1);
    _21 <- Scratch_Restart_Ema_Type.ema_alpha ( * self_1);
    _19 <- ([#"../Scratch/src/restart.rs" 42 19 42 41] _20 .< _21);
    switch (_19)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    _22 <- Scratch_Restart_Ema_Type.ema_alpha ( * self_1);
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA a b _22 d e) };
    _22 <- any Float64.t;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB9
  }
  BB8 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB9
  }
  BB9 {
    goto BB11
  }
  BB10 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB11
  }
  BB11 {
    goto BB13
  }
  BB12 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module Scratch_Restart_Impl1_New_Interface
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant_Stub as Invariant0
  val new [#"../Scratch/src/restart.rs" 49 4 49 30] (alpha : Float64.t) : Scratch_Restart_Ema_Type.t_ema
    ensures { [#"../Scratch/src/restart.rs" 49 26 49 30] Invariant0.invariant' result }
    
end
module Scratch_Restart_Impl1_New
  use prelude.Float64
  use prelude.Float32
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant0
  let rec cfg new [#"../Scratch/src/restart.rs" 49 4 49 30] [@cfg:stackify] [@cfg:subregion_analysis] (alpha : Float64.t) : Scratch_Restart_Ema_Type.t_ema
    ensures { [#"../Scratch/src/restart.rs" 49 26 49 30] Invariant0.invariant' result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Restart_Ema_Type.t_ema;
  var alpha_1 : Float64.t;
  var _2 : Float64.t;
  {
    alpha_1 <- alpha;
    goto BB0
  }
  BB0 {
    _2 <- alpha_1;
    _0 <- Scratch_Restart_Ema_Type.C_EMA ([#"../Scratch/src/restart.rs" 50 21 50 24] 1.0000000000000000000000000000000000000000000000000000000000000000) _2 ([#"../Scratch/src/restart.rs" 50 39 50 42] 1.0000000000000000000000000000000000000000000000000000000000000000) ([#"../Scratch/src/restart.rs" 50 50 50 51] (1 : usize)) ([#"../Scratch/src/restart.rs" 50 61 50 62] (1 : usize));
    return _0
  }
  
end
module Scratch_Restart_Glucose_Type
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  type t_glucose  =
    | C_Glucose usize usize (Scratch_Restart_Ema_Type.t_ema) (Scratch_Restart_Ema_Type.t_ema) (Scratch_Restart_Ema_Type.t_ema) usize Float64.t Float64.t usize usize
    
  let function glucose_ema_lbd_narrow (self : t_glucose) : Scratch_Restart_Ema_Type.t_ema
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ a _ _ _ _ _ _ _ -> a
      end
  let function glucose_ema_lbd_wide (self : t_glucose) : Scratch_Restart_Ema_Type.t_ema
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ a _ _ _ _ _ _ -> a
      end
  let function glucose_ema_trail_wide (self : t_glucose) : Scratch_Restart_Ema_Type.t_ema
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ a _ _ _ _ _ -> a
      end
  let function glucose_minimum_conflicts (self : t_glucose) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose a _ _ _ _ _ _ _ _ _ -> a
      end
  let function glucose_force (self : t_glucose) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ _ _ a _ _ _ -> a
      end
  let function glucose_num_restarts (self : t_glucose) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ _ _ _ _ a _ -> a
      end
  let function glucose_last_trail_size (self : t_glucose) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ _ a _ _ _ _ -> a
      end
  let function glucose_block (self : t_glucose) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ _ _ _ a _ _ -> a
      end
  let function glucose_minimum_conflicts_for_blocking_restarts (self : t_glucose) : usize
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ a _ _ _ _ _ _ _ _ -> a
      end
  let function glucose_num_blocked (self : t_glucose) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ _ _ _ _ _ a -> a
      end
end
module Scratch_Restart_Impl2_Invariant_Stub
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 69 4 69 30] (self : Scratch_Restart_Glucose_Type.t_glucose)
    
end
module Scratch_Restart_Impl2_Invariant_Interface
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 69 4 69 30] (self : Scratch_Restart_Glucose_Type.t_glucose)
    
end
module Scratch_Restart_Impl2_Invariant
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant_Stub as Invariant0
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 69 4 69 30] (self : Scratch_Restart_Glucose_Type.t_glucose)
    
   =
    [#"../Scratch/src/restart.rs" 68 4 68 16] Invariant0.invariant' (Scratch_Restart_Glucose_Type.glucose_ema_lbd_narrow self) /\ Invariant0.invariant' (Scratch_Restart_Glucose_Type.glucose_ema_lbd_wide self) /\ Invariant0.invariant' (Scratch_Restart_Glucose_Type.glucose_ema_trail_wide self)
  val invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 69 4 69 30] (self : Scratch_Restart_Glucose_Type.t_glucose) : bool
    ensures { result = invariant' self }
    
end
module Core_Ops_Range_Range_Type
  type t_range 'idx =
    | C_Range 'idx 'idx
    
  let function range_start (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range a _ -> a
      end
  let function range_end (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range _ a -> a
      end
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Stub
  type self
  predicate into_iter_pre (self : self)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Interface
  type self
  predicate into_iter_pre (self : self)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre
  type self
  predicate into_iter_pre (self : self) =
    true
  val into_iter_pre (self : self) : bool
    ensures { result = into_iter_pre self }
    
end
module Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type
  type self
  type intoIter
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Stub
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Interface
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
  val into_iter_post (self : self) (res : IntoIter0.intoIter) : bool
    ensures { result = into_iter_post self res }
    
end
module Core_Iter_Traits_Collect_Impl0_IntoIter_Interface
  type i
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Stub as IntoIterPost0 with
    type self = i,
    type IntoIter0.intoIter = i
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = i
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Stub as IntoIterPre0 with
    type self = i
  val into_iter (self : i) : i
    requires {IntoIterPre0.into_iter_pre self}
    requires {Invariant0.invariant' self}
    ensures { IntoIterPost0.into_iter_post self result }
    ensures { Invariant0.invariant' result }
    
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Stub
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Interface
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
end
module CreusotContracts_Std1_Iter_Iterator_Completed
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
  val completed (self : borrowed self) : bool
    ensures { result = completed self }
    
end
module Core_Iter_Traits_Iterator_Iterator_Item_Type
  type self
  type item
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Stub
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Interface
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
end
module CreusotContracts_Std1_Iter_Iterator_Produces
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
  val produces (self : self) (visited : Seq.seq Item0.item) (_o : self) : bool
    ensures { result = produces self visited _o }
    
end
module Core_Iter_Range_Impl3_Next_Interface
  type a
  use prelude.Borrow
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces0 with
    type self = Core_Ops_Range_Range_Type.t_range a,
    type Item0.item = a
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Stub as Completed0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  val next (self : borrowed (Core_Ops_Range_Range_Type.t_range a)) : Core_Option_Option_Type.t_option a
    ensures { match (result) with
      | Core_Option_Option_Type.C_None -> Completed0.completed self
      | Core_Option_Option_Type.C_Some v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self)
      end }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre_Stub
  type i
  predicate into_iter_pre (self : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre_Interface
  type i
  predicate into_iter_pre (self : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre
  type i
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = i
  predicate into_iter_pre (self : i) =
    Invariant0.invariant' self
  val into_iter_pre (self : i) : bool
    ensures { result = into_iter_pre self }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost_Stub
  type i
  predicate into_iter_post (self : i) (res : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost_Interface
  type i
  predicate into_iter_post (self : i) (res : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost
  type i
  predicate into_iter_post (self : i) (res : i) =
    self = res
  val into_iter_post (self : i) (res : i) : bool
    ensures { result = into_iter_post self res }
    
end
module CreusotContracts_Model_DeepModel_DeepModelTy_Type
  type self
  type deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Stub
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Interface
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
  val deep_model (self : self) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed_Stub
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx))
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed_Interface
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx))
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed
  type idx
  use prelude.Borrow
  use prelude.Int
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = idx,
    type DeepModelTy0.deepModelTy = int
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) =
    Resolve0.resolve self /\ DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start ( * self)) >= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_end ( * self))
  val completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) : bool
    ensures { result = completed self }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces
  type idx
  use seq.Seq
  use prelude.Int
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = idx,
    type DeepModelTy0.deepModelTy = int
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
   =
    Core_Ops_Range_Range_Type.range_end self = Core_Ops_Range_Range_Type.range_end o /\ DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) <= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) /\ (Seq.length visited > 0 -> DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) <= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_end o)) /\ Seq.length visited = DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) - DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) /\ (forall i : int . 0 <= i /\ i < Seq.length visited -> DeepModel0.deep_model (Seq.get visited i) = DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) + i)
  val produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx) : bool
    ensures { result = produces self visited o }
    
end
module CreusotContracts_Invariant_Invariant_IsInhabited_Stub
  type self
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = self
  function is_inhabited (_1' : ()) : bool
end
module CreusotContracts_Invariant_Invariant_IsInhabited_Interface
  type self
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = self
  function is_inhabited (_1' : ()) : bool
  axiom is_inhabited_spec : forall _1' : () . is_inhabited _1' && (exists x : self . Invariant0.invariant' x /\ Invariant0.invariant' x)
end
module CreusotContracts_Invariant_Invariant_IsInhabited
  type self
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = self
  function is_inhabited (_1' : ()) : bool =
    true
  val is_inhabited (_1' : ()) : bool
    ensures { result = is_inhabited _1' }
    
  axiom is_inhabited_spec : forall _1' : () . is_inhabited _1' && (exists x : self . Invariant0.invariant' x /\ Invariant0.invariant' x)
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
  axiom produces_refl_spec : forall a : Core_Ops_Range_Range_Type.t_range idx . Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : () =
    ()
  val produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
    ensures { result = produces_refl a }
    
  axiom produces_refl_spec : forall a : Core_Ops_Range_Range_Type.t_range idx . Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
  axiom produces_trans_spec : forall a : Core_Ops_Range_Range_Type.t_range idx, ab : Seq.seq idx, b : Core_Ops_Range_Range_Type.t_range idx, bc : Seq.seq idx, c : Core_Ops_Range_Range_Type.t_range idx . Produces0.produces a ab b -> Produces0.produces b bc c -> Produces0.produces a (Seq.(++) ab bc) c
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
   =
    ()
  val produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {Produces0.produces a ab b}
    requires {Produces0.produces b bc c}
    ensures { result = produces_trans a ab b bc c }
    
  axiom produces_trans_spec : forall a : Core_Ops_Range_Range_Type.t_range idx, ab : Seq.seq idx, b : Core_Ops_Range_Range_Type.t_range idx, bc : Seq.seq idx, c : Core_Ops_Range_Range_Type.t_range idx . Produces0.produces a ab b -> Produces0.produces b bc c -> Produces0.produces a (Seq.(++) ab bc) c
end
module CreusotContracts_Std1_Num_Impl16_DeepModel_Stub
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int
end
module CreusotContracts_Std1_Num_Impl16_DeepModel_Interface
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int
end
module CreusotContracts_Std1_Num_Impl16_DeepModel
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int =
    UIntSize.to_int self
  val deep_model (self : usize) : int
    ensures { result = deep_model self }
    
end
module Scratch_Restart_DivFloatWithTenNTimes_Interface
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  val div_float_with_ten_n_times [#"../Scratch/src/restart.rs" 76 0 76 58] (f : Float64.t) (n : usize) : Float64.t
end
module Scratch_Restart_DivFloatWithTenNTimes
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.IntSize
  use prelude.Float32
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl16_DeepModel as DeepModel0
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces as Produces0 with
    type idx = usize,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans as ProducesTrans0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl as ProducesRefl0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Invariant_Invariant_Invariant as Invariant0 with
    type self = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Invariant_Invariant_IsInhabited as IsInhabited0 with
    type self = Core_Ops_Range_Range_Type.t_range usize,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Completed as Completed0 with
    type idx = usize,
    predicate Resolve0.resolve = Resolve0.resolve,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate Invariant0.invariant' = Invariant0.invariant'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Iter_Range_Impl3_Next_Interface as Next0 with
    type a = usize,
    type Item0.item = usize,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post
  let rec cfg div_float_with_ten_n_times [#"../Scratch/src/restart.rs" 76 0 76 58] [@cfg:stackify] [@cfg:subregion_analysis] (f : Float64.t) (n : usize) : Float64.t
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Float64.t;
  var f_1 : Float64.t;
  var n_2 : usize;
  var _3 : ();
  var _4 : Core_Ops_Range_Range_Type.t_range usize;
  var _5 : Core_Ops_Range_Range_Type.t_range usize;
  var _6 : usize;
  var iter_7 : Core_Ops_Range_Range_Type.t_range usize;
  var _8 : ();
  var _9 : ();
  var _10 : Core_Option_Option_Type.t_option usize;
  var _11 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _12 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _13 : isize;
  var _14 : ();
  {
    f_1 <- f;
    n_2 <- n;
    goto BB0
  }
  BB0 {
    _6 <- n_2;
    _5 <- Core_Ops_Range_Range_Type.C_Range ([#"../Scratch/src/restart.rs" 77 13 77 14] (0 : usize)) _6;
    _4 <- ([#"../Scratch/src/restart.rs" 77 13 77 17] IntoIter0.into_iter _5);
    goto BB1
  }
  BB1 {
    iter_7 <- _4;
    _4 <- any Core_Ops_Range_Range_Type.t_range usize;
    goto BB2
  }
  BB2 {
    _12 <- borrow_mut iter_7;
    iter_7 <-  ^ _12;
    _11 <- borrow_mut ( * _12);
    _12 <- { _12 with current = ( ^ _11) };
    assume { Resolve0.resolve _12 };
    _10 <- ([#"../Scratch/src/restart.rs" 77 13 77 17] Next0.next _11);
    goto BB3
  }
  BB3 {
    switch (_10)
      | Core_Option_Option_Type.C_None -> goto BB6
      | Core_Option_Option_Type.C_Some _ -> goto BB4
      end
  }
  BB4 {
    f_1 <- ([#"../Scratch/src/restart.rs" 78 8 78 17] f_1 ./ ([#"../Scratch/src/restart.rs" 78 13 78 17] 10.0000000000000000000000000000000000000000000000000000000000000000));
    _9 <- ();
    _8 <- ();
    goto BB2
  }
  BB5 {
    absurd
  }
  BB6 {
    _3 <- ();
    _0 <- f_1;
    return _0
  }
  
end
module Scratch_Restart_Impl3_New_Interface
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant_Stub as Invariant0
  val new [#"../Scratch/src/restart.rs" 85 4 85 20] (_1' : ()) : Scratch_Restart_Glucose_Type.t_glucose
    ensures { [#"../Scratch/src/restart.rs" 85 16 85 20] Invariant0.invariant' result }
    
end
module Scratch_Restart_Impl3_New
  use prelude.Float64
  use prelude.Float32
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant1
  clone Scratch_Restart_DivFloatWithTenNTimes_Interface as DivFloatWithTenNTimes0
  clone Scratch_Restart_Impl1_New_Interface as New0 with
    predicate Invariant0.invariant' = Invariant1.invariant'
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg new [#"../Scratch/src/restart.rs" 85 4 85 20] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : Scratch_Restart_Glucose_Type.t_glucose
    ensures { [#"../Scratch/src/restart.rs" 85 16 85 20] Invariant0.invariant' result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Restart_Glucose_Type.t_glucose;
  var _1 : Scratch_Restart_Ema_Type.t_ema;
  var _2 : Scratch_Restart_Ema_Type.t_ema;
  var _3 : Float64.t;
  var _4 : Scratch_Restart_Ema_Type.t_ema;
  {
    goto BB0
  }
  BB0 {
    _1 <- ([#"../Scratch/src/restart.rs" 89 28 89 42] New0.new ([#"../Scratch/src/restart.rs" 89 37 89 41] 0.0299999999999999988897769753748434595763683319091796875000000000));
    goto BB1
  }
  BB1 {
    _3 <- ([#"../Scratch/src/restart.rs" 90 35 90 70] DivFloatWithTenNTimes0.div_float_with_ten_n_times ([#"../Scratch/src/restart.rs" 90 62 90 66] 0.0010000000000000000208166817117216851329430937767028808593750000) ([#"../Scratch/src/restart.rs" 90 68 90 69] (2 : usize)));
    goto BB2
  }
  BB2 {
    _2 <- ([#"../Scratch/src/restart.rs" 90 26 90 71] New0.new _3);
    goto BB3
  }
  BB3 {
    _4 <- ([#"../Scratch/src/restart.rs" 91 28 91 42] New0.new ([#"../Scratch/src/restart.rs" 91 37 91 41] 0.0002999999999999999737189393389513725196593441069126129150390625));
    goto BB4
  }
  BB4 {
    _0 <- Scratch_Restart_Glucose_Type.C_Glucose ([#"../Scratch/src/restart.rs" 87 31 87 33] (50 : usize)) ([#"../Scratch/src/restart.rs" 88 53 88 59] (10000 : usize)) _1 _2 _4 ([#"../Scratch/src/restart.rs" 92 29 92 30] (0 : usize)) ([#"../Scratch/src/restart.rs" 93 19 93 23] 1.2500000000000000000000000000000000000000000000000000000000000000) ([#"../Scratch/src/restart.rs" 94 19 94 22] 1.3999999999999999111821580299874767661094665527343750000000000000) ([#"../Scratch/src/restart.rs" 95 26 95 27] (0 : usize)) ([#"../Scratch/src/restart.rs" 96 25 96 26] (0 : usize));
    return _0
  }
  
end
module Scratch_Restart_UsizeToF64_Interface
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  val usize_to_f64 [#"../Scratch/src/restart.rs" 103 0 103 32] (u : usize) : Float64.t
end
module Scratch_Restart_F64ToUsize_Interface
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  val f64_to_usize [#"../Scratch/src/restart.rs" 109 0 109 32] (f : Float64.t) : usize
end
module Scratch_Restart_Powf_Interface
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  val powf [#"../Scratch/src/restart.rs" 113 0 113 32] (f : Float64.t) (u : usize) : Float64.t
end
module Scratch_Restart_Powf
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.IntSize
  use prelude.Float32
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl16_DeepModel as DeepModel0
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces as Produces0 with
    type idx = usize,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans as ProducesTrans0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl as ProducesRefl0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Invariant_Invariant_Invariant as Invariant0 with
    type self = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Invariant_Invariant_IsInhabited as IsInhabited0 with
    type self = Core_Ops_Range_Range_Type.t_range usize,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Completed as Completed0 with
    type idx = usize,
    predicate Resolve0.resolve = Resolve0.resolve,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate Invariant0.invariant' = Invariant0.invariant'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Iter_Range_Impl3_Next_Interface as Next0 with
    type a = usize,
    type Item0.item = usize,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post
  let rec cfg powf [#"../Scratch/src/restart.rs" 113 0 113 32] [@cfg:stackify] [@cfg:subregion_analysis] (f : Float64.t) (u : usize) : Float64.t
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Float64.t;
  var f_1 : Float64.t;
  var u_2 : usize;
  var o_3 : Float64.t;
  var _4 : ();
  var _5 : Core_Ops_Range_Range_Type.t_range usize;
  var _6 : Core_Ops_Range_Range_Type.t_range usize;
  var _7 : usize;
  var iter_8 : Core_Ops_Range_Range_Type.t_range usize;
  var _9 : ();
  var _10 : ();
  var _11 : Core_Option_Option_Type.t_option usize;
  var _12 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _13 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _14 : isize;
  var _15 : ();
  var _16 : Float64.t;
  {
    f_1 <- f;
    u_2 <- u;
    goto BB0
  }
  BB0 {
    o_3 <- ([#"../Scratch/src/restart.rs" 114 16 114 19] 1.0000000000000000000000000000000000000000000000000000000000000000);
    _7 <- u_2;
    _6 <- Core_Ops_Range_Range_Type.C_Range ([#"../Scratch/src/restart.rs" 115 13 115 14] (0 : usize)) _7;
    _5 <- ([#"../Scratch/src/restart.rs" 115 13 115 17] IntoIter0.into_iter _6);
    goto BB1
  }
  BB1 {
    iter_8 <- _5;
    _5 <- any Core_Ops_Range_Range_Type.t_range usize;
    goto BB2
  }
  BB2 {
    _13 <- borrow_mut iter_8;
    iter_8 <-  ^ _13;
    _12 <- borrow_mut ( * _13);
    _13 <- { _13 with current = ( ^ _12) };
    assume { Resolve0.resolve _13 };
    _11 <- ([#"../Scratch/src/restart.rs" 115 13 115 17] Next0.next _12);
    goto BB3
  }
  BB3 {
    switch (_11)
      | Core_Option_Option_Type.C_None -> goto BB6
      | Core_Option_Option_Type.C_Some _ -> goto BB4
      end
  }
  BB4 {
    _16 <- f_1;
    o_3 <- ([#"../Scratch/src/restart.rs" 116 8 116 14] o_3 .* _16);
    _10 <- ();
    _9 <- ();
    goto BB2
  }
  BB5 {
    absurd
  }
  BB6 {
    _4 <- ();
    _0 <- o_3;
    return _0
  }
  
end
module Scratch_Restart_Impl4_TriggerRestart_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  val trigger_restart [#"../Scratch/src/restart.rs" 122 4 122 71] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 122 39 122 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 122 39 122 43] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl4_TriggerRestart
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant2
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  clone Scratch_Restart_Impl2_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg trigger_restart [#"../Scratch/src/restart.rs" 122 4 122 71] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 122 39 122 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 122 39 122 43] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : borrowed (Scratch_Restart_Glucose_Type.t_glucose);
  var curr_confl_2 : usize;
  var _3 : ();
  var _4 : bool;
  var _5 : usize;
  var _6 : usize;
  var _7 : ();
  var _8 : ();
  var _9 : bool;
  var _10 : Float64.t;
  var _11 : Float64.t;
  var _12 : Float64.t;
  var _13 : Float64.t;
  var _14 : ();
  var _15 : ();
  var _16 : bool;
  var _17 : usize;
  var _18 : ();
  var _19 : bool;
  var _20 : usize;
  var _21 : usize;
  var _22 : usize;
  {
    self_1 <- self;
    curr_confl_2 <- curr_confl;
    goto BB0
  }
  BB0 {
    _5 <- curr_confl_2;
    _6 <- Scratch_Restart_Glucose_Type.glucose_minimum_conflicts ( * self_1);
    _4 <- ([#"../Scratch/src/restart.rs" 123 11 123 46] _5 < _6);
    switch (_4)
      | False -> goto BB2
      | True -> goto BB1
      end
  }
  BB1 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"../Scratch/src/restart.rs" 124 19 124 24] false);
    goto BB11
  }
  BB2 {
    _3 <- ();
    _11 <- Scratch_Restart_Ema_Type.ema_value (Scratch_Restart_Glucose_Type.glucose_ema_lbd_narrow ( * self_1));
    _12 <- Scratch_Restart_Ema_Type.ema_value (Scratch_Restart_Glucose_Type.glucose_ema_lbd_wide ( * self_1));
    _10 <- ([#"../Scratch/src/restart.rs" 126 11 126 62] _11 ./ _12);
    _13 <- Scratch_Restart_Glucose_Type.glucose_force ( * self_1);
    _9 <- ([#"../Scratch/src/restart.rs" 126 11 126 75] _10 .> _13);
    switch (_9)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    _17 <- Scratch_Restart_Glucose_Type.glucose_num_restarts ( * self_1);
    _16 <- ([#"../Scratch/src/restart.rs" 127 15 127 45] _17 < ([#"../Scratch/src/restart.rs" 127 35 127 45] (18446744073709551615 : usize)));
    switch (_16)
      | False -> goto BB6
      | True -> goto BB5
      end
  }
  BB4 {
    assume { Resolve0.resolve self_1 };
    _8 <- ();
    _0 <- ([#"../Scratch/src/restart.rs" 135 8 135 13] false);
    goto BB11
  }
  BB5 {
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h ([#"../Scratch/src/restart.rs" 128 16 128 38] Scratch_Restart_Glucose_Type.glucose_num_restarts ( * self_1) + ([#"../Scratch/src/restart.rs" 128 37 128 38] (1 : usize))) j) };
    _15 <- ();
    goto BB7
  }
  BB6 {
    _15 <- ();
    goto BB7
  }
  BB7 {
    _20 <- curr_confl_2;
    _21 <- ([#"../Scratch/src/restart.rs" 130 28 130 43] ([#"../Scratch/src/restart.rs" 130 28 130 38] (18446744073709551615 : usize)) - ([#"../Scratch/src/restart.rs" 130 41 130 43] (50 : usize)));
    _19 <- ([#"../Scratch/src/restart.rs" 130 15 130 43] _20 < _21);
    switch (_19)
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    _22 <- curr_confl_2;
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose ([#"../Scratch/src/restart.rs" 131 16 131 56] _22 + ([#"../Scratch/src/restart.rs" 131 54 131 56] (50 : usize))) b c d e f g h i j) };
    assume { Resolve0.resolve self_1 };
    _18 <- ();
    goto BB10
  }
  BB9 {
    assume { Resolve0.resolve self_1 };
    _18 <- ();
    goto BB10
  }
  BB10 {
    _0 <- ([#"../Scratch/src/restart.rs" 133 19 133 23] true);
    goto BB11
  }
  BB11 {
    return _0
  }
  
end
module Scratch_Restart_Impl4_Update_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  val update [#"../Scratch/src/restart.rs" 138 4 138 65] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (trail_len : usize) (lbd : usize) : ()
    requires {[#"../Scratch/src/restart.rs" 138 30 138 34] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 138 30 138 34] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl4_Update
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant2
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant3 with
    type t = Scratch_Restart_Ema_Type.t_ema,
    predicate Invariant0.invariant' = Invariant2.invariant'
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  clone Scratch_Restart_Impl1_Update_Interface as Update0 with
    predicate Invariant0.invariant' = Invariant3.invariant',
    predicate Invariant1.invariant' = Invariant2.invariant'
  clone Scratch_Restart_UsizeToF64_Interface as UsizeToF640
  clone Scratch_Restart_Impl2_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg update [#"../Scratch/src/restart.rs" 138 4 138 65] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (trail_len : usize) (lbd : usize) : ()
    requires {[#"../Scratch/src/restart.rs" 138 30 138 34] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 138 30 138 34] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Restart_Glucose_Type.t_glucose);
  var trail_len_2 : usize;
  var lbd_3 : usize;
  var _4 : ();
  var _5 : borrowed (Scratch_Restart_Ema_Type.t_ema);
  var _6 : Float64.t;
  var _7 : usize;
  var _8 : usize;
  var _9 : ();
  var _10 : borrowed (Scratch_Restart_Ema_Type.t_ema);
  var _11 : Float64.t;
  var _12 : usize;
  var _13 : ();
  var _14 : borrowed (Scratch_Restart_Ema_Type.t_ema);
  var _15 : Float64.t;
  var _16 : usize;
  {
    self_1 <- self;
    trail_len_2 <- trail_len;
    lbd_3 <- lbd;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut (Scratch_Restart_Glucose_Type.glucose_ema_trail_wide ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b c d ( ^ _5) f g h i j) };
    _7 <- trail_len_2;
    _6 <- ([#"../Scratch/src/restart.rs" 139 35 139 58] UsizeToF640.usize_to_f64 _7);
    goto BB1
  }
  BB1 {
    _4 <- ([#"../Scratch/src/restart.rs" 139 8 139 59] Update0.update _5 _6);
    goto BB2
  }
  BB2 {
    _8 <- trail_len_2;
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b c d e _8 g h i j) };
    _8 <- any usize;
    _10 <- borrow_mut (Scratch_Restart_Glucose_Type.glucose_ema_lbd_narrow ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b ( ^ _10) d e f g h i j) };
    _12 <- lbd_3;
    _11 <- ([#"../Scratch/src/restart.rs" 141 35 141 52] UsizeToF640.usize_to_f64 _12);
    goto BB3
  }
  BB3 {
    _9 <- ([#"../Scratch/src/restart.rs" 141 8 141 53] Update0.update _10 _11);
    goto BB4
  }
  BB4 {
    _14 <- borrow_mut (Scratch_Restart_Glucose_Type.glucose_ema_lbd_wide ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b c ( ^ _14) e f g h i j) };
    assume { Resolve0.resolve self_1 };
    _16 <- lbd_3;
    _15 <- ([#"../Scratch/src/restart.rs" 142 33 142 50] UsizeToF640.usize_to_f64 _16);
    goto BB5
  }
  BB5 {
    _13 <- ([#"../Scratch/src/restart.rs" 142 8 142 51] Update0.update _14 _15);
    goto BB6
  }
  BB6 {
    _0 <- ();
    return _0
  }
  
end
module Scratch_Restart_Impl4_BlockRestart_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  val block_restart [#"../Scratch/src/restart.rs" 145 4 145 69] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 145 37 145 41] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 145 37 145 41] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl4_BlockRestart
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant2
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  clone Scratch_Restart_UsizeToF64_Interface as UsizeToF640
  clone Scratch_Restart_Impl2_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg block_restart [#"../Scratch/src/restart.rs" 145 4 145 69] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 145 37 145 41] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 145 37 145 41] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : borrowed (Scratch_Restart_Glucose_Type.t_glucose);
  var curr_confl_2 : usize;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : Float64.t;
  var _7 : usize;
  var _8 : Float64.t;
  var _9 : Float64.t;
  var _10 : Float64.t;
  var _11 : bool;
  var _12 : usize;
  var _13 : usize;
  var _14 : ();
  var _15 : ();
  var _16 : bool;
  var _17 : usize;
  var _18 : usize;
  var _19 : usize;
  var _20 : ();
  var _21 : bool;
  var _22 : usize;
  {
    self_1 <- self;
    curr_confl_2 <- curr_confl;
    goto BB0
  }
  BB0 {
    _7 <- Scratch_Restart_Glucose_Type.glucose_last_trail_size ( * self_1);
    _6 <- ([#"../Scratch/src/restart.rs" 146 11 146 45] UsizeToF640.usize_to_f64 _7);
    goto BB4
  }
  BB1 {
    _4 <- ([#"../Scratch/src/restart.rs" 146 11 147 73] false);
    goto BB3
  }
  BB2 {
    _12 <- curr_confl_2;
    _13 <- Scratch_Restart_Glucose_Type.glucose_minimum_conflicts_for_blocking_restarts ( * self_1);
    _11 <- ([#"../Scratch/src/restart.rs" 147 15 147 73] _12 >= _13);
    _4 <- _11;
    _11 <- any bool;
    goto BB3
  }
  BB3 {
    switch (_4)
      | False -> goto BB12
      | True -> goto BB5
      end
  }
  BB4 {
    _9 <- Scratch_Restart_Glucose_Type.glucose_block ( * self_1);
    _10 <- Scratch_Restart_Ema_Type.ema_value (Scratch_Restart_Glucose_Type.glucose_ema_trail_wide ( * self_1));
    _8 <- ([#"../Scratch/src/restart.rs" 146 48 146 86] _9 .* _10);
    _5 <- ([#"../Scratch/src/restart.rs" 146 11 146 86] _6 .> _8);
    switch (_5)
      | False -> goto BB1
      | True -> goto BB2
      end
  }
  BB5 {
    _17 <- curr_confl_2;
    _18 <- ([#"../Scratch/src/restart.rs" 149 28 149 43] ([#"../Scratch/src/restart.rs" 149 28 149 38] (18446744073709551615 : usize)) - ([#"../Scratch/src/restart.rs" 149 41 149 43] (50 : usize)));
    _16 <- ([#"../Scratch/src/restart.rs" 149 15 149 43] _17 < _18);
    switch (_16)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    _19 <- curr_confl_2;
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose ([#"../Scratch/src/restart.rs" 150 16 150 56] _19 + ([#"../Scratch/src/restart.rs" 150 54 150 56] (50 : usize))) b c d e f g h i j) };
    _15 <- ();
    goto BB8
  }
  BB7 {
    _15 <- ();
    goto BB8
  }
  BB8 {
    _22 <- Scratch_Restart_Glucose_Type.glucose_num_blocked ( * self_1);
    _21 <- ([#"../Scratch/src/restart.rs" 152 15 152 44] _22 < ([#"../Scratch/src/restart.rs" 152 34 152 44] (18446744073709551615 : usize)));
    switch (_21)
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i ([#"../Scratch/src/restart.rs" 153 16 153 37] Scratch_Restart_Glucose_Type.glucose_num_blocked ( * self_1) + ([#"../Scratch/src/restart.rs" 153 36 153 37] (1 : usize)))) };
    assume { Resolve0.resolve self_1 };
    _20 <- ();
    goto BB11
  }
  BB10 {
    assume { Resolve0.resolve self_1 };
    _20 <- ();
    goto BB11
  }
  BB11 {
    _0 <- ([#"../Scratch/src/restart.rs" 155 19 155 23] true);
    goto BB13
  }
  BB12 {
    assume { Resolve0.resolve self_1 };
    _3 <- ();
    _0 <- ([#"../Scratch/src/restart.rs" 157 8 157 13] false);
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module Scratch_Restart_Luby_Type
  use prelude.Int
  use prelude.UIntSize
  type t_luby  =
    | C_Luby usize usize usize
    
  let function luby_step (self : t_luby) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Luby a _ _ -> a
      end
  let function luby_limit (self : t_luby) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Luby _ _ a -> a
      end
  let function luby_curr_restarts (self : t_luby) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Luby _ a _ -> a
      end
end
module Scratch_Restart_Impl5_Invariant_Stub
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 173 4 173 30] (self : Scratch_Restart_Luby_Type.t_luby)
    
end
module Scratch_Restart_Impl5_Invariant_Interface
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 173 4 173 30] (self : Scratch_Restart_Luby_Type.t_luby)
    
end
module Scratch_Restart_Impl5_Invariant
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 173 4 173 30] (self : Scratch_Restart_Luby_Type.t_luby)
    
   =
    [#"../Scratch/src/restart.rs" 174 8 174 26] Scratch_Restart_Luby_Type.luby_step self > (0 : usize)
  val invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 173 4 173 30] (self : Scratch_Restart_Luby_Type.t_luby) : bool
    ensures { result = invariant' self }
    
end
module Scratch_Restart_Impl6_New_Interface
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant_Stub as Invariant0
  val new [#"../Scratch/src/restart.rs" 180 4 180 20] (_1' : ()) : Scratch_Restart_Luby_Type.t_luby
    ensures { [#"../Scratch/src/restart.rs" 180 16 180 20] Invariant0.invariant' result }
    
end
module Scratch_Restart_Impl6_New
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant as Invariant0
  let rec cfg new [#"../Scratch/src/restart.rs" 180 4 180 20] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : Scratch_Restart_Luby_Type.t_luby
    ensures { [#"../Scratch/src/restart.rs" 180 16 180 20] Invariant0.invariant' result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Restart_Luby_Type.t_luby;
  {
    goto BB0
  }
  BB0 {
    _0 <- Scratch_Restart_Luby_Type.C_Luby ([#"../Scratch/src/restart.rs" 181 42 181 45] (100 : usize)) ([#"../Scratch/src/restart.rs" 181 62 181 63] (0 : usize)) ([#"../Scratch/src/restart.rs" 181 72 181 75] (100 : usize));
    return _0
  }
  
end
module Scratch_Restart_Luby_Interface
  use prelude.UIntSize
  use prelude.Int
  use prelude.Float64
  val luby [#"../Scratch/src/restart.rs" 187 0 187 34] (y : Float64.t) (x : usize) : usize
    requires {[#"../Scratch/src/restart.rs" 186 11 186 35] UIntSize.to_int x < 9223372036854775806}
    
end
module Scratch_Restart_Luby
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  clone Scratch_Restart_F64ToUsize_Interface as F64ToUsize0
  clone Scratch_Restart_Powf_Interface as Powf0
  clone Core_Num_Impl11_Max as Max0
  let rec cfg luby [#"../Scratch/src/restart.rs" 187 0 187 34] [@cfg:stackify] [@cfg:subregion_analysis] (y : Float64.t) (x : usize) : usize
    requires {[#"../Scratch/src/restart.rs" 186 11 186 35] UIntSize.to_int x < 9223372036854775806}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var y_1 : Float64.t;
  var x_2 : usize;
  var size_4 : usize;
  var seq_5 : usize;
  var _6 : ();
  var _10 : ();
  var _11 : bool;
  var _12 : usize;
  var _13 : usize;
  var _14 : usize;
  var _15 : usize;
  var _16 : usize;
  var _17 : ();
  var _18 : ();
  var _19 : ();
  var x_20 : usize;
  var _21 : ();
  var _22 : bool;
  var _23 : bool;
  var _24 : bool;
  var _25 : usize;
  var _26 : bool;
  var _27 : usize;
  var _28 : bool;
  var _29 : usize;
  var _30 : usize;
  var _31 : usize;
  var _32 : usize;
  var _33 : usize;
  var _34 : bool;
  var _35 : bool;
  var _36 : usize;
  var _37 : usize;
  var _38 : bool;
  var _39 : ();
  var _40 : ();
  var _41 : ();
  var _42 : Float64.t;
  var _43 : Float64.t;
  var _44 : usize;
  {
    y_1 <- y;
    x_2 <- x;
    goto BB0
  }
  BB0 {
    size_4 <- ([#"../Scratch/src/restart.rs" 188 19 188 20] (1 : usize));
    seq_5 <- ([#"../Scratch/src/restart.rs" 189 25 189 26] (0 : usize));
    goto BB1
  }
  BB1 {
    invariant { [#"../Scratch/src/restart.rs" 190 16 190 36] UIntSize.to_int size_4 <= UIntSize.to_int Max0.mAX' };
    invariant { [#"../Scratch/src/restart.rs" 191 16 191 25] UIntSize.to_int size_4 > 0 };
    invariant { [#"../Scratch/src/restart.rs" 192 16 192 28] UIntSize.to_int seq_5 < UIntSize.to_int size_4 };
    _12 <- size_4;
    _14 <- x_2;
    _13 <- ([#"../Scratch/src/restart.rs" 193 17 193 22] _14 + ([#"../Scratch/src/restart.rs" 193 21 193 22] (1 : usize)));
    _11 <- ([#"../Scratch/src/restart.rs" 193 10 193 22] _12 < _13);
    switch (_11)
      | False -> goto BB3
      | True -> goto BB2
      end
  }
  BB2 {
    seq_5 <- ([#"../Scratch/src/restart.rs" 194 8 194 16] seq_5 + ([#"../Scratch/src/restart.rs" 194 15 194 16] (1 : usize)));
    _16 <- size_4;
    _15 <- ([#"../Scratch/src/restart.rs" 195 15 195 23] ([#"../Scratch/src/restart.rs" 195 15 195 16] (2 : usize)) * _16);
    size_4 <- ([#"../Scratch/src/restart.rs" 195 8 195 27] _15 + ([#"../Scratch/src/restart.rs" 195 26 195 27] (1 : usize)));
    _10 <- ();
    goto BB1
  }
  BB3 {
    _6 <- ();
    x_20 <- x_2;
    goto BB4
  }
  BB4 {
    _25 <- size_4;
    _24 <- ([#"../Scratch/src/restart.rs" 200 10 200 18] _25 > ([#"../Scratch/src/restart.rs" 200 17 200 18] (0 : usize)));
    switch (_24)
      | False -> goto BB8
      | True -> goto BB9
      end
  }
  BB5 {
    _22 <- ([#"../Scratch/src/restart.rs" 200 10 200 46] false);
    goto BB7
  }
  BB6 {
    _30 <- size_4;
    _29 <- ([#"../Scratch/src/restart.rs" 200 33 200 41] _30 - ([#"../Scratch/src/restart.rs" 200 40 200 41] (1 : usize)));
    _31 <- x_20;
    _28 <- ([#"../Scratch/src/restart.rs" 200 33 200 46] _29 <> _31);
    _22 <- _28;
    _28 <- any bool;
    goto BB7
  }
  BB7 {
    switch (_22)
      | False -> goto BB17
      | True -> goto BB11
      end
  }
  BB8 {
    _23 <- ([#"../Scratch/src/restart.rs" 200 10 200 29] false);
    goto BB10
  }
  BB9 {
    _27 <- seq_5;
    _26 <- ([#"../Scratch/src/restart.rs" 200 22 200 29] _27 > ([#"../Scratch/src/restart.rs" 200 28 200 29] (0 : usize)));
    _23 <- _26;
    _26 <- any bool;
    goto BB10
  }
  BB10 {
    switch (_23)
      | False -> goto BB5
      | True -> goto BB6
      end
  }
  BB11 {
    _33 <- size_4;
    _32 <- ([#"../Scratch/src/restart.rs" 203 15 203 25] _33 - ([#"../Scratch/src/restart.rs" 203 23 203 24] (1 : usize)));
    _34 <- ([#"../Scratch/src/restart.rs" 203 15 203 29] ([#"../Scratch/src/restart.rs" 203 28 203 29] (2 : usize)) = ([#"../Scratch/src/restart.rs" 203 15 203 29] (0 : usize)));
    assert { [#"../Scratch/src/restart.rs" 203 15 203 29] not _34 };
    goto BB12
  }
  BB12 {
    size_4 <- ([#"../Scratch/src/restart.rs" 203 8 203 29] _32 / ([#"../Scratch/src/restart.rs" 203 28 203 29] (2 : usize)));
    seq_5 <- ([#"../Scratch/src/restart.rs" 204 8 204 16] seq_5 - ([#"../Scratch/src/restart.rs" 204 15 204 16] (1 : usize)));
    _36 <- size_4;
    _35 <- ([#"../Scratch/src/restart.rs" 205 11 205 19] _36 > ([#"../Scratch/src/restart.rs" 205 18 205 19] (0 : usize)));
    switch (_35)
      | False -> goto BB15
      | True -> goto BB13
      end
  }
  BB13 {
    _37 <- size_4;
    _38 <- ([#"../Scratch/src/restart.rs" 206 12 206 21] _37 = ([#"../Scratch/src/restart.rs" 206 12 206 21] (0 : usize)));
    assert { [#"../Scratch/src/restart.rs" 206 12 206 21] not _38 };
    goto BB14
  }
  BB14 {
    x_20 <- ([#"../Scratch/src/restart.rs" 206 12 206 21] x_20 % _37);
    _10 <- ();
    goto BB16
  }
  BB15 {
    _10 <- ();
    goto BB16
  }
  BB16 {
    goto BB4
  }
  BB17 {
    _21 <- ();
    _43 <- y_1;
    _44 <- seq_5;
    _42 <- ([#"../Scratch/src/restart.rs" 211 17 211 29] Powf0.powf _43 _44);
    goto BB18
  }
  BB18 {
    _0 <- ([#"../Scratch/src/restart.rs" 211 4 211 30] F64ToUsize0.f64_to_usize _42);
    goto BB19
  }
  BB19 {
    return _0
  }
  
end
module Scratch_Restart_Impl7_TriggerRestart_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Luby_Type.t_luby
  val trigger_restart [#"../Scratch/src/restart.rs" 216 4 216 71] (self : borrowed (Scratch_Restart_Luby_Type.t_luby)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 216 39 216 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 216 39 216 43] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl7_TriggerRestart
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float32
  clone Scratch_Restart_Luby_Interface as Luby1
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Luby_Type.t_luby
  clone Scratch_Restart_Impl5_Invariant as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Luby_Type.t_luby,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg trigger_restart [#"../Scratch/src/restart.rs" 216 4 216 71] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Luby_Type.t_luby)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 216 39 216 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 216 39 216 43] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : borrowed (Scratch_Restart_Luby_Type.t_luby);
  var curr_confl_2 : usize;
  var _3 : ();
  var _4 : bool;
  var _5 : usize;
  var _6 : usize;
  var _7 : ();
  var _8 : ();
  var _9 : bool;
  var _10 : usize;
  var _11 : ();
  var incr_12 : usize;
  var _13 : usize;
  var _14 : ();
  var _15 : bool;
  var _16 : usize;
  var _17 : usize;
  var _18 : usize;
  var _19 : bool;
  var _20 : usize;
  var _21 : ();
  var _22 : bool;
  var _23 : usize;
  var _24 : usize;
  var _25 : usize;
  var _26 : usize;
  var _27 : usize;
  {
    self_1 <- self;
    curr_confl_2 <- curr_confl;
    goto BB0
  }
  BB0 {
    _5 <- curr_confl_2;
    _6 <- Scratch_Restart_Luby_Type.luby_limit ( * self_1);
    _4 <- ([#"../Scratch/src/restart.rs" 217 11 217 35] _5 <= _6);
    switch (_4)
      | False -> goto BB2
      | True -> goto BB1
      end
  }
  BB1 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"../Scratch/src/restart.rs" 218 19 218 24] false);
    goto BB13
  }
  BB2 {
    _3 <- ();
    _10 <- Scratch_Restart_Luby_Type.luby_curr_restarts ( * self_1);
    _9 <- ([#"../Scratch/src/restart.rs" 222 11 222 52] _10 >= ([#"../Scratch/src/restart.rs" 222 33 222 52] (9223372036854775806 : usize)));
    switch (_9)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"../Scratch/src/restart.rs" 223 19 223 23] true);
    goto BB13
  }
  BB4 {
    _8 <- ();
    _13 <- Scratch_Restart_Luby_Type.luby_curr_restarts ( * self_1);
    incr_12 <- ([#"../Scratch/src/restart.rs" 226 23 226 52] Luby1.luby ([#"../Scratch/src/restart.rs" 226 28 226 31] 2.0000000000000000000000000000000000000000000000000000000000000000) _13);
    goto BB5
  }
  BB5 {
    _16 <- incr_12;
    _18 <- Scratch_Restart_Luby_Type.luby_step ( * self_1);
    _19 <- ([#"../Scratch/src/restart.rs" 227 18 227 40] _18 = ([#"../Scratch/src/restart.rs" 227 18 227 40] (0 : usize)));
    assert { [#"../Scratch/src/restart.rs" 227 18 227 40] not _19 };
    goto BB6
  }
  BB6 {
    _17 <- ([#"../Scratch/src/restart.rs" 227 18 227 40] ([#"../Scratch/src/restart.rs" 227 18 227 28] (18446744073709551615 : usize)) / _18);
    _15 <- ([#"../Scratch/src/restart.rs" 227 11 227 40] _16 < _17);
    switch (_15)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    _20 <- Scratch_Restart_Luby_Type.luby_step ( * self_1);
    incr_12 <- ([#"../Scratch/src/restart.rs" 228 12 228 29] incr_12 * _20);
    _14 <- ();
    goto BB9
  }
  BB8 {
    _14 <- ();
    goto BB9
  }
  BB9 {
    _24 <- curr_confl_2;
    _23 <- ([#"../Scratch/src/restart.rs" 230 11 230 34] ([#"../Scratch/src/restart.rs" 230 11 230 21] (18446744073709551615 : usize)) - _24);
    _25 <- incr_12;
    _22 <- ([#"../Scratch/src/restart.rs" 230 11 230 41] _23 > _25);
    switch (_22)
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    _26 <- curr_confl_2;
    _27 <- incr_12;
    self_1 <- { self_1 with current = (let Scratch_Restart_Luby_Type.C_Luby a b c =  * self_1 in Scratch_Restart_Luby_Type.C_Luby a b ([#"../Scratch/src/restart.rs" 231 12 231 42] _26 + _27)) };
    _21 <- ();
    goto BB12
  }
  BB11 {
    _21 <- ();
    goto BB12
  }
  BB12 {
    self_1 <- { self_1 with current = (let Scratch_Restart_Luby_Type.C_Luby a b c =  * self_1 in Scratch_Restart_Luby_Type.C_Luby a ([#"../Scratch/src/restart.rs" 233 8 233 31] Scratch_Restart_Luby_Type.luby_curr_restarts ( * self_1) + ([#"../Scratch/src/restart.rs" 233 30 233 31] (1 : usize))) c) };
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"../Scratch/src/restart.rs" 236 8 236 12] true);
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module Scratch_Restart_RestartMode_Type
  type t_restartmode  =
    | C_Glucose
    | C_Luby
    
end
module Scratch_Restart_Restart_Type
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  type t_restart  =
    | C_Restart (Scratch_Restart_RestartMode_Type.t_restartmode) (Scratch_Restart_Luby_Type.t_luby) (Scratch_Restart_Glucose_Type.t_glucose)
    
  let function restart_luby (self : t_restart) : Scratch_Restart_Luby_Type.t_luby = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Restart _ a _ -> a
      end
  let function restart_glucose (self : t_restart) : Scratch_Restart_Glucose_Type.t_glucose
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Restart _ _ a -> a
      end
  let function restart_restart (self : t_restart) : Scratch_Restart_RestartMode_Type.t_restartmode
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Restart a _ _ -> a
      end
end
module Scratch_Restart_Impl8_Invariant_Stub
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  predicate invariant' [#"../Scratch/src/restart.rs" 249 4 249 30] (self : Scratch_Restart_Restart_Type.t_restart)
end
module Scratch_Restart_Impl8_Invariant_Interface
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  predicate invariant' [#"../Scratch/src/restart.rs" 249 4 249 30] (self : Scratch_Restart_Restart_Type.t_restart)
end
module Scratch_Restart_Impl8_Invariant
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl2_Invariant_Stub as Invariant1
  clone Scratch_Restart_Impl5_Invariant_Stub as Invariant0
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  predicate invariant' [#"../Scratch/src/restart.rs" 249 4 249 30] (self : Scratch_Restart_Restart_Type.t_restart) =
    [#"../Scratch/src/restart.rs" 250 8 253 9] Invariant0.invariant' (Scratch_Restart_Restart_Type.restart_luby self) /\ Invariant1.invariant' (Scratch_Restart_Restart_Type.restart_glucose self)
  val invariant' [#"../Scratch/src/restart.rs" 249 4 249 30] (self : Scratch_Restart_Restart_Type.t_restart) : bool
    ensures { result = invariant' self }
    
end
module Scratch_Restart_Impl9_New_Interface
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant_Stub as Invariant0
  val new [#"../Scratch/src/restart.rs" 258 4 258 34] (_1' : ()) : Scratch_Restart_Restart_Type.t_restart
    ensures { [#"../Scratch/src/restart.rs" 258 27 258 34] Invariant0.invariant' result }
    
end
module Scratch_Restart_Impl9_New
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant3
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant2 with
    predicate Invariant0.invariant' = Invariant3.invariant'
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant as Invariant1
  clone Scratch_Restart_Impl3_New_Interface as New1 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone Scratch_Restart_Impl6_New_Interface as New0 with
    predicate Invariant0.invariant' = Invariant1.invariant'
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant as Invariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Invariant1.invariant' = Invariant2.invariant'
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  let rec cfg new [#"../Scratch/src/restart.rs" 258 4 258 34] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : Scratch_Restart_Restart_Type.t_restart
    ensures { [#"../Scratch/src/restart.rs" 258 27 258 34] Invariant0.invariant' result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Restart_Restart_Type.t_restart;
  var _1 : Scratch_Restart_RestartMode_Type.t_restartmode;
  var _2 : Scratch_Restart_Luby_Type.t_luby;
  var _3 : Scratch_Restart_Glucose_Type.t_glucose;
  {
    goto BB0
  }
  BB0 {
    _1 <- Scratch_Restart_RestartMode_Type.C_Glucose;
    _2 <- ([#"../Scratch/src/restart.rs" 259 55 259 66] New0.new ());
    goto BB1
  }
  BB1 {
    _3 <- ([#"../Scratch/src/restart.rs" 259 77 259 91] New1.new ());
    goto BB2
  }
  BB2 {
    _0 <- Scratch_Restart_Restart_Type.C_Restart _1 _2 _3;
    return _0
  }
  
end
module Scratch_Restart_Impl9_SetRestartMode_Interface
  use prelude.Borrow
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  val set_restart_mode [#"../Scratch/src/restart.rs" 262 4 262 64] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (mode : Scratch_Restart_RestartMode_Type.t_restartmode) : ()
    requires {[#"../Scratch/src/restart.rs" 262 40 262 44] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 262 40 262 44] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl9_SetRestartMode
  use prelude.Borrow
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant4
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant3 with
    predicate Invariant0.invariant' = Invariant4.invariant'
  clone Scratch_Restart_Impl5_Invariant as Invariant2
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  clone Scratch_Restart_Impl8_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart,
    predicate Invariant0.invariant' = Invariant1.invariant'
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  let rec cfg set_restart_mode [#"../Scratch/src/restart.rs" 262 4 262 64] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (mode : Scratch_Restart_RestartMode_Type.t_restartmode) : ()
    requires {[#"../Scratch/src/restart.rs" 262 40 262 44] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 262 40 262 44] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Restart_Restart_Type.t_restart);
  var mode_2 : Scratch_Restart_RestartMode_Type.t_restartmode;
  var _3 : Scratch_Restart_RestartMode_Type.t_restartmode;
  {
    self_1 <- self;
    mode_2 <- mode;
    goto BB0
  }
  BB0 {
    _3 <- mode_2;
    mode_2 <- any Scratch_Restart_RestartMode_Type.t_restartmode;
    self_1 <- { self_1 with current = (let Scratch_Restart_Restart_Type.C_Restart a b c =  * self_1 in Scratch_Restart_Restart_Type.C_Restart _3 b c) };
    _3 <- any Scratch_Restart_RestartMode_Type.t_restartmode;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Scratch_Restart_Impl9_TriggerRestart_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  val trigger_restart [#"../Scratch/src/restart.rs" 266 4 266 71] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 266 39 266 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 266 39 266 43] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl9_TriggerRestart
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.IntSize
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant6
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant3 with
    predicate Invariant0.invariant' = Invariant6.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant5 with
    type t = Scratch_Restart_Glucose_Type.t_glucose,
    predicate Invariant0.invariant' = Invariant3.invariant'
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant as Invariant2
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant4 with
    type t = Scratch_Restart_Luby_Type.t_luby,
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone Scratch_Restart_Impl4_TriggerRestart_Interface as TriggerRestart1 with
    predicate Invariant0.invariant' = Invariant5.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  clone Scratch_Restart_Impl7_TriggerRestart_Interface as TriggerRestart0 with
    predicate Invariant0.invariant' = Invariant4.invariant',
    predicate Invariant1.invariant' = Invariant2.invariant'
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  clone Scratch_Restart_Impl8_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg trigger_restart [#"../Scratch/src/restart.rs" 266 4 266 71] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 266 39 266 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 266 39 266 43] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : borrowed (Scratch_Restart_Restart_Type.t_restart);
  var curr_confl_2 : usize;
  var _3 : isize;
  var _4 : borrowed (Scratch_Restart_Glucose_Type.t_glucose);
  var _5 : usize;
  var _6 : borrowed (Scratch_Restart_Luby_Type.t_luby);
  var _7 : usize;
  {
    self_1 <- self;
    curr_confl_2 <- curr_confl;
    goto BB0
  }
  BB0 {
    switch (Scratch_Restart_Restart_Type.restart_restart ( * self_1))
      | Scratch_Restart_RestartMode_Type.C_Glucose -> goto BB3
      | Scratch_Restart_RestartMode_Type.C_Luby -> goto BB1
      end
  }
  BB1 {
    _6 <- borrow_mut (Scratch_Restart_Restart_Type.restart_luby ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Restart_Type.C_Restart a b c =  * self_1 in Scratch_Restart_Restart_Type.C_Restart a ( ^ _6) c) };
    assume { Resolve0.resolve self_1 };
    _7 <- curr_confl_2;
    _0 <- ([#"../Scratch/src/restart.rs" 269 33 269 70] TriggerRestart0.trigger_restart _6 _7);
    goto BB5
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    _4 <- borrow_mut (Scratch_Restart_Restart_Type.restart_glucose ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Restart_Type.C_Restart a b c =  * self_1 in Scratch_Restart_Restart_Type.C_Restart a b ( ^ _4)) };
    assume { Resolve0.resolve self_1 };
    _5 <- curr_confl_2;
    _0 <- ([#"../Scratch/src/restart.rs" 268 36 268 76] TriggerRestart1.trigger_restart _4 _5);
    goto BB4
  }
  BB4 {
    goto BB6
  }
  BB5 {
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Scratch_Restart_Impl9_BlockRestart_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  val block_restart [#"../Scratch/src/restart.rs" 273 4 273 69] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 273 37 273 41] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 273 37 273 41] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl9_BlockRestart
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.IntSize
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant5
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant3 with
    predicate Invariant0.invariant' = Invariant5.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant4 with
    type t = Scratch_Restart_Glucose_Type.t_glucose,
    predicate Invariant0.invariant' = Invariant3.invariant'
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant as Invariant2
  clone Scratch_Restart_Impl4_BlockRestart_Interface as BlockRestart0 with
    predicate Invariant0.invariant' = Invariant4.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  clone Scratch_Restart_Impl8_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg block_restart [#"../Scratch/src/restart.rs" 273 4 273 69] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 273 37 273 41] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 273 37 273 41] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : borrowed (Scratch_Restart_Restart_Type.t_restart);
  var curr_confl_2 : usize;
  var _3 : isize;
  var _4 : borrowed (Scratch_Restart_Glucose_Type.t_glucose);
  var _5 : usize;
  {
    self_1 <- self;
    curr_confl_2 <- curr_confl;
    goto BB0
  }
  BB0 {
    switch (Scratch_Restart_Restart_Type.restart_restart ( * self_1))
      | Scratch_Restart_RestartMode_Type.C_Glucose -> goto BB3
      | Scratch_Restart_RestartMode_Type.C_Luby -> goto BB1
      end
  }
  BB1 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"../Scratch/src/restart.rs" 276 33 276 37] true);
    goto BB5
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB3 {
    _4 <- borrow_mut (Scratch_Restart_Restart_Type.restart_glucose ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Restart_Type.C_Restart a b c =  * self_1 in Scratch_Restart_Restart_Type.C_Restart a b ( ^ _4)) };
    assume { Resolve0.resolve self_1 };
    _5 <- curr_confl_2;
    _0 <- ([#"../Scratch/src/restart.rs" 275 36 275 74] BlockRestart0.block_restart _4 _5);
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module CreusotContracts_Invariant_Impl0_Invariant_Stub
  type t
  use prelude.Borrow
  predicate invariant' (self : t)
end
module CreusotContracts_Invariant_Impl0_Invariant_Interface
  type t
  use prelude.Borrow
  predicate invariant' (self : t)
end
module CreusotContracts_Invariant_Impl0_Invariant
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = t
  predicate invariant' (self : t) =
    Invariant0.invariant' self
  val invariant' (self : t) : bool
    ensures { result = invariant' self }
    
end
module Scratch_Restart_Impl9_GetNumberOfRestarts_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone CreusotContracts_Invariant_Impl0_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  val get_number_of_restarts [#"../Scratch/src/restart.rs" 280 4 280 56] (self : Scratch_Restart_Restart_Type.t_restart) : usize
    requires {[#"../Scratch/src/restart.rs" 280 42 280 46] Invariant0.invariant' self}
    
end
module Scratch_Restart_Impl9_GetNumberOfRestarts
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant4
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant3 with
    predicate Invariant0.invariant' = Invariant4.invariant'
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant as Invariant2
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  clone CreusotContracts_Invariant_Impl0_Invariant as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg get_number_of_restarts [#"../Scratch/src/restart.rs" 280 4 280 56] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Restart_Restart_Type.t_restart) : usize
    requires {[#"../Scratch/src/restart.rs" 280 42 280 46] Invariant0.invariant' self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self_1 : Scratch_Restart_Restart_Type.t_restart;
  var _2 : bool;
  var _3 : usize;
  var _4 : usize;
  var _5 : usize;
  var _6 : usize;
  var _7 : usize;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- Scratch_Restart_Glucose_Type.glucose_num_restarts (Scratch_Restart_Restart_Type.restart_glucose self_1);
    _3 <- ([#"../Scratch/src/restart.rs" 281 11 281 49] ([#"../Scratch/src/restart.rs" 281 11 281 21] (18446744073709551615 : usize)) - _4);
    _5 <- Scratch_Restart_Luby_Type.luby_curr_restarts (Scratch_Restart_Restart_Type.restart_luby self_1);
    _2 <- ([#"../Scratch/src/restart.rs" 281 11 281 75] _3 > _5);
    switch (_2)
      | False -> goto BB2
      | True -> goto BB1
      end
  }
  BB1 {
    _6 <- Scratch_Restart_Glucose_Type.glucose_num_restarts (Scratch_Restart_Restart_Type.restart_glucose self_1);
    _7 <- Scratch_Restart_Luby_Type.luby_curr_restarts (Scratch_Restart_Restart_Type.restart_luby self_1);
    _0 <- ([#"../Scratch/src/restart.rs" 282 12 282 63] _6 + _7);
    goto BB3
  }
  BB2 {
    _0 <- ([#"../Scratch/src/restart.rs" 284 12 284 22] (18446744073709551615 : usize));
    goto BB3
  }
  BB3 {
    return _0
  }
  
end
module Scratch_Logic_Pos_Stub
  use prelude.Int
  use prelude.UInt8
  function pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8
end
module Scratch_Logic_Pos_Interface
  use prelude.Int
  use prelude.UInt8
  function pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8
end
module Scratch_Logic_Pos
  use prelude.Int
  use prelude.UInt8
  function pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8 =
    [#"../Scratch/src/logic.rs" 9 4 9 7] (1 : uint8)
  val pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8
    ensures { result = pos _1' }
    
end
module Scratch_Logic_Neg_Stub
  use prelude.Int
  use prelude.UInt8
  function neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8
end
module Scratch_Logic_Neg_Interface
  use prelude.Int
  use prelude.UInt8
  function neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8
end
module Scratch_Logic_Neg
  use prelude.Int
  use prelude.UInt8
  function neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8 =
    [#"../Scratch/src/logic.rs" 14 4 14 7] (0 : uint8)
  val neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8
    ensures { result = neg _1' }
    
end
module Scratch_Logic_BoolToAssignedstate_Stub
  use prelude.UInt8
  use prelude.Int
  function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
end
module Scratch_Logic_BoolToAssignedstate_Interface
  use prelude.UInt8
  use prelude.Int
  function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
  axiom bool_to_assignedstate_spec : forall b : bool . ([#"../Scratch/src/logic.rs" 31 0 31 31] not b -> UInt8.to_int (bool_to_assignedstate b) = 0) && ([#"../Scratch/src/logic.rs" 30 0 30 30] b -> UInt8.to_int (bool_to_assignedstate b) = 1)
end
module Scratch_Logic_BoolToAssignedstate
  use prelude.UInt8
  use prelude.Int
  function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8 =
    [#"../Scratch/src/logic.rs" 29 0 29 8] if b then (1 : uint8) else (0 : uint8)
  val bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
    ensures { result = bool_to_assignedstate b }
    
  axiom bool_to_assignedstate_spec : forall b : bool . ([#"../Scratch/src/logic.rs" 31 0 31 31] not b -> UInt8.to_int (bool_to_assignedstate b) = 0) && ([#"../Scratch/src/logic.rs" 30 0 30 30] b -> UInt8.to_int (bool_to_assignedstate b) = 1)
end
module Scratch_Logic_BoolToAssignedstate_Impl
  use prelude.UInt8
  use prelude.Int
  let rec ghost function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
    ensures { [#"../Scratch/src/logic.rs" 30 0 30 30] b -> UInt8.to_int result = 1 }
    ensures { [#"../Scratch/src/logic.rs" 31 0 31 31] not b -> UInt8.to_int result = 0 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/logic.rs" 29 0 29 8] if b then (1 : uint8) else (0 : uint8)
end
module Scratch_Logic_FlipV_Stub
  use prelude.Int
  use prelude.UInt8
  function flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8
end
module Scratch_Logic_FlipV_Interface
  use prelude.Int
  use prelude.UInt8
  function flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8
end
module Scratch_Logic_FlipV
  use prelude.Int
  use prelude.UInt8
  function flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8 =
    [#"../Scratch/src/logic.rs" 42 4 50 5] if UInt8.to_int v = 0 then
      (1 : uint8)
    else
      if UInt8.to_int v = 1 then (0 : uint8) else v
    
  val flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8
    ensures { result = flip_v v }
    
end
module Scratch_Assignments_Impl0
  
end
module Scratch_Clause_Impl0
  
end
module Scratch_Formula_Impl0
  
end
module Scratch_Lit_Impl0
  
end
module Scratch_Clause_Impl3
  use prelude.Borrow
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  goal clone'_refn : [#"../Scratch/src/clause.rs" 6 9 6 14] forall self : Scratch_Clause_Clause_Type.t_clause . forall result : Scratch_Clause_Clause_Type.t_clause . result = self -> result = self
end
module Scratch_Lit_Impl4
  use prelude.Borrow
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  goal clone'_refn : [#"../Scratch/src/lit.rs" 10 9 10 14] forall self : Scratch_Lit_Lit_Type.t_lit . forall result : Scratch_Lit_Lit_Type.t_lit . result = self -> result = self
end
module Scratch_Lit_Impl5
  
end
module Scratch_Lit_Impl1
  
end
module Scratch_Restart_Impl0
  
end
module Scratch_Restart_Impl2
  
end
module Scratch_Restart_Impl5
  
end
module Scratch_Restart_Impl8
  
end
