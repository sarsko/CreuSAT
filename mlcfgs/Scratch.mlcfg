
module Core_Ptr_NonNull_NonNull_Type
  use prelude.Opaque
  type t_nonnull 't =
    | C_NonNull opaque_ptr
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_unique 't =
    | C_Unique (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) (Core_Marker_PhantomData_Type.t_phantomdata 't)
    
end
module Alloc_RawVec_RawVec_Type
  use prelude.Int
  use prelude.UIntSize
  use Core_Ptr_Unique_Unique_Type as Core_Ptr_Unique_Unique_Type
  type t_rawvec 't 'a =
    | C_RawVec (Core_Ptr_Unique_Unique_Type.t_unique 't) usize 'a
    
end
module Alloc_Vec_Vec_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_RawVec_RawVec_Type as Alloc_RawVec_RawVec_Type
  type t_vec 't 'a =
    | C_Vec (Alloc_RawVec_RawVec_Type.t_rawvec 't 'a) usize
    
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
    
end
module Scratch_Assignments_Assignments_Type
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_assignments  =
    | C_Assignments (Alloc_Vec_Vec_Type.t_vec uint8 (Alloc_Alloc_Global_Type.t_global))
    
  let function assignments_0 (self : t_assignments) : Alloc_Vec_Vec_Type.t_vec uint8 (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Assignments a -> a
      end
end
module Core_Num_Impl11_Max_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant mAX'  : usize
end
module Core_Num_Impl11_Max
  use prelude.Int
  use prelude.UIntSize
  let constant mAX'  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    (18446744073709551615 : usize)
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel_Interface
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX'
end
module CreusotContracts_Std1_Vec_Impl0_ShallowModel
  type t
  type a
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
  val shallow_model (self : Alloc_Vec_Vec_Type.t_vec t a) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Alloc_Vec_Vec_Type.t_vec t a . [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX'
end
module Scratch_Assignments_Impl0_ShallowModel_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  function shallow_model [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    
end
module Scratch_Assignments_Impl0_ShallowModel_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  function shallow_model [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    
end
module Scratch_Assignments_Impl0_ShallowModel
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  function shallow_model [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    
   =
    [#"../Scratch/src/assignments.rs" 19 4 19 12] ShallowModel0.shallow_model (Scratch_Assignments_Assignments_Type.assignments_0 self)
  val shallow_model [#"../Scratch/src/assignments.rs" 20 4 20 50] (self : Scratch_Assignments_Assignments_Type.t_assignments) : Seq.seq uint8
    ensures { result = shallow_model self }
    
end
module Scratch_Logic_Unset_Stub
  use prelude.Int
  use prelude.UInt8
  predicate unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8)
end
module Scratch_Logic_Unset_Interface
  use prelude.Int
  use prelude.UInt8
  predicate unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8)
end
module Scratch_Logic_Unset
  use prelude.Int
  use prelude.UInt8
  predicate unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8) =
    [#"../Scratch/src/logic.rs" 19 4 25 5] if UInt8.to_int v >= 2 then true else false
  val unset [#"../Scratch/src/logic.rs" 18 0 18 38] (v : uint8) : bool
    ensures { result = unset v }
    
end
module Scratch_Assignments_CompatibleInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Scratch_Assignments_CompatibleInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Scratch_Assignments_CompatibleInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  clone Scratch_Logic_Unset_Stub as Unset0
  predicate compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8) =
    [#"../Scratch/src/assignments.rs" 28 8 29 43] Seq.length a = Seq.length a2 /\ (forall i : int . 0 <= i /\ i < Seq.length a -> Unset0.unset (Seq.get a i) \/ Seq.get a i = Seq.get a2 i)
  val compatible_inner [#"../Scratch/src/assignments.rs" 26 0 26 78] (a : Seq.seq uint8) (a2 : Seq.seq uint8) : bool
    ensures { result = compatible_inner a a2 }
    
end
module Scratch_Assignments_CompleteInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8)
end
module Scratch_Assignments_CompleteInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8)
end
module Scratch_Assignments_CompleteInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  clone Scratch_Logic_Unset_Stub as Unset0
  predicate complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8) =
    [#"../Scratch/src/assignments.rs" 35 4 37 5] forall i : int . 0 <= i /\ i < Seq.length a -> not Unset0.unset (Seq.get a i)
  val complete_inner [#"../Scratch/src/assignments.rs" 34 0 34 52] (a : Seq.seq uint8) : bool
    ensures { result = complete_inner a }
    
end
module Scratch_Assignments_CompatibleCompleteInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Assignments_CompatibleCompleteInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  predicate compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Assignments_CompatibleCompleteInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  clone Scratch_Assignments_CompleteInner_Stub as CompleteInner0
  clone Scratch_Assignments_CompatibleInner_Stub as CompatibleInner0
  predicate compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
   =
    [#"../Scratch/src/assignments.rs" 42 4 42 49] CompatibleInner0.compatible_inner a a2 /\ CompleteInner0.complete_inner a2
  val compatible_complete_inner [#"../Scratch/src/assignments.rs" 41 0 41 87] (a : Seq.seq uint8) (a2 : Seq.seq uint8) : bool
    ensures { result = compatible_complete_inner a a2 }
    
end
module Scratch_Lit_Lit_Type
  use prelude.Int
  use prelude.UIntSize
  type t_lit  =
    | C_Lit usize bool
    
  let function lit_idx (self : t_lit) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Lit a _ -> a
      end
  let function lit_polarity (self : t_lit) : bool = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Lit _ a -> a
      end
end
module Scratch_Clause_Clause_Type
  use prelude.Int
  use prelude.UInt32
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_clause  =
    | C_Clause bool uint32 usize (Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global))
    
  let function clause_deleted (self : t_clause) : bool = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause a _ _ _ -> a
      end
  let function clause_lbd (self : t_clause) : uint32 = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause _ a _ _ -> a
      end
  let function clause_search (self : t_clause) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause _ _ a _ -> a
      end
  let function clause_lits (self : t_clause) : Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Clause _ _ _ a -> a
      end
end
module Scratch_Formula_Formula_Type
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_formula  =
    | C_Formula (Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global)) usize
    
  let function formula_num_vars (self : t_formula) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Formula _ a -> a
      end
  let function formula_clauses (self : t_formula) : Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global)
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Formula a _ -> a
      end
end
module Scratch_Assignments_Impl1_Invariant_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Assignments_Impl1_Invariant_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Assignments_Impl1_Invariant
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/assignments.rs" 49 8 52 9] UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars f) = Seq.length (ShallowModel0.shallow_model self) /\ (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> UInt8.to_int (Seq.get (ShallowModel0.shallow_model self) i) <= 3)
  val invariant' [#"../Scratch/src/assignments.rs" 48 4 48 46] (self : Scratch_Assignments_Assignments_Type.t_assignments) (f : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = invariant' self f }
    
end
module Scratch_Assignments_Impl1_Complete_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Assignments_Impl1_Complete_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  predicate complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Assignments_Impl1_Complete
  use prelude.Int
  use seq.Seq
  clone Scratch_Logic_Unset_Stub as Unset0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/assignments.rs" 57 8 59 9] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> not Unset0.unset (Seq.get (ShallowModel0.shallow_model self) i)
  val complete [#"../Scratch/src/assignments.rs" 56 4 56 33] (self : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = complete self }
    
end
module Core_Clone_Impls_Impl19_Clone_Interface
  use prelude.Borrow
  val clone' (self : bool) : bool
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    
end
module Core_Clone_Impls_Impl8_Clone_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  val clone' (self : uint32) : uint32
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    
end
module Core_Clone_Impls_Impl5_Clone_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  val clone' (self : usize) : usize
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    
end
module Alloc_Vec_Impl11_Clone_Interface
  type t
  type a
  use prelude.Borrow
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  val clone' (self : Alloc_Vec_Vec_Type.t_vec t a) : Alloc_Vec_Vec_Type.t_vec t a
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/clone.rs" 7 0 20 1] result = self }
    
end
module Scratch_Clause_Impl3_Clone_Interface
  use prelude.Borrow
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  val clone' [#"../Scratch/src/clause.rs" 6 9 6 14] (self : Scratch_Clause_Clause_Type.t_clause) : Scratch_Clause_Clause_Type.t_clause
    ensures { [#"../Scratch/src/clause.rs" 6 9 6 14] result = self }
    
end
module Scratch_Clause_Impl3_Clone
  use prelude.Borrow
  use prelude.Int
  use prelude.UInt32
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Alloc_Vec_Impl11_Clone_Interface as Clone3 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global
  clone Core_Clone_Impls_Impl5_Clone_Interface as Clone2
  clone Core_Clone_Impls_Impl8_Clone_Interface as Clone1
  clone Core_Clone_Impls_Impl19_Clone_Interface as Clone0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  let rec cfg clone' [#"../Scratch/src/clause.rs" 6 9 6 14] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Clause_Clause_Type.t_clause) : Scratch_Clause_Clause_Type.t_clause
    ensures { [#"../Scratch/src/clause.rs" 6 9 6 14] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Clause_Clause_Type.t_clause;
  var self_1 : Scratch_Clause_Clause_Type.t_clause;
  var _3 : bool;
  var _4 : bool;
  var _5 : bool;
  var _6 : uint32;
  var _7 : uint32;
  var _8 : uint32;
  var _9 : usize;
  var _10 : usize;
  var _11 : usize;
  var _12 : Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global);
  var _13 : Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global);
  var _14 : Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _5 <- Scratch_Clause_Clause_Type.clause_deleted self_1;
    _4 <- _5;
    _3 <- ([#"../Scratch/src/clause.rs" 8 4 8 21] Clone0.clone' _4);
    goto BB1
  }
  BB1 {
    _8 <- Scratch_Clause_Clause_Type.clause_lbd self_1;
    _7 <- _8;
    _6 <- ([#"../Scratch/src/clause.rs" 9 4 9 16] Clone1.clone' _7);
    goto BB2
  }
  BB2 {
    _11 <- Scratch_Clause_Clause_Type.clause_search self_1;
    _10 <- _11;
    _9 <- ([#"../Scratch/src/clause.rs" 10 4 10 21] Clone2.clone' _10);
    goto BB3
  }
  BB3 {
    _14 <- Scratch_Clause_Clause_Type.clause_lits self_1;
    _13 <- _14;
    _12 <- ([#"../Scratch/src/clause.rs" 11 4 11 22] Clone3.clone' _13);
    goto BB4
  }
  BB4 {
    _0 <- Scratch_Clause_Clause_Type.C_Clause _3 _6 _9 _12;
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Scratch_Clause_Impl0_ShallowModel_Stub
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  function shallow_model [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Clause_Impl0_ShallowModel_Interface
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  function shallow_model [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Clause_Impl0_ShallowModel
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  function shallow_model [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    
   =
    [#"../Scratch/src/clause.rs" 18 4 18 12] ShallowModel0.shallow_model (Scratch_Clause_Clause_Type.clause_lits self)
  val shallow_model [#"../Scratch/src/clause.rs" 19 4 19 50] (self : Scratch_Clause_Clause_Type.t_clause) : Seq.seq (Scratch_Lit_Lit_Type.t_lit)
    ensures { result = shallow_model self }
    
end
module Scratch_Lit_Impl2_IndexLogic_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
end
module Scratch_Lit_Impl2_IndexLogic_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
end
module Scratch_Lit_Impl2_IndexLogic
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
   =
    [#"../Scratch/src/lit.rs" 51 8 51 31] UIntSize.to_int (Scratch_Lit_Lit_Type.lit_idx self)
  val index_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 50 4 50 35] (self : Scratch_Lit_Lit_Type.t_lit) : int
    ensures { result = index_logic self }
    
end
module Scratch_Lit_Impl3_Invariant_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int)
end
module Scratch_Lit_Impl3_Invariant_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int)
end
module Scratch_Lit_Impl3_Invariant
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int) =
    [#"../Scratch/src/lit.rs" 102 20 102 42] IndexLogic0.index_logic self < n
  val invariant' [#"../Scratch/src/lit.rs" 101 4 101 42] (self : Scratch_Lit_Lit_Type.t_lit) (n : int) : bool
    ensures { result = invariant' self n }
    
end
module Scratch_Clause_VarsInRangeInner_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_VarsInRangeInner_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_VarsInRangeInner
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_Invariant_Stub as Invariant0
  predicate vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
   =
    [#"../Scratch/src/clause.rs" 26 4 29 5] forall i : int . 0 <= i /\ i < Seq.length s -> Invariant0.invariant' (Seq.get s i) n
  val vars_in_range_inner [#"../Scratch/src/clause.rs" 25 0 25 55] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int) : bool
    ensures { result = vars_in_range_inner s n }
    
end
module Scratch_Clause_NoDuplicateIndexesInner_Stub
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Clause_NoDuplicateIndexesInner_Interface
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Clause_NoDuplicateIndexesInner
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
   =
    [#"../Scratch/src/clause.rs" 46 4 49 5] forall k : int . forall j : int . 0 <= j /\ j < Seq.length s /\ 0 <= k /\ k < j -> not IndexLogic0.index_logic (Seq.get s k) = IndexLogic0.index_logic (Seq.get s j)
  val no_duplicate_indexes_inner [#"../Scratch/src/clause.rs" 45 0 45 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) : bool
    ensures { result = no_duplicate_indexes_inner s }
    
end
module Scratch_Clause_InvariantInternal_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_InvariantInternal_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
end
module Scratch_Clause_InvariantInternal
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_NoDuplicateIndexesInner_Stub as NoDuplicateIndexesInner0
  clone Scratch_Clause_VarsInRangeInner_Stub as VarsInRangeInner0
  predicate invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int)
    
   =
    [#"../Scratch/src/clause.rs" 34 4 34 62] VarsInRangeInner0.vars_in_range_inner s n /\ NoDuplicateIndexesInner0.no_duplicate_indexes_inner s
  val invariant_internal [#"../Scratch/src/clause.rs" 33 0 33 54] (s : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) (n : int) : bool
    ensures { result = invariant_internal s n }
    
end
module Scratch_Lit_Impl2_IsPositiveLogic_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    
end
module Scratch_Lit_Impl2_IsPositiveLogic_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    
end
module Scratch_Lit_Impl2_IsPositiveLogic
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    
   =
    [#"../Scratch/src/lit.rs" 57 20 57 33] Scratch_Lit_Lit_Type.lit_polarity self
  val is_positive_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 56 4 56 42] (self : Scratch_Lit_Lit_Type.t_lit) : bool
    ensures { result = is_positive_logic self }
    
end
module Scratch_Lit_Impl3_SatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_SatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_SatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  predicate sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) =
    [#"../Scratch/src/lit.rs" 108 12 111 13] if IsPositiveLogic0.is_positive_logic self then
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 1
    else
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 0
    
  val sat_inner [#"../Scratch/src/lit.rs" 106 4 106 57] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) : bool
    ensures { result = sat_inner self a }
    
end
module Scratch_Clause_Impl2_SatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_SatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_SatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 163 8 166 9] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) /\ SatInner0.sat_inner (Seq.get (ShallowModel0.shallow_model self) i) a
  val sat_inner [#"../Scratch/src/clause.rs" 162 4 162 57] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = sat_inner self a }
    
end
module Scratch_Formula_FormulaSatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8)
    
end
module Scratch_Formula_FormulaSatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8)
    
end
module Scratch_Formula_FormulaSatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  predicate formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 34 4 37 5] forall i : int . 0 <= i /\ i < Seq.length (let (a, _) = f in a) -> SatInner0.sat_inner (Seq.get (let (a, _) = f in a) i) a
  val formula_sat_inner [#"../Scratch/src/formula.rs" 33 0 33 78] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (a : Seq.seq uint8) : bool
    ensures { result = formula_sat_inner f a }
    
end
module Scratch_Formula_EventuallySatComplete_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_EventuallySatComplete_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_EventuallySatComplete
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_FormulaSatInner_Stub as FormulaSatInner0
  clone Scratch_Assignments_CompleteInner_Stub as CompleteInner0
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/formula.rs" 42 4 44 5] exists a2 : Seq.seq uint8 . Seq.length a2 = (let (_, a) = f in a) /\ CompleteInner0.complete_inner a2 /\ FormulaSatInner0.formula_sat_inner f a2
  val eventually_sat_complete [#"../Scratch/src/formula.rs" 41 0 41 61] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = eventually_sat_complete f }
    
end
module Scratch_Clause_EquisatExtensionInner_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_EquisatExtensionInner_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_EquisatExtensionInner
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_EventuallySatComplete_Stub as EventuallySatComplete0
  predicate equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/clause.rs" 39 4 41 5] EventuallySatComplete0.eventually_sat_complete f -> EventuallySatComplete0.eventually_sat_complete (Seq.snoc (let (a, _) = f in a) c, let (_, a) = f in a)
  val equisat_extension_inner [#"../Scratch/src/clause.rs" 38 0 38 72] (c : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = equisat_extension_inner c f }
    
end
module Scratch_Lit_Impl3_UnsatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  predicate unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
   =
    [#"../Scratch/src/lit.rs" 118 12 121 13] if IsPositiveLogic0.is_positive_logic self then
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 0
    else
      UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) = 1
    
  val unsat_inner [#"../Scratch/src/lit.rs" 116 4 116 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) : bool
    ensures { result = unsat_inner self a }
    
end
module Scratch_Clause_Impl1_PostUnitInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_PostUnitInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_PostUnitInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsatInner_Stub as UnsatInner0
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 61 8 65 9] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) /\ SatInner0.sat_inner (Seq.get (ShallowModel0.shallow_model self) i) a /\ (forall j : int . 0 <= j /\ j < Seq.length (ShallowModel0.shallow_model self) /\ j <> i -> UnsatInner0.unsat_inner (Seq.get (ShallowModel0.shallow_model self) j) a)
  val post_unit_inner [#"../Scratch/src/clause.rs" 60 4 60 63] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = post_unit_inner self a }
    
end
module Scratch_Lit_Impl3_UnsetInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsetInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
end
module Scratch_Lit_Impl3_UnsetInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8)
   =
    [#"../Scratch/src/lit.rs" 127 20 127 47] UInt8.to_int (Seq.get a (IndexLogic0.index_logic self)) >= 2
  val unset_inner [#"../Scratch/src/lit.rs" 126 4 126 59] (self : Scratch_Lit_Lit_Type.t_lit) (a : Seq.seq uint8) : bool
    ensures { result = unset_inner self a }
    
end
module Scratch_Clause_Impl1_NoUnsetInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_NoUnsetInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_NoUnsetInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsetInner_Stub as UnsetInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 70 8 72 9] forall j : int . 0 <= j /\ j < Seq.length (ShallowModel0.shallow_model self) -> not UnsetInner0.unset_inner (Seq.get (ShallowModel0.shallow_model self) j) a
  val no_unset_inner [#"../Scratch/src/clause.rs" 69 4 69 62] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = no_unset_inner self a }
    
end
module Scratch_Clause_Impl1_PostUnit_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl1_PostUnit_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl1_PostUnit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl1_PostUnitInner_Stub as PostUnitInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 77 20 77 44] PostUnitInner0.post_unit_inner self (ShallowModel0.shallow_model a)
  val post_unit [#"../Scratch/src/clause.rs" 76 4 76 50] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = post_unit self a }
    
end
module Scratch_Clause_Impl1_EqAssnInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_EqAssnInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
end
module Scratch_Clause_Impl1_EqAssnInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 82 8 85 9] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> Seq.get a (IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model self) i)) = Seq.get a2 (IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model self) i))
  val eq_assn_inner [#"../Scratch/src/clause.rs" 81 4 81 85] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8) : bool
    ensures { result = eq_assn_inner self a a2 }
    
end
module Scratch_Formula_Impl0_ShallowModel_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  function shallow_model [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    
end
module Scratch_Formula_Impl0_ShallowModel_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  function shallow_model [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    
end
module Scratch_Formula_Impl0_ShallowModel
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  function shallow_model [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    
   =
    [#"../Scratch/src/formula.rs" 20 8 20 69] (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self), UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self))
  val shallow_model [#"../Scratch/src/formula.rs" 19 4 19 50] (self : Scratch_Formula_Formula_Type.t_formula) : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)
    ensures { result = shallow_model self }
    
end
module Scratch_Clause_Impl2_EquisatExtension_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_EquisatExtension_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_EquisatExtension
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_EquisatExtensionInner_Stub as EquisatExtensionInner0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_ShallowModel_Stub as ShallowModel0
  predicate equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/clause.rs" 92 20 92 53] EquisatExtensionInner0.equisat_extension_inner self (ShallowModel0.shallow_model f)
  val equisat_extension [#"../Scratch/src/clause.rs" 91 4 91 54] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = equisat_extension self f }
    
end
module Scratch_Clause_Impl2_SameIdxSamePolarityExcept_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int)
    
end
module Scratch_Clause_Impl2_SameIdxSamePolarityExcept_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int)
    
end
module Scratch_Clause_Impl2_SameIdxSamePolarityExcept
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int)
    
   =
    [#"../Scratch/src/clause.rs" 97 8 102 9] forall j : int . forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) /\ 0 <= j /\ j < Seq.length (ShallowModel0.shallow_model other) -> IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model self) i) <> exception' /\ IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model self) i) = IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model other) j) -> IsPositiveLogic0.is_positive_logic (Seq.get (ShallowModel0.shallow_model self) i) = IsPositiveLogic0.is_positive_logic (Seq.get (ShallowModel0.shallow_model other) j)
  val same_idx_same_polarity_except [#"../Scratch/src/clause.rs" 96 4 96 85] (self : Scratch_Clause_Clause_Type.t_clause) (other : Scratch_Clause_Clause_Type.t_clause) (exception' : int) : bool
    ensures { result = same_idx_same_polarity_except self other exception' }
    
end
module Scratch_Lit_Impl3_LitIn_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIn_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIn
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
   =
    [#"../Scratch/src/lit.rs" 89 8 89 76] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model c) /\ Seq.get (ShallowModel0.shallow_model c) i = self
  val lit_in [#"../Scratch/src/lit.rs" 88 4 88 42] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = lit_in self c }
    
end
module Scratch_Lit_Impl3_IsOpp_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Lit_Impl3_IsOpp_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit)
    
end
module Scratch_Lit_Impl3_IsOpp
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit)
    
   =
    [#"../Scratch/src/lit.rs" 78 12 78 102] IndexLogic0.index_logic self = IndexLogic0.index_logic o /\ IsPositiveLogic0.is_positive_logic self <> IsPositiveLogic0.is_positive_logic o
  val is_opp [#"../Scratch/src/lit.rs" 76 4 76 39] (self : Scratch_Lit_Lit_Type.t_lit) (o : Scratch_Lit_Lit_Type.t_lit) : bool
    ensures { result = is_opp self o }
    
end
module Scratch_Clause_Impl2_ResolventOf_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int)
    
end
module Scratch_Clause_Impl2_ResolventOf_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int)
    
end
module Scratch_Clause_Impl2_ResolventOf
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_IsOpp_Stub as IsOpp0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Lit_Impl3_LitIn_Stub as LitIn0
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int)
    
   =
    [#"../Scratch/src/clause.rs" 107 8 114 9] (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model c) /\ i <> m -> LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model c) i) self) /\ (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model c2) /\ i <> k -> LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model c2) i) self) /\ (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model self) i) c \/ LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model self) i) c2) /\ not LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model c) m) self /\ not LitIn0.lit_in (Seq.get (ShallowModel0.shallow_model c2) k) self /\ IsOpp0.is_opp (Seq.get (ShallowModel0.shallow_model c2) k) (Seq.get (ShallowModel0.shallow_model c) m)
  val resolvent_of [#"../Scratch/src/clause.rs" 106 4 106 76] (self : Scratch_Clause_Clause_Type.t_clause) (c : Scratch_Clause_Clause_Type.t_clause) (c2 : Scratch_Clause_Clause_Type.t_clause) (k : int) (m : int) : bool
    ensures { result = resolvent_of self c c2 k m }
    
end
module Scratch_Clause_Impl2_InFormula_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_InFormula_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Clause_Impl2_InFormula
  use prelude.Int
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/clause.rs" 119 8 122 9] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses f)) /\ Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses f)) i = self
  val in_formula [#"../Scratch/src/clause.rs" 118 4 118 47] (self : Scratch_Clause_Clause_Type.t_clause) (f : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = in_formula self f }
    
end
module Scratch_Clause_Impl2_InFormulaInner_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_Impl2_InFormulaInner_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Clause_Impl2_InFormulaInner
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/clause.rs" 127 8 129 9] exists i : int . 0 <= i /\ i < Seq.length (let (a, _) = f in a) /\ Seq.get (let (a, _) = f in a) i = self
  val in_formula_inner [#"../Scratch/src/clause.rs" 126 4 126 64] (self : Scratch_Clause_Clause_Type.t_clause) (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = in_formula_inner self f }
    
end
module Scratch_Clause_Impl2_VarsInRange_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
    
end
module Scratch_Clause_Impl2_VarsInRange_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
    
end
module Scratch_Clause_Impl2_VarsInRange
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_VarsInRangeInner_Stub as VarsInRangeInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
    
   =
    [#"../Scratch/src/clause.rs" 183 20 183 49] VarsInRangeInner0.vars_in_range_inner (ShallowModel0.shallow_model self) n
  val vars_in_range [#"../Scratch/src/clause.rs" 182 4 182 46] (self : Scratch_Clause_Clause_Type.t_clause) (n : int) : bool
    ensures { result = vars_in_range self n }
    
end
module Scratch_Clause_Impl2_UnitInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnitInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnitInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsetInner_Stub as UnsetInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  clone Scratch_Clause_Impl2_VarsInRange_Stub as VarsInRange0
  predicate unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 134 8 141 9] VarsInRange0.vars_in_range self (Seq.length a) /\ not SatInner0.sat_inner self a /\ (exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) /\ UnsetInner0.unset_inner (Seq.get (ShallowModel0.shallow_model self) i) a /\ (forall j : int . 0 <= j /\ j < Seq.length (ShallowModel0.shallow_model self) /\ j <> i -> not UnsetInner0.unset_inner (Seq.get (ShallowModel0.shallow_model self) j) a))
  val unit_inner [#"../Scratch/src/clause.rs" 133 4 133 54] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = unit_inner self a }
    
end
module Scratch_Clause_Impl2_Unit_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unit_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_UnitInner_Stub as UnitInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 145 20 145 39] UnitInner0.unit_inner self (ShallowModel0.shallow_model a)
  val unit [#"../Scratch/src/clause.rs" 144 4 144 45] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unit self a }
    
end
module Scratch_Clause_Impl2_UnsatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnsatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
end
module Scratch_Clause_Impl2_UnsatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsatInner_Stub as UnsatInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/clause.rs" 150 8 153 9] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> UnsatInner0.unsat_inner (Seq.get (ShallowModel0.shallow_model self) i) a
  val unsat_inner [#"../Scratch/src/clause.rs" 149 4 149 59] (self : Scratch_Clause_Clause_Type.t_clause) (a : Seq.seq uint8) : bool
    ensures { result = unsat_inner self a }
    
end
module Scratch_Clause_Impl2_Unsat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unsat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unsat
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_UnsatInner_Stub as UnsatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 158 20 158 40] UnsatInner0.unsat_inner self (ShallowModel0.shallow_model a)
  val unsat [#"../Scratch/src/clause.rs" 157 4 157 46] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unsat self a }
    
end
module Scratch_Clause_Impl2_Sat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Sat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Sat
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 172 12 172 30] SatInner0.sat_inner self (ShallowModel0.shallow_model a)
  val sat [#"../Scratch/src/clause.rs" 170 4 170 44] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = sat self a }
    
end
module Scratch_Clause_Impl2_Unknown_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unknown_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Clause_Impl2_Unknown
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  predicate unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/clause.rs" 178 8 178 38] not Sat0.sat self a /\ not Unsat0.unsat self a
  val unknown [#"../Scratch/src/clause.rs" 177 4 177 48] (self : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unknown self a }
    
end
module Scratch_Clause_Impl2_NoDuplicateIndexes_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_NoDuplicateIndexes_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_NoDuplicateIndexes
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_NoDuplicateIndexesInner_Stub as NoDuplicateIndexesInner0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause)
   =
    [#"../Scratch/src/clause.rs" 188 20 188 53] NoDuplicateIndexesInner0.no_duplicate_indexes_inner (ShallowModel0.shallow_model self)
  val no_duplicate_indexes [#"../Scratch/src/clause.rs" 187 4 187 45] (self : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = no_duplicate_indexes self }
    
end
module Scratch_Clause_Impl2_SearchIdxInRange_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_SearchIdxInRange_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause)
end
module Scratch_Clause_Impl2_SearchIdxInRange
  use prelude.UIntSize
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause)
   =
    [#"../Scratch/src/clause.rs" 193 20 193 68] 2 <= UIntSize.to_int (Scratch_Clause_Clause_Type.clause_search self) /\ UIntSize.to_int (Scratch_Clause_Clause_Type.clause_search self) <= Seq.length (ShallowModel0.shallow_model self)
  val search_idx_in_range [#"../Scratch/src/clause.rs" 192 4 192 44] (self : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = search_idx_in_range self }
    
end
module Scratch_Clause_Impl2_Invariant_Stub
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
end
module Scratch_Clause_Impl2_Invariant_Interface
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
end
module Scratch_Clause_Impl2_Invariant
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Clause_InvariantInternal_Stub as InvariantInternal0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int)
   =
    [#"../Scratch/src/clause.rs" 198 20 198 48] InvariantInternal0.invariant_internal (ShallowModel0.shallow_model self) n
  val invariant' [#"../Scratch/src/clause.rs" 197 4 197 42] (self : Scratch_Clause_Clause_Type.t_clause) (n : int) : bool
    ensures { result = invariant' self n }
    
end
module Scratch_Lit_IdxInLogic_Stub
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_IdxInLogic_Interface
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_IdxInLogic
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  predicate idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
   =
    [#"../Scratch/src/lit.rs" 40 4 43 5] exists i : int . 0 <= i /\ i < Seq.length c /\ IndexLogic0.index_logic (Seq.get c i) = idx
  val idx_in_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 39 0 39 50] (idx : int) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) : bool
    ensures { result = idx_in_logic idx c }
    
end
module Scratch_Clause_Impl2_ClauseIsSeen_Stub
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global))
    
end
module Scratch_Clause_Impl2_ClauseIsSeen_Interface
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global))
    
end
module Scratch_Clause_Impl2_ClauseIsSeen
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Lit_IdxInLogic_Stub as IdxInLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel1
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global))
    
   =
    [#"../Scratch/src/clause.rs" 203 8 206 9] forall idx : int . 0 <= idx /\ idx < Seq.length (ShallowModel0.shallow_model seen) -> Seq.get (ShallowModel0.shallow_model seen) idx = IdxInLogic0.idx_in_logic idx (ShallowModel1.shallow_model self)
  val clause_is_seen [#"../Scratch/src/clause.rs" 202 4 202 56] (self : Scratch_Clause_Clause_Type.t_clause) (seen : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = clause_is_seen self seen }
    
end
module Scratch_Clause_Impl2_Equals_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Clause_Impl2_Equals_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Clause_Impl2_Equals
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause)
    
   =
    [#"../Scratch/src/clause.rs" 211 8 215 9] Seq.length (ShallowModel0.shallow_model self) = Seq.length (ShallowModel0.shallow_model o) /\ (forall j : int . 0 <= j /\ j < Seq.length (ShallowModel0.shallow_model self) -> Seq.get (ShallowModel0.shallow_model self) j = Seq.get (ShallowModel0.shallow_model o) j)
  val equals [#"../Scratch/src/clause.rs" 210 4 210 42] (self : Scratch_Clause_Clause_Type.t_clause) (o : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = equals self o }
    
end
module Scratch_Formula_FormulaInvariant_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_FormulaInvariant_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_FormulaInvariant
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Invariant_Stub as Invariant0
  predicate formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/formula.rs" 26 4 29 5] forall i : int . 0 <= i /\ i < Seq.length (let (a, _) = f in a) -> Invariant0.invariant' (Seq.get (let (a, _) = f in a) i) (let (_, a) = f in a) /\ Seq.length (ShallowModel0.shallow_model (Seq.get (let (a, _) = f in a) i)) > 0
  val formula_invariant [#"../Scratch/src/formula.rs" 25 0 25 55] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = formula_invariant f }
    
end
module Scratch_Formula_Equisat_Stub
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_Equisat_Interface
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  predicate equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
end
module Scratch_Formula_Equisat
  use seq.Seq
  use prelude.Int
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_EventuallySatComplete_Stub as EventuallySatComplete0
  predicate equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int))
    
   =
    [#"../Scratch/src/formula.rs" 50 8 50 64] EventuallySatComplete0.eventually_sat_complete f = EventuallySatComplete0.eventually_sat_complete o
  val equisat [#"../Scratch/src/formula.rs" 48 0 48 64] (f : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) (o : (Seq.seq (Scratch_Clause_Clause_Type.t_clause), int)) : bool
    ensures { result = equisat f o }
    
end
module Scratch_Formula_Impl1_SatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_SatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_SatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Clause_Impl2_SatInner_Stub as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 108 8 111 9] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) -> SatInner0.sat_inner (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) i) a
  val sat_inner [#"../Scratch/src/formula.rs" 107 4 107 57] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = sat_inner self a }
    
end
module Scratch_Formula_Impl1_EventuallySatComplete_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_EventuallySatComplete_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_EventuallySatComplete
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use prelude.UIntSize
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner_Stub as SatInner0
  clone Scratch_Assignments_CompleteInner_Stub as CompleteInner0
  predicate eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/formula.rs" 58 8 60 9] exists a2 : Seq.seq uint8 . Seq.length a2 = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self) /\ CompleteInner0.complete_inner a2 /\ SatInner0.sat_inner self a2
  val eventually_sat_complete [#"../Scratch/src/formula.rs" 57 4 57 48] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = eventually_sat_complete self }
    
end
module Scratch_Formula_Impl1_Equisat_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_Equisat_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula)
    
end
module Scratch_Formula_Impl1_Equisat
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_EventuallySatComplete_Stub as EventuallySatComplete0
  predicate equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula)
    
   =
    [#"../Scratch/src/formula.rs" 65 8 65 69] EventuallySatComplete0.eventually_sat_complete self = EventuallySatComplete0.eventually_sat_complete o
  val equisat [#"../Scratch/src/formula.rs" 64 4 64 44] (self : Scratch_Formula_Formula_Type.t_formula) (o : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = equisat self o }
    
end
module Scratch_Formula_Impl1_InvariantMirror_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_InvariantMirror_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_InvariantMirror
  use prelude.Int
  use seq.Seq
  use prelude.UIntSize
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel1
  clone Scratch_Clause_Impl2_Invariant_Stub as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula) =
    [#"../Scratch/src/formula.rs" 78 12 82 45] (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) -> Invariant0.invariant' (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) i) (UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self))) /\ (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) -> Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) i)) >= 1)
  val invariant_mirror [#"../Scratch/src/formula.rs" 76 4 76 37] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = invariant_mirror self }
    
end
module Scratch_Formula_Impl1_Invariant_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_Invariant_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula)
  axiom invariant'_spec : forall self : Scratch_Formula_Formula_Type.t_formula . [#"../Scratch/src/formula.rs" 70 14 70 47] invariant' self = InvariantMirror0.invariant_mirror self
end
module Scratch_Formula_Impl1_Invariant
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_FormulaInvariant_Stub as FormulaInvariant0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula) =
    [#"../Scratch/src/formula.rs" 72 20 72 44] FormulaInvariant0.formula_invariant (ShallowModel0.shallow_model self)
  val invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = invariant' self }
    
  axiom invariant'_spec : forall self : Scratch_Formula_Formula_Type.t_formula . [#"../Scratch/src/formula.rs" 70 14 70 47] invariant' self = InvariantMirror0.invariant_mirror self
end
module Scratch_Formula_Impl1_Invariant_Impl
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl3_Invariant as Invariant1 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_VarsInRangeInner as VarsInRangeInner0 with
    predicate Invariant0.invariant' = Invariant1.invariant'
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel3 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Clause_InvariantInternal as InvariantInternal0 with
    predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
    predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel as ShallowModel2 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Formula_FormulaInvariant as FormulaInvariant0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_ShallowModel as ShallowModel0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Formula_Impl1_InvariantMirror as InvariantMirror0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec ghost predicate invariant' [#"../Scratch/src/formula.rs" 71 4 71 34] (self : Scratch_Formula_Formula_Type.t_formula)
    ensures { [#"../Scratch/src/formula.rs" 70 14 70 47] result = InvariantMirror0.invariant_mirror self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/formula.rs" 72 20 72 44] let a' = ShallowModel0.shallow_model self in FormulaInvariant0.formula_invariant a'
end
module Scratch_Formula_Impl1_EventuallySatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use prelude.UIntSize
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner_Stub as SatInner0
  clone Scratch_Assignments_CompatibleInner_Stub as CompatibleInner0
  predicate eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 89 8 91 9] exists a2 : Seq.seq uint8 . Seq.length a2 = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self) /\ CompatibleInner0.compatible_inner a a2 /\ SatInner0.sat_inner self a2
  val eventually_sat_inner [#"../Scratch/src/formula.rs" 88 4 88 64] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = eventually_sat_inner self a }
    
end
module Scratch_Formula_Impl1_EventuallySatCompleteInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatCompleteInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_EventuallySatCompleteInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use prelude.UIntSize
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner_Stub as SatInner0
  clone Scratch_Assignments_CompatibleCompleteInner_Stub as CompatibleCompleteInner0
  predicate eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 96 8 98 9] exists a2 : Seq.seq uint8 . Seq.length a2 = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars self) /\ CompatibleCompleteInner0.compatible_complete_inner a a2 /\ SatInner0.sat_inner self a2
  val eventually_sat_complete_inner [#"../Scratch/src/formula.rs" 95 4 95 73] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = eventually_sat_complete_inner self a }
    
end
module Scratch_Formula_Impl1_EventuallySat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_EventuallySat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_EventuallySat
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_EventuallySatInner_Stub as EventuallySatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/formula.rs" 103 20 103 49] EventuallySatInner0.eventually_sat_inner self (ShallowModel0.shallow_model a)
  val eventually_sat [#"../Scratch/src/formula.rs" 102 4 102 51] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = eventually_sat self a }
    
end
module Scratch_Formula_Impl1_Sat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Sat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Sat
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Formula_FormulaSatInner_Stub as FormulaSatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel1
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl0_ShallowModel_Stub as ShallowModel0
  predicate sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/formula.rs" 116 20 116 48] FormulaSatInner0.formula_sat_inner (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model a)
  val sat [#"../Scratch/src/formula.rs" 115 4 115 44] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = sat self a }
    
end
module Scratch_Formula_Impl1_UnsatInner_Stub
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_UnsatInner_Interface
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
end
module Scratch_Formula_Impl1_UnsatInner
  use seq.Seq
  use prelude.Int
  use prelude.UInt8
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone Scratch_Clause_Impl2_UnsatInner_Stub as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8)
    
   =
    [#"../Scratch/src/formula.rs" 121 8 124 9] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) /\ UnsatInner0.unsat_inner (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses self)) i) a
  val unsat_inner [#"../Scratch/src/formula.rs" 120 4 120 55] (self : Scratch_Formula_Formula_Type.t_formula) (a : Seq.seq uint8) : bool
    ensures { result = unsat_inner self a }
    
end
module Scratch_Formula_Impl1_Unsat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Unsat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Formula_Impl1_Unsat
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_UnsatInner_Stub as UnsatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/formula.rs" 129 20 129 40] UnsatInner0.unsat_inner self (ShallowModel0.shallow_model a)
  val unsat [#"../Scratch/src/formula.rs" 128 4 128 46] (self : Scratch_Formula_Formula_Type.t_formula) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unsat self a }
    
end
module Scratch_Formula_Impl1_NotSatisfiable_Stub
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_NotSatisfiable_Interface
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  predicate not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula)
end
module Scratch_Formula_Impl1_NotSatisfiable
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl2_EquisatExtension_Stub as EquisatExtension0
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula)
   =
    [#"../Scratch/src/formula.rs" 134 8 134 82] exists c : Scratch_Clause_Clause_Type.t_clause . Seq.length (ShallowModel0.shallow_model c) = 0 /\ EquisatExtension0.equisat_extension c self
  val not_satisfiable [#"../Scratch/src/formula.rs" 133 4 133 40] (self : Scratch_Formula_Formula_Type.t_formula) : bool
    ensures { result = not_satisfiable self }
    
end
module Scratch_Lit_Impl4_Clone_Interface
  use prelude.Borrow
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  val clone' [#"../Scratch/src/lit.rs" 10 9 10 14] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { [#"../Scratch/src/lit.rs" 10 9 10 14] result = self }
    
end
module Scratch_Lit_Impl4_Clone
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  clone Core_Clone_Impls_Impl19_Clone_Interface as Clone1
  clone Core_Clone_Impls_Impl5_Clone_Interface as Clone0
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  let rec cfg clone' [#"../Scratch/src/lit.rs" 10 9 10 14] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { [#"../Scratch/src/lit.rs" 10 9 10 14] result = self }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Lit_Lit_Type.t_lit;
  var self_1 : Scratch_Lit_Lit_Type.t_lit;
  var _3 : usize;
  var _4 : usize;
  var _5 : usize;
  var _6 : bool;
  var _7 : bool;
  var _8 : bool;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _5 <- Scratch_Lit_Lit_Type.lit_idx self_1;
    _4 <- _5;
    _3 <- ([#"../Scratch/src/lit.rs" 12 4 12 18] Clone0.clone' _4);
    goto BB1
  }
  BB1 {
    _8 <- Scratch_Lit_Lit_Type.lit_polarity self_1;
    _7 <- _8;
    _6 <- ([#"../Scratch/src/lit.rs" 13 4 13 22] Clone1.clone' _7);
    goto BB2
  }
  BB2 {
    _0 <- Scratch_Lit_Lit_Type.C_Lit _3 _6;
    return _0
  }
  
end
module Scratch_Lit_Impl0_ShallowModel_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function shallow_model [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl0_ShallowModel_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function shallow_model [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl0_ShallowModel
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function shallow_model [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
   =
    [#"../Scratch/src/lit.rs" 22 8 22 12] self
  val shallow_model [#"../Scratch/src/lit.rs" 21 4 21 34] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { result = shallow_model self }
    
end
module Scratch_Lit_Impl1_DeepModel_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl1_DeepModel_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
end
module Scratch_Lit_Impl1_DeepModel
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    
   =
    [#"../Scratch/src/lit.rs" 32 8 32 12] self
  val deep_model [#"../Scratch/src/lit.rs" 31 4 31 31] (self : Scratch_Lit_Lit_Type.t_lit) : Scratch_Lit_Lit_Type.t_lit
    ensures { result = deep_model self }
    
end
module Scratch_Lit_Impl2_ToWatchidxLogic_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToWatchidxLogic_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToWatchidxLogic
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  function to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
   =
    [#"../Scratch/src/lit.rs" 63 8 63 91] IndexLogic0.index_logic self * 2 + (if IsPositiveLogic0.is_positive_logic self then
      0
    else
      1
    )
  val to_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 62 4 62 41] (self : Scratch_Lit_Lit_Type.t_lit) : int
    ensures { result = to_watchidx_logic self }
    
end
module Scratch_Lit_Impl2_ToNegWatchidxLogic_Stub
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToNegWatchidxLogic_Interface
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  function to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
end
module Scratch_Lit_Impl2_ToNegWatchidxLogic
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IsPositiveLogic_Stub as IsPositiveLogic0
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  function to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    
   =
    [#"../Scratch/src/lit.rs" 69 8 69 91] IndexLogic0.index_logic self * 2 + (if IsPositiveLogic0.is_positive_logic self then
      1
    else
      0
    )
  val to_neg_watchidx_logic [@inline:trivial] [#"../Scratch/src/lit.rs" 68 4 68 45] (self : Scratch_Lit_Lit_Type.t_lit) : int
    ensures { result = to_neg_watchidx_logic self }
    
end
module Scratch_Lit_Impl3_LitInInternal_Stub
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_Impl3_LitInInternal_Interface
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
end
module Scratch_Lit_Impl3_LitInInternal
  use seq.Seq
  use prelude.Int
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit))
    
   =
    [#"../Scratch/src/lit.rs" 84 8 84 74] exists i : int . 0 <= i /\ i < Seq.length c /\ Seq.get c i = self
  val lit_in_internal [#"../Scratch/src/lit.rs" 83 4 83 53] (self : Scratch_Lit_Lit_Type.t_lit) (c : Seq.seq (Scratch_Lit_Lit_Type.t_lit)) : bool
    ensures { result = lit_in_internal self c }
    
end
module Scratch_Lit_Impl3_LitIdxIn_Stub
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIdxIn_Interface
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
end
module Scratch_Lit_Impl3_LitIdxIn
  use prelude.Int
  use seq.Seq
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic_Stub as IndexLogic0
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  predicate lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause)
    
   =
    [#"../Scratch/src/lit.rs" 94 8 97 9] exists i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model c) /\ IndexLogic0.index_logic (Seq.get (ShallowModel0.shallow_model c) i) = IndexLogic0.index_logic self
  val lit_idx_in [#"../Scratch/src/lit.rs" 93 4 93 46] (self : Scratch_Lit_Lit_Type.t_lit) (c : Scratch_Clause_Clause_Type.t_clause) : bool
    ensures { result = lit_idx_in self c }
    
end
module Scratch_Lit_Impl3_Sat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Sat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Sat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/lit.rs" 132 20 132 38] SatInner0.sat_inner self (ShallowModel0.shallow_model a)
  val sat [#"../Scratch/src/lit.rs" 131 4 131 44] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = sat self a }
    
end
module Scratch_Lit_Impl3_Unset_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unset_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unset
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsetInner_Stub as UnsetInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/lit.rs" 137 20 137 40] UnsetInner0.unset_inner self (ShallowModel0.shallow_model a)
  val unset [#"../Scratch/src/lit.rs" 136 4 136 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unset self a }
    
end
module Scratch_Lit_Impl3_Unsat_Stub
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unsat_Interface
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  predicate unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
end
module Scratch_Lit_Impl3_Unsat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl3_UnsatInner_Stub as UnsatInner0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel0
  predicate unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments)
    
   =
    [#"../Scratch/src/lit.rs" 142 20 142 40] UnsatInner0.unsat_inner self (ShallowModel0.shallow_model a)
  val unsat [#"../Scratch/src/lit.rs" 141 4 141 46] (self : Scratch_Lit_Lit_Type.t_lit) (a : Scratch_Assignments_Assignments_Type.t_assignments) : bool
    ensures { result = unsat self a }
    
end
module CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub
  type t
  use seq.Seq
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t)
end
module CreusotContracts_Logic_Seq_Impl0_PermutationOf_Interface
  type t
  use seq.Seq
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t)
end
module CreusotContracts_Logic_Seq_Impl0_PermutationOf
  type t
  use seq.Seq
  use seq.Permut
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/logic/seq.rs" 89 8 89 37] Permut.permut self o 0 (Seq.length self)
  val permutation_of (self : Seq.seq t) (o : Seq.seq t) : bool
    ensures { result = permutation_of self o }
    
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
  axiom lemma_clause_permuted_maintains_sat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a) -> ([#"../Scratch/src/scratch.rs" 25 0 25 67] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Sat0.sat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Sat_Stub as Sat0
  function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
   =
    [#"../Scratch/src/scratch.rs" 23 0 23 8] ()
  val lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a}
    ensures { result = lemma_clause_permuted_maintains_sat c a }
    
  axiom lemma_clause_permuted_maintains_sat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a) -> ([#"../Scratch/src/scratch.rs" 25 0 25 67] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Sat0.sat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsSat_Impl
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic as IsPositiveLogic0
  clone Scratch_Lit_Impl3_SatInner as SatInner1 with
    function IsPositiveLogic0.is_positive_logic = IsPositiveLogic0.is_positive_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel3 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel2 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel as ShallowModel0 with
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_SatInner as SatInner0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate SatInner0.sat_inner = SatInner1.sat_inner
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel as ShallowModel1 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  clone Scratch_Clause_Impl2_Sat as Sat0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate SatInner0.sat_inner = SatInner0.sat_inner
  let rec ghost function lemma_clause_permuted_maintains_sat [#"../Scratch/src/scratch.rs" 26 0 26 69] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 24 11 24 19] Sat0.sat c a}
    ensures { [#"../Scratch/src/scratch.rs" 25 0 25 67] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Sat0.sat c2 a }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/scratch.rs" 23 0 23 8] ()
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat_Stub
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat_Interface
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
  axiom lemma_clause_permuted_maintains_unsat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a) -> ([#"../Scratch/src/scratch.rs" 30 0 30 69] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Unsat0.unsat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf_Stub as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel0
  clone Scratch_Clause_Impl2_Unsat_Stub as Unsat0
  function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    
   =
    [#"../Scratch/src/scratch.rs" 28 0 28 8] ()
  val lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a}
    ensures { result = lemma_clause_permuted_maintains_unsat c a }
    
  axiom lemma_clause_permuted_maintains_unsat_spec : forall c : Scratch_Clause_Clause_Type.t_clause, a : Scratch_Assignments_Assignments_Type.t_assignments . ([#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a) -> ([#"../Scratch/src/scratch.rs" 30 0 30 69] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Unsat0.unsat c2 a)
end
module Scratch_Scratch_LemmaClausePermutedMaintainsUnsat_Impl
  use prelude.Int
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl2_IsPositiveLogic as IsPositiveLogic0
  clone Scratch_Lit_Impl3_UnsatInner as UnsatInner1 with
    function IsPositiveLogic0.is_positive_logic = IsPositiveLogic0.is_positive_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel3 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel2 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel as ShallowModel0 with
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_UnsatInner as UnsatInner0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel as ShallowModel1 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Logic_Seq_Impl0_PermutationOf as PermutationOf0 with
    type t = Scratch_Lit_Lit_Type.t_lit
  clone Scratch_Clause_Impl2_Unsat as Unsat0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  let rec ghost function lemma_clause_permuted_maintains_unsat [#"../Scratch/src/scratch.rs" 31 0 31 71] (c : Scratch_Clause_Clause_Type.t_clause) (a : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 29 11 29 21] Unsat0.unsat c a}
    ensures { [#"../Scratch/src/scratch.rs" 30 0 30 69] forall c2 : Scratch_Clause_Clause_Type.t_clause . PermutationOf0.permutation_of (ShallowModel0.shallow_model c2) (ShallowModel0.shallow_model c) -> Unsat0.unsat c2 a }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/scratch.rs" 28 0 28 8] ()
end
module CreusotContracts_Resolve_Impl1_Resolve_Stub
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve_Interface
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Resolve_Impl1_Resolve
  type t
  use prelude.Borrow
  predicate resolve (self : borrowed t) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/resolve.rs" 23 20 23 34]  ^ self =  * self
  val resolve (self : borrowed t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Model_ShallowModel_ShallowModelTy_Type
  type self
  type shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Stub
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel_Interface
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_ShallowModel_ShallowModel
  type self
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = self
  function shallow_model (self : self) : ShallowModelTy0.shallowModelTy
  val shallow_model (self : self) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Model_Impl3_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl3_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/model.rs" 54 8 54 31] ShallowModel0.shallow_model ( * self)
  val shallow_model (self : borrowed t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
end
module CreusotContracts_Std1_Slice_SliceIndex_InBounds
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy)
  val in_bounds (self : self) (seq : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = in_bounds self seq }
    
end
module Core_Slice_Index_SliceIndex_Output_Type
  type self
  type t
  type output
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue_Interface
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
end
module CreusotContracts_Std1_Slice_SliceIndex_HasValue
  type self
  type t
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = self,
    type t = t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output)
  val has_value (self : self) (seq : ShallowModelTy0.shallowModelTy) (out : Output0.output) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Interface
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
end
module CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere
  type self
  type t
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  predicate resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy)
    
  val resolve_elswhere (self : self) (old' : ShallowModelTy0.shallowModelTy) (fin : ShallowModelTy0.shallowModelTy) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Alloc_Vec_Impl14_IndexMut_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_ResolveElswhere_Stub as ResolveElswhere0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (index : i) : borrowed Output0.output
    requires {[#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 118 27 118 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 119 26 119 54] HasValue0.has_value index (ShallowModel0.shallow_model self) ( * result) }
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 120 26 120 57] HasValue0.has_value index (ShallowModel1.shallow_model ( ^ self)) ( ^ result) }
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 121 26 121 62] ResolveElswhere0.resolve_elswhere index (ShallowModel0.shallow_model self) (ShallowModel1.shallow_model ( ^ self)) }
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 122 26 122 55] Seq.length (ShallowModel1.shallow_model ( ^ self)) = Seq.length (ShallowModel0.shallow_model self) }
    
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : slice t) : Seq.seq t
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel_Interface
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : slice t) : Seq.seq t
  axiom shallow_model_spec : forall self : slice t . ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model self = Slice.id self) && ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module CreusotContracts_Std1_Slice_Impl0_ShallowModel
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  function shallow_model (self : slice t) : Seq.seq t
  val shallow_model (self : slice t) : Seq.seq t
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : slice t . ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 18 14 18 41] shallow_model self = Slice.id self) && ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 17 14 17 41] Seq.length (shallow_model self) <= UIntSize.to_int Max0.mAX')
end
module Alloc_Vec_Impl10_DerefMut_Interface
  type t
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel3 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel2 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val deref_mut (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) : borrowed (slice t)
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 138 26 138 42] ShallowModel0.shallow_model result = ShallowModel1.shallow_model self }
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 139 26 139 48] ShallowModel2.shallow_model ( ^ result) = ShallowModel3.shallow_model ( ^ self) }
    
end
module Core_Slice_Impl0_Swap_Interface
  type t
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use seq.Permut
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val swap (self : borrowed (slice t)) (a : usize) (b : usize) : ()
    requires {[#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 213 19 213 35] UIntSize.to_int a < Seq.length (ShallowModel0.shallow_model self)}
    requires {[#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 214 19 214 35] UIntSize.to_int b < Seq.length (ShallowModel0.shallow_model self)}
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 215 8 215 52] Permut.exchange (ShallowModel1.shallow_model ( ^ self)) (ShallowModel0.shallow_model self) (UIntSize.to_int a) (UIntSize.to_int b) }
    
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_InBounds
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 102 20 102 37] UIntSize.to_int self < Seq.length seq
  val in_bounds [@inline:trivial] (self : usize) (seq : Seq.seq t) : bool
    ensures { result = in_bounds self seq }
    
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t)
end
module CreusotContracts_Std1_Slice_Impl5_HasValue
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 108 20 108 37] Seq.get seq (UIntSize.to_int self) = out
  val has_value [@inline:trivial] (self : usize) (seq : Seq.seq t) (out : t) : bool
    ensures { result = has_value self seq out }
    
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Stub
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere_Interface
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t)
end
module CreusotContracts_Std1_Slice_Impl5_ResolveElswhere
  type t
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  predicate resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 114 8 114 96] forall i : int . 0 <= i /\ i <> UIntSize.to_int self /\ i < Seq.length old' -> Seq.get old' i = Seq.get fin i
  val resolve_elswhere [@inline:trivial] (self : usize) (old' : Seq.seq t) (fin : Seq.seq t) : bool
    ensures { result = resolve_elswhere self old' fin }
    
end
module Scratch_Scratch_Swap_Interface
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use seq.Permut
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_InvariantMirror_Stub as InvariantMirror0
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Formula_Impl1_Equisat_Stub as Equisat0
  clone Scratch_Lit_Impl3_SatInner_Stub as SatInner0
  clone Scratch_Assignments_Impl0_ShallowModel_Stub as ShallowModel2
  clone Scratch_Clause_Impl0_ShallowModel_Stub as ShallowModel1
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Formula_Impl1_Invariant_Stub as Invariant0 with
    predicate InvariantMirror0.invariant_mirror = InvariantMirror0.invariant_mirror,
    axiom .
  val swap [#"../Scratch/src/scratch.rs" 43 0 43 83] (f : borrowed (Scratch_Formula_Formula_Type.t_formula)) (cref : usize) (j : usize) (k : usize) (assignments : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( * f)}
    requires {[#"../Scratch/src/scratch.rs" 34 11 34 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) >= 2}
    requires {[#"../Scratch/src/scratch.rs" 35 11 35 35] UIntSize.to_int cref < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f)))}
    requires {[#"../Scratch/src/scratch.rs" 36 11 36 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int j}
    requires {[#"../Scratch/src/scratch.rs" 37 11 37 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int k}
    requires {[#"../Scratch/src/scratch.rs" 38 0 38 59] not SatInner0.sat_inner (Seq.get (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) 0) (ShallowModel2.shallow_model assignments)}
    ensures { [#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( ^ f) }
    ensures { [#"../Scratch/src/scratch.rs" 39 0 39 72] Permut.exchange (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) (UIntSize.to_int cref))) (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) (UIntSize.to_int j) (UIntSize.to_int k) }
    ensures { [#"../Scratch/src/scratch.rs" 40 10 40 39] UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( * f)) = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( ^ f)) }
    ensures { [#"../Scratch/src/scratch.rs" 41 10 41 49] Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) = Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) }
    ensures { [#"../Scratch/src/scratch.rs" 42 10 42 23] Equisat0.equisat ( * f) ( ^ f) }
    
end
module Scratch_Scratch_Swap
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use prelude.Slice
  use seq.Seq
  use seq.Permut
  use prelude.UInt8
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  clone Scratch_Lit_Impl2_IndexLogic as IndexLogic0
  clone Scratch_Lit_Impl3_Invariant as Invariant2 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0 with
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  clone Scratch_Clause_VarsInRangeInner as VarsInRangeInner0 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone Scratch_Lit_Impl2_IsPositiveLogic as IsPositiveLogic0
  clone Scratch_Lit_Impl3_SatInner as SatInner0 with
    function IsPositiveLogic0.is_positive_logic = IsPositiveLogic0.is_positive_logic,
    function IndexLogic0.index_logic = IndexLogic0.index_logic
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel4 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  clone Scratch_Clause_Impl0_ShallowModel as ShallowModel1 with
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Clause_Impl2_SatInner as SatInner2 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Scratch_Logic_Unset as Unset0
  clone Scratch_Clause_InvariantInternal as InvariantInternal0 with
    predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
    predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Formula_Formula_Type as Scratch_Formula_Formula_Type
  clone Scratch_Formula_Impl1_SatInner as SatInner1 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate SatInner0.sat_inner = SatInner2.sat_inner,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Assignments_CompleteInner as CompleteInner0 with
    predicate Unset0.unset = Unset0.unset
  clone Scratch_Clause_Impl2_Invariant as Invariant1 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel9 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel8 with
    type t = Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (Scratch_Lit_Lit_Type.t_lit),
    function ShallowModel0.shallow_model = ShallowModel4.shallow_model
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel7 with
    type t = slice (Scratch_Lit_Lit_Type.t_lit),
    type ShallowModelTy0.shallowModelTy = Seq.seq (Scratch_Lit_Lit_Type.t_lit),
    function ShallowModel0.shallow_model = ShallowModel9.shallow_model
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel6 with
    type t = Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq (Scratch_Clause_Clause_Type.t_clause),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Scratch_Formula_Impl1_EventuallySatComplete as EventuallySatComplete0 with
    predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
    predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel5 with
    type t = uint8,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Formula_FormulaInvariant as FormulaInvariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone Scratch_Formula_Impl0_ShallowModel as ShallowModel3 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Formula_Impl1_InvariantMirror as InvariantMirror0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    predicate Invariant0.invariant' = Invariant1.invariant',
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Scratch_Clause_Clause_Type.t_clause
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = slice (Scratch_Lit_Lit_Type.t_lit)
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Formula_Formula_Type.t_formula
  clone Core_Slice_Impl0_Swap_Interface as Swap0 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel9.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl10_DerefMut_Interface as DerefMut0 with
    type t = Scratch_Lit_Lit_Type.t_lit,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel8.shallow_model,
    function ShallowModel2.shallow_model = ShallowModel9.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = Scratch_Clause_Clause_Type.t_clause,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    type Output0.output = Scratch_Clause_Clause_Type.t_clause,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Formula_Impl1_Equisat as Equisat0 with
    predicate EventuallySatComplete0.eventually_sat_complete = EventuallySatComplete0.eventually_sat_complete
  use Scratch_Assignments_Assignments_Type as Scratch_Assignments_Assignments_Type
  clone Scratch_Assignments_Impl0_ShallowModel as ShallowModel2 with
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Formula_Impl1_Invariant as Invariant0 with
    predicate InvariantMirror0.invariant_mirror = InvariantMirror0.invariant_mirror,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
    axiom .
  let rec cfg swap [#"../Scratch/src/scratch.rs" 43 0 43 83] [@cfg:stackify] [@cfg:subregion_analysis] (f : borrowed (Scratch_Formula_Formula_Type.t_formula)) (cref : usize) (j : usize) (k : usize) (assignments : Scratch_Assignments_Assignments_Type.t_assignments) : ()
    requires {[#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( * f)}
    requires {[#"../Scratch/src/scratch.rs" 34 11 34 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) >= 2}
    requires {[#"../Scratch/src/scratch.rs" 35 11 35 35] UIntSize.to_int cref < Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f)))}
    requires {[#"../Scratch/src/scratch.rs" 36 11 36 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int j}
    requires {[#"../Scratch/src/scratch.rs" 37 11 37 40] Seq.length (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) > UIntSize.to_int k}
    requires {[#"../Scratch/src/scratch.rs" 38 0 38 59] not SatInner0.sat_inner (Seq.get (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) 0) (ShallowModel2.shallow_model assignments)}
    ensures { [#"../Scratch/src/scratch.rs" 33 0 33 33] Invariant0.invariant' ( ^ f) }
    ensures { [#"../Scratch/src/scratch.rs" 39 0 39 72] Permut.exchange (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) (UIntSize.to_int cref))) (ShallowModel1.shallow_model (Seq.get (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) (UIntSize.to_int cref))) (UIntSize.to_int j) (UIntSize.to_int k) }
    ensures { [#"../Scratch/src/scratch.rs" 40 10 40 39] UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( * f)) = UIntSize.to_int (Scratch_Formula_Formula_Type.formula_num_vars ( ^ f)) }
    ensures { [#"../Scratch/src/scratch.rs" 41 10 41 49] Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( * f))) = Seq.length (ShallowModel0.shallow_model (Scratch_Formula_Formula_Type.formula_clauses ( ^ f))) }
    ensures { [#"../Scratch/src/scratch.rs" 42 10 42 23] Equisat0.equisat ( * f) ( ^ f) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var f_1 : borrowed (Scratch_Formula_Formula_Type.t_formula);
  var cref_2 : usize;
  var j_3 : usize;
  var k_4 : usize;
  var assignments_5 : Scratch_Assignments_Assignments_Type.t_assignments;
  var old_f_17 : Ghost.ghost_ty (borrowed (Scratch_Formula_Formula_Type.t_formula));
  var _19 : ();
  var _20 : borrowed (slice (Scratch_Lit_Lit_Type.t_lit));
  var _21 : borrowed (slice (Scratch_Lit_Lit_Type.t_lit));
  var _22 : borrowed (Alloc_Vec_Vec_Type.t_vec (Scratch_Lit_Lit_Type.t_lit) (Alloc_Alloc_Global_Type.t_global));
  var _23 : borrowed (Scratch_Clause_Clause_Type.t_clause);
  var _24 : borrowed (Alloc_Vec_Vec_Type.t_vec (Scratch_Clause_Clause_Type.t_clause) (Alloc_Alloc_Global_Type.t_global));
  var _25 : usize;
  var _26 : usize;
  var _27 : usize;
  var _28 : ();
  {
    f_1 <- f;
    cref_2 <- cref;
    j_3 <- j;
    k_4 <- k;
    assignments_5 <- assignments;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    old_f_17 <- ([#"../Scratch/src/scratch.rs" 44 37 44 49] Ghost.new f_1);
    goto BB2
  }
  BB2 {
    _24 <- borrow_mut (Scratch_Formula_Formula_Type.formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Scratch_Formula_Formula_Type.C_Formula a b =  * f_1 in Scratch_Formula_Formula_Type.C_Formula ( ^ _24) b) };
    _25 <- cref_2;
    _23 <- ([#"../Scratch/src/scratch.rs" 46 4 46 19] IndexMut0.index_mut _24 _25);
    goto BB3
  }
  BB3 {
    _22 <- borrow_mut (Scratch_Clause_Clause_Type.clause_lits ( * _23));
    _23 <- { _23 with current = (let Scratch_Clause_Clause_Type.C_Clause a b c d =  * _23 in Scratch_Clause_Clause_Type.C_Clause a b c ( ^ _22)) };
    _21 <- ([#"../Scratch/src/scratch.rs" 46 4 46 35] DerefMut0.deref_mut _22);
    goto BB4
  }
  BB4 {
    _20 <- borrow_mut ( * _21);
    _21 <- { _21 with current = ( ^ _20) };
    _26 <- j_3;
    _27 <- k_4;
    _19 <- ([#"../Scratch/src/scratch.rs" 46 4 46 35] Swap0.swap _20 _26 _27);
    goto BB5
  }
  BB5 {
    assume { Resolve0.resolve f_1 };
    assume { Resolve1.resolve _21 };
    assume { Resolve2.resolve _23 };
    assert { [@expl:assertion] [#"../Scratch/src/scratch.rs" 48 18 48 38]  ^ f_1 =  ^ Ghost.inner old_f_17 };
    _28 <- ();
    _0 <- ();
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Scratch_Restart_Ema_Type
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  type t_ema  =
    | C_EMA Float64.t Float64.t Float64.t usize usize
    
  let function ema_wait (self : t_ema) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_EMA _ _ _ a _ -> a
      end
  let function ema_period (self : t_ema) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_EMA _ _ _ _ a -> a
      end
  let function ema_beta (self : t_ema) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_EMA _ _ a _ _ -> a
      end
  let function ema_value (self : t_ema) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_EMA a _ _ _ _ -> a
      end
  let function ema_alpha (self : t_ema) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_EMA _ a _ _ _ -> a
      end
end
module Scratch_Restart_Impl0_Invariant_Stub
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 22 4 22 30] (self : Scratch_Restart_Ema_Type.t_ema)
    
end
module Scratch_Restart_Impl0_Invariant_Interface
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 22 4 22 30] (self : Scratch_Restart_Ema_Type.t_ema)
    
end
module Scratch_Restart_Impl0_Invariant
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 22 4 22 30] (self : Scratch_Restart_Ema_Type.t_ema)
    
   =
    [#"../Scratch/src/restart.rs" 24 12 25 35] Scratch_Restart_Ema_Type.ema_wait self > (0 : usize) /\ Scratch_Restart_Ema_Type.ema_period self > (0 : usize)
  val invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 22 4 22 30] (self : Scratch_Restart_Ema_Type.t_ema) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Invariant_Invariant_Stub
  type self
  predicate invariant' (self : self)
end
module CreusotContracts_Invariant_Invariant_Invariant_Interface
  type self
  predicate invariant' (self : self)
end
module CreusotContracts_Invariant_Invariant_Invariant
  type self
  predicate invariant' (self : self) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/invariant.rs" 8 8 8 12] true
  val invariant' (self : self) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Invariant_Impl1_Invariant_Stub
  type t
  use prelude.Borrow
  predicate invariant' (self : borrowed t)
end
module CreusotContracts_Invariant_Impl1_Invariant_Interface
  type t
  use prelude.Borrow
  predicate invariant' (self : borrowed t)
end
module CreusotContracts_Invariant_Impl1_Invariant
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = t
  predicate invariant' (self : borrowed t) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/invariant.rs" 34 20 34 39] Invariant0.invariant' ( * self)
  val invariant' (self : borrowed t) : bool
    ensures { result = invariant' self }
    
end
module Scratch_Restart_Impl1_Update_Interface
  use prelude.Borrow
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Ema_Type.t_ema
  val update [#"../Scratch/src/restart.rs" 31 4 31 35] (self : borrowed (Scratch_Restart_Ema_Type.t_ema)) (next : Float64.t) : ()
    requires {[#"../Scratch/src/restart.rs" 31 19 31 23] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 31 19 31 23] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl1_Update
  use prelude.Borrow
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float32
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Ema_Type.t_ema
  clone Scratch_Restart_Impl0_Invariant as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Ema_Type.t_ema,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg update [#"../Scratch/src/restart.rs" 31 4 31 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Ema_Type.t_ema)) (next : Float64.t) : ()
    requires {[#"../Scratch/src/restart.rs" 31 19 31 23] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 31 19 31 23] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Restart_Ema_Type.t_ema);
  var next_2 : Float64.t;
  var _3 : Float64.t;
  var _4 : Float64.t;
  var _5 : Float64.t;
  var _6 : Float64.t;
  var _7 : Float64.t;
  var _8 : bool;
  var _9 : Float64.t;
  var _10 : Float64.t;
  var _11 : bool;
  var _12 : usize;
  var _13 : ();
  var _14 : bool;
  var _15 : usize;
  var _16 : usize;
  var _17 : bool;
  var _18 : usize;
  var _19 : bool;
  var _20 : Float64.t;
  var _21 : Float64.t;
  var _22 : Float64.t;
  {
    self_1 <- self;
    next_2 <- next;
    goto BB0
  }
  BB0 {
    _4 <- Scratch_Restart_Ema_Type.ema_beta ( * self_1);
    _6 <- next_2;
    _7 <- Scratch_Restart_Ema_Type.ema_value ( * self_1);
    _5 <- ([#"../Scratch/src/restart.rs" 32 34 32 53] _6 .- _7);
    _3 <- ([#"../Scratch/src/restart.rs" 32 22 32 53] _4 .* _5);
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA ([#"../Scratch/src/restart.rs" 32 8 32 53] Scratch_Restart_Ema_Type.ema_value ( * self_1) .+ _3) b c d e) };
    _9 <- Scratch_Restart_Ema_Type.ema_beta ( * self_1);
    _10 <- Scratch_Restart_Ema_Type.ema_alpha ( * self_1);
    _8 <- ([#"../Scratch/src/restart.rs" 34 11 34 33] _9 .> _10);
    switch (_8)
      | False -> goto BB12
      | True -> goto BB1
      end
  }
  BB1 {
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA a b c ([#"../Scratch/src/restart.rs" 35 12 35 26] Scratch_Restart_Ema_Type.ema_wait ( * self_1) - ([#"../Scratch/src/restart.rs" 35 25 35 26] (1 : usize))) e) };
    _12 <- Scratch_Restart_Ema_Type.ema_wait ( * self_1);
    _11 <- ([#"../Scratch/src/restart.rs" 36 15 36 29] _12 = ([#"../Scratch/src/restart.rs" 36 28 36 29] (0 : usize)));
    switch (_11)
      | False -> goto BB10
      | True -> goto BB2
      end
  }
  BB2 {
    _15 <- Scratch_Restart_Ema_Type.ema_period ( * self_1);
    _17 <- ([#"../Scratch/src/restart.rs" 37 33 37 47] ([#"../Scratch/src/restart.rs" 37 46 37 47] (2 : usize)) = ([#"../Scratch/src/restart.rs" 37 33 37 47] (0 : usize)));
    assert { [@expl:division by zero] [#"../Scratch/src/restart.rs" 37 33 37 47] not _17 };
    goto BB3
  }
  BB3 {
    _16 <- ([#"../Scratch/src/restart.rs" 37 33 37 47] ([#"../Scratch/src/restart.rs" 37 33 37 43] (18446744073709551615 : usize)) / ([#"../Scratch/src/restart.rs" 37 46 37 47] (2 : usize)));
    _14 <- ([#"../Scratch/src/restart.rs" 37 19 37 47] _15 < _16);
    switch (_14)
      | False -> goto BB5
      | True -> goto BB4
      end
  }
  BB4 {
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA a b c d ([#"../Scratch/src/restart.rs" 38 20 38 36] Scratch_Restart_Ema_Type.ema_period ( * self_1) * ([#"../Scratch/src/restart.rs" 38 35 38 36] (2 : usize)))) };
    _13 <- ();
    goto BB6
  }
  BB5 {
    _13 <- ();
    goto BB6
  }
  BB6 {
    _18 <- Scratch_Restart_Ema_Type.ema_period ( * self_1);
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA a b c _18 e) };
    _18 <- any usize;
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA a b ([#"../Scratch/src/restart.rs" 41 16 41 32] Scratch_Restart_Ema_Type.ema_beta ( * self_1) .* ([#"../Scratch/src/restart.rs" 41 29 41 32] 0.5000000000000000000000000000000000000000000000000000000000000000)) d e) };
    _20 <- Scratch_Restart_Ema_Type.ema_beta ( * self_1);
    _21 <- Scratch_Restart_Ema_Type.ema_alpha ( * self_1);
    _19 <- ([#"../Scratch/src/restart.rs" 42 19 42 41] _20 .< _21);
    switch (_19)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    _22 <- Scratch_Restart_Ema_Type.ema_alpha ( * self_1);
    self_1 <- { self_1 with current = (let Scratch_Restart_Ema_Type.C_EMA a b c d e =  * self_1 in Scratch_Restart_Ema_Type.C_EMA a b _22 d e) };
    _22 <- any Float64.t;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB9
  }
  BB8 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB9
  }
  BB9 {
    goto BB11
  }
  BB10 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB11
  }
  BB11 {
    goto BB13
  }
  BB12 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module Scratch_Restart_Impl1_New_Interface
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant_Stub as Invariant0
  val new [#"../Scratch/src/restart.rs" 49 4 49 30] (alpha : Float64.t) : Scratch_Restart_Ema_Type.t_ema
    ensures { [#"../Scratch/src/restart.rs" 49 26 49 30] Invariant0.invariant' result }
    
end
module Scratch_Restart_Impl1_New
  use prelude.Float64
  use prelude.Float32
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant0
  let rec cfg new [#"../Scratch/src/restart.rs" 49 4 49 30] [@cfg:stackify] [@cfg:subregion_analysis] (alpha : Float64.t) : Scratch_Restart_Ema_Type.t_ema
    ensures { [#"../Scratch/src/restart.rs" 49 26 49 30] Invariant0.invariant' result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Restart_Ema_Type.t_ema;
  var alpha_1 : Float64.t;
  var _2 : Float64.t;
  {
    alpha_1 <- alpha;
    goto BB0
  }
  BB0 {
    _2 <- alpha_1;
    _0 <- Scratch_Restart_Ema_Type.C_EMA ([#"../Scratch/src/restart.rs" 50 21 50 24] 1.0000000000000000000000000000000000000000000000000000000000000000) _2 ([#"../Scratch/src/restart.rs" 50 39 50 42] 1.0000000000000000000000000000000000000000000000000000000000000000) ([#"../Scratch/src/restart.rs" 50 50 50 51] (1 : usize)) ([#"../Scratch/src/restart.rs" 50 61 50 62] (1 : usize));
    return _0
  }
  
end
module Scratch_Restart_Glucose_Type
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  type t_glucose  =
    | C_Glucose usize usize (Scratch_Restart_Ema_Type.t_ema) (Scratch_Restart_Ema_Type.t_ema) (Scratch_Restart_Ema_Type.t_ema) usize Float64.t Float64.t usize usize
    
  let function glucose_ema_lbd_narrow (self : t_glucose) : Scratch_Restart_Ema_Type.t_ema
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ a _ _ _ _ _ _ _ -> a
      end
  let function glucose_ema_lbd_wide (self : t_glucose) : Scratch_Restart_Ema_Type.t_ema
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ a _ _ _ _ _ _ -> a
      end
  let function glucose_ema_trail_wide (self : t_glucose) : Scratch_Restart_Ema_Type.t_ema
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ a _ _ _ _ _ -> a
      end
  let function glucose_minimum_conflicts (self : t_glucose) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose a _ _ _ _ _ _ _ _ _ -> a
      end
  let function glucose_force (self : t_glucose) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ _ _ a _ _ _ -> a
      end
  let function glucose_num_restarts (self : t_glucose) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ _ _ _ _ a _ -> a
      end
  let function glucose_last_trail_size (self : t_glucose) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ _ a _ _ _ _ -> a
      end
  let function glucose_block (self : t_glucose) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ _ _ _ a _ _ -> a
      end
  let function glucose_minimum_conflicts_for_blocking_restarts (self : t_glucose) : usize
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ a _ _ _ _ _ _ _ _ -> a
      end
  let function glucose_num_blocked (self : t_glucose) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Glucose _ _ _ _ _ _ _ _ _ a -> a
      end
end
module Scratch_Restart_Impl2_Invariant_Stub
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 69 4 69 30] (self : Scratch_Restart_Glucose_Type.t_glucose)
    
end
module Scratch_Restart_Impl2_Invariant_Interface
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 69 4 69 30] (self : Scratch_Restart_Glucose_Type.t_glucose)
    
end
module Scratch_Restart_Impl2_Invariant
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant_Stub as Invariant0
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 69 4 69 30] (self : Scratch_Restart_Glucose_Type.t_glucose)
    
   =
    [#"../Scratch/src/restart.rs" 68 4 68 16] Invariant0.invariant' (Scratch_Restart_Glucose_Type.glucose_ema_lbd_narrow self) /\ Invariant0.invariant' (Scratch_Restart_Glucose_Type.glucose_ema_lbd_wide self) /\ Invariant0.invariant' (Scratch_Restart_Glucose_Type.glucose_ema_trail_wide self)
  val invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 69 4 69 30] (self : Scratch_Restart_Glucose_Type.t_glucose) : bool
    ensures { result = invariant' self }
    
end
module Core_Ops_Range_Range_Type
  type t_range 'idx =
    | C_Range 'idx 'idx
    
  let function range_start (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range a _ -> a
      end
  let function range_end (self : t_range 'idx) : 'idx = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Range _ a -> a
      end
end
module Core_Option_Option_Type
  type t_option 't =
    | C_None
    | C_Some 't
    
  let function some_0 (self : t_option 't) : 't = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_None -> any 't
      | C_Some a -> a
      end
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Stub
  type self
  predicate into_iter_pre (self : self)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Interface
  type self
  predicate into_iter_pre (self : self)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre
  type self
  predicate into_iter_pre (self : self) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter.rs" 55 20 55 24] true
  val into_iter_pre (self : self) : bool
    ensures { result = into_iter_pre self }
    
end
module Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type
  type self
  type intoIter
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Stub
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Interface
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
end
module CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost
  type self
  clone Core_Iter_Traits_Collect_IntoIterator_IntoIter_Type as IntoIter0 with
    type self = self
  predicate into_iter_post (self : self) (res : IntoIter0.intoIter)
  val into_iter_post (self : self) (res : IntoIter0.intoIter) : bool
    ensures { result = into_iter_post self res }
    
end
module Core_Iter_Traits_Collect_Impl0_IntoIter_Interface
  type i
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPost_Stub as IntoIterPost0 with
    type self = i,
    type IntoIter0.intoIter = i
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = i
  clone CreusotContracts_Std1_Iter_IntoIterator_IntoIterPre_Stub as IntoIterPre0 with
    type self = i
  val into_iter (self : i) : i
    requires {[#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter.rs" 79 0 147 1] IntoIterPre0.into_iter_pre self}
    requires {Invariant0.invariant' self}
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter.rs" 79 0 147 1] IntoIterPost0.into_iter_post self result }
    ensures { Invariant0.invariant' result }
    
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Stub
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
end
module CreusotContracts_Std1_Iter_Iterator_Completed_Interface
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
end
module CreusotContracts_Std1_Iter_Iterator_Completed
  type self
  use prelude.Borrow
  predicate completed (self : borrowed self)
  val completed (self : borrowed self) : bool
    ensures { result = completed self }
    
end
module Core_Iter_Traits_Iterator_Iterator_Item_Type
  type self
  type item
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Stub
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
end
module CreusotContracts_Std1_Iter_Iterator_Produces_Interface
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
end
module CreusotContracts_Std1_Iter_Iterator_Produces
  type self
  use seq.Seq
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = self
  predicate produces (self : self) (visited : Seq.seq Item0.item) (_o : self)
  val produces (self : self) (visited : Seq.seq Item0.item) (_o : self) : bool
    ensures { result = produces self visited _o }
    
end
module Core_Iter_Range_Impl3_Next_Interface
  type a
  use prelude.Borrow
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Iterator_Produces_Stub as Produces0 with
    type self = Core_Ops_Range_Range_Type.t_range a,
    type Item0.item = a
  clone CreusotContracts_Std1_Iter_Iterator_Completed_Stub as Completed0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = Core_Ops_Range_Range_Type.t_range a
  val next (self : borrowed (Core_Ops_Range_Range_Type.t_range a)) : Core_Option_Option_Type.t_option a
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter.rs" 85 26 88 17] match (result) with
      | Core_Option_Option_Type.C_None -> Completed0.completed self
      | Core_Option_Option_Type.C_Some v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self)
      end }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre_Stub
  type i
  predicate into_iter_pre (self : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre_Interface
  type i
  predicate into_iter_pre (self : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPre
  type i
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = i
  predicate into_iter_pre (self : i) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter.rs" 65 8 65 24] Invariant0.invariant' self
  val into_iter_pre (self : i) : bool
    ensures { result = into_iter_pre self }
    
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost_Stub
  type i
  predicate into_iter_post (self : i) (res : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost_Interface
  type i
  predicate into_iter_post (self : i) (res : i)
end
module CreusotContracts_Std1_Iter_Impl0_IntoIterPost
  type i
  predicate into_iter_post (self : i) (res : i) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter.rs" 70 8 70 19] self = res
  val into_iter_post (self : i) (res : i) : bool
    ensures { result = into_iter_post self res }
    
end
module CreusotContracts_Model_DeepModel_DeepModelTy_Type
  type self
  type deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Stub
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel_Interface
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
end
module CreusotContracts_Model_DeepModel_DeepModel
  type self
  clone CreusotContracts_Model_DeepModel_DeepModelTy_Type as DeepModelTy0 with
    type self = self
  function deep_model (self : self) : DeepModelTy0.deepModelTy
  val deep_model (self : self) : DeepModelTy0.deepModelTy
    ensures { result = deep_model self }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed_Stub
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx))
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed_Interface
  type idx
  use prelude.Borrow
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx))
end
module CreusotContracts_Std1_Iter_Range_Impl0_Completed
  type idx
  use prelude.Borrow
  use prelude.Int
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = idx,
    type DeepModelTy0.deepModelTy = int
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = Core_Ops_Range_Range_Type.t_range idx
  predicate completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 13 12 13 78] Resolve0.resolve self /\ DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start ( * self)) >= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_end ( * self))
  val completed (self : borrowed (Core_Ops_Range_Range_Type.t_range idx)) : bool
    ensures { result = completed self }
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_Produces
  type idx
  use seq.Seq
  use prelude.Int
  use prelude.Int
  clone CreusotContracts_Model_DeepModel_DeepModel_Stub as DeepModel0 with
    type self = idx,
    type DeepModelTy0.deepModelTy = int
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  predicate produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx)
    
   =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 19 8 25 9] Core_Ops_Range_Range_Type.range_end self = Core_Ops_Range_Range_Type.range_end o /\ DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) <= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) /\ (Seq.length visited > 0 -> DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) <= DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_end o)) /\ Seq.length visited = DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start o) - DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) /\ (forall i : int . 0 <= i /\ i < Seq.length visited -> DeepModel0.deep_model (Seq.get visited i) = DeepModel0.deep_model (Core_Ops_Range_Range_Type.range_start self) + i)
  val produces (self : Core_Ops_Range_Range_Type.t_range idx) (visited : Seq.seq idx) (o : Core_Ops_Range_Range_Type.t_range idx) : bool
    ensures { result = produces self visited o }
    
end
module CreusotContracts_Invariant_Invariant_IsInhabited_Stub
  type self
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = self
  function is_inhabited (_1' : ()) : bool
end
module CreusotContracts_Invariant_Invariant_IsInhabited_Interface
  type self
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = self
  function is_inhabited (_1' : ()) : bool
  axiom is_inhabited_spec : forall _1' : () . ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/invariant.rs" 13 14 13 20] is_inhabited _1') && ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/invariant.rs" 12 4 12 45] exists x : self . Invariant0.invariant' x /\ Invariant0.invariant' x)
end
module CreusotContracts_Invariant_Invariant_IsInhabited
  type self
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = self
  function is_inhabited (_1' : ()) : bool =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/invariant.rs" 18 8 18 12] true
  val is_inhabited (_1' : ()) : bool
    ensures { result = is_inhabited _1' }
    
  axiom is_inhabited_spec : forall _1' : () . ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/invariant.rs" 13 14 13 20] is_inhabited _1') && ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/invariant.rs" 12 4 12 45] exists x : self . Invariant0.invariant' x /\ Invariant0.invariant' x)
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
  axiom produces_refl_spec : forall a : Core_Ops_Range_Range_Type.t_range idx . [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 29 14 29 39] Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : () =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 28 4 28 10] ()
  val produces_refl (a : Core_Ops_Range_Range_Type.t_range idx) : ()
    ensures { result = produces_refl a }
    
  axiom produces_refl_spec : forall a : Core_Ops_Range_Range_Type.t_range idx . [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 29 14 29 39] Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Stub
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans_Interface
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
  axiom produces_trans_spec : forall a : Core_Ops_Range_Range_Type.t_range idx, ab : Seq.seq idx, b : Core_Ops_Range_Range_Type.t_range idx, bc : Seq.seq idx, c : Core_Ops_Range_Range_Type.t_range idx . ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 33 15 33 32] Produces0.produces a ab b) -> ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 34 15 34 32] Produces0.produces b bc c) -> ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 35 14 35 42] Produces0.produces a (Seq.(++) ab bc) c)
end
module CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans
  type idx
  use seq.Seq
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces_Stub as Produces0 with
    type idx = idx
  function produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    
   =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 32 4 32 10] ()
  val produces_trans (a : Core_Ops_Range_Range_Type.t_range idx) (ab : Seq.seq idx) (b : Core_Ops_Range_Range_Type.t_range idx) (bc : Seq.seq idx) (c : Core_Ops_Range_Range_Type.t_range idx) : ()
    requires {[#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 33 15 33 32] Produces0.produces a ab b}
    requires {[#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 34 15 34 32] Produces0.produces b bc c}
    ensures { result = produces_trans a ab b bc c }
    
  axiom produces_trans_spec : forall a : Core_Ops_Range_Range_Type.t_range idx, ab : Seq.seq idx, b : Core_Ops_Range_Range_Type.t_range idx, bc : Seq.seq idx, c : Core_Ops_Range_Range_Type.t_range idx . ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 33 15 33 32] Produces0.produces a ab b) -> ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 34 15 34 32] Produces0.produces b bc c) -> ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter/range.rs" 35 14 35 42] Produces0.produces a (Seq.(++) ab bc) c)
end
module CreusotContracts_Std1_Num_Impl16_DeepModel_Stub
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int
end
module CreusotContracts_Std1_Num_Impl16_DeepModel_Interface
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int
end
module CreusotContracts_Std1_Num_Impl16_DeepModel
  use prelude.Int
  use prelude.UIntSize
  function deep_model (self : usize) : int =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/num.rs" 20 16 20 35] UIntSize.to_int self
  val deep_model (self : usize) : int
    ensures { result = deep_model self }
    
end
module Scratch_Restart_DivFloatWithTenNTimes_Interface
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  val div_float_with_ten_n_times [#"../Scratch/src/restart.rs" 76 0 76 58] (f : Float64.t) (n : usize) : Float64.t
end
module Scratch_Restart_DivFloatWithTenNTimes
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.IntSize
  use prelude.Float32
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl16_DeepModel as DeepModel0
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces as Produces0 with
    type idx = usize,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans as ProducesTrans0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl as ProducesRefl0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Invariant_Invariant_Invariant as Invariant0 with
    type self = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Invariant_Invariant_IsInhabited as IsInhabited0 with
    type self = Core_Ops_Range_Range_Type.t_range usize,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Completed as Completed0 with
    type idx = usize,
    predicate Resolve0.resolve = Resolve0.resolve,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate Invariant0.invariant' = Invariant0.invariant'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Iter_Range_Impl3_Next_Interface as Next0 with
    type a = usize,
    type Item0.item = usize,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post
  let rec cfg div_float_with_ten_n_times [#"../Scratch/src/restart.rs" 76 0 76 58] [@cfg:stackify] [@cfg:subregion_analysis] (f : Float64.t) (n : usize) : Float64.t
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Float64.t;
  var f_1 : Float64.t;
  var n_2 : usize;
  var _3 : ();
  var _4 : Core_Ops_Range_Range_Type.t_range usize;
  var _5 : Core_Ops_Range_Range_Type.t_range usize;
  var _6 : usize;
  var iter_7 : Core_Ops_Range_Range_Type.t_range usize;
  var _8 : ();
  var _9 : ();
  var _10 : Core_Option_Option_Type.t_option usize;
  var _11 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _12 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _13 : isize;
  var _14 : ();
  {
    f_1 <- f;
    n_2 <- n;
    goto BB0
  }
  BB0 {
    _6 <- n_2;
    _5 <- Core_Ops_Range_Range_Type.C_Range ([#"../Scratch/src/restart.rs" 77 13 77 14] (0 : usize)) _6;
    _4 <- ([#"../Scratch/src/restart.rs" 77 13 77 17] IntoIter0.into_iter _5);
    goto BB1
  }
  BB1 {
    iter_7 <- _4;
    _4 <- any Core_Ops_Range_Range_Type.t_range usize;
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _12 <- borrow_mut iter_7;
    iter_7 <-  ^ _12;
    _11 <- borrow_mut ( * _12);
    _12 <- { _12 with current = ( ^ _11) };
    _10 <- ([#"../Scratch/src/restart.rs" 77 13 77 17] Next0.next _11);
    goto BB4
  }
  BB4 {
    assume { Resolve0.resolve _12 };
    switch (_10)
      | Core_Option_Option_Type.C_None -> goto BB5
      | Core_Option_Option_Type.C_Some _ -> goto BB6
      end
  }
  BB5 {
    goto BB8
  }
  BB6 {
    f_1 <- ([#"../Scratch/src/restart.rs" 78 8 78 17] f_1 ./ ([#"../Scratch/src/restart.rs" 78 13 78 17] 10.0000000000000000000000000000000000000000000000000000000000000000));
    _9 <- ();
    _8 <- ();
    goto BB2
  }
  BB7 {
    absurd
  }
  BB8 {
    _3 <- ();
    _0 <- f_1;
    return _0
  }
  
end
module Scratch_Restart_Impl3_New_Interface
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant_Stub as Invariant0
  val new [#"../Scratch/src/restart.rs" 85 4 85 20] (_1' : ()) : Scratch_Restart_Glucose_Type.t_glucose
    ensures { [#"../Scratch/src/restart.rs" 85 16 85 20] Invariant0.invariant' result }
    
end
module Scratch_Restart_Impl3_New
  use prelude.Float64
  use prelude.Float32
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant1
  clone Scratch_Restart_DivFloatWithTenNTimes_Interface as DivFloatWithTenNTimes0
  clone Scratch_Restart_Impl1_New_Interface as New0 with
    predicate Invariant0.invariant' = Invariant1.invariant'
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg new [#"../Scratch/src/restart.rs" 85 4 85 20] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : Scratch_Restart_Glucose_Type.t_glucose
    ensures { [#"../Scratch/src/restart.rs" 85 16 85 20] Invariant0.invariant' result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Restart_Glucose_Type.t_glucose;
  var _1 : Scratch_Restart_Ema_Type.t_ema;
  var _2 : Scratch_Restart_Ema_Type.t_ema;
  var _3 : Float64.t;
  var _4 : Scratch_Restart_Ema_Type.t_ema;
  {
    goto BB0
  }
  BB0 {
    _1 <- ([#"../Scratch/src/restart.rs" 89 28 89 42] New0.new ([#"../Scratch/src/restart.rs" 89 37 89 41] 0.0299999999999999988897769753748434595763683319091796875000000000));
    goto BB1
  }
  BB1 {
    _3 <- ([#"../Scratch/src/restart.rs" 90 35 90 70] DivFloatWithTenNTimes0.div_float_with_ten_n_times ([#"../Scratch/src/restart.rs" 90 62 90 66] 0.0010000000000000000208166817117216851329430937767028808593750000) ([#"../Scratch/src/restart.rs" 90 68 90 69] (2 : usize)));
    goto BB2
  }
  BB2 {
    _2 <- ([#"../Scratch/src/restart.rs" 90 26 90 71] New0.new _3);
    goto BB3
  }
  BB3 {
    _4 <- ([#"../Scratch/src/restart.rs" 91 28 91 42] New0.new ([#"../Scratch/src/restart.rs" 91 37 91 41] 0.0002999999999999999737189393389513725196593441069126129150390625));
    goto BB4
  }
  BB4 {
    _0 <- Scratch_Restart_Glucose_Type.C_Glucose ([#"../Scratch/src/restart.rs" 87 31 87 33] (50 : usize)) ([#"../Scratch/src/restart.rs" 88 53 88 59] (10000 : usize)) _1 _2 _4 ([#"../Scratch/src/restart.rs" 92 29 92 30] (0 : usize)) ([#"../Scratch/src/restart.rs" 93 19 93 23] 1.2500000000000000000000000000000000000000000000000000000000000000) ([#"../Scratch/src/restart.rs" 94 19 94 22] 1.3999999999999999111821580299874767661094665527343750000000000000) ([#"../Scratch/src/restart.rs" 95 26 95 27] (0 : usize)) ([#"../Scratch/src/restart.rs" 96 25 96 26] (0 : usize));
    return _0
  }
  
end
module Scratch_Restart_UsizeToF64_Interface
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  val usize_to_f64 [#"../Scratch/src/restart.rs" 103 0 103 32] (u : usize) : Float64.t
end
module Scratch_Restart_F64ToUsize_Interface
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  val f64_to_usize [#"../Scratch/src/restart.rs" 109 0 109 32] (f : Float64.t) : usize
end
module Scratch_Restart_Powf_Interface
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  val powf [#"../Scratch/src/restart.rs" 113 0 113 32] (f : Float64.t) (u : usize) : Float64.t
end
module Scratch_Restart_Powf
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use prelude.IntSize
  use prelude.Float32
  use prelude.Int
  clone CreusotContracts_Std1_Num_Impl16_DeepModel as DeepModel0
  use Core_Ops_Range_Range_Type as Core_Ops_Range_Range_Type
  clone CreusotContracts_Std1_Iter_Range_Impl0_Produces as Produces0 with
    type idx = usize,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesTrans as ProducesTrans0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Std1_Iter_Range_Impl0_ProducesRefl as ProducesRefl0 with
    type idx = usize,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Invariant_Invariant_Invariant as Invariant0 with
    type self = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Invariant_Invariant_IsInhabited as IsInhabited0 with
    type self = Core_Ops_Range_Range_Type.t_range usize,
    predicate Invariant0.invariant' = Invariant0.invariant',
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Range_Impl0_Completed as Completed0 with
    type idx = usize,
    predicate Resolve0.resolve = Resolve0.resolve,
    function DeepModel0.deep_model = DeepModel0.deep_model
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Ops_Range_Range_Type.t_range usize
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate Invariant0.invariant' = Invariant0.invariant'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Iter_Range_Impl3_Next_Interface as Next0 with
    type a = usize,
    type Item0.item = usize,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Ops_Range_Range_Type.t_range usize,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate Invariant0.invariant' = Invariant0.invariant',
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post
  let rec cfg powf [#"../Scratch/src/restart.rs" 113 0 113 32] [@cfg:stackify] [@cfg:subregion_analysis] (f : Float64.t) (u : usize) : Float64.t
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Float64.t;
  var f_1 : Float64.t;
  var u_2 : usize;
  var o_3 : Float64.t;
  var _4 : ();
  var _5 : Core_Ops_Range_Range_Type.t_range usize;
  var _6 : Core_Ops_Range_Range_Type.t_range usize;
  var _7 : usize;
  var iter_8 : Core_Ops_Range_Range_Type.t_range usize;
  var _9 : ();
  var _10 : ();
  var _11 : Core_Option_Option_Type.t_option usize;
  var _12 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _13 : borrowed (Core_Ops_Range_Range_Type.t_range usize);
  var _14 : isize;
  var _15 : ();
  var _16 : Float64.t;
  {
    f_1 <- f;
    u_2 <- u;
    goto BB0
  }
  BB0 {
    o_3 <- ([#"../Scratch/src/restart.rs" 114 16 114 19] 1.0000000000000000000000000000000000000000000000000000000000000000);
    _7 <- u_2;
    _6 <- Core_Ops_Range_Range_Type.C_Range ([#"../Scratch/src/restart.rs" 115 13 115 14] (0 : usize)) _7;
    _5 <- ([#"../Scratch/src/restart.rs" 115 13 115 17] IntoIter0.into_iter _6);
    goto BB1
  }
  BB1 {
    iter_8 <- _5;
    _5 <- any Core_Ops_Range_Range_Type.t_range usize;
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _13 <- borrow_mut iter_8;
    iter_8 <-  ^ _13;
    _12 <- borrow_mut ( * _13);
    _13 <- { _13 with current = ( ^ _12) };
    _11 <- ([#"../Scratch/src/restart.rs" 115 13 115 17] Next0.next _12);
    goto BB4
  }
  BB4 {
    assume { Resolve0.resolve _13 };
    switch (_11)
      | Core_Option_Option_Type.C_None -> goto BB5
      | Core_Option_Option_Type.C_Some _ -> goto BB6
      end
  }
  BB5 {
    goto BB8
  }
  BB6 {
    _16 <- f_1;
    o_3 <- ([#"../Scratch/src/restart.rs" 116 8 116 14] o_3 .* _16);
    _10 <- ();
    _9 <- ();
    goto BB2
  }
  BB7 {
    absurd
  }
  BB8 {
    _4 <- ();
    _0 <- o_3;
    return _0
  }
  
end
module Scratch_Restart_Impl4_TriggerRestart_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  val trigger_restart [#"../Scratch/src/restart.rs" 122 4 122 71] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 122 39 122 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 122 39 122 43] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl4_TriggerRestart
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant2
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  clone Scratch_Restart_Impl2_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg trigger_restart [#"../Scratch/src/restart.rs" 122 4 122 71] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 122 39 122 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 122 39 122 43] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : borrowed (Scratch_Restart_Glucose_Type.t_glucose);
  var curr_confl_2 : usize;
  var _3 : ();
  var _4 : bool;
  var _5 : usize;
  var _6 : usize;
  var _7 : ();
  var _8 : ();
  var _9 : bool;
  var _10 : Float64.t;
  var _11 : Float64.t;
  var _12 : Float64.t;
  var _13 : Float64.t;
  var _14 : ();
  var _15 : ();
  var _16 : bool;
  var _17 : usize;
  var _18 : ();
  var _19 : bool;
  var _20 : usize;
  var _21 : usize;
  var _22 : usize;
  {
    self_1 <- self;
    curr_confl_2 <- curr_confl;
    goto BB0
  }
  BB0 {
    _5 <- curr_confl_2;
    _6 <- Scratch_Restart_Glucose_Type.glucose_minimum_conflicts ( * self_1);
    _4 <- ([#"../Scratch/src/restart.rs" 123 11 123 46] _5 < _6);
    switch (_4)
      | False -> goto BB2
      | True -> goto BB1
      end
  }
  BB1 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"../Scratch/src/restart.rs" 124 19 124 24] false);
    goto BB11
  }
  BB2 {
    _3 <- ();
    _11 <- Scratch_Restart_Ema_Type.ema_value (Scratch_Restart_Glucose_Type.glucose_ema_lbd_narrow ( * self_1));
    _12 <- Scratch_Restart_Ema_Type.ema_value (Scratch_Restart_Glucose_Type.glucose_ema_lbd_wide ( * self_1));
    _10 <- ([#"../Scratch/src/restart.rs" 126 11 126 62] _11 ./ _12);
    _13 <- Scratch_Restart_Glucose_Type.glucose_force ( * self_1);
    _9 <- ([#"../Scratch/src/restart.rs" 126 11 126 75] _10 .> _13);
    switch (_9)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    _17 <- Scratch_Restart_Glucose_Type.glucose_num_restarts ( * self_1);
    _16 <- ([#"../Scratch/src/restart.rs" 127 15 127 45] _17 < ([#"../Scratch/src/restart.rs" 127 35 127 45] (18446744073709551615 : usize)));
    switch (_16)
      | False -> goto BB6
      | True -> goto BB5
      end
  }
  BB4 {
    assume { Resolve0.resolve self_1 };
    _8 <- ();
    _0 <- ([#"../Scratch/src/restart.rs" 135 8 135 13] false);
    goto BB11
  }
  BB5 {
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h ([#"../Scratch/src/restart.rs" 128 16 128 38] Scratch_Restart_Glucose_Type.glucose_num_restarts ( * self_1) + ([#"../Scratch/src/restart.rs" 128 37 128 38] (1 : usize))) j) };
    _15 <- ();
    goto BB7
  }
  BB6 {
    _15 <- ();
    goto BB7
  }
  BB7 {
    _20 <- curr_confl_2;
    _21 <- ([#"../Scratch/src/restart.rs" 130 28 130 43] ([#"../Scratch/src/restart.rs" 130 28 130 38] (18446744073709551615 : usize)) - ([#"../Scratch/src/restart.rs" 130 41 130 43] (50 : usize)));
    _19 <- ([#"../Scratch/src/restart.rs" 130 15 130 43] _20 < _21);
    switch (_19)
      | False -> goto BB9
      | True -> goto BB8
      end
  }
  BB8 {
    _22 <- curr_confl_2;
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose ([#"../Scratch/src/restart.rs" 131 16 131 56] _22 + ([#"../Scratch/src/restart.rs" 131 54 131 56] (50 : usize))) b c d e f g h i j) };
    assume { Resolve0.resolve self_1 };
    _18 <- ();
    goto BB10
  }
  BB9 {
    assume { Resolve0.resolve self_1 };
    _18 <- ();
    goto BB10
  }
  BB10 {
    _0 <- ([#"../Scratch/src/restart.rs" 133 19 133 23] true);
    goto BB11
  }
  BB11 {
    return _0
  }
  
end
module Scratch_Restart_Impl4_Update_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  val update [#"../Scratch/src/restart.rs" 138 4 138 65] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (trail_len : usize) (lbd : usize) : ()
    requires {[#"../Scratch/src/restart.rs" 138 30 138 34] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 138 30 138 34] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl4_Update
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant2
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant3 with
    type t = Scratch_Restart_Ema_Type.t_ema,
    predicate Invariant0.invariant' = Invariant2.invariant'
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  clone Scratch_Restart_Impl1_Update_Interface as Update0 with
    predicate Invariant0.invariant' = Invariant3.invariant',
    predicate Invariant1.invariant' = Invariant2.invariant'
  clone Scratch_Restart_UsizeToF64_Interface as UsizeToF640
  clone Scratch_Restart_Impl2_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg update [#"../Scratch/src/restart.rs" 138 4 138 65] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (trail_len : usize) (lbd : usize) : ()
    requires {[#"../Scratch/src/restart.rs" 138 30 138 34] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 138 30 138 34] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Restart_Glucose_Type.t_glucose);
  var trail_len_2 : usize;
  var lbd_3 : usize;
  var _4 : ();
  var _5 : borrowed (Scratch_Restart_Ema_Type.t_ema);
  var _6 : Float64.t;
  var _7 : usize;
  var _8 : usize;
  var _9 : ();
  var _10 : borrowed (Scratch_Restart_Ema_Type.t_ema);
  var _11 : Float64.t;
  var _12 : usize;
  var _13 : ();
  var _14 : borrowed (Scratch_Restart_Ema_Type.t_ema);
  var _15 : Float64.t;
  var _16 : usize;
  {
    self_1 <- self;
    trail_len_2 <- trail_len;
    lbd_3 <- lbd;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut (Scratch_Restart_Glucose_Type.glucose_ema_trail_wide ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b c d ( ^ _5) f g h i j) };
    _7 <- trail_len_2;
    _6 <- ([#"../Scratch/src/restart.rs" 139 35 139 58] UsizeToF640.usize_to_f64 _7);
    goto BB1
  }
  BB1 {
    _4 <- ([#"../Scratch/src/restart.rs" 139 8 139 59] Update0.update _5 _6);
    goto BB2
  }
  BB2 {
    _8 <- trail_len_2;
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b c d e _8 g h i j) };
    _8 <- any usize;
    _10 <- borrow_mut (Scratch_Restart_Glucose_Type.glucose_ema_lbd_narrow ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b ( ^ _10) d e f g h i j) };
    _12 <- lbd_3;
    _11 <- ([#"../Scratch/src/restart.rs" 141 35 141 52] UsizeToF640.usize_to_f64 _12);
    goto BB3
  }
  BB3 {
    _9 <- ([#"../Scratch/src/restart.rs" 141 8 141 53] Update0.update _10 _11);
    goto BB4
  }
  BB4 {
    _14 <- borrow_mut (Scratch_Restart_Glucose_Type.glucose_ema_lbd_wide ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b c ( ^ _14) e f g h i j) };
    _16 <- lbd_3;
    _15 <- ([#"../Scratch/src/restart.rs" 142 33 142 50] UsizeToF640.usize_to_f64 _16);
    goto BB5
  }
  BB5 {
    _13 <- ([#"../Scratch/src/restart.rs" 142 8 142 51] Update0.update _14 _15);
    goto BB6
  }
  BB6 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Scratch_Restart_Impl4_BlockRestart_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  val block_restart [#"../Scratch/src/restart.rs" 145 4 145 69] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 145 37 145 41] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 145 37 145 41] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl4_BlockRestart
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant2
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose
  clone Scratch_Restart_UsizeToF64_Interface as UsizeToF640
  clone Scratch_Restart_Impl2_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Glucose_Type.t_glucose,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg block_restart [#"../Scratch/src/restart.rs" 145 4 145 69] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Glucose_Type.t_glucose)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 145 37 145 41] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 145 37 145 41] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : borrowed (Scratch_Restart_Glucose_Type.t_glucose);
  var curr_confl_2 : usize;
  var _3 : ();
  var _4 : bool;
  var _5 : bool;
  var _6 : Float64.t;
  var _7 : usize;
  var _8 : Float64.t;
  var _9 : Float64.t;
  var _10 : Float64.t;
  var _11 : bool;
  var _12 : usize;
  var _13 : usize;
  var _14 : ();
  var _15 : ();
  var _16 : bool;
  var _17 : usize;
  var _18 : usize;
  var _19 : usize;
  var _20 : ();
  var _21 : bool;
  var _22 : usize;
  {
    self_1 <- self;
    curr_confl_2 <- curr_confl;
    goto BB0
  }
  BB0 {
    _7 <- Scratch_Restart_Glucose_Type.glucose_last_trail_size ( * self_1);
    _6 <- ([#"../Scratch/src/restart.rs" 146 11 146 45] UsizeToF640.usize_to_f64 _7);
    goto BB4
  }
  BB1 {
    _4 <- ([#"../Scratch/src/restart.rs" 146 11 147 73] false);
    goto BB3
  }
  BB2 {
    _12 <- curr_confl_2;
    _13 <- Scratch_Restart_Glucose_Type.glucose_minimum_conflicts_for_blocking_restarts ( * self_1);
    _11 <- ([#"../Scratch/src/restart.rs" 147 15 147 73] _12 >= _13);
    _4 <- _11;
    _11 <- any bool;
    goto BB3
  }
  BB3 {
    switch (_4)
      | False -> goto BB12
      | True -> goto BB5
      end
  }
  BB4 {
    _9 <- Scratch_Restart_Glucose_Type.glucose_block ( * self_1);
    _10 <- Scratch_Restart_Ema_Type.ema_value (Scratch_Restart_Glucose_Type.glucose_ema_trail_wide ( * self_1));
    _8 <- ([#"../Scratch/src/restart.rs" 146 48 146 86] _9 .* _10);
    _5 <- ([#"../Scratch/src/restart.rs" 146 11 146 86] _6 .> _8);
    switch (_5)
      | False -> goto BB1
      | True -> goto BB2
      end
  }
  BB5 {
    _17 <- curr_confl_2;
    _18 <- ([#"../Scratch/src/restart.rs" 149 28 149 43] ([#"../Scratch/src/restart.rs" 149 28 149 38] (18446744073709551615 : usize)) - ([#"../Scratch/src/restart.rs" 149 41 149 43] (50 : usize)));
    _16 <- ([#"../Scratch/src/restart.rs" 149 15 149 43] _17 < _18);
    switch (_16)
      | False -> goto BB7
      | True -> goto BB6
      end
  }
  BB6 {
    _19 <- curr_confl_2;
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose ([#"../Scratch/src/restart.rs" 150 16 150 56] _19 + ([#"../Scratch/src/restart.rs" 150 54 150 56] (50 : usize))) b c d e f g h i j) };
    _15 <- ();
    goto BB8
  }
  BB7 {
    _15 <- ();
    goto BB8
  }
  BB8 {
    _22 <- Scratch_Restart_Glucose_Type.glucose_num_blocked ( * self_1);
    _21 <- ([#"../Scratch/src/restart.rs" 152 15 152 44] _22 < ([#"../Scratch/src/restart.rs" 152 34 152 44] (18446744073709551615 : usize)));
    switch (_21)
      | False -> goto BB10
      | True -> goto BB9
      end
  }
  BB9 {
    self_1 <- { self_1 with current = (let Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i j =  * self_1 in Scratch_Restart_Glucose_Type.C_Glucose a b c d e f g h i ([#"../Scratch/src/restart.rs" 153 16 153 37] Scratch_Restart_Glucose_Type.glucose_num_blocked ( * self_1) + ([#"../Scratch/src/restart.rs" 153 36 153 37] (1 : usize)))) };
    assume { Resolve0.resolve self_1 };
    _20 <- ();
    goto BB11
  }
  BB10 {
    assume { Resolve0.resolve self_1 };
    _20 <- ();
    goto BB11
  }
  BB11 {
    _0 <- ([#"../Scratch/src/restart.rs" 155 19 155 23] true);
    goto BB13
  }
  BB12 {
    assume { Resolve0.resolve self_1 };
    _3 <- ();
    _0 <- ([#"../Scratch/src/restart.rs" 157 8 157 13] false);
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module Scratch_Restart_Luby_Type
  use prelude.Int
  use prelude.UIntSize
  type t_luby  =
    | C_Luby usize usize usize
    
  let function luby_step (self : t_luby) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Luby a _ _ -> a
      end
  let function luby_limit (self : t_luby) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Luby _ _ a -> a
      end
  let function luby_curr_restarts (self : t_luby) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Luby _ a _ -> a
      end
end
module Scratch_Restart_Impl5_Invariant_Stub
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 173 4 173 30] (self : Scratch_Restart_Luby_Type.t_luby)
    
end
module Scratch_Restart_Impl5_Invariant_Interface
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 173 4 173 30] (self : Scratch_Restart_Luby_Type.t_luby)
    
end
module Scratch_Restart_Impl5_Invariant
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 173 4 173 30] (self : Scratch_Restart_Luby_Type.t_luby)
    
   =
    [#"../Scratch/src/restart.rs" 174 8 174 26] Scratch_Restart_Luby_Type.luby_step self > (0 : usize)
  val invariant' [@inline:trivial] [#"../Scratch/src/restart.rs" 173 4 173 30] (self : Scratch_Restart_Luby_Type.t_luby) : bool
    ensures { result = invariant' self }
    
end
module Scratch_Restart_Impl6_New_Interface
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant_Stub as Invariant0
  val new [#"../Scratch/src/restart.rs" 180 4 180 20] (_1' : ()) : Scratch_Restart_Luby_Type.t_luby
    ensures { [#"../Scratch/src/restart.rs" 180 16 180 20] Invariant0.invariant' result }
    
end
module Scratch_Restart_Impl6_New
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant as Invariant0
  let rec cfg new [#"../Scratch/src/restart.rs" 180 4 180 20] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : Scratch_Restart_Luby_Type.t_luby
    ensures { [#"../Scratch/src/restart.rs" 180 16 180 20] Invariant0.invariant' result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Restart_Luby_Type.t_luby;
  {
    goto BB0
  }
  BB0 {
    _0 <- Scratch_Restart_Luby_Type.C_Luby ([#"../Scratch/src/restart.rs" 181 42 181 45] (100 : usize)) ([#"../Scratch/src/restart.rs" 181 62 181 63] (0 : usize)) ([#"../Scratch/src/restart.rs" 181 72 181 75] (100 : usize));
    return _0
  }
  
end
module Scratch_Restart_Luby_Interface
  use prelude.UIntSize
  use prelude.Int
  use prelude.Float64
  val luby [#"../Scratch/src/restart.rs" 187 0 187 34] (y : Float64.t) (x : usize) : usize
    requires {[#"../Scratch/src/restart.rs" 186 11 186 35] UIntSize.to_int x < 9223372036854775806}
    
end
module Scratch_Restart_Luby
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  clone Scratch_Restart_F64ToUsize_Interface as F64ToUsize0
  clone Scratch_Restart_Powf_Interface as Powf0
  clone Core_Num_Impl11_Max as Max0
  let rec cfg luby [#"../Scratch/src/restart.rs" 187 0 187 34] [@cfg:stackify] [@cfg:subregion_analysis] (y : Float64.t) (x : usize) : usize
    requires {[#"../Scratch/src/restart.rs" 186 11 186 35] UIntSize.to_int x < 9223372036854775806}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var y_1 : Float64.t;
  var x_2 : usize;
  var size_4 : usize;
  var seq_5 : usize;
  var _6 : ();
  var _10 : ();
  var _11 : bool;
  var _12 : usize;
  var _13 : usize;
  var _14 : usize;
  var _15 : usize;
  var _16 : usize;
  var _17 : ();
  var _18 : ();
  var _19 : ();
  var x_20 : usize;
  var _21 : ();
  var _22 : bool;
  var _23 : bool;
  var _24 : bool;
  var _25 : usize;
  var _26 : bool;
  var _27 : usize;
  var _28 : bool;
  var _29 : usize;
  var _30 : usize;
  var _31 : usize;
  var _32 : usize;
  var _33 : usize;
  var _34 : bool;
  var _35 : bool;
  var _36 : usize;
  var _37 : usize;
  var _38 : bool;
  var _39 : ();
  var _40 : ();
  var _41 : ();
  var _42 : Float64.t;
  var _43 : Float64.t;
  var _44 : usize;
  {
    y_1 <- y;
    x_2 <- x;
    goto BB0
  }
  BB0 {
    size_4 <- ([#"../Scratch/src/restart.rs" 188 19 188 20] (1 : usize));
    seq_5 <- ([#"../Scratch/src/restart.rs" 189 25 189 26] (0 : usize));
    goto BB1
  }
  BB1 {
    invariant { [#"../Scratch/src/restart.rs" 190 16 190 36] UIntSize.to_int size_4 <= UIntSize.to_int Max0.mAX' };
    invariant { [#"../Scratch/src/restart.rs" 191 16 191 25] UIntSize.to_int size_4 > 0 };
    invariant { [#"../Scratch/src/restart.rs" 192 16 192 28] UIntSize.to_int seq_5 < UIntSize.to_int size_4 };
    goto BB2
  }
  BB2 {
    _12 <- size_4;
    _14 <- x_2;
    _13 <- ([#"../Scratch/src/restart.rs" 193 17 193 22] _14 + ([#"../Scratch/src/restart.rs" 193 21 193 22] (1 : usize)));
    _11 <- ([#"../Scratch/src/restart.rs" 193 10 193 22] _12 < _13);
    switch (_11)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    seq_5 <- ([#"../Scratch/src/restart.rs" 194 8 194 16] seq_5 + ([#"../Scratch/src/restart.rs" 194 15 194 16] (1 : usize)));
    _16 <- size_4;
    _15 <- ([#"../Scratch/src/restart.rs" 195 15 195 23] ([#"../Scratch/src/restart.rs" 195 15 195 16] (2 : usize)) * _16);
    size_4 <- ([#"../Scratch/src/restart.rs" 195 8 195 27] _15 + ([#"../Scratch/src/restart.rs" 195 26 195 27] (1 : usize)));
    _10 <- ();
    goto BB1
  }
  BB4 {
    _6 <- ();
    x_20 <- x_2;
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    _25 <- size_4;
    _24 <- ([#"../Scratch/src/restart.rs" 200 10 200 18] _25 > ([#"../Scratch/src/restart.rs" 200 17 200 18] (0 : usize)));
    switch (_24)
      | False -> goto BB10
      | True -> goto BB11
      end
  }
  BB7 {
    _22 <- ([#"../Scratch/src/restart.rs" 200 10 200 46] false);
    goto BB9
  }
  BB8 {
    _30 <- size_4;
    _29 <- ([#"../Scratch/src/restart.rs" 200 33 200 41] _30 - ([#"../Scratch/src/restart.rs" 200 40 200 41] (1 : usize)));
    _31 <- x_20;
    _28 <- ([#"../Scratch/src/restart.rs" 200 33 200 46] _29 <> _31);
    _22 <- _28;
    _28 <- any bool;
    goto BB9
  }
  BB9 {
    switch (_22)
      | False -> goto BB19
      | True -> goto BB13
      end
  }
  BB10 {
    _23 <- ([#"../Scratch/src/restart.rs" 200 10 200 29] false);
    goto BB12
  }
  BB11 {
    _27 <- seq_5;
    _26 <- ([#"../Scratch/src/restart.rs" 200 22 200 29] _27 > ([#"../Scratch/src/restart.rs" 200 28 200 29] (0 : usize)));
    _23 <- _26;
    _26 <- any bool;
    goto BB12
  }
  BB12 {
    switch (_23)
      | False -> goto BB7
      | True -> goto BB8
      end
  }
  BB13 {
    _33 <- size_4;
    _32 <- ([#"../Scratch/src/restart.rs" 203 15 203 25] _33 - ([#"../Scratch/src/restart.rs" 203 23 203 24] (1 : usize)));
    _34 <- ([#"../Scratch/src/restart.rs" 203 15 203 29] ([#"../Scratch/src/restart.rs" 203 28 203 29] (2 : usize)) = ([#"../Scratch/src/restart.rs" 203 15 203 29] (0 : usize)));
    assert { [@expl:division by zero] [#"../Scratch/src/restart.rs" 203 15 203 29] not _34 };
    goto BB14
  }
  BB14 {
    size_4 <- ([#"../Scratch/src/restart.rs" 203 8 203 29] _32 / ([#"../Scratch/src/restart.rs" 203 28 203 29] (2 : usize)));
    seq_5 <- ([#"../Scratch/src/restart.rs" 204 8 204 16] seq_5 - ([#"../Scratch/src/restart.rs" 204 15 204 16] (1 : usize)));
    _36 <- size_4;
    _35 <- ([#"../Scratch/src/restart.rs" 205 11 205 19] _36 > ([#"../Scratch/src/restart.rs" 205 18 205 19] (0 : usize)));
    switch (_35)
      | False -> goto BB17
      | True -> goto BB15
      end
  }
  BB15 {
    _37 <- size_4;
    _38 <- ([#"../Scratch/src/restart.rs" 206 12 206 21] _37 = ([#"../Scratch/src/restart.rs" 206 12 206 21] (0 : usize)));
    assert { [@expl:remainder by zero] [#"../Scratch/src/restart.rs" 206 12 206 21] not _38 };
    goto BB16
  }
  BB16 {
    x_20 <- ([#"../Scratch/src/restart.rs" 206 12 206 21] x_20 % _37);
    _10 <- ();
    goto BB18
  }
  BB17 {
    _10 <- ();
    goto BB18
  }
  BB18 {
    goto BB5
  }
  BB19 {
    _21 <- ();
    _43 <- y_1;
    _44 <- seq_5;
    _42 <- ([#"../Scratch/src/restart.rs" 211 17 211 29] Powf0.powf _43 _44);
    goto BB20
  }
  BB20 {
    _0 <- ([#"../Scratch/src/restart.rs" 211 4 211 30] F64ToUsize0.f64_to_usize _42);
    goto BB21
  }
  BB21 {
    return _0
  }
  
end
module Scratch_Restart_Impl7_TriggerRestart_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Luby_Type.t_luby
  val trigger_restart [#"../Scratch/src/restart.rs" 216 4 216 71] (self : borrowed (Scratch_Restart_Luby_Type.t_luby)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 216 39 216 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 216 39 216 43] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl7_TriggerRestart
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float32
  clone Scratch_Restart_Luby_Interface as Luby1
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Luby_Type.t_luby
  clone Scratch_Restart_Impl5_Invariant as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Luby_Type.t_luby,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg trigger_restart [#"../Scratch/src/restart.rs" 216 4 216 71] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Luby_Type.t_luby)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 216 39 216 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 216 39 216 43] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : borrowed (Scratch_Restart_Luby_Type.t_luby);
  var curr_confl_2 : usize;
  var _3 : ();
  var _4 : bool;
  var _5 : usize;
  var _6 : usize;
  var _7 : ();
  var _8 : ();
  var _9 : bool;
  var _10 : usize;
  var _11 : ();
  var incr_12 : usize;
  var _13 : usize;
  var _14 : ();
  var _15 : bool;
  var _16 : usize;
  var _17 : usize;
  var _18 : usize;
  var _19 : bool;
  var _20 : usize;
  var _21 : ();
  var _22 : bool;
  var _23 : usize;
  var _24 : usize;
  var _25 : usize;
  var _26 : usize;
  var _27 : usize;
  {
    self_1 <- self;
    curr_confl_2 <- curr_confl;
    goto BB0
  }
  BB0 {
    _5 <- curr_confl_2;
    _6 <- Scratch_Restart_Luby_Type.luby_limit ( * self_1);
    _4 <- ([#"../Scratch/src/restart.rs" 217 11 217 35] _5 <= _6);
    switch (_4)
      | False -> goto BB2
      | True -> goto BB1
      end
  }
  BB1 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"../Scratch/src/restart.rs" 218 19 218 24] false);
    goto BB13
  }
  BB2 {
    _3 <- ();
    _10 <- Scratch_Restart_Luby_Type.luby_curr_restarts ( * self_1);
    _9 <- ([#"../Scratch/src/restart.rs" 222 11 222 52] _10 >= ([#"../Scratch/src/restart.rs" 222 33 222 52] (9223372036854775806 : usize)));
    switch (_9)
      | False -> goto BB4
      | True -> goto BB3
      end
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"../Scratch/src/restart.rs" 223 19 223 23] true);
    goto BB13
  }
  BB4 {
    _8 <- ();
    _13 <- Scratch_Restart_Luby_Type.luby_curr_restarts ( * self_1);
    incr_12 <- ([#"../Scratch/src/restart.rs" 226 23 226 52] Luby1.luby ([#"../Scratch/src/restart.rs" 226 28 226 31] 2.0000000000000000000000000000000000000000000000000000000000000000) _13);
    goto BB5
  }
  BB5 {
    _16 <- incr_12;
    _18 <- Scratch_Restart_Luby_Type.luby_step ( * self_1);
    _19 <- ([#"../Scratch/src/restart.rs" 227 18 227 40] _18 = ([#"../Scratch/src/restart.rs" 227 18 227 40] (0 : usize)));
    assert { [@expl:division by zero] [#"../Scratch/src/restart.rs" 227 18 227 40] not _19 };
    goto BB6
  }
  BB6 {
    _17 <- ([#"../Scratch/src/restart.rs" 227 18 227 40] ([#"../Scratch/src/restart.rs" 227 18 227 28] (18446744073709551615 : usize)) / _18);
    _15 <- ([#"../Scratch/src/restart.rs" 227 11 227 40] _16 < _17);
    switch (_15)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    _20 <- Scratch_Restart_Luby_Type.luby_step ( * self_1);
    incr_12 <- ([#"../Scratch/src/restart.rs" 228 12 228 29] incr_12 * _20);
    _14 <- ();
    goto BB9
  }
  BB8 {
    _14 <- ();
    goto BB9
  }
  BB9 {
    _24 <- curr_confl_2;
    _23 <- ([#"../Scratch/src/restart.rs" 230 11 230 34] ([#"../Scratch/src/restart.rs" 230 11 230 21] (18446744073709551615 : usize)) - _24);
    _25 <- incr_12;
    _22 <- ([#"../Scratch/src/restart.rs" 230 11 230 41] _23 > _25);
    switch (_22)
      | False -> goto BB11
      | True -> goto BB10
      end
  }
  BB10 {
    _26 <- curr_confl_2;
    _27 <- incr_12;
    self_1 <- { self_1 with current = (let Scratch_Restart_Luby_Type.C_Luby a b c =  * self_1 in Scratch_Restart_Luby_Type.C_Luby a b ([#"../Scratch/src/restart.rs" 231 12 231 42] _26 + _27)) };
    _21 <- ();
    goto BB12
  }
  BB11 {
    _21 <- ();
    goto BB12
  }
  BB12 {
    self_1 <- { self_1 with current = (let Scratch_Restart_Luby_Type.C_Luby a b c =  * self_1 in Scratch_Restart_Luby_Type.C_Luby a ([#"../Scratch/src/restart.rs" 233 8 233 31] Scratch_Restart_Luby_Type.luby_curr_restarts ( * self_1) + ([#"../Scratch/src/restart.rs" 233 30 233 31] (1 : usize))) c) };
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"../Scratch/src/restart.rs" 236 8 236 12] true);
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module Scratch_Restart_RestartMode_Type
  type t_restartmode  =
    | C_Glucose
    | C_Luby
    
end
module Scratch_Restart_Restart_Type
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  type t_restart  =
    | C_Restart (Scratch_Restart_RestartMode_Type.t_restartmode) (Scratch_Restart_Luby_Type.t_luby) (Scratch_Restart_Glucose_Type.t_glucose)
    
  let function restart_luby (self : t_restart) : Scratch_Restart_Luby_Type.t_luby = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Restart _ a _ -> a
      end
  let function restart_glucose (self : t_restart) : Scratch_Restart_Glucose_Type.t_glucose
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Restart _ _ a -> a
      end
  let function restart_restart (self : t_restart) : Scratch_Restart_RestartMode_Type.t_restartmode
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Restart a _ _ -> a
      end
end
module Scratch_Restart_Impl8_Invariant_Stub
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  predicate invariant' [#"../Scratch/src/restart.rs" 249 4 249 30] (self : Scratch_Restart_Restart_Type.t_restart)
end
module Scratch_Restart_Impl8_Invariant_Interface
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  predicate invariant' [#"../Scratch/src/restart.rs" 249 4 249 30] (self : Scratch_Restart_Restart_Type.t_restart)
end
module Scratch_Restart_Impl8_Invariant
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl2_Invariant_Stub as Invariant1
  clone Scratch_Restart_Impl5_Invariant_Stub as Invariant0
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  predicate invariant' [#"../Scratch/src/restart.rs" 249 4 249 30] (self : Scratch_Restart_Restart_Type.t_restart) =
    [#"../Scratch/src/restart.rs" 250 8 253 9] Invariant0.invariant' (Scratch_Restart_Restart_Type.restart_luby self) /\ Invariant1.invariant' (Scratch_Restart_Restart_Type.restart_glucose self)
  val invariant' [#"../Scratch/src/restart.rs" 249 4 249 30] (self : Scratch_Restart_Restart_Type.t_restart) : bool
    ensures { result = invariant' self }
    
end
module Scratch_Restart_Impl9_New_Interface
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant_Stub as Invariant0
  val new [#"../Scratch/src/restart.rs" 258 4 258 34] (_1' : ()) : Scratch_Restart_Restart_Type.t_restart
    ensures { [#"../Scratch/src/restart.rs" 258 27 258 34] Invariant0.invariant' result }
    
end
module Scratch_Restart_Impl9_New
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant3
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant2 with
    predicate Invariant0.invariant' = Invariant3.invariant'
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant as Invariant1
  clone Scratch_Restart_Impl3_New_Interface as New1 with
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone Scratch_Restart_Impl6_New_Interface as New0 with
    predicate Invariant0.invariant' = Invariant1.invariant'
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant as Invariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    predicate Invariant1.invariant' = Invariant2.invariant'
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  let rec cfg new [#"../Scratch/src/restart.rs" 258 4 258 34] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : Scratch_Restart_Restart_Type.t_restart
    ensures { [#"../Scratch/src/restart.rs" 258 27 258 34] Invariant0.invariant' result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Restart_Restart_Type.t_restart;
  var _1 : Scratch_Restart_RestartMode_Type.t_restartmode;
  var _2 : Scratch_Restart_Luby_Type.t_luby;
  var _3 : Scratch_Restart_Glucose_Type.t_glucose;
  {
    goto BB0
  }
  BB0 {
    _1 <- Scratch_Restart_RestartMode_Type.C_Glucose;
    _2 <- ([#"../Scratch/src/restart.rs" 259 55 259 66] New0.new ());
    goto BB1
  }
  BB1 {
    _3 <- ([#"../Scratch/src/restart.rs" 259 77 259 91] New1.new ());
    goto BB2
  }
  BB2 {
    _0 <- Scratch_Restart_Restart_Type.C_Restart _1 _2 _3;
    return _0
  }
  
end
module Scratch_Restart_Impl9_SetRestartMode_Interface
  use prelude.Borrow
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  val set_restart_mode [#"../Scratch/src/restart.rs" 262 4 262 64] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (mode : Scratch_Restart_RestartMode_Type.t_restartmode) : ()
    requires {[#"../Scratch/src/restart.rs" 262 40 262 44] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 262 40 262 44] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl9_SetRestartMode
  use prelude.Borrow
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant4
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant3 with
    predicate Invariant0.invariant' = Invariant4.invariant'
  clone Scratch_Restart_Impl5_Invariant as Invariant2
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  clone Scratch_Restart_Impl8_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart,
    predicate Invariant0.invariant' = Invariant1.invariant'
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  let rec cfg set_restart_mode [#"../Scratch/src/restart.rs" 262 4 262 64] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (mode : Scratch_Restart_RestartMode_Type.t_restartmode) : ()
    requires {[#"../Scratch/src/restart.rs" 262 40 262 44] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 262 40 262 44] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Restart_Restart_Type.t_restart);
  var mode_2 : Scratch_Restart_RestartMode_Type.t_restartmode;
  var _3 : Scratch_Restart_RestartMode_Type.t_restartmode;
  {
    self_1 <- self;
    mode_2 <- mode;
    goto BB0
  }
  BB0 {
    _3 <- mode_2;
    mode_2 <- any Scratch_Restart_RestartMode_Type.t_restartmode;
    self_1 <- { self_1 with current = (let Scratch_Restart_Restart_Type.C_Restart a b c =  * self_1 in Scratch_Restart_Restart_Type.C_Restart _3 b c) };
    _3 <- any Scratch_Restart_RestartMode_Type.t_restartmode;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Scratch_Restart_Impl9_TriggerRestart_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  val trigger_restart [#"../Scratch/src/restart.rs" 266 4 266 71] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 266 39 266 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 266 39 266 43] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl9_TriggerRestart
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.IntSize
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant6
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant3 with
    predicate Invariant0.invariant' = Invariant6.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant5 with
    type t = Scratch_Restart_Glucose_Type.t_glucose,
    predicate Invariant0.invariant' = Invariant3.invariant'
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant as Invariant2
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant4 with
    type t = Scratch_Restart_Luby_Type.t_luby,
    predicate Invariant0.invariant' = Invariant2.invariant'
  clone Scratch_Restart_Impl4_TriggerRestart_Interface as TriggerRestart1 with
    predicate Invariant0.invariant' = Invariant5.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  clone Scratch_Restart_Impl7_TriggerRestart_Interface as TriggerRestart0 with
    predicate Invariant0.invariant' = Invariant4.invariant',
    predicate Invariant1.invariant' = Invariant2.invariant'
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  clone Scratch_Restart_Impl8_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg trigger_restart [#"../Scratch/src/restart.rs" 266 4 266 71] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 266 39 266 43] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 266 39 266 43] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : borrowed (Scratch_Restart_Restart_Type.t_restart);
  var curr_confl_2 : usize;
  var _3 : isize;
  var _4 : borrowed (Scratch_Restart_Glucose_Type.t_glucose);
  var _5 : usize;
  var _6 : borrowed (Scratch_Restart_Luby_Type.t_luby);
  var _7 : usize;
  {
    self_1 <- self;
    curr_confl_2 <- curr_confl;
    goto BB0
  }
  BB0 {
    switch (Scratch_Restart_Restart_Type.restart_restart ( * self_1))
      | Scratch_Restart_RestartMode_Type.C_Glucose -> goto BB1
      | Scratch_Restart_RestartMode_Type.C_Luby -> goto BB2
      end
  }
  BB1 {
    goto BB4
  }
  BB2 {
    _6 <- borrow_mut (Scratch_Restart_Restart_Type.restart_luby ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Restart_Type.C_Restart a b c =  * self_1 in Scratch_Restart_Restart_Type.C_Restart a ( ^ _6) c) };
    _7 <- curr_confl_2;
    _0 <- ([#"../Scratch/src/restart.rs" 269 33 269 70] TriggerRestart0.trigger_restart _6 _7);
    goto BB6
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB4 {
    _4 <- borrow_mut (Scratch_Restart_Restart_Type.restart_glucose ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Restart_Type.C_Restart a b c =  * self_1 in Scratch_Restart_Restart_Type.C_Restart a b ( ^ _4)) };
    _5 <- curr_confl_2;
    _0 <- ([#"../Scratch/src/restart.rs" 268 36 268 76] TriggerRestart1.trigger_restart _4 _5);
    goto BB5
  }
  BB5 {
    assume { Resolve0.resolve self_1 };
    goto BB7
  }
  BB6 {
    assume { Resolve0.resolve self_1 };
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Scratch_Restart_Impl9_BlockRestart_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant_Stub as Invariant1
  clone CreusotContracts_Invariant_Impl1_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  val block_restart [#"../Scratch/src/restart.rs" 273 4 273 69] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 273 37 273 41] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 273 37 273 41] Invariant1.invariant' ( ^ self) }
    
end
module Scratch_Restart_Impl9_BlockRestart
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.IntSize
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant5
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant3 with
    predicate Invariant0.invariant' = Invariant5.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant4 with
    type t = Scratch_Restart_Glucose_Type.t_glucose,
    predicate Invariant0.invariant' = Invariant3.invariant'
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant as Invariant2
  clone Scratch_Restart_Impl4_BlockRestart_Interface as BlockRestart0 with
    predicate Invariant0.invariant' = Invariant4.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  use Scratch_Restart_RestartMode_Type as Scratch_Restart_RestartMode_Type
  clone Scratch_Restart_Impl8_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  clone CreusotContracts_Invariant_Impl1_Invariant as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg block_restart [#"../Scratch/src/restart.rs" 273 4 273 69] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Restart_Restart_Type.t_restart)) (curr_confl : usize) : bool
    requires {[#"../Scratch/src/restart.rs" 273 37 273 41] Invariant0.invariant' self}
    ensures { [#"../Scratch/src/restart.rs" 273 37 273 41] Invariant1.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : borrowed (Scratch_Restart_Restart_Type.t_restart);
  var curr_confl_2 : usize;
  var _3 : isize;
  var _4 : borrowed (Scratch_Restart_Glucose_Type.t_glucose);
  var _5 : usize;
  {
    self_1 <- self;
    curr_confl_2 <- curr_confl;
    goto BB0
  }
  BB0 {
    switch (Scratch_Restart_Restart_Type.restart_restart ( * self_1))
      | Scratch_Restart_RestartMode_Type.C_Glucose -> goto BB1
      | Scratch_Restart_RestartMode_Type.C_Luby -> goto BB2
      end
  }
  BB1 {
    goto BB4
  }
  BB2 {
    assume { Resolve0.resolve self_1 };
    _0 <- ([#"../Scratch/src/restart.rs" 276 33 276 37] true);
    goto BB6
  }
  BB3 {
    assume { Resolve0.resolve self_1 };
    absurd
  }
  BB4 {
    _4 <- borrow_mut (Scratch_Restart_Restart_Type.restart_glucose ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Restart_Restart_Type.C_Restart a b c =  * self_1 in Scratch_Restart_Restart_Type.C_Restart a b ( ^ _4)) };
    _5 <- curr_confl_2;
    _0 <- ([#"../Scratch/src/restart.rs" 275 36 275 74] BlockRestart0.block_restart _4 _5);
    goto BB5
  }
  BB5 {
    assume { Resolve0.resolve self_1 };
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module CreusotContracts_Invariant_Impl0_Invariant_Stub
  type t
  use prelude.Borrow
  predicate invariant' (self : t)
end
module CreusotContracts_Invariant_Impl0_Invariant_Interface
  type t
  use prelude.Borrow
  predicate invariant' (self : t)
end
module CreusotContracts_Invariant_Impl0_Invariant
  type t
  use prelude.Borrow
  clone CreusotContracts_Invariant_Invariant_Invariant_Stub as Invariant0 with
    type self = t
  predicate invariant' (self : t) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/invariant.rs" 26 20 26 39] Invariant0.invariant' self
  val invariant' (self : t) : bool
    ensures { result = invariant' self }
    
end
module Scratch_Restart_Impl9_GetNumberOfRestarts_Interface
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone CreusotContracts_Invariant_Impl0_Invariant_Stub as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart
  val get_number_of_restarts [#"../Scratch/src/restart.rs" 280 4 280 56] (self : Scratch_Restart_Restart_Type.t_restart) : usize
    requires {[#"../Scratch/src/restart.rs" 280 42 280 46] Invariant0.invariant' self}
    
end
module Scratch_Restart_Impl9_GetNumberOfRestarts
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use Scratch_Restart_Ema_Type as Scratch_Restart_Ema_Type
  clone Scratch_Restart_Impl0_Invariant as Invariant4
  use Scratch_Restart_Glucose_Type as Scratch_Restart_Glucose_Type
  clone Scratch_Restart_Impl2_Invariant as Invariant3 with
    predicate Invariant0.invariant' = Invariant4.invariant'
  use Scratch_Restart_Luby_Type as Scratch_Restart_Luby_Type
  clone Scratch_Restart_Impl5_Invariant as Invariant2
  use Scratch_Restart_Restart_Type as Scratch_Restart_Restart_Type
  clone Scratch_Restart_Impl8_Invariant as Invariant1 with
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate Invariant1.invariant' = Invariant3.invariant'
  clone CreusotContracts_Invariant_Impl0_Invariant as Invariant0 with
    type t = Scratch_Restart_Restart_Type.t_restart,
    predicate Invariant0.invariant' = Invariant1.invariant'
  let rec cfg get_number_of_restarts [#"../Scratch/src/restart.rs" 280 4 280 56] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Restart_Restart_Type.t_restart) : usize
    requires {[#"../Scratch/src/restart.rs" 280 42 280 46] Invariant0.invariant' self}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self_1 : Scratch_Restart_Restart_Type.t_restart;
  var _2 : bool;
  var _3 : usize;
  var _4 : usize;
  var _5 : usize;
  var _6 : usize;
  var _7 : usize;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- Scratch_Restart_Glucose_Type.glucose_num_restarts (Scratch_Restart_Restart_Type.restart_glucose self_1);
    _3 <- ([#"../Scratch/src/restart.rs" 281 11 281 49] ([#"../Scratch/src/restart.rs" 281 11 281 21] (18446744073709551615 : usize)) - _4);
    _5 <- Scratch_Restart_Luby_Type.luby_curr_restarts (Scratch_Restart_Restart_Type.restart_luby self_1);
    _2 <- ([#"../Scratch/src/restart.rs" 281 11 281 75] _3 > _5);
    switch (_2)
      | False -> goto BB2
      | True -> goto BB1
      end
  }
  BB1 {
    _6 <- Scratch_Restart_Glucose_Type.glucose_num_restarts (Scratch_Restart_Restart_Type.restart_glucose self_1);
    _7 <- Scratch_Restart_Luby_Type.luby_curr_restarts (Scratch_Restart_Restart_Type.restart_luby self_1);
    _0 <- ([#"../Scratch/src/restart.rs" 282 12 282 63] _6 + _7);
    goto BB3
  }
  BB2 {
    _0 <- ([#"../Scratch/src/restart.rs" 284 12 284 22] (18446744073709551615 : usize));
    goto BB3
  }
  BB3 {
    return _0
  }
  
end
module Scratch_Vsids_Invalid_Stub
  use prelude.Int
  use prelude.UIntSize
  val constant iNVALID' [#"../Scratch/src/vsids.rs" 8 0 8 20]  : usize
end
module Scratch_Vsids_Invalid
  use prelude.Int
  use prelude.UIntSize
  let constant iNVALID' [#"../Scratch/src/vsids.rs" 8 0 8 20]  : usize = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/vsids.rs" 8 0 8 20] (18446744073709551615 : usize)
end
module Scratch_Vsids_Heap_Type
  use prelude.Float64
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  type t_heap  =
    | C_Heap (Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global)) (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)) usize
    
  let function heap_num_vars (self : t_heap) : usize = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Heap _ _ _ a -> a
      end
  let function heap_activity (self : t_heap) : Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Heap a _ _ _ -> a
      end
  let function heap_indices (self : t_heap) : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Heap _ _ a _ -> a
      end
  let function heap_heap (self : t_heap) : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_Heap _ a _ _ -> a
      end
end
module Scratch_Vsids_Impl0_Invariant_Stub
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/vsids.rs" 23 4 23 30] (self : Scratch_Vsids_Heap_Type.t_heap)
end
module Scratch_Vsids_Impl0_Invariant_Interface
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/vsids.rs" 23 4 23 30] (self : Scratch_Vsids_Heap_Type.t_heap)
end
module Scratch_Vsids_Impl0_Invariant
  use prelude.UIntSize
  use prelude.Int
  use seq.Seq
  use prelude.Float64
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  predicate invariant' [@inline:trivial] [#"../Scratch/src/vsids.rs" 23 4 23 30] (self : Scratch_Vsids_Heap_Type.t_heap)
   =
    [#"../Scratch/src/vsids.rs" 24 8 31 9] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars self) < 9223372036854775807 /\ Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_activity self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars self) /\ Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_indices self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars self) /\ Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self)) <= UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars self) /\ (forall i : int . 0 <= i /\ i < Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self)) -> UIntSize.to_int (Seq.get (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self)) i) < Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_indices self)) /\ UIntSize.to_int (Seq.get (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self)) i) < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_activity self)))
  val invariant' [@inline:trivial] [#"../Scratch/src/vsids.rs" 23 4 23 30] (self : Scratch_Vsids_Heap_Type.t_heap) : bool
    ensures { result = invariant' self }
    
end
module CreusotContracts_Model_Impl1_ShallowModel_Stub
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel_Interface
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy
end
module CreusotContracts_Model_Impl1_ShallowModel
  type t
  use prelude.Borrow
  clone CreusotContracts_Model_ShallowModel_ShallowModelTy_Type as ShallowModelTy0 with
    type self = t
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = t,
    type ShallowModelTy0.shallowModelTy = ShallowModelTy0.shallowModelTy
  function shallow_model (self : t) : ShallowModelTy0.shallowModelTy =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/model.rs" 38 8 38 31] ShallowModel0.shallow_model self
  val shallow_model (self : t) : ShallowModelTy0.shallowModelTy
    ensures { result = shallow_model self }
    
end
module Alloc_Vec_Impl13_Index_Interface
  type t
  type i
  type a
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  use seq.Seq
  clone Core_Slice_Index_SliceIndex_Output_Type as Output0 with
    type self = i,
    type t = slice t
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Slice_SliceIndex_HasValue_Stub as HasValue0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t,
    type Output0.output = Output0.output
  clone CreusotContracts_Std1_Slice_SliceIndex_InBounds_Stub as InBounds0 with
    type self = i,
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val index (self : Alloc_Vec_Vec_Type.t_vec t a) (index : i) : Output0.output
    requires {[#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 127 27 127 46] InBounds0.in_bounds index (ShallowModel0.shallow_model self)}
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 128 26 128 54] HasValue0.has_value index (ShallowModel0.shallow_model self) result }
    
end
module Scratch_Vsids_Impl1_Index_Interface
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  val index [#"../Scratch/src/vsids.rs" 40 4 40 40] (self : Scratch_Vsids_Heap_Type.t_heap) (ix : usize) : usize
    requires {[#"../Scratch/src/vsids.rs" 38 15 38 37] UIntSize.to_int ix < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self))}
    ensures { [#"../Scratch/src/vsids.rs" 39 14 39 40] Seq.get (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self)) (UIntSize.to_int ix) = result }
    
end
module Scratch_Vsids_Impl1_Index
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = usize
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  let rec cfg index [#"../Scratch/src/vsids.rs" 40 4 40 40] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Vsids_Heap_Type.t_heap) (ix : usize) : usize
    requires {[#"../Scratch/src/vsids.rs" 38 15 38 37] UIntSize.to_int ix < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self))}
    ensures { [#"../Scratch/src/vsids.rs" 39 14 39 40] Seq.get (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self)) (UIntSize.to_int ix) = result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self_1 : Scratch_Vsids_Heap_Type.t_heap;
  var ix_2 : usize;
  var _5 : usize;
  var _6 : usize;
  var _7 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _8 : usize;
  {
    self_1 <- self;
    ix_2 <- ix;
    goto BB0
  }
  BB0 {
    _7 <- Scratch_Vsids_Heap_Type.heap_heap self_1;
    _8 <- ix_2;
    _6 <- ([#"../Scratch/src/vsids.rs" 44 9 44 22] Index0.index _7 _8);
    goto BB1
  }
  BB1 {
    _5 <- _6;
    _0 <- _5;
    return _0
  }
  
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub
  type t
  type s
  use prelude.Int
  function index_logic [@inline:trivial] (self : s) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic_Interface
  type t
  type s
  use prelude.Int
  function index_logic [@inline:trivial] (self : s) (ix : int) : t
end
module CreusotContracts_Logic_Ops_Impl0_IndexLogic
  type t
  type s
  use prelude.Int
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Model_ShallowModel_ShallowModel_Stub as ShallowModel0 with
    type self = s,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  function index_logic [@inline:trivial] (self : s) (ix : int) : t =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/logic/ops.rs" 16 8 16 31] Seq.get (ShallowModel0.shallow_model self) ix
  val index_logic [@inline:trivial] (self : s) (ix : int) : t
    ensures { result = index_logic self ix }
    
end
module CreusotContracts_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Std1_Vec_Impl10_Resolve_Stub
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
end
module CreusotContracts_Std1_Vec_Impl10_Resolve_Interface
  type t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  predicate resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global))
end
module CreusotContracts_Std1_Vec_Impl10_Resolve
  type t
  use prelude.Int
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Resolve_Resolve_Resolve_Stub as Resolve0 with
    type self = t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type s = Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 47 8 47 85] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel0.shallow_model self) -> Resolve0.resolve (IndexLogic0.index_logic self i)
  val resolve (self : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)) : bool
    ensures { result = resolve self }
    
end
module Alloc_Vec_Impl0_New_Interface
  type t
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val new (_1' : ()) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 55 26 55 44] Seq.length (ShallowModel0.shallow_model result) = 0 }
    
end
module CreusotContracts_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/resolve.rs" 33 8 33 12] true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module Scratch_Vsids_Test_Interface
  val test [#"../Scratch/src/vsids.rs" 65 0 65 9] (_1' : ()) : ()
end
module Scratch_Vsids_Test
  use prelude.Int
  use prelude.Int32
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Resolve_Impl2_Resolve as Resolve1 with
    type t = usize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = usize,
    type s = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Std1_Vec_Impl10_Resolve as Resolve0 with
    type t = usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    predicate Resolve0.resolve = Resolve1.resolve,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl0_New_Interface as New0 with
    type t = usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg test [#"../Scratch/src/vsids.rs" 65 0 65 9] [@cfg:stackify] [@cfg:subregion_analysis] (_1' : ()) : ()
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var i_1 : int32;
  var n_2 : int32;
  var heap_3 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _5 : ();
  var _6 : bool;
  var _7 : int32;
  var _8 : int32;
  var _9 : ();
  var _10 : ();
  var _11 : ();
  {
    goto BB0
  }
  BB0 {
    i_1 <- ([#"../Scratch/src/vsids.rs" 66 16 66 17] (0 : int32));
    n_2 <- ([#"../Scratch/src/vsids.rs" 67 12 67 14] (10 : int32));
    heap_3 <- ([#"../Scratch/src/vsids.rs" 68 26 68 36] New0.new ());
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve heap_3 };
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    invariant { [#"../Scratch/src/vsids.rs" 69 16 69 33] Seq.length (ShallowModel0.shallow_model heap_3) = Int32.to_int i_1 };
    goto BB4
  }
  BB4 {
    _7 <- i_1;
    _8 <- n_2;
    _6 <- ([#"../Scratch/src/vsids.rs" 70 10 70 15] _7 < _8);
    switch (_6)
      | False -> goto BB6
      | True -> goto BB5
      end
  }
  BB5 {
    _5 <- ();
    goto BB3
  }
  BB6 {
    _0 <- ();
    goto BB7
  }
  BB7 {
    return _0
  }
  
end
module Alloc_Vec_Impl1_Push_Interface
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val push (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) (value : t) : ()
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 65 26 65 51] ShallowModel0.shallow_model ( ^ self) = Seq.snoc (ShallowModel1.shallow_model self) value }
    
end
module Alloc_Vec_Impl1_Len_Interface
  type t
  type a
  use prelude.UIntSize
  use seq.Seq
  use prelude.Borrow
  use prelude.Int
  use seq.Seq
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl1_ShallowModel_Stub as ShallowModel0 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  val len (self : Alloc_Vec_Vec_Type.t_vec t a) : usize
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 62 26 62 48] UIntSize.to_int result = Seq.length (ShallowModel0.shallow_model self) }
    
end
module Scratch_Vsids_Impl2_Left_Interface
  use prelude.UIntSize
  use prelude.Int
  clone Core_Num_Impl11_Max_Stub as Max0
  val left [#"../Scratch/src/vsids.rs" 171 4 171 32] (idx : usize) : usize
    requires {[#"../Scratch/src/vsids.rs" 169 15 169 43] UIntSize.to_int idx < div (UIntSize.to_int Max0.mAX' - 1) 2}
    ensures { [#"../Scratch/src/vsids.rs" 170 14 170 37] UIntSize.to_int result = UIntSize.to_int idx * 2 + 1 }
    
end
module Scratch_Vsids_Impl2_Left
  use prelude.Int
  use prelude.UIntSize
  clone Core_Num_Impl11_Max as Max0
  let rec cfg left [#"../Scratch/src/vsids.rs" 171 4 171 32] [@cfg:stackify] [@cfg:subregion_analysis] (idx : usize) : usize
    requires {[#"../Scratch/src/vsids.rs" 169 15 169 43] UIntSize.to_int idx < div (UIntSize.to_int Max0.mAX' - 1) 2}
    ensures { [#"../Scratch/src/vsids.rs" 170 14 170 37] UIntSize.to_int result = UIntSize.to_int idx * 2 + 1 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var idx_1 : usize;
  var _4 : usize;
  var _5 : usize;
  {
    idx_1 <- idx;
    goto BB0
  }
  BB0 {
    _5 <- idx_1;
    _4 <- ([#"../Scratch/src/vsids.rs" 172 8 172 15] _5 * ([#"../Scratch/src/vsids.rs" 172 14 172 15] (2 : usize)));
    _0 <- ([#"../Scratch/src/vsids.rs" 172 8 172 19] _4 + ([#"../Scratch/src/vsids.rs" 172 18 172 19] (1 : usize)));
    return _0
  }
  
end
module Scratch_Vsids_Impl2_Right_Interface
  use prelude.UIntSize
  use prelude.Int
  clone Core_Num_Impl11_Max_Stub as Max0
  val right [#"../Scratch/src/vsids.rs" 177 4 177 33] (idx : usize) : usize
    requires {[#"../Scratch/src/vsids.rs" 175 15 175 43] UIntSize.to_int idx < div (UIntSize.to_int Max0.mAX' - 1) 2}
    ensures { [#"../Scratch/src/vsids.rs" 176 14 176 39] UIntSize.to_int result = (UIntSize.to_int idx + 1) * 2 }
    
end
module Scratch_Vsids_Impl2_Right
  use prelude.Int
  use prelude.UIntSize
  clone Core_Num_Impl11_Max as Max0
  let rec cfg right [#"../Scratch/src/vsids.rs" 177 4 177 33] [@cfg:stackify] [@cfg:subregion_analysis] (idx : usize) : usize
    requires {[#"../Scratch/src/vsids.rs" 175 15 175 43] UIntSize.to_int idx < div (UIntSize.to_int Max0.mAX' - 1) 2}
    ensures { [#"../Scratch/src/vsids.rs" 176 14 176 39] UIntSize.to_int result = (UIntSize.to_int idx + 1) * 2 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var idx_1 : usize;
  var _4 : usize;
  var _5 : usize;
  {
    idx_1 <- idx;
    goto BB0
  }
  BB0 {
    _5 <- idx_1;
    _4 <- ([#"../Scratch/src/vsids.rs" 178 8 178 17] _5 + ([#"../Scratch/src/vsids.rs" 178 15 178 16] (1 : usize)));
    _0 <- ([#"../Scratch/src/vsids.rs" 178 8 178 21] _4 * ([#"../Scratch/src/vsids.rs" 178 20 178 21] (2 : usize)));
    return _0
  }
  
end
module Scratch_Vsids_Impl2_LessThan_Interface
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use prelude.Float64
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  val less_than [#"../Scratch/src/vsids.rs" 236 4 236 51] (self : Scratch_Vsids_Heap_Type.t_heap) (x : usize) (y : usize) : bool
    requires {[#"../Scratch/src/vsids.rs" 234 15 234 40] UIntSize.to_int x < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_activity self))}
    requires {[#"../Scratch/src/vsids.rs" 235 15 235 40] UIntSize.to_int y < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_activity self))}
    
end
module Scratch_Vsids_Impl2_LessThan
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = Float64.t
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = Float64.t
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq Float64.t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = Float64.t,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = Float64.t
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  let rec cfg less_than [#"../Scratch/src/vsids.rs" 236 4 236 51] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Vsids_Heap_Type.t_heap) (x : usize) (y : usize) : bool
    requires {[#"../Scratch/src/vsids.rs" 234 15 234 40] UIntSize.to_int x < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_activity self))}
    requires {[#"../Scratch/src/vsids.rs" 235 15 235 40] UIntSize.to_int y < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_activity self))}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : Scratch_Vsids_Heap_Type.t_heap;
  var x_2 : usize;
  var y_3 : usize;
  var _6 : Float64.t;
  var _7 : Float64.t;
  var _8 : Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global);
  var _9 : usize;
  var _10 : Float64.t;
  var _11 : Float64.t;
  var _12 : Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global);
  var _13 : usize;
  {
    self_1 <- self;
    x_2 <- x;
    y_3 <- y;
    goto BB0
  }
  BB0 {
    _8 <- Scratch_Vsids_Heap_Type.heap_activity self_1;
    _9 <- x_2;
    _7 <- ([#"../Scratch/src/vsids.rs" 237 8 237 24] Index0.index _8 _9);
    goto BB1
  }
  BB1 {
    _6 <- _7;
    _12 <- Scratch_Vsids_Heap_Type.heap_activity self_1;
    _13 <- y_3;
    _11 <- ([#"../Scratch/src/vsids.rs" 237 27 237 43] Index0.index _12 _13);
    goto BB2
  }
  BB2 {
    _10 <- _11;
    _0 <- ([#"../Scratch/src/vsids.rs" 237 8 237 43] _6 .> _10);
    return _0
  }
  
end
module Scratch_Vsids_Impl2_PercolateDown_Interface
  use prelude.UIntSize
  use prelude.Int
  use prelude.Borrow
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant_Stub as Invariant0
  val percolate_down [#"../Scratch/src/vsids.rs" 284 4 284 48] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) (idx : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 279 15 279 41] UIntSize.to_int idx < 9223372036854775807}
    requires {[#"../Scratch/src/vsids.rs" 282 4 282 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 283 15 283 38] UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self)))}
    ensures { [#"../Scratch/src/vsids.rs" 280 14 280 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    ensures { [#"../Scratch/src/vsids.rs" 281 14 281 53] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self))) = Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( ^ self))) }
    ensures { [#"../Scratch/src/vsids.rs" 282 4 282 40] Invariant0.invariant' ( ^ self) }
    
end
module Scratch_Vsids_Impl2_PercolateDown
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.Float64
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Scratch_Vsids_Heap_Type.t_heap
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = usize
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = usize,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Vsids_Impl2_LessThan_Interface as LessThan0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl2_Right_Interface as Right0 with
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Scratch_Vsids_Impl2_Left_Interface as Left0 with
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl1_Index_Interface as Index0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl0_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg percolate_down [#"../Scratch/src/vsids.rs" 284 4 284 48] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) (idx : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 279 15 279 41] UIntSize.to_int idx < 9223372036854775807}
    requires {[#"../Scratch/src/vsids.rs" 282 4 282 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 283 15 283 38] UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self)))}
    ensures { [#"../Scratch/src/vsids.rs" 280 14 280 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    ensures { [#"../Scratch/src/vsids.rs" 281 14 281 53] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self))) = Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( ^ self))) }
    ensures { [#"../Scratch/src/vsids.rs" 282 4 282 40] Invariant0.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var idx_2 : usize;
  var x_9 : usize;
  var _10 : usize;
  var _11 : Scratch_Vsids_Heap_Type.t_heap;
  var _12 : usize;
  var old_self_13 : Ghost.ghost_ty (borrowed (Scratch_Vsids_Heap_Type.t_heap));
  var _15 : ();
  var _21 : ();
  var _22 : bool;
  var _23 : usize;
  var _24 : usize;
  var _25 : usize;
  var _26 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var right_27 : usize;
  var _28 : usize;
  var left_29 : usize;
  var _30 : usize;
  var child_31 : usize;
  var _32 : bool;
  var _33 : bool;
  var _34 : usize;
  var _35 : usize;
  var _36 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _37 : bool;
  var _38 : Scratch_Vsids_Heap_Type.t_heap;
  var _39 : usize;
  var _40 : usize;
  var _41 : Scratch_Vsids_Heap_Type.t_heap;
  var _42 : usize;
  var _43 : usize;
  var _44 : usize;
  var _45 : Scratch_Vsids_Heap_Type.t_heap;
  var _46 : usize;
  var _47 : ();
  var _48 : bool;
  var _49 : bool;
  var _50 : Scratch_Vsids_Heap_Type.t_heap;
  var _51 : usize;
  var _52 : usize;
  var _53 : Scratch_Vsids_Heap_Type.t_heap;
  var _54 : usize;
  var _55 : usize;
  var _56 : ();
  var _57 : usize;
  var _58 : usize;
  var _59 : Scratch_Vsids_Heap_Type.t_heap;
  var _60 : usize;
  var _61 : borrowed usize;
  var _62 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _63 : usize;
  var i_64 : usize;
  var _65 : usize;
  var _66 : Scratch_Vsids_Heap_Type.t_heap;
  var _67 : usize;
  var _68 : usize;
  var _69 : borrowed usize;
  var _70 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _71 : usize;
  var _72 : usize;
  var _73 : ();
  var _74 : ();
  var _75 : ();
  var _76 : usize;
  var _77 : borrowed usize;
  var _78 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _79 : usize;
  var _80 : usize;
  var _81 : borrowed usize;
  var _82 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _83 : usize;
  {
    self_1 <- self;
    idx_2 <- idx;
    goto BB0
  }
  BB0 {
    _11 <-  * self_1;
    _12 <- idx_2;
    _10 <- ([#"../Scratch/src/vsids.rs" 285 16 285 25] Index0.index _11 _12);
    goto BB1
  }
  BB1 {
    x_9 <- _10;
    old_self_13 <- ([#"../Scratch/src/vsids.rs" 286 41 286 53] Ghost.new self_1);
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    invariant { [#"../Scratch/src/vsids.rs" 288 20 288 36] Invariant0.invariant' ( * self_1) };
    invariant { [#"../Scratch/src/vsids.rs" 289 20 289 43] UIntSize.to_int idx_2 < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self_1))) };
    invariant { [#"../Scratch/src/vsids.rs" 290 20 290 45] UIntSize.to_int x_9 < Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_activity ( * self_1))) };
    invariant { [#"../Scratch/src/vsids.rs" 291 20 291 56] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * Ghost.inner old_self_13)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self_1)) };
    invariant { [#"../Scratch/src/vsids.rs" 292 20 292 60] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self_1))) = Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * Ghost.inner old_self_13))) };
    goto BB4
  }
  BB4 {
    _24 <- idx_2;
    _23 <- ([#"../Scratch/src/vsids.rs" 293 14 293 29] Left0.left _24);
    goto BB5
  }
  BB5 {
    _26 <- Scratch_Vsids_Heap_Type.heap_heap ( * self_1);
    _25 <- ([#"../Scratch/src/vsids.rs" 293 32 293 47] Len0.len _26);
    goto BB6
  }
  BB6 {
    _22 <- ([#"../Scratch/src/vsids.rs" 293 14 293 47] _23 < _25);
    switch (_22)
      | False -> goto BB28
      | True -> goto BB7
      end
  }
  BB7 {
    _28 <- idx_2;
    right_27 <- ([#"../Scratch/src/vsids.rs" 294 24 294 40] Right0.right _28);
    goto BB8
  }
  BB8 {
    _30 <- idx_2;
    left_29 <- ([#"../Scratch/src/vsids.rs" 295 23 295 38] Left0.left _30);
    goto BB9
  }
  BB9 {
    _34 <- right_27;
    _36 <- Scratch_Vsids_Heap_Type.heap_heap ( * self_1);
    _35 <- ([#"../Scratch/src/vsids.rs" 296 35 296 50] Len0.len _36);
    goto BB13
  }
  BB10 {
    _32 <- ([#"../Scratch/src/vsids.rs" 296 27 296 93] false);
    goto BB12
  }
  BB11 {
    _38 <-  * self_1;
    _41 <-  * self_1;
    _42 <- right_27;
    _40 <- ([#"../Scratch/src/vsids.rs" 296 69 296 80] Index0.index _41 _42);
    goto BB14
  }
  BB12 {
    switch (_32)
      | False -> goto BB18
      | True -> goto BB17
      end
  }
  BB13 {
    _33 <- ([#"../Scratch/src/vsids.rs" 296 27 296 50] _34 < _35);
    switch (_33)
      | False -> goto BB10
      | True -> goto BB11
      end
  }
  BB14 {
    _39 <- _40;
    _45 <-  * self_1;
    _46 <- left_29;
    _44 <- ([#"../Scratch/src/vsids.rs" 296 82 296 92] Index0.index _45 _46);
    goto BB15
  }
  BB15 {
    _43 <- _44;
    _37 <- ([#"../Scratch/src/vsids.rs" 296 54 296 93] LessThan0.less_than _38 _39 _43);
    goto BB16
  }
  BB16 {
    _32 <- _37;
    _37 <- any bool;
    goto BB12
  }
  BB17 {
    child_31 <- right_27;
    goto BB19
  }
  BB18 {
    child_31 <- left_29;
    goto BB19
  }
  BB19 {
    _50 <-  * self_1;
    _53 <-  * self_1;
    _54 <- child_31;
    _52 <- ([#"../Scratch/src/vsids.rs" 297 31 297 42] Index0.index _53 _54);
    goto BB20
  }
  BB20 {
    _51 <- _52;
    _55 <- x_9;
    _49 <- ([#"../Scratch/src/vsids.rs" 297 16 297 46] LessThan0.less_than _50 _51 _55);
    goto BB21
  }
  BB21 {
    _48 <- not _49;
    switch (_48)
      | False -> goto BB23
      | True -> goto BB22
      end
  }
  BB22 {
    _15 <- ();
    goto BB29
  }
  BB23 {
    _47 <- ();
    _59 <-  * self_1;
    _60 <- child_31;
    _58 <- ([#"../Scratch/src/vsids.rs" 300 29 300 40] Index0.index _59 _60);
    goto BB24
  }
  BB24 {
    _57 <- _58;
    _62 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_heap ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a ( ^ _62) c d) };
    _63 <- idx_2;
    _61 <- ([#"../Scratch/src/vsids.rs" 300 12 300 26] IndexMut0.index_mut _62 _63);
    goto BB25
  }
  BB25 {
    _61 <- { _61 with current = _57 };
    _57 <- any usize;
    assume { Resolve0.resolve _61 };
    _66 <-  * self_1;
    _67 <- idx_2;
    _65 <- ([#"../Scratch/src/vsids.rs" 301 20 301 29] Index0.index _66 _67);
    goto BB26
  }
  BB26 {
    i_64 <- _65;
    _68 <- idx_2;
    _70 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_indices ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a b ( ^ _70) d) };
    _71 <- i_64;
    _69 <- ([#"../Scratch/src/vsids.rs" 302 12 302 27] IndexMut0.index_mut _70 _71);
    goto BB27
  }
  BB27 {
    _69 <- { _69 with current = _68 };
    _68 <- any usize;
    assume { Resolve0.resolve _69 };
    _72 <- child_31;
    idx_2 <- _72;
    _72 <- any usize;
    _21 <- ();
    goto BB3
  }
  BB28 {
    _15 <- ();
    goto BB29
  }
  BB29 {
    _76 <- x_9;
    _78 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_heap ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a ( ^ _78) c d) };
    _79 <- idx_2;
    _77 <- ([#"../Scratch/src/vsids.rs" 306 8 306 22] IndexMut0.index_mut _78 _79);
    goto BB30
  }
  BB30 {
    _77 <- { _77 with current = _76 };
    _76 <- any usize;
    assume { Resolve0.resolve _77 };
    _80 <- idx_2;
    _82 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_indices ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a b ( ^ _82) d) };
    _83 <- x_9;
    _81 <- ([#"../Scratch/src/vsids.rs" 307 8 307 23] IndexMut0.index_mut _82 _83);
    goto BB31
  }
  BB31 {
    _81 <- { _81 with current = _80 };
    _80 <- any usize;
    assume { Resolve0.resolve _81 };
    assume { Resolve1.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Scratch_Vsids_Impl2_PercolateAll_Interface
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant_Stub as Invariant0
  val percolate_all [#"../Scratch/src/vsids.rs" 108 4 108 31] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) : ()
    requires {[#"../Scratch/src/vsids.rs" 105 4 105 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 106 15 106 35] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self))) > 1}
    requires {[#"../Scratch/src/vsids.rs" 107 15 107 49] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self))) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self))}
    ensures { [#"../Scratch/src/vsids.rs" 105 4 105 40] Invariant0.invariant' ( ^ self) }
    
end
module Scratch_Vsids_Impl2_PercolateAll
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.Float64
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Vsids_Heap_Type.t_heap
  clone Scratch_Vsids_Impl0_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl2_PercolateDown_Interface as PercolateDown0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  let rec cfg percolate_all [#"../Scratch/src/vsids.rs" 108 4 108 31] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) : ()
    requires {[#"../Scratch/src/vsids.rs" 105 4 105 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 106 15 106 35] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self))) > 1}
    requires {[#"../Scratch/src/vsids.rs" 107 15 107 49] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self))) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self))}
    ensures { [#"../Scratch/src/vsids.rs" 105 4 105 40] Invariant0.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var i_6 : usize;
  var _7 : usize;
  var _8 : usize;
  var _9 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _10 : bool;
  var old_self_11 : Ghost.ghost_ty (borrowed (Scratch_Vsids_Heap_Type.t_heap));
  var _16 : ();
  var _17 : ();
  var _18 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var _19 : usize;
  var _20 : ();
  var _21 : bool;
  var _22 : usize;
  var _23 : ();
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _9 <- Scratch_Vsids_Heap_Type.heap_heap ( * self_1);
    _8 <- ([#"../Scratch/src/vsids.rs" 109 20 109 35] Len0.len _9);
    goto BB1
  }
  BB1 {
    _10 <- ([#"../Scratch/src/vsids.rs" 109 20 109 39] ([#"../Scratch/src/vsids.rs" 109 38 109 39] (2 : usize)) = ([#"../Scratch/src/vsids.rs" 109 20 109 39] (0 : usize)));
    assert { [@expl:division by zero] [#"../Scratch/src/vsids.rs" 109 20 109 39] not _10 };
    goto BB2
  }
  BB2 {
    _7 <- ([#"../Scratch/src/vsids.rs" 109 20 109 39] _8 / ([#"../Scratch/src/vsids.rs" 109 38 109 39] (2 : usize)));
    i_6 <- ([#"../Scratch/src/vsids.rs" 109 20 109 43] _7 - ([#"../Scratch/src/vsids.rs" 109 42 109 43] (1 : usize)));
    old_self_11 <- ([#"../Scratch/src/vsids.rs" 110 41 110 53] Ghost.new self_1);
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    invariant { [#"../Scratch/src/vsids.rs" 112 20 112 54] Scratch_Vsids_Heap_Type.heap_num_vars ( * Ghost.inner old_self_11) = Scratch_Vsids_Heap_Type.heap_num_vars ( * self_1) };
    invariant { [#"../Scratch/src/vsids.rs" 113 20 113 36] Invariant0.invariant' ( * self_1) };
    invariant { [#"../Scratch/src/vsids.rs" 114 20 114 41] UIntSize.to_int i_6 < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self_1))) };
    goto BB5
  }
  BB5 {
    _18 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _18) };
    _19 <- i_6;
    _17 <- ([#"../Scratch/src/vsids.rs" 116 12 116 34] PercolateDown0.percolate_down _18 _19);
    goto BB6
  }
  BB6 {
    _22 <- i_6;
    _21 <- ([#"../Scratch/src/vsids.rs" 117 15 117 21] _22 = ([#"../Scratch/src/vsids.rs" 117 20 117 21] (0 : usize)));
    switch (_21)
      | False -> goto BB8
      | True -> goto BB7
      end
  }
  BB7 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    return _0
  }
  BB8 {
    _20 <- ();
    i_6 <- ([#"../Scratch/src/vsids.rs" 120 12 120 18] i_6 - ([#"../Scratch/src/vsids.rs" 120 17 120 18] (1 : usize)));
    _16 <- ();
    goto BB4
  }
  
end
module Scratch_Vsids_Impl2_New_Interface
  use prelude.UIntSize
  use prelude.Int
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant_Stub as Invariant0
  val new [#"../Scratch/src/vsids.rs" 77 4 77 46] (num_vars : usize) : Scratch_Vsids_Heap_Type.t_heap
    requires {[#"../Scratch/src/vsids.rs" 75 15 75 46] UIntSize.to_int num_vars < 9223372036854775807}
    ensures { [#"../Scratch/src/vsids.rs" 76 14 76 32] Invariant0.invariant' result }
    
end
module Scratch_Vsids_Impl2_New
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use prelude.Borrow
  use seq.Seq
  use prelude.Float32
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq Float64.t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl2_PercolateAll_Interface as PercolateAll0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl1_Push_Interface as Push1 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel3.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl1_Push_Interface as Push0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl0_New_Interface as New1 with
    type t = Float64.t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl0_New_Interface as New0 with
    type t = usize,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg new [#"../Scratch/src/vsids.rs" 77 4 77 46] [@cfg:stackify] [@cfg:subregion_analysis] (num_vars : usize) : Scratch_Vsids_Heap_Type.t_heap
    requires {[#"../Scratch/src/vsids.rs" 75 15 75 46] UIntSize.to_int num_vars < 9223372036854775807}
    ensures { [#"../Scratch/src/vsids.rs" 76 14 76 32] Invariant0.invariant' result }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Vsids_Heap_Type.t_heap;
  var num_vars_1 : usize;
  var heap_4 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var indices_5 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var activity_6 : Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global);
  var i_7 : usize;
  var _8 : ();
  var _14 : ();
  var _15 : bool;
  var _16 : usize;
  var _17 : usize;
  var _18 : ();
  var _19 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _20 : usize;
  var _21 : ();
  var _22 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _23 : usize;
  var _24 : ();
  var _25 : borrowed (Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global));
  var _26 : ();
  var _27 : ();
  var _28 : ();
  var heap_29 : Scratch_Vsids_Heap_Type.t_heap;
  var _30 : Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global);
  var _31 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _32 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _33 : usize;
  var _34 : ();
  var _35 : bool;
  var _36 : usize;
  var _37 : ();
  var _38 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  {
    num_vars_1 <- num_vars;
    goto BB0
  }
  BB0 {
    heap_4 <- ([#"../Scratch/src/vsids.rs" 78 23 78 33] New0.new ());
    goto BB1
  }
  BB1 {
    indices_5 <- ([#"../Scratch/src/vsids.rs" 79 26 79 36] New0.new ());
    goto BB2
  }
  BB2 {
    activity_6 <- ([#"../Scratch/src/vsids.rs" 80 27 80 37] New1.new ());
    goto BB3
  }
  BB3 {
    i_7 <- ([#"../Scratch/src/vsids.rs" 83 20 83 21] (0 : usize));
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    invariant { [#"../Scratch/src/vsids.rs" 84 20 84 41] Seq.length (ShallowModel0.shallow_model activity_6) = UIntSize.to_int i_7 };
    invariant { [#"../Scratch/src/vsids.rs" 85 20 85 40] Seq.length (ShallowModel1.shallow_model indices_5) = UIntSize.to_int i_7 };
    invariant { [#"../Scratch/src/vsids.rs" 86 20 86 37] Seq.length (ShallowModel1.shallow_model heap_4) = UIntSize.to_int i_7 };
    invariant { [#"../Scratch/src/vsids.rs" 84 8 84 43] forall i : int . 0 <= i /\ i < Seq.length (ShallowModel1.shallow_model heap_4) -> UIntSize.to_int (Seq.get (ShallowModel1.shallow_model heap_4) i) < Seq.length (ShallowModel1.shallow_model indices_5) /\ UIntSize.to_int (Seq.get (ShallowModel1.shallow_model heap_4) i) < Seq.length (ShallowModel0.shallow_model activity_6) };
    invariant { [#"../Scratch/src/vsids.rs" 88 20 88 35] UIntSize.to_int i_7 <= UIntSize.to_int num_vars_1 };
    goto BB9
  }
  BB9 {
    _16 <- i_7;
    _17 <- num_vars_1;
    _15 <- ([#"../Scratch/src/vsids.rs" 89 14 89 26] _16 < _17);
    switch (_15)
      | False -> goto BB14
      | True -> goto BB10
      end
  }
  BB10 {
    _19 <- borrow_mut indices_5;
    indices_5 <-  ^ _19;
    _20 <- i_7;
    _18 <- ([#"../Scratch/src/vsids.rs" 90 12 90 27] Push0.push _19 _20);
    goto BB11
  }
  BB11 {
    _22 <- borrow_mut heap_4;
    heap_4 <-  ^ _22;
    _23 <- i_7;
    _21 <- ([#"../Scratch/src/vsids.rs" 91 12 91 24] Push0.push _22 _23);
    goto BB12
  }
  BB12 {
    _25 <- borrow_mut activity_6;
    activity_6 <-  ^ _25;
    _24 <- ([#"../Scratch/src/vsids.rs" 92 12 92 30] Push1.push _25 ([#"../Scratch/src/vsids.rs" 92 26 92 29] 0.0000000000000000000000000000000000000000000000000000000000000000));
    goto BB13
  }
  BB13 {
    i_7 <- ([#"../Scratch/src/vsids.rs" 93 12 93 18] i_7 + ([#"../Scratch/src/vsids.rs" 93 17 93 18] (1 : usize)));
    _14 <- ();
    goto BB8
  }
  BB14 {
    _8 <- ();
    _30 <- activity_6;
    activity_6 <- any Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global);
    _31 <- heap_4;
    heap_4 <- any Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
    _32 <- indices_5;
    indices_5 <- any Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
    _33 <- num_vars_1;
    heap_29 <- Scratch_Vsids_Heap_Type.C_Heap _30 _31 _32 _33;
    goto BB15
  }
  BB15 {
    goto BB16
  }
  BB16 {
    goto BB17
  }
  BB17 {
    _36 <- num_vars_1;
    _35 <- ([#"../Scratch/src/vsids.rs" 98 11 98 23] _36 > ([#"../Scratch/src/vsids.rs" 98 22 98 23] (1 : usize)));
    switch (_35)
      | False -> goto BB20
      | True -> goto BB18
      end
  }
  BB18 {
    _38 <- borrow_mut heap_29;
    heap_29 <-  ^ _38;
    _37 <- ([#"../Scratch/src/vsids.rs" 99 12 99 32] PercolateAll0.percolate_all _38);
    goto BB19
  }
  BB19 {
    _34 <- ();
    goto BB21
  }
  BB20 {
    _34 <- ();
    goto BB21
  }
  BB21 {
    _0 <- heap_29;
    heap_29 <- any Scratch_Vsids_Heap_Type.t_heap;
    goto BB22
  }
  BB22 {
    goto BB23
  }
  BB23 {
    goto BB24
  }
  BB24 {
    goto BB25
  }
  BB25 {
    return _0
  }
  
end
module Scratch_Vsids_Impl2_Parent_Interface
  use prelude.UIntSize
  use prelude.Int
  clone Core_Num_Impl11_Max_Stub as Max0
  val parent [#"../Scratch/src/vsids.rs" 186 4 186 34] (idx : usize) : usize
    ensures { [#"../Scratch/src/vsids.rs" 184 4 184 52] UIntSize.to_int idx = 0 -> UIntSize.to_int result = UIntSize.to_int Max0.mAX' }
    ensures { [#"../Scratch/src/vsids.rs" 185 4 185 54] UIntSize.to_int idx > 0 -> UIntSize.to_int result = div (UIntSize.to_int idx - 1) 2 }
    
end
module Scratch_Vsids_Impl2_Parent
  use prelude.Int
  use prelude.UIntSize
  clone Core_Num_Impl11_Max as Max0
  let rec cfg parent [#"../Scratch/src/vsids.rs" 186 4 186 34] [@cfg:stackify] [@cfg:subregion_analysis] (idx : usize) : usize
    ensures { [#"../Scratch/src/vsids.rs" 184 4 184 52] UIntSize.to_int idx = 0 -> UIntSize.to_int result = UIntSize.to_int Max0.mAX' }
    ensures { [#"../Scratch/src/vsids.rs" 185 4 185 54] UIntSize.to_int idx > 0 -> UIntSize.to_int result = div (UIntSize.to_int idx - 1) 2 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var idx_1 : usize;
  var _4 : bool;
  var _5 : usize;
  var _6 : usize;
  var _7 : usize;
  var _8 : bool;
  {
    idx_1 <- idx;
    goto BB0
  }
  BB0 {
    _5 <- idx_1;
    _4 <- ([#"../Scratch/src/vsids.rs" 188 11 188 18] _5 > ([#"../Scratch/src/vsids.rs" 188 17 188 18] (0 : usize)));
    switch (_4)
      | False -> goto BB3
      | True -> goto BB1
      end
  }
  BB1 {
    _7 <- idx_1;
    _6 <- ([#"../Scratch/src/vsids.rs" 189 12 189 21] _7 - ([#"../Scratch/src/vsids.rs" 189 19 189 20] (1 : usize)));
    _8 <- ([#"../Scratch/src/vsids.rs" 189 12 189 25] ([#"../Scratch/src/vsids.rs" 189 24 189 25] (2 : usize)) = ([#"../Scratch/src/vsids.rs" 189 12 189 25] (0 : usize)));
    assert { [@expl:division by zero] [#"../Scratch/src/vsids.rs" 189 12 189 25] not _8 };
    goto BB2
  }
  BB2 {
    _0 <- ([#"../Scratch/src/vsids.rs" 189 12 189 25] _6 / ([#"../Scratch/src/vsids.rs" 189 24 189 25] (2 : usize)));
    goto BB4
  }
  BB3 {
    _0 <- ([#"../Scratch/src/vsids.rs" 191 11 191 21] (18446744073709551615 : usize));
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Scratch_Vsids_Impl2_InHeap_Interface
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  val in_heap [#"../Scratch/src/vsids.rs" 198 4 198 39] (self : Scratch_Vsids_Heap_Type.t_heap) (v : usize) : bool
    ensures { [#"../Scratch/src/vsids.rs" 197 14 197 91] result = (UIntSize.to_int v < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_indices self)) /\ UIntSize.to_int (Seq.get (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_indices self)) (UIntSize.to_int v)) < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self))) }
    
end
module Scratch_Vsids_Impl2_InHeap
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = usize
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  let rec cfg in_heap [#"../Scratch/src/vsids.rs" 198 4 198 39] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Vsids_Heap_Type.t_heap) (v : usize) : bool
    ensures { [#"../Scratch/src/vsids.rs" 197 14 197 91] result = (UIntSize.to_int v < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_indices self)) /\ UIntSize.to_int (Seq.get (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_indices self)) (UIntSize.to_int v)) < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : Scratch_Vsids_Heap_Type.t_heap;
  var v_2 : usize;
  var _4 : bool;
  var _5 : usize;
  var _6 : usize;
  var _7 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _8 : bool;
  var _9 : usize;
  var _10 : usize;
  var _11 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _12 : usize;
  var _13 : usize;
  var _14 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  {
    self_1 <- self;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    _5 <- v_2;
    _7 <- Scratch_Vsids_Heap_Type.heap_indices self_1;
    _6 <- ([#"../Scratch/src/vsids.rs" 199 12 199 30] Len0.len _7);
    goto BB4
  }
  BB1 {
    _0 <- ([#"../Scratch/src/vsids.rs" 199 8 199 67] false);
    goto BB3
  }
  BB2 {
    _11 <- Scratch_Vsids_Heap_Type.heap_indices self_1;
    _12 <- v_2;
    _10 <- ([#"../Scratch/src/vsids.rs" 199 34 199 49] Index0.index _11 _12);
    goto BB5
  }
  BB3 {
    return _0
  }
  BB4 {
    _4 <- ([#"../Scratch/src/vsids.rs" 199 8 199 30] _5 < _6);
    switch (_4)
      | False -> goto BB1
      | True -> goto BB2
      end
  }
  BB5 {
    _9 <- _10;
    _14 <- Scratch_Vsids_Heap_Type.heap_heap self_1;
    _13 <- ([#"../Scratch/src/vsids.rs" 199 52 199 67] Len0.len _14);
    goto BB6
  }
  BB6 {
    _8 <- ([#"../Scratch/src/vsids.rs" 199 34 199 67] _9 < _13);
    _0 <- _8;
    _8 <- any bool;
    goto BB3
  }
  
end
module Scratch_Vsids_Impl2_Empty_Interface
  use seq.Seq
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  val empty [#"../Scratch/src/vsids.rs" 204 4 204 27] (self : Scratch_Vsids_Heap_Type.t_heap) : bool
    ensures { [#"../Scratch/src/vsids.rs" 203 14 203 47] result = (Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self)) = 0) }
    
end
module Scratch_Vsids_Impl2_Empty
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  let rec cfg empty [#"../Scratch/src/vsids.rs" 204 4 204 27] [@cfg:stackify] [@cfg:subregion_analysis] (self : Scratch_Vsids_Heap_Type.t_heap) : bool
    ensures { [#"../Scratch/src/vsids.rs" 203 14 203 47] result = (Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap self)) = 0) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : bool;
  var self_1 : Scratch_Vsids_Heap_Type.t_heap;
  var _3 : usize;
  var _4 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _4 <- Scratch_Vsids_Heap_Type.heap_heap self_1;
    _3 <- ([#"../Scratch/src/vsids.rs" 205 8 205 23] Len0.len _4);
    goto BB1
  }
  BB1 {
    _0 <- ([#"../Scratch/src/vsids.rs" 205 8 205 28] _3 = ([#"../Scratch/src/vsids.rs" 205 27 205 28] (0 : usize)));
    return _0
  }
  
end
module Scratch_Vsids_Impl2_PercolateUp_Interface
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant_Stub as Invariant0
  val percolate_up [#"../Scratch/src/vsids.rs" 256 4 256 46] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) (idx : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 253 4 253 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 255 15 255 38] UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self)))}
    ensures { [#"../Scratch/src/vsids.rs" 253 4 253 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 254 14 254 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    
end
module Scratch_Vsids_Impl2_PercolateUp
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Ghost
  use seq.Seq
  use prelude.Float64
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = usize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Scratch_Vsids_Heap_Type.t_heap
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = usize
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = usize,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Vsids_Impl2_LessThan_Interface as LessThan0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl13_Index_Interface as Index1 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = usize
  clone Scratch_Vsids_Impl2_Parent_Interface as Parent0 with
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl1_Index_Interface as Index0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl0_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg percolate_up [#"../Scratch/src/vsids.rs" 256 4 256 46] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) (idx : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 253 4 253 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 255 15 255 38] UIntSize.to_int idx < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self)))}
    ensures { [#"../Scratch/src/vsids.rs" 253 4 253 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 254 14 254 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var idx_2 : usize;
  var x_7 : usize;
  var _8 : usize;
  var _9 : Scratch_Vsids_Heap_Type.t_heap;
  var _10 : usize;
  var p_11 : usize;
  var _12 : usize;
  var old_self_13 : Ghost.ghost_ty (borrowed (Scratch_Vsids_Heap_Type.t_heap));
  var _15 : ();
  var _22 : ();
  var _23 : bool;
  var _24 : bool;
  var _25 : usize;
  var _26 : bool;
  var _27 : Scratch_Vsids_Heap_Type.t_heap;
  var _28 : usize;
  var _29 : usize;
  var _30 : usize;
  var _31 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _32 : usize;
  var _33 : usize;
  var _34 : usize;
  var _35 : Scratch_Vsids_Heap_Type.t_heap;
  var _36 : usize;
  var _37 : borrowed usize;
  var _38 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _39 : usize;
  var i_40 : usize;
  var _41 : usize;
  var _42 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _43 : usize;
  var _44 : usize;
  var _45 : borrowed usize;
  var _46 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _47 : usize;
  var _48 : usize;
  var _49 : usize;
  var _50 : usize;
  var _51 : ();
  var _52 : ();
  var _53 : ();
  var _54 : usize;
  var _55 : borrowed usize;
  var _56 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _57 : usize;
  var _58 : usize;
  var _59 : borrowed usize;
  var _60 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _61 : usize;
  {
    self_1 <- self;
    idx_2 <- idx;
    goto BB0
  }
  BB0 {
    _9 <-  * self_1;
    _10 <- idx_2;
    _8 <- ([#"../Scratch/src/vsids.rs" 257 16 257 25] Index0.index _9 _10);
    goto BB1
  }
  BB1 {
    x_7 <- _8;
    _12 <- idx_2;
    p_11 <- ([#"../Scratch/src/vsids.rs" 258 20 258 37] Parent0.parent _12);
    goto BB2
  }
  BB2 {
    old_self_13 <- ([#"../Scratch/src/vsids.rs" 259 41 259 53] Ghost.new self_1);
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    invariant { [#"../Scratch/src/vsids.rs" 261 20 261 36] Invariant0.invariant' ( * self_1) };
    invariant { [#"../Scratch/src/vsids.rs" 262 20 262 43] UIntSize.to_int idx_2 < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self_1))) };
    invariant { [#"../Scratch/src/vsids.rs" 261 8 261 38] UIntSize.to_int idx_2 <> 0 -> UIntSize.to_int p_11 < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self_1))) };
    invariant { [#"../Scratch/src/vsids.rs" 264 20 264 45] UIntSize.to_int x_7 < Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_activity ( * self_1))) };
    invariant { [#"../Scratch/src/vsids.rs" 265 20 265 56] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * Ghost.inner old_self_13)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self_1)) };
    invariant { [#"../Scratch/src/vsids.rs" 266 20 266 60] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self_1))) = Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * Ghost.inner old_self_13))) };
    goto BB5
  }
  BB5 {
    _25 <- idx_2;
    _24 <- ([#"../Scratch/src/vsids.rs" 267 14 267 22] _25 <> ([#"../Scratch/src/vsids.rs" 267 21 267 22] (0 : usize)));
    switch (_24)
      | False -> goto BB6
      | True -> goto BB7
      end
  }
  BB6 {
    _23 <- ([#"../Scratch/src/vsids.rs" 267 14 267 57] false);
    goto BB8
  }
  BB7 {
    _27 <-  * self_1;
    _28 <- x_7;
    _31 <- Scratch_Vsids_Heap_Type.heap_heap ( * self_1);
    _32 <- p_11;
    _30 <- ([#"../Scratch/src/vsids.rs" 267 44 267 56] Index1.index _31 _32);
    goto BB9
  }
  BB8 {
    switch (_23)
      | False -> goto BB17
      | True -> goto BB11
      end
  }
  BB9 {
    _29 <- _30;
    _26 <- ([#"../Scratch/src/vsids.rs" 267 26 267 57] LessThan0.less_than _27 _28 _29);
    goto BB10
  }
  BB10 {
    _23 <- _26;
    _26 <- any bool;
    goto BB8
  }
  BB11 {
    _35 <-  * self_1;
    _36 <- p_11;
    _34 <- ([#"../Scratch/src/vsids.rs" 268 29 268 36] Index0.index _35 _36);
    goto BB12
  }
  BB12 {
    _33 <- _34;
    _38 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_heap ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a ( ^ _38) c d) };
    _39 <- idx_2;
    _37 <- ([#"../Scratch/src/vsids.rs" 268 12 268 26] IndexMut0.index_mut _38 _39);
    goto BB13
  }
  BB13 {
    _37 <- { _37 with current = _33 };
    _33 <- any usize;
    assume { Resolve0.resolve _37 };
    _42 <- Scratch_Vsids_Heap_Type.heap_heap ( * self_1);
    _43 <- p_11;
    _41 <- ([#"../Scratch/src/vsids.rs" 269 20 269 32] Index1.index _42 _43);
    goto BB14
  }
  BB14 {
    i_40 <- _41;
    _44 <- idx_2;
    _46 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_indices ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a b ( ^ _46) d) };
    _47 <- i_40;
    _45 <- ([#"../Scratch/src/vsids.rs" 270 12 270 27] IndexMut0.index_mut _46 _47);
    goto BB15
  }
  BB15 {
    _45 <- { _45 with current = _44 };
    _44 <- any usize;
    assume { Resolve0.resolve _45 };
    _48 <- p_11;
    idx_2 <- _48;
    _48 <- any usize;
    _50 <- idx_2;
    _49 <- ([#"../Scratch/src/vsids.rs" 272 16 272 33] Parent0.parent _50);
    goto BB16
  }
  BB16 {
    p_11 <- _49;
    _49 <- any usize;
    _22 <- ();
    goto BB4
  }
  BB17 {
    _15 <- ();
    _54 <- x_7;
    _56 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_heap ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a ( ^ _56) c d) };
    _57 <- idx_2;
    _55 <- ([#"../Scratch/src/vsids.rs" 275 8 275 22] IndexMut0.index_mut _56 _57);
    goto BB18
  }
  BB18 {
    _55 <- { _55 with current = _54 };
    _54 <- any usize;
    assume { Resolve0.resolve _55 };
    _58 <- idx_2;
    _60 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_indices ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a b ( ^ _60) d) };
    _61 <- x_7;
    _59 <- ([#"../Scratch/src/vsids.rs" 276 8 276 23] IndexMut0.index_mut _60 _61);
    goto BB19
  }
  BB19 {
    _59 <- { _59 with current = _58 };
    _58 <- any usize;
    assume { Resolve0.resolve _59 };
    assume { Resolve1.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Scratch_Vsids_Impl2_Decrease_Interface
  use prelude.Borrow
  use prelude.UIntSize
  use prelude.Int
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant_Stub as Invariant0
  val decrease [#"../Scratch/src/vsids.rs" 212 4 212 36] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 209 4 209 40] Invariant0.invariant' ( * self)}
    ensures { [#"../Scratch/src/vsids.rs" 209 4 209 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 210 14 210 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    
end
module Scratch_Vsids_Impl2_Decrease
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Float64
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Vsids_Heap_Type.t_heap
  clone Scratch_Vsids_Impl0_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl2_PercolateUp_Interface as PercolateUp0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = usize
  clone Scratch_Vsids_Impl2_InHeap_Interface as InHeap0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg decrease [#"../Scratch/src/vsids.rs" 212 4 212 36] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 209 4 209 40] Invariant0.invariant' ( * self)}
    ensures { [#"../Scratch/src/vsids.rs" 209 4 209 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 210 14 210 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var v_2 : usize;
  var _6 : bool;
  var _7 : Scratch_Vsids_Heap_Type.t_heap;
  var _8 : usize;
  var idx_9 : usize;
  var _10 : usize;
  var _11 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _12 : usize;
  var _13 : ();
  var _14 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var _15 : usize;
  {
    self_1 <- self;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    _7 <-  * self_1;
    _8 <- v_2;
    _6 <- ([#"../Scratch/src/vsids.rs" 213 11 213 26] InHeap0.in_heap _7 _8);
    goto BB1
  }
  BB1 {
    switch (_6)
      | False -> goto BB5
      | True -> goto BB2
      end
  }
  BB2 {
    _11 <- Scratch_Vsids_Heap_Type.heap_indices ( * self_1);
    _12 <- v_2;
    _10 <- ([#"../Scratch/src/vsids.rs" 214 22 214 37] Index0.index _11 _12);
    goto BB3
  }
  BB3 {
    idx_9 <- _10;
    _14 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _14) };
    _15 <- idx_9;
    _13 <- ([#"../Scratch/src/vsids.rs" 215 12 215 34] PercolateUp0.percolate_up _14 _15);
    goto BB4
  }
  BB4 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB6
  }
  BB5 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Scratch_Vsids_Impl2_Increase_Interface
  use prelude.Borrow
  use prelude.UIntSize
  use prelude.Int
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant_Stub as Invariant0
  val increase [#"../Scratch/src/vsids.rs" 224 4 224 36] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 221 4 221 40] Invariant0.invariant' ( * self)}
    ensures { [#"../Scratch/src/vsids.rs" 221 4 221 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 222 14 222 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    
end
module Scratch_Vsids_Impl2_Increase
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Float64
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Vsids_Heap_Type.t_heap
  clone Scratch_Vsids_Impl0_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl2_PercolateDown_Interface as PercolateDown0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = usize
  clone Scratch_Vsids_Impl2_InHeap_Interface as InHeap0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg increase [#"../Scratch/src/vsids.rs" 224 4 224 36] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 221 4 221 40] Invariant0.invariant' ( * self)}
    ensures { [#"../Scratch/src/vsids.rs" 221 4 221 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 222 14 222 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var v_2 : usize;
  var _6 : bool;
  var _7 : Scratch_Vsids_Heap_Type.t_heap;
  var _8 : usize;
  var idx_9 : usize;
  var _10 : usize;
  var _11 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _12 : usize;
  var _13 : ();
  var _14 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var _15 : usize;
  {
    self_1 <- self;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    _7 <-  * self_1;
    _8 <- v_2;
    _6 <- ([#"../Scratch/src/vsids.rs" 225 11 225 26] InHeap0.in_heap _7 _8);
    goto BB1
  }
  BB1 {
    switch (_6)
      | False -> goto BB5
      | True -> goto BB2
      end
  }
  BB2 {
    _11 <- Scratch_Vsids_Heap_Type.heap_indices ( * self_1);
    _12 <- v_2;
    _10 <- ([#"../Scratch/src/vsids.rs" 226 22 226 37] Index0.index _11 _12);
    goto BB3
  }
  BB3 {
    idx_9 <- _10;
    _14 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _14) };
    _15 <- idx_9;
    _13 <- ([#"../Scratch/src/vsids.rs" 227 12 227 36] PercolateDown0.percolate_down _14 _15);
    goto BB4
  }
  BB4 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB6
  }
  BB5 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB6
  }
  BB6 {
    return _0
  }
  
end
module Scratch_Vsids_Impl2_Insert_Interface
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant_Stub as Invariant0
  val insert [#"../Scratch/src/vsids.rs" 245 4 245 34] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 241 4 241 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 243 15 243 53] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self))) < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_indices ( * self)))}
    requires {[#"../Scratch/src/vsids.rs" 244 15 244 39] UIntSize.to_int v < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_indices ( * self)))}
    ensures { [#"../Scratch/src/vsids.rs" 241 4 241 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 242 14 242 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    
end
module Scratch_Vsids_Impl2_Insert
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Float64
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Scratch_Vsids_Heap_Type.t_heap
  clone Scratch_Vsids_Impl0_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl2_PercolateUp_Interface as PercolateUp0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl1_Push_Interface as Push0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel3.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = usize
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = usize,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  let rec cfg insert [#"../Scratch/src/vsids.rs" 245 4 245 34] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 241 4 241 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 243 15 243 53] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self))) < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_indices ( * self)))}
    requires {[#"../Scratch/src/vsids.rs" 244 15 244 39] UIntSize.to_int v < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_indices ( * self)))}
    ensures { [#"../Scratch/src/vsids.rs" 241 4 241 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 242 14 242 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var v_2 : usize;
  var old_len_8 : usize;
  var _9 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _10 : usize;
  var _11 : borrowed usize;
  var _12 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _13 : usize;
  var _14 : ();
  var _15 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _16 : usize;
  var _17 : ();
  var _18 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var _19 : usize;
  {
    self_1 <- self;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    _9 <- Scratch_Vsids_Heap_Type.heap_heap ( * self_1);
    old_len_8 <- ([#"../Scratch/src/vsids.rs" 246 22 246 37] Len0.len _9);
    goto BB1
  }
  BB1 {
    _10 <- old_len_8;
    _12 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_indices ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a b ( ^ _12) d) };
    _13 <- v_2;
    _11 <- ([#"../Scratch/src/vsids.rs" 247 8 247 23] IndexMut0.index_mut _12 _13);
    goto BB2
  }
  BB2 {
    _11 <- { _11 with current = _10 };
    _10 <- any usize;
    assume { Resolve0.resolve _11 };
    _15 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_heap ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a ( ^ _15) c d) };
    _16 <- v_2;
    _14 <- ([#"../Scratch/src/vsids.rs" 248 8 248 25] Push0.push _15 _16);
    goto BB3
  }
  BB3 {
    _18 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _18) };
    _19 <- old_len_8;
    _17 <- ([#"../Scratch/src/vsids.rs" 249 8 249 34] PercolateUp0.percolate_up _18 _19);
    goto BB4
  }
  BB4 {
    assume { Resolve1.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Alloc_Vec_Impl1_Pop_Interface
  type t
  type a
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use seq_ext.SeqExt
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec t a,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = a,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Option_Option_Type as Core_Option_Option_Type
  val pop (self : borrowed (Alloc_Vec_Vec_Type.t_vec t a)) : Core_Option_Option_Type.t_option t
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 68 26 73 17] match (result) with
      | Core_Option_Option_Type.C_Some t -> ShallowModel0.shallow_model ( ^ self) = SeqExt.subsequence (ShallowModel1.shallow_model self) 0 (Seq.length (ShallowModel1.shallow_model self) - 1) /\ ShallowModel1.shallow_model self = Seq.snoc (ShallowModel0.shallow_model ( ^ self)) t
      | Core_Option_Option_Type.C_None ->  * self =  ^ self /\ Seq.length (ShallowModel1.shallow_model self) = 0
      end }
    
end
module Scratch_Vsids_Impl2_RemoveMin_Interface
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant_Stub as Invariant0
  val remove_min [#"../Scratch/src/vsids.rs" 313 4 313 37] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) : usize
    requires {[#"../Scratch/src/vsids.rs" 310 4 310 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 312 15 312 35] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self))) > 0}
    ensures { [#"../Scratch/src/vsids.rs" 310 4 310 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 311 14 311 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    
end
module Scratch_Vsids_Impl2_RemoveMin
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use seq.Seq
  use prelude.Float64
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = usize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = usize
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = usize
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq usize,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Scratch_Vsids_Heap_Type.t_heap
  clone Scratch_Vsids_Impl0_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl2_PercolateDown_Interface as PercolateDown0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Alloc_Vec_Impl1_Pop_Interface as Pop0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel3.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = usize
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = usize,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl13_Index_Interface as Index1 with
    type t = usize,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = usize
  clone Alloc_Vec_Impl1_Len_Interface as Len0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model
  clone Scratch_Vsids_Impl1_Index_Interface as Index0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg remove_min [#"../Scratch/src/vsids.rs" 313 4 313 37] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Heap_Type.t_heap)) : usize
    requires {[#"../Scratch/src/vsids.rs" 310 4 310 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 312 15 312 35] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap ( * self))) > 0}
    ensures { [#"../Scratch/src/vsids.rs" 310 4 310 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 311 14 311 49] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( * self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars ( ^ self)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self_1 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var x_6 : usize;
  var _7 : usize;
  var _8 : Scratch_Vsids_Heap_Type.t_heap;
  var _9 : usize;
  var _10 : usize;
  var _11 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _12 : usize;
  var _13 : usize;
  var _14 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _15 : borrowed usize;
  var _16 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var first_17 : usize;
  var _18 : usize;
  var _19 : Scratch_Vsids_Heap_Type.t_heap;
  var _20 : borrowed usize;
  var _21 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _22 : usize;
  var _23 : borrowed usize;
  var _24 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _25 : usize;
  var _26 : Core_Option_Option_Type.t_option usize;
  var _27 : borrowed (Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global));
  var _28 : ();
  var _29 : bool;
  var _30 : usize;
  var _31 : Alloc_Vec_Vec_Type.t_vec usize (Alloc_Alloc_Global_Type.t_global);
  var _32 : ();
  var _33 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _8 <-  * self_1;
    _7 <- ([#"../Scratch/src/vsids.rs" 314 16 314 23] Index0.index _8 ([#"../Scratch/src/vsids.rs" 314 21 314 22] (0 : usize)));
    goto BB1
  }
  BB1 {
    x_6 <- _7;
    _11 <- Scratch_Vsids_Heap_Type.heap_heap ( * self_1);
    _14 <- Scratch_Vsids_Heap_Type.heap_heap ( * self_1);
    _13 <- ([#"../Scratch/src/vsids.rs" 315 33 315 48] Len0.len _14);
    goto BB2
  }
  BB2 {
    _12 <- ([#"../Scratch/src/vsids.rs" 315 33 315 52] _13 - ([#"../Scratch/src/vsids.rs" 315 51 315 52] (1 : usize)));
    _10 <- ([#"../Scratch/src/vsids.rs" 315 23 315 53] Index1.index _11 _12);
    goto BB3
  }
  BB3 {
    _9 <- _10;
    _16 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_heap ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a ( ^ _16) c d) };
    _15 <- ([#"../Scratch/src/vsids.rs" 315 8 315 20] IndexMut0.index_mut _16 ([#"../Scratch/src/vsids.rs" 315 18 315 19] (0 : usize)));
    goto BB4
  }
  BB4 {
    _15 <- { _15 with current = _9 };
    _9 <- any usize;
    assume { Resolve0.resolve _15 };
    _19 <-  * self_1;
    _18 <- ([#"../Scratch/src/vsids.rs" 316 20 316 27] Index0.index _19 ([#"../Scratch/src/vsids.rs" 316 25 316 26] (0 : usize)));
    goto BB5
  }
  BB5 {
    first_17 <- _18;
    _21 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_indices ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a b ( ^ _21) d) };
    _22 <- first_17;
    _20 <- ([#"../Scratch/src/vsids.rs" 317 8 317 27] IndexMut0.index_mut _21 _22);
    goto BB6
  }
  BB6 {
    _20 <- { _20 with current = ([#"../Scratch/src/vsids.rs" 317 30 317 31] (0 : usize)) };
    assume { Resolve0.resolve _20 };
    _24 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_indices ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a b ( ^ _24) d) };
    _25 <- x_6;
    _23 <- ([#"../Scratch/src/vsids.rs" 318 8 318 23] IndexMut0.index_mut _24 _25);
    goto BB7
  }
  BB7 {
    _23 <- { _23 with current = ([#"../Scratch/src/vsids.rs" 318 26 318 33] (18446744073709551615 : usize)) };
    assume { Resolve0.resolve _23 };
    _27 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_heap ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Heap_Type.C_Heap a b c d =  * self_1 in Scratch_Vsids_Heap_Type.C_Heap a ( ^ _27) c d) };
    _26 <- ([#"../Scratch/src/vsids.rs" 319 8 319 23] Pop0.pop _27);
    goto BB8
  }
  BB8 {
    _31 <- Scratch_Vsids_Heap_Type.heap_heap ( * self_1);
    _30 <- ([#"../Scratch/src/vsids.rs" 320 11 320 26] Len0.len _31);
    goto BB9
  }
  BB9 {
    _29 <- ([#"../Scratch/src/vsids.rs" 320 11 320 30] _30 > ([#"../Scratch/src/vsids.rs" 320 29 320 30] (1 : usize)));
    switch (_29)
      | False -> goto BB12
      | True -> goto BB10
      end
  }
  BB10 {
    _33 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _33) };
    _32 <- ([#"../Scratch/src/vsids.rs" 321 12 321 34] PercolateDown0.percolate_down _33 ([#"../Scratch/src/vsids.rs" 321 32 321 33] (0 : usize)));
    goto BB11
  }
  BB11 {
    assume { Resolve1.resolve self_1 };
    _28 <- ();
    goto BB13
  }
  BB12 {
    assume { Resolve1.resolve self_1 };
    _28 <- ();
    goto BB13
  }
  BB13 {
    _0 <- x_6;
    return _0
  }
  
end
module Scratch_Vsids_Vsids_Type
  use prelude.Float64
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  type t_vsids  =
    | C_VSIDS (Scratch_Vsids_Heap_Type.t_heap) Float64.t Float64.t (Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global))
    
  let function vsids_order_heap (self : t_vsids) : Scratch_Vsids_Heap_Type.t_heap = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VSIDS a _ _ _ -> a
      end
  let function vsids_decision (self : t_vsids) : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global)
   = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VSIDS _ _ _ a -> a
      end
  let function vsids_var_inc (self : t_vsids) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VSIDS _ a _ _ -> a
      end
  let function vsids_var_decay (self : t_vsids) : Float64.t = [@vc:do_not_keep_trace] [@vc:sp]
    match (self) with
      | C_VSIDS _ _ a _ -> a
      end
end
module Scratch_Vsids_Impl3_Invariant_Stub
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  predicate invariant' [#"../Scratch/src/vsids.rs" 337 4 337 30] (self : Scratch_Vsids_Vsids_Type.t_vsids)
end
module Scratch_Vsids_Impl3_Invariant_Interface
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  predicate invariant' [#"../Scratch/src/vsids.rs" 337 4 337 30] (self : Scratch_Vsids_Vsids_Type.t_vsids)
end
module Scratch_Vsids_Impl3_Invariant
  use seq.Seq
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone Scratch_Vsids_Impl0_Invariant_Stub as Invariant0
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  predicate invariant' [#"../Scratch/src/vsids.rs" 337 4 337 30] (self : Scratch_Vsids_Vsids_Type.t_vsids) =
    [#"../Scratch/src/vsids.rs" 338 8 341 9] Invariant0.invariant' (Scratch_Vsids_Vsids_Type.vsids_order_heap self) /\ Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Vsids_Type.vsids_decision self)) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap self))
  val invariant' [#"../Scratch/src/vsids.rs" 337 4 337 30] (self : Scratch_Vsids_Vsids_Type.t_vsids) : bool
    ensures { result = invariant' self }
    
end
module Scratch_Vsids_Impl4_RemoveMin_Interface
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone Scratch_Vsids_Impl3_Invariant_Stub as Invariant0
  val remove_min [#"../Scratch/src/vsids.rs" 350 4 350 37] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) : usize
    requires {[#"../Scratch/src/vsids.rs" 347 4 347 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 349 15 349 46] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self)))) > 0}
    ensures { [#"../Scratch/src/vsids.rs" 347 4 347 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 348 14 348 71] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self))) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( ^ self))) }
    
end
module Scratch_Vsids_Impl4_RemoveMin
  use prelude.Int
  use prelude.UIntSize
  use prelude.Borrow
  use seq.Seq
  use prelude.Float64
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel2 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant as Invariant1 with
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Vsids_Vsids_Type.t_vsids
  clone Scratch_Vsids_Impl2_RemoveMin_Interface as RemoveMin0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl3_Invariant as Invariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg remove_min [#"../Scratch/src/vsids.rs" 350 4 350 37] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) : usize
    requires {[#"../Scratch/src/vsids.rs" 347 4 347 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 349 15 349 46] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self)))) > 0}
    ensures { [#"../Scratch/src/vsids.rs" 347 4 347 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 348 14 348 71] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self))) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( ^ self))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : usize;
  var self_1 : borrowed (Scratch_Vsids_Vsids_Type.t_vsids);
  var _6 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _6 <- borrow_mut (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Vsids_Type.C_VSIDS a b c d =  * self_1 in Scratch_Vsids_Vsids_Type.C_VSIDS ( ^ _6) b c d) };
    _0 <- ([#"../Scratch/src/vsids.rs" 351 8 351 36] RemoveMin0.remove_min _6);
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve self_1 };
    return _0
  }
  
end
module Alloc_Vec_FromElem_Interface
  type t
  use seq.Seq
  use prelude.UIntSize
  use prelude.Int
  clone Core_Num_Impl11_Max_Stub as Max0
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type s = Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val from_elem (elem : t) (n : usize) : Alloc_Vec_Vec_Type.t_vec t (Alloc_Alloc_Global_Type.t_global)
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 143 22 143 41] Seq.length (ShallowModel0.shallow_model result) = UIntSize.to_int n }
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/vec.rs" 144 12 144 78] forall i : int . 0 <= i /\ i < UIntSize.to_int n -> IndexLogic0.index_logic result i = elem }
    
end
module Scratch_Vsids_Impl5_New_Interface
  use prelude.UIntSize
  use prelude.Int
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  val new [#"../Scratch/src/vsids.rs" 357 4 357 35] (num_vars : usize) : Scratch_Vsids_Vsids_Type.t_vsids
    requires {[#"../Scratch/src/vsids.rs" 356 15 356 46] UIntSize.to_int num_vars < 9223372036854775807}
    
end
module Scratch_Vsids_Impl5_New
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float32
  use prelude.Float64
  use seq.Seq
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel2 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = bool,
    type s = Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global),
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant as Invariant0 with
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel2.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_FromElem_Interface as FromElem0 with
    type t = bool,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl2_New_Interface as New0 with
    predicate Invariant0.invariant' = Invariant0.invariant'
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  let rec cfg new [#"../Scratch/src/vsids.rs" 357 4 357 35] [@cfg:stackify] [@cfg:subregion_analysis] (num_vars : usize) : Scratch_Vsids_Vsids_Type.t_vsids
    requires {[#"../Scratch/src/vsids.rs" 356 15 356 46] UIntSize.to_int num_vars < 9223372036854775807}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : Scratch_Vsids_Vsids_Type.t_vsids;
  var num_vars_1 : usize;
  var _3 : Scratch_Vsids_Heap_Type.t_heap;
  var _4 : usize;
  var _5 : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global);
  var _6 : usize;
  {
    num_vars_1 <- num_vars;
    goto BB0
  }
  BB0 {
    _4 <- num_vars_1;
    _3 <- ([#"../Scratch/src/vsids.rs" 359 24 359 43] New0.new _4);
    goto BB1
  }
  BB1 {
    _6 <- num_vars_1;
    _5 <- ([#"../Scratch/src/vsids.rs" 362 22 362 42] FromElem0.from_elem ([#"../Scratch/src/vsids.rs" 362 27 362 31] true) _6);
    goto BB2
  }
  BB2 {
    _0 <- Scratch_Vsids_Vsids_Type.C_VSIDS _3 ([#"../Scratch/src/vsids.rs" 360 21 360 24] 1.0000000000000000000000000000000000000000000000000000000000000000) ([#"../Scratch/src/vsids.rs" 361 23 361 27] 0.9499999999999999555910790149937383830547332763671875000000000000) _5;
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    return _0
  }
  
end
module Core_Slice_Iter_IterMut_Type
  use prelude.Opaque
  use prelude.Borrow
  use Core_Marker_PhantomData_Type as Core_Marker_PhantomData_Type
  use Core_Ptr_NonNull_NonNull_Type as Core_Ptr_NonNull_NonNull_Type
  type t_itermut 't =
    | C_IterMut (Core_Ptr_NonNull_NonNull_Type.t_nonnull 't) opaque_ptr (Core_Marker_PhantomData_Type.t_phantomdata (borrowed 't))
    
end
module CreusotContracts_Std1_Slice_Impl16_ShallowModel_Stub
  type t
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  function shallow_model (self : Core_Slice_Iter_IterMut_Type.t_itermut t) : borrowed (slice t)
end
module CreusotContracts_Std1_Slice_Impl16_ShallowModel_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  function shallow_model (self : Core_Slice_Iter_IterMut_Type.t_itermut t) : borrowed (slice t)
  axiom shallow_model_spec : forall self : Core_Slice_Iter_IterMut_Type.t_itermut t . [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 368 14 368 50] Seq.length (ShallowModel0.shallow_model ( ^ shallow_model self)) = Seq.length (ShallowModel0.shallow_model ( * shallow_model self))
end
module CreusotContracts_Std1_Slice_Impl16_ShallowModel
  type t
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  function shallow_model (self : Core_Slice_Iter_IterMut_Type.t_itermut t) : borrowed (slice t)
  val shallow_model (self : Core_Slice_Iter_IterMut_Type.t_itermut t) : borrowed (slice t)
    ensures { result = shallow_model self }
    
  axiom shallow_model_spec : forall self : Core_Slice_Iter_IterMut_Type.t_itermut t . [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 368 14 368 50] Seq.length (ShallowModel0.shallow_model ( ^ shallow_model self)) = Seq.length (ShallowModel0.shallow_model ( * shallow_model self))
end
module CreusotContracts_Std1_Slice_Impl19_Resolve_Stub
  type t
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  predicate resolve (self : Core_Slice_Iter_IterMut_Type.t_itermut t)
end
module CreusotContracts_Std1_Slice_Impl19_Resolve_Interface
  type t
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  predicate resolve (self : Core_Slice_Iter_IterMut_Type.t_itermut t)
end
module CreusotContracts_Std1_Slice_Impl19_Resolve
  type t
  use prelude.Borrow
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl16_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate resolve (self : Core_Slice_Iter_IterMut_Type.t_itermut t) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 378 20 378 36]  * ShallowModel0.shallow_model self =  ^ ShallowModel0.shallow_model self
  val resolve (self : Core_Slice_Iter_IterMut_Type.t_itermut t) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Std1_Slice_Impl17_Invariant_Stub
  type t
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  predicate invariant' (self : Core_Slice_Iter_IterMut_Type.t_itermut t)
end
module CreusotContracts_Std1_Slice_Impl17_Invariant_Interface
  type t
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  predicate invariant' (self : Core_Slice_Iter_IterMut_Type.t_itermut t)
end
module CreusotContracts_Std1_Slice_Impl17_Invariant
  type t
  use prelude.Borrow
  use seq.Seq
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl16_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate invariant' (self : Core_Slice_Iter_IterMut_Type.t_itermut t) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 387 20 387 54] Seq.length (ShallowModel1.shallow_model ( ^ ShallowModel0.shallow_model self)) = Seq.length (ShallowModel1.shallow_model ( * ShallowModel0.shallow_model self))
  val invariant' (self : Core_Slice_Iter_IterMut_Type.t_itermut t) : bool
    ensures { result = invariant' self }
    
end
module Core_Slice_Impl0_IterMut_Interface
  type t
  use prelude.Borrow
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl17_Invariant_Stub as Invariant0 with
    type t = t
  clone CreusotContracts_Std1_Slice_Impl16_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX',
    axiom .
  val iter_mut (self : borrowed (slice t)) : Core_Slice_Iter_IterMut_Type.t_itermut t
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 208 0 301 1] ShallowModel0.shallow_model result = self }
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 258 18 258 36] Invariant0.invariant' result }
    
end
module CreusotContracts_Std1_Slice_Impl18_Completed_Stub
  type t
  use prelude.Borrow
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  predicate completed (self : borrowed (Core_Slice_Iter_IterMut_Type.t_itermut t))
end
module CreusotContracts_Std1_Slice_Impl18_Completed_Interface
  type t
  use prelude.Borrow
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  predicate completed (self : borrowed (Core_Slice_Iter_IterMut_Type.t_itermut t))
end
module CreusotContracts_Std1_Slice_Impl18_Completed
  type t
  use prelude.Borrow
  use seq.Seq
  use prelude.Slice
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = Core_Slice_Iter_IterMut_Type.t_itermut t,
    type ShallowModelTy0.shallowModelTy = borrowed (slice t)
  clone CreusotContracts_Resolve_Impl1_Resolve_Stub as Resolve0 with
    type t = Core_Slice_Iter_IterMut_Type.t_itermut t
  predicate completed (self : borrowed (Core_Slice_Iter_IterMut_Type.t_itermut t)) =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 394 20 394 61] Resolve0.resolve self /\ ShallowModel1.shallow_model ( * ShallowModel0.shallow_model self) = Seq.empty 
  val completed (self : borrowed (Core_Slice_Iter_IterMut_Type.t_itermut t)) : bool
    ensures { result = completed self }
    
end
module CreusotContracts_Std1_Slice_Impl4_ToMutSeq_Stub
  type t
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic1 with
    type t = t,
    type s = slice t
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type s = borrowed (slice t)
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  function to_mut_seq (self : borrowed (slice t)) : Seq.seq (borrowed t)
end
module CreusotContracts_Std1_Slice_Impl4_ToMutSeq_Interface
  type t
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic1 with
    type t = t,
    type s = slice t
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type s = borrowed (slice t)
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  function to_mut_seq (self : borrowed (slice t)) : Seq.seq (borrowed t)
  axiom to_mut_seq_spec : forall self : borrowed (slice t) . ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 70 4 70 85] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq self) ->  ^ Seq.get (to_mut_seq self) i = IndexLogic1.index_logic ( ^ self) i) && ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 69 4 69 82] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq self) ->  * Seq.get (to_mut_seq self) i = IndexLogic0.index_logic self i) && ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 68 14 68 41] Seq.length (to_mut_seq self) = Seq.length (ShallowModel0.shallow_model self))
end
module CreusotContracts_Std1_Slice_Impl4_ToMutSeq
  type t
  use seq.Seq
  use prelude.Int
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic1 with
    type t = t,
    type s = slice t
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type s = borrowed (slice t)
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel0 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  function to_mut_seq (self : borrowed (slice t)) : Seq.seq (borrowed t)
  val to_mut_seq (self : borrowed (slice t)) : Seq.seq (borrowed t)
    ensures { result = to_mut_seq self }
    
  axiom to_mut_seq_spec : forall self : borrowed (slice t) . ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 70 4 70 85] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq self) ->  ^ Seq.get (to_mut_seq self) i = IndexLogic1.index_logic ( ^ self) i) && ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 69 4 69 82] forall i : int . 0 <= i /\ i < Seq.length (to_mut_seq self) ->  * Seq.get (to_mut_seq self) i = IndexLogic0.index_logic self i) && ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 68 14 68 41] Seq.length (to_mut_seq self) = Seq.length (ShallowModel0.shallow_model self))
end
module CreusotContracts_Std1_Slice_Impl18_Produces_Stub
  type t
  use seq.Seq
  use prelude.Borrow
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  predicate produces (self : Core_Slice_Iter_IterMut_Type.t_itermut t) (visited : Seq.seq (borrowed t)) (tl : Core_Slice_Iter_IterMut_Type.t_itermut t)
    
end
module CreusotContracts_Std1_Slice_Impl18_Produces_Interface
  type t
  use seq.Seq
  use prelude.Borrow
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  predicate produces (self : Core_Slice_Iter_IterMut_Type.t_itermut t) (visited : Seq.seq (borrowed t)) (tl : Core_Slice_Iter_IterMut_Type.t_itermut t)
    
end
module CreusotContracts_Std1_Slice_Impl18_Produces
  type t
  use seq.Seq
  use prelude.Borrow
  use prelude.Slice
  use seq.Seq
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic1 with
    type t = t,
    type s = slice t
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic_Stub as IndexLogic0 with
    type t = t,
    type s = borrowed (slice t)
  clone CreusotContracts_Model_Impl3_ShallowModel_Stub as ShallowModel2 with
    type t = slice t,
    type ShallowModelTy0.shallowModelTy = Seq.seq t
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Slice_Impl4_ToMutSeq_Stub as ToMutSeq0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function IndexLogic1.index_logic = IndexLogic1.index_logic,
    axiom .
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl16_ShallowModel_Stub as ShallowModel0 with
    type t = t,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX',
    axiom .
  predicate produces (self : Core_Slice_Iter_IterMut_Type.t_itermut t) (visited : Seq.seq (borrowed t)) (tl : Core_Slice_Iter_IterMut_Type.t_itermut t)
    
   =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 400 12 400 66] ToMutSeq0.to_mut_seq (ShallowModel0.shallow_model self) = Seq.(++) visited (ToMutSeq0.to_mut_seq (ShallowModel0.shallow_model tl))
  val produces (self : Core_Slice_Iter_IterMut_Type.t_itermut t) (visited : Seq.seq (borrowed t)) (tl : Core_Slice_Iter_IterMut_Type.t_itermut t) : bool
    ensures { result = produces self visited tl }
    
end
module Core_Slice_Iter_Impl189_Next_Interface
  type t
  use prelude.Borrow
  use seq.Seq
  use Core_Option_Option_Type as Core_Option_Option_Type
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl18_Produces_Stub as Produces0 with
    type t = t
  clone CreusotContracts_Std1_Slice_Impl18_Completed_Stub as Completed0 with
    type t = t
  clone Core_Iter_Traits_Iterator_Iterator_Item_Type as Item0 with
    type self = Core_Slice_Iter_IterMut_Type.t_itermut t
  val next (self : borrowed (Core_Slice_Iter_IterMut_Type.t_itermut t)) : Core_Option_Option_Type.t_option (borrowed t)
    ensures { [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/iter.rs" 85 26 88 17] match (result) with
      | Core_Option_Option_Type.C_None -> Completed0.completed self
      | Core_Option_Option_Type.C_Some v -> Produces0.produces ( * self) (Seq.singleton v) ( ^ self)
      end }
    
end
module CreusotContracts_Std1_Slice_Impl18_ProducesRefl_Stub
  type t
  use seq.Seq
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl18_Produces_Stub as Produces0 with
    type t = t
  function produces_refl (a : Core_Slice_Iter_IterMut_Type.t_itermut t) : ()
end
module CreusotContracts_Std1_Slice_Impl18_ProducesRefl_Interface
  type t
  use seq.Seq
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl18_Produces_Stub as Produces0 with
    type t = t
  function produces_refl (a : Core_Slice_Iter_IterMut_Type.t_itermut t) : ()
  axiom produces_refl_spec : forall a : Core_Slice_Iter_IterMut_Type.t_itermut t . [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 405 14 405 39] Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Slice_Impl18_ProducesRefl
  type t
  use seq.Seq
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl18_Produces_Stub as Produces0 with
    type t = t
  function produces_refl (a : Core_Slice_Iter_IterMut_Type.t_itermut t) : () =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 404 4 404 10] ()
  val produces_refl (a : Core_Slice_Iter_IterMut_Type.t_itermut t) : ()
    ensures { result = produces_refl a }
    
  axiom produces_refl_spec : forall a : Core_Slice_Iter_IterMut_Type.t_itermut t . [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 405 14 405 39] Produces0.produces a (Seq.empty ) a
end
module CreusotContracts_Std1_Slice_Impl18_ProducesTrans_Stub
  type t
  use seq.Seq
  use prelude.Borrow
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl18_Produces_Stub as Produces0 with
    type t = t
  function produces_trans (a : Core_Slice_Iter_IterMut_Type.t_itermut t) (ab : Seq.seq (borrowed t)) (b : Core_Slice_Iter_IterMut_Type.t_itermut t) (bc : Seq.seq (borrowed t)) (c : Core_Slice_Iter_IterMut_Type.t_itermut t) : ()
    
end
module CreusotContracts_Std1_Slice_Impl18_ProducesTrans_Interface
  type t
  use seq.Seq
  use prelude.Borrow
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl18_Produces_Stub as Produces0 with
    type t = t
  function produces_trans (a : Core_Slice_Iter_IterMut_Type.t_itermut t) (ab : Seq.seq (borrowed t)) (b : Core_Slice_Iter_IterMut_Type.t_itermut t) (bc : Seq.seq (borrowed t)) (c : Core_Slice_Iter_IterMut_Type.t_itermut t) : ()
    
  axiom produces_trans_spec : forall a : Core_Slice_Iter_IterMut_Type.t_itermut t, ab : Seq.seq (borrowed t), b : Core_Slice_Iter_IterMut_Type.t_itermut t, bc : Seq.seq (borrowed t), c : Core_Slice_Iter_IterMut_Type.t_itermut t . ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 409 15 409 32] Produces0.produces a ab b) -> ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 410 15 410 32] Produces0.produces b bc c) -> ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 411 14 411 42] Produces0.produces a (Seq.(++) ab bc) c)
end
module CreusotContracts_Std1_Slice_Impl18_ProducesTrans
  type t
  use seq.Seq
  use prelude.Borrow
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl18_Produces_Stub as Produces0 with
    type t = t
  function produces_trans (a : Core_Slice_Iter_IterMut_Type.t_itermut t) (ab : Seq.seq (borrowed t)) (b : Core_Slice_Iter_IterMut_Type.t_itermut t) (bc : Seq.seq (borrowed t)) (c : Core_Slice_Iter_IterMut_Type.t_itermut t) : ()
    
   =
    [#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 408 4 408 10] ()
  val produces_trans (a : Core_Slice_Iter_IterMut_Type.t_itermut t) (ab : Seq.seq (borrowed t)) (b : Core_Slice_Iter_IterMut_Type.t_itermut t) (bc : Seq.seq (borrowed t)) (c : Core_Slice_Iter_IterMut_Type.t_itermut t) : ()
    requires {[#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 409 15 409 32] Produces0.produces a ab b}
    requires {[#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 410 15 410 32] Produces0.produces b bc c}
    ensures { result = produces_trans a ab b bc c }
    
  axiom produces_trans_spec : forall a : Core_Slice_Iter_IterMut_Type.t_itermut t, ab : Seq.seq (borrowed t), b : Core_Slice_Iter_IterMut_Type.t_itermut t, bc : Seq.seq (borrowed t), c : Core_Slice_Iter_IterMut_Type.t_itermut t . ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 409 15 409 32] Produces0.produces a ab b) -> ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 410 15 410 32] Produces0.produces b bc c) -> ([#"../../../.cargo/git/checkouts/creusot-8bb2a9f6fb1f15ef/fc75680/creusot-contracts/src/std/slice.rs" 411 14 411 42] Produces0.produces a (Seq.(++) ab bc) c)
end
module Scratch_Vsids_Impl5_Rescale_Interface
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Float64
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone Scratch_Vsids_Impl3_Invariant_Stub as Invariant0
  val rescale [#"../Scratch/src/vsids.rs" 384 4 384 35] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 380 4 380 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 383 15 383 51] UIntSize.to_int v < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_activity (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self))))}
    ensures { [#"../Scratch/src/vsids.rs" 380 4 380 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 381 14 381 75] Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_heap (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self)))) = Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_heap (Scratch_Vsids_Vsids_Type.vsids_order_heap ( ^ self)))) }
    ensures { [#"../Scratch/src/vsids.rs" 382 14 382 69] Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self)) = Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( ^ self)) }
    
end
module Scratch_Vsids_Impl5_Rescale
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use prelude.Slice
  use prelude.IntSize
  use seq.Seq
  use prelude.Float32
  use seq.Seq
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Slice_Impl0_ShallowModel as ShallowModel5 with
    type t = Float64.t,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic1 with
    type t = Float64.t,
    type s = slice Float64.t,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel3 with
    type t = slice Float64.t,
    type ShallowModelTy0.shallowModelTy = Seq.seq Float64.t,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model
  clone CreusotContracts_Logic_Ops_Impl0_IndexLogic as IndexLogic0 with
    type t = Float64.t,
    type s = borrowed (slice Float64.t),
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model
  clone CreusotContracts_Std1_Slice_Impl4_ToMutSeq as ToMutSeq0 with
    type t = Float64.t,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function IndexLogic1.index_logic = IndexLogic1.index_logic,
    axiom .
  use Core_Slice_Iter_IterMut_Type as Core_Slice_Iter_IterMut_Type
  clone CreusotContracts_Std1_Slice_Impl16_ShallowModel as ShallowModel6 with
    type t = Float64.t,
    function ShallowModel0.shallow_model = ShallowModel5.shallow_model,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel7 with
    type t = Core_Slice_Iter_IterMut_Type.t_itermut Float64.t,
    type ShallowModelTy0.shallowModelTy = borrowed (slice Float64.t),
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model
  clone CreusotContracts_Std1_Slice_Impl18_Produces as Produces0 with
    type t = Float64.t,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model,
    function ToMutSeq0.to_mut_seq = ToMutSeq0.to_mut_seq,
    function ShallowModel1.shallow_model = ShallowModel5.shallow_model,
    val Max0.mAX' = Max0.mAX',
    function ShallowModel2.shallow_model = ShallowModel3.shallow_model,
    function IndexLogic0.index_logic = IndexLogic0.index_logic,
    function IndexLogic1.index_logic = IndexLogic1.index_logic
  clone CreusotContracts_Std1_Slice_Impl18_ProducesTrans as ProducesTrans0 with
    type t = Float64.t,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Std1_Slice_Impl18_ProducesRefl as ProducesRefl0 with
    type t = Float64.t,
    predicate Produces0.produces = Produces0.produces,
    axiom .
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Core_Slice_Iter_IterMut_Type.t_itermut Float64.t
  clone CreusotContracts_Std1_Slice_Impl18_Completed as Completed0 with
    type t = Float64.t,
    predicate Resolve0.resolve = Resolve0.resolve,
    function ShallowModel0.shallow_model = ShallowModel7.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel5.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPost as IntoIterPost0 with
    type i = Core_Slice_Iter_IterMut_Type.t_itermut Float64.t
  clone CreusotContracts_Std1_Slice_Impl17_Invariant as Invariant2 with
    type t = Float64.t,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel5.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Std1_Iter_Impl0_IntoIterPre as IntoIterPre0 with
    type i = Core_Slice_Iter_IterMut_Type.t_itermut Float64.t,
    predicate Invariant0.invariant' = Invariant2.invariant'
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel4 with
    type t = Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq Float64.t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel2 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant as Invariant1 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve4 with
    type t = Float64.t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve3 with
    type t = slice Float64.t
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve2 with
    type t = Scratch_Vsids_Vsids_Type.t_vsids
  clone CreusotContracts_Std1_Slice_Impl19_Resolve as Resolve1 with
    type t = Float64.t,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel5.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Core_Option_Option_Type as Core_Option_Option_Type
  clone Core_Slice_Iter_Impl189_Next_Interface as Next0 with
    type t = Float64.t,
    type Item0.item = borrowed Float64.t,
    predicate Completed0.completed = Completed0.completed,
    predicate Produces0.produces = Produces0.produces
  clone Core_Iter_Traits_Collect_Impl0_IntoIter_Interface as IntoIter0 with
    type i = Core_Slice_Iter_IterMut_Type.t_itermut Float64.t,
    predicate IntoIterPre0.into_iter_pre = IntoIterPre0.into_iter_pre,
    predicate Invariant0.invariant' = Invariant2.invariant',
    predicate IntoIterPost0.into_iter_post = IntoIterPost0.into_iter_post
  clone Core_Slice_Impl0_IterMut_Interface as IterMut1 with
    type t = Float64.t,
    function ShallowModel0.shallow_model = ShallowModel6.shallow_model,
    predicate Invariant0.invariant' = Invariant2.invariant',
    function ShallowModel1.shallow_model = ShallowModel5.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl10_DerefMut_Interface as DerefMut0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel4.shallow_model,
    function ShallowModel2.shallow_model = ShallowModel5.shallow_model,
    function ShallowModel3.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl3_Invariant as Invariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg rescale [#"../Scratch/src/vsids.rs" 384 4 384 35] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 380 4 380 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 383 15 383 51] UIntSize.to_int v < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_activity (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self))))}
    ensures { [#"../Scratch/src/vsids.rs" 380 4 380 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 381 14 381 75] Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_heap (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self)))) = Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Heap_Type.heap_heap (Scratch_Vsids_Vsids_Type.vsids_order_heap ( ^ self)))) }
    ensures { [#"../Scratch/src/vsids.rs" 382 14 382 69] Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self)) = Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( ^ self)) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Vsids_Type.t_vsids);
  var v_2 : usize;
  var _8 : ();
  var _9 : Core_Slice_Iter_IterMut_Type.t_itermut Float64.t;
  var _10 : Core_Slice_Iter_IterMut_Type.t_itermut Float64.t;
  var _11 : borrowed (slice Float64.t);
  var _12 : borrowed (slice Float64.t);
  var _13 : borrowed (Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global));
  var iter_14 : Core_Slice_Iter_IterMut_Type.t_itermut Float64.t;
  var _15 : ();
  var _16 : ();
  var _17 : Core_Option_Option_Type.t_option (borrowed Float64.t);
  var _18 : borrowed (Core_Slice_Iter_IterMut_Type.t_itermut Float64.t);
  var _19 : borrowed (Core_Slice_Iter_IterMut_Type.t_itermut Float64.t);
  var _20 : isize;
  var _21 : ();
  var e_22 : borrowed Float64.t;
  {
    self_1 <- self;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    _13 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_activity (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self_1)));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Vsids_Type.C_VSIDS a b c d =  * self_1 in Scratch_Vsids_Vsids_Type.C_VSIDS (let Scratch_Vsids_Heap_Type.C_Heap a b c d = Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self_1) in Scratch_Vsids_Heap_Type.C_Heap ( ^ _13) b c d) b c d) };
    _12 <- ([#"../Scratch/src/vsids.rs" 386 17 386 52] DerefMut0.deref_mut _13);
    goto BB1
  }
  BB1 {
    _11 <- borrow_mut ( * _12);
    _12 <- { _12 with current = ( ^ _11) };
    _10 <- ([#"../Scratch/src/vsids.rs" 386 17 386 52] IterMut1.iter_mut _11);
    goto BB2
  }
  BB2 {
    _9 <- ([#"../Scratch/src/vsids.rs" 386 17 386 52] IntoIter0.into_iter _10);
    goto BB3
  }
  BB3 {
    iter_14 <- _9;
    _9 <- any Core_Slice_Iter_IterMut_Type.t_itermut Float64.t;
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    _19 <- borrow_mut iter_14;
    iter_14 <-  ^ _19;
    _18 <- borrow_mut ( * _19);
    _19 <- { _19 with current = ( ^ _18) };
    _17 <- ([#"../Scratch/src/vsids.rs" 386 17 386 52] Next0.next _18);
    goto BB6
  }
  BB6 {
    assume { Resolve0.resolve _19 };
    switch (_17)
      | Core_Option_Option_Type.C_None -> goto BB7
      | Core_Option_Option_Type.C_Some _ -> goto BB8
      end
  }
  BB7 {
    goto BB10
  }
  BB8 {
    e_22 <- Core_Option_Option_Type.some_0 _17;
    _17 <- (let Core_Option_Option_Type.C_Some a = _17 in Core_Option_Option_Type.C_Some (any borrowed Float64.t));
    e_22 <- { e_22 with current = ([#"../Scratch/src/vsids.rs" 387 12 387 24]  * e_22 .* ([#"../Scratch/src/vsids.rs" 387 18 387 24] 0.0000000000000000000000000000000000000000000000000000000000000000)) };
    assume { Resolve4.resolve e_22 };
    _16 <- ();
    _15 <- ();
    goto BB4
  }
  BB9 {
    assume { Resolve1.resolve iter_14 };
    assume { Resolve2.resolve self_1 };
    assume { Resolve3.resolve _12 };
    absurd
  }
  BB10 {
    assume { Resolve1.resolve iter_14 };
    _8 <- ();
    assume { Resolve3.resolve _12 };
    self_1 <- { self_1 with current = (let Scratch_Vsids_Vsids_Type.C_VSIDS a b c d =  * self_1 in Scratch_Vsids_Vsids_Type.C_VSIDS a ([#"../Scratch/src/vsids.rs" 389 8 389 30] Scratch_Vsids_Vsids_Type.vsids_var_inc ( * self_1) .* ([#"../Scratch/src/vsids.rs" 389 24 389 30] 0.0000000000000000000000000000000000000000000000000000000000000000)) c d) };
    assume { Resolve2.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Scratch_Vsids_Impl5_BumpVariable_Interface
  use prelude.Borrow
  use prelude.UIntSize
  use seq.Seq
  use prelude.Int
  use prelude.Float64
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone Scratch_Vsids_Impl3_Invariant_Stub as Invariant0
  val bump_variable [#"../Scratch/src/vsids.rs" 394 4 394 41] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 392 4 392 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 393 15 393 51] UIntSize.to_int v < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_activity (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self))))}
    ensures { [#"../Scratch/src/vsids.rs" 392 4 392 40] Invariant0.invariant' ( ^ self) }
    
end
module Scratch_Vsids_Impl5_BumpVariable
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use prelude.Float64
  use seq.Seq
  use prelude.Float32
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel4 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel3 with
    type t = Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq Float64.t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = Float64.t
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = Float64.t
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = Float64.t
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq Float64.t,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant as Invariant1 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Scratch_Vsids_Vsids_Type.t_vsids
  clone Scratch_Vsids_Impl2_Decrease_Interface as Decrease0 with
    predicate Invariant0.invariant' = Invariant1.invariant'
  clone Scratch_Vsids_Impl3_Invariant as Invariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl5_Rescale_Interface as Rescale0 with
    predicate Invariant0.invariant' = Invariant0.invariant',
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel4.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = Float64.t,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = Float64.t
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Float64.t
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = Float64.t,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = Float64.t,
    val Max0.mAX' = Max0.mAX'
  let rec cfg bump_variable [#"../Scratch/src/vsids.rs" 394 4 394 41] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 392 4 392 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 393 15 393 51] UIntSize.to_int v < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_activity (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self))))}
    ensures { [#"../Scratch/src/vsids.rs" 392 4 392 40] Invariant0.invariant' ( ^ self) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Vsids_Type.t_vsids);
  var v_2 : usize;
  var _6 : Float64.t;
  var _7 : borrowed Float64.t;
  var _8 : borrowed (Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global));
  var _9 : usize;
  var _10 : ();
  var _11 : bool;
  var _12 : Float64.t;
  var _13 : Float64.t;
  var _14 : Alloc_Vec_Vec_Type.t_vec Float64.t (Alloc_Alloc_Global_Type.t_global);
  var _15 : usize;
  var _16 : ();
  var _17 : borrowed (Scratch_Vsids_Vsids_Type.t_vsids);
  var _18 : usize;
  var _19 : ();
  var _20 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var _21 : usize;
  {
    self_1 <- self;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    _6 <- Scratch_Vsids_Vsids_Type.vsids_var_inc ( * self_1);
    _8 <- borrow_mut (Scratch_Vsids_Heap_Type.heap_activity (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self_1)));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Vsids_Type.C_VSIDS a b c d =  * self_1 in Scratch_Vsids_Vsids_Type.C_VSIDS (let Scratch_Vsids_Heap_Type.C_Heap a b c d = Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self_1) in Scratch_Vsids_Heap_Type.C_Heap ( ^ _8) b c d) b c d) };
    _9 <- v_2;
    _7 <- ([#"../Scratch/src/vsids.rs" 395 8 395 35] IndexMut0.index_mut _8 _9);
    goto BB1
  }
  BB1 {
    _7 <- { _7 with current = ([#"../Scratch/src/vsids.rs" 395 8 395 51]  * _7 .+ _6) };
    assume { Resolve0.resolve _7 };
    _14 <- Scratch_Vsids_Heap_Type.heap_activity (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self_1));
    _15 <- v_2;
    _13 <- ([#"../Scratch/src/vsids.rs" 396 11 396 38] Index0.index _14 _15);
    goto BB2
  }
  BB2 {
    _12 <- _13;
    _11 <- ([#"../Scratch/src/vsids.rs" 396 11 396 46] _12 .> ([#"../Scratch/src/vsids.rs" 396 41 396 46] 10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104.0000000000000000000000000000000000000000000000000000000000000000));
    switch (_11)
      | False -> goto BB5
      | True -> goto BB3
      end
  }
  BB3 {
    _17 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _17) };
    _18 <- v_2;
    _16 <- ([#"../Scratch/src/vsids.rs" 397 12 397 27] Rescale0.rescale _17 _18);
    goto BB4
  }
  BB4 {
    _10 <- ();
    goto BB6
  }
  BB5 {
    _10 <- ();
    goto BB6
  }
  BB6 {
    _20 <- borrow_mut (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Vsids_Type.C_VSIDS a b c d =  * self_1 in Scratch_Vsids_Vsids_Type.C_VSIDS ( ^ _20) b c d) };
    _21 <- v_2;
    _19 <- ([#"../Scratch/src/vsids.rs" 401 8 401 35] Decrease0.decrease _20 _21);
    goto BB7
  }
  BB7 {
    assume { Resolve1.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Scratch_Vsids_Impl5_DecayVarInc_Interface
  use prelude.Borrow
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  val decay_var_inc [#"../Scratch/src/vsids.rs" 405 4 405 31] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) : ()
end
module Scratch_Vsids_Impl5_DecayVarInc
  use prelude.Borrow
  use prelude.Float64
  use prelude.Float32
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Vsids_Vsids_Type.t_vsids
  let rec cfg decay_var_inc [#"../Scratch/src/vsids.rs" 405 4 405 31] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Vsids_Type.t_vsids);
  var _2 : Float64.t;
  var _3 : Float64.t;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _3 <- Scratch_Vsids_Vsids_Type.vsids_var_decay ( * self_1);
    _2 <- ([#"../Scratch/src/vsids.rs" 406 24 406 44] ([#"../Scratch/src/vsids.rs" 406 24 406 27] 1.0000000000000000000000000000000000000000000000000000000000000000) ./ _3);
    self_1 <- { self_1 with current = (let Scratch_Vsids_Vsids_Type.C_VSIDS a b c d =  * self_1 in Scratch_Vsids_Vsids_Type.C_VSIDS a ([#"../Scratch/src/vsids.rs" 406 8 406 44] Scratch_Vsids_Vsids_Type.vsids_var_inc ( * self_1) .* _2) c d) };
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Scratch_Vsids_Impl5_SetVarDecay_Interface
  use prelude.Borrow
  use prelude.Float64
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  val set_var_decay [#"../Scratch/src/vsids.rs" 410 4 410 45] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) (new_val : Float64.t) : ()
    
end
module Scratch_Vsids_Impl5_SetVarDecay
  use prelude.Borrow
  use prelude.Float64
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Vsids_Vsids_Type.t_vsids
  let rec cfg set_var_decay [#"../Scratch/src/vsids.rs" 410 4 410 45] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) (new_val : Float64.t) : ()
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Vsids_Type.t_vsids);
  var new_val_2 : Float64.t;
  var _3 : Float64.t;
  {
    self_1 <- self;
    new_val_2 <- new_val;
    goto BB0
  }
  BB0 {
    _3 <- new_val_2;
    self_1 <- { self_1 with current = (let Scratch_Vsids_Vsids_Type.C_VSIDS a b c d =  * self_1 in Scratch_Vsids_Vsids_Type.C_VSIDS a b _3 d) };
    _3 <- any Float64.t;
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Scratch_Vsids_Impl5_Insert_Interface
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use prelude.UIntSize
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel1 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone Scratch_Vsids_Impl3_Invariant_Stub as Invariant0
  val insert [#"../Scratch/src/vsids.rs" 419 4 419 34] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 415 4 415 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 417 15 417 75] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self)))) < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_indices (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self))))}
    requires {[#"../Scratch/src/vsids.rs" 418 15 418 40] UIntSize.to_int v < Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Vsids_Type.vsids_decision ( * self)))}
    ensures { [#"../Scratch/src/vsids.rs" 415 4 415 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 416 14 416 71] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self))) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( ^ self))) }
    
end
module Scratch_Vsids_Impl5_Insert
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use prelude.Float64
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel3 with
    type t = Float64.t,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = bool
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = bool
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel1 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl1_ShallowModel as ShallowModel2 with
    type t = Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq bool,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Heap_Type as Scratch_Vsids_Heap_Type
  clone Scratch_Vsids_Impl0_Invariant as Invariant1 with
    function ShallowModel0.shallow_model = ShallowModel3.shallow_model,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = Scratch_Vsids_Vsids_Type.t_vsids
  clone Scratch_Vsids_Impl2_Insert_Interface as Insert0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Alloc_Vec_Impl13_Index_Interface as Index0 with
    type t = bool,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel2.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    type Output0.output = bool
  clone Scratch_Vsids_Impl2_InHeap_Interface as InHeap0 with
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model,
    val Max0.mAX' = Max0.mAX'
  clone Scratch_Vsids_Impl3_Invariant as Invariant0 with
    predicate Invariant0.invariant' = Invariant1.invariant',
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    val Max0.mAX' = Max0.mAX'
  let rec cfg insert [#"../Scratch/src/vsids.rs" 419 4 419 34] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 415 4 415 40] Invariant0.invariant' ( * self)}
    requires {[#"../Scratch/src/vsids.rs" 417 15 417 75] Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_heap (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self)))) < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Heap_Type.heap_indices (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self))))}
    requires {[#"../Scratch/src/vsids.rs" 418 15 418 40] UIntSize.to_int v < Seq.length (ShallowModel1.shallow_model (Scratch_Vsids_Vsids_Type.vsids_decision ( * self)))}
    ensures { [#"../Scratch/src/vsids.rs" 415 4 415 40] Invariant0.invariant' ( ^ self) }
    ensures { [#"../Scratch/src/vsids.rs" 416 14 416 71] UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self))) = UIntSize.to_int (Scratch_Vsids_Heap_Type.heap_num_vars (Scratch_Vsids_Vsids_Type.vsids_order_heap ( ^ self))) }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Vsids_Type.t_vsids);
  var v_2 : usize;
  var _8 : bool;
  var _9 : bool;
  var _10 : bool;
  var _11 : Scratch_Vsids_Heap_Type.t_heap;
  var _12 : usize;
  var _13 : bool;
  var _14 : bool;
  var _15 : Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global);
  var _16 : usize;
  var _17 : ();
  var _18 : borrowed (Scratch_Vsids_Heap_Type.t_heap);
  var _19 : usize;
  {
    self_1 <- self;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    _11 <- Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self_1);
    _12 <- v_2;
    _10 <- ([#"../Scratch/src/vsids.rs" 420 12 420 38] InHeap0.in_heap _11 _12);
    goto BB4
  }
  BB1 {
    _8 <- ([#"../Scratch/src/vsids.rs" 420 11 420 58] false);
    goto BB3
  }
  BB2 {
    _15 <- Scratch_Vsids_Vsids_Type.vsids_decision ( * self_1);
    _16 <- v_2;
    _14 <- ([#"../Scratch/src/vsids.rs" 420 42 420 58] Index0.index _15 _16);
    goto BB5
  }
  BB3 {
    switch (_8)
      | False -> goto BB8
      | True -> goto BB6
      end
  }
  BB4 {
    _9 <- not _10;
    switch (_9)
      | False -> goto BB1
      | True -> goto BB2
      end
  }
  BB5 {
    _13 <- _14;
    _8 <- _13;
    _13 <- any bool;
    goto BB3
  }
  BB6 {
    _18 <- borrow_mut (Scratch_Vsids_Vsids_Type.vsids_order_heap ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Vsids_Type.C_VSIDS a b c d =  * self_1 in Scratch_Vsids_Vsids_Type.C_VSIDS ( ^ _18) b c d) };
    _19 <- v_2;
    _17 <- ([#"../Scratch/src/vsids.rs" 421 12 421 37] Insert0.insert _18 _19);
    goto BB7
  }
  BB7 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB9
  }
  BB8 {
    assume { Resolve0.resolve self_1 };
    _0 <- ();
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module Scratch_Vsids_Impl5_TurnOffDecisionForIdx_Interface
  use prelude.UIntSize
  use prelude.Borrow
  use seq.Seq
  use prelude.Int
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max_Stub as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel_Stub as ShallowModel0 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  val turn_off_decision_for_idx [#"../Scratch/src/vsids.rs" 438 4 438 53] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 437 15 437 40] UIntSize.to_int v < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Vsids_Type.vsids_decision ( * self)))}
    
end
module Scratch_Vsids_Impl5_TurnOffDecisionForIdx
  use prelude.Borrow
  use prelude.Int
  use prelude.UIntSize
  use seq.Seq
  use seq.Seq
  clone CreusotContracts_Std1_Slice_Impl5_ResolveElswhere as ResolveElswhere0 with
    type t = bool
  clone CreusotContracts_Std1_Slice_Impl5_HasValue as HasValue0 with
    type t = bool
  clone CreusotContracts_Std1_Slice_Impl5_InBounds as InBounds0 with
    type t = bool
  use Alloc_Alloc_Global_Type as Alloc_Alloc_Global_Type
  use Alloc_Vec_Vec_Type as Alloc_Vec_Vec_Type
  clone Core_Num_Impl11_Max as Max0
  clone CreusotContracts_Std1_Vec_Impl0_ShallowModel as ShallowModel0 with
    type t = bool,
    type a = Alloc_Alloc_Global_Type.t_global,
    val Max0.mAX' = Max0.mAX',
    axiom .
  clone CreusotContracts_Model_Impl3_ShallowModel as ShallowModel1 with
    type t = Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global),
    type ShallowModelTy0.shallowModelTy = Seq.seq bool,
    function ShallowModel0.shallow_model = ShallowModel0.shallow_model
  use Scratch_Vsids_Vsids_Type as Scratch_Vsids_Vsids_Type
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve1 with
    type t = Scratch_Vsids_Vsids_Type.t_vsids
  clone CreusotContracts_Resolve_Impl1_Resolve as Resolve0 with
    type t = bool
  clone Alloc_Vec_Impl14_IndexMut_Interface as IndexMut0 with
    type t = bool,
    type i = usize,
    type a = Alloc_Alloc_Global_Type.t_global,
    function ShallowModel0.shallow_model = ShallowModel1.shallow_model,
    predicate InBounds0.in_bounds = InBounds0.in_bounds,
    predicate HasValue0.has_value = HasValue0.has_value,
    function ShallowModel1.shallow_model = ShallowModel0.shallow_model,
    predicate ResolveElswhere0.resolve_elswhere = ResolveElswhere0.resolve_elswhere,
    type Output0.output = bool,
    val Max0.mAX' = Max0.mAX'
  let rec cfg turn_off_decision_for_idx [#"../Scratch/src/vsids.rs" 438 4 438 53] [@cfg:stackify] [@cfg:subregion_analysis] (self : borrowed (Scratch_Vsids_Vsids_Type.t_vsids)) (v : usize) : ()
    requires {[#"../Scratch/src/vsids.rs" 437 15 437 40] UIntSize.to_int v < Seq.length (ShallowModel0.shallow_model (Scratch_Vsids_Vsids_Type.vsids_decision ( * self)))}
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : ();
  var self_1 : borrowed (Scratch_Vsids_Vsids_Type.t_vsids);
  var v_2 : usize;
  var _4 : borrowed bool;
  var _5 : borrowed (Alloc_Vec_Vec_Type.t_vec bool (Alloc_Alloc_Global_Type.t_global));
  var _6 : usize;
  {
    self_1 <- self;
    v_2 <- v;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut (Scratch_Vsids_Vsids_Type.vsids_decision ( * self_1));
    self_1 <- { self_1 with current = (let Scratch_Vsids_Vsids_Type.C_VSIDS a b c d =  * self_1 in Scratch_Vsids_Vsids_Type.C_VSIDS a b c ( ^ _5)) };
    _6 <- v_2;
    _4 <- ([#"../Scratch/src/vsids.rs" 439 8 439 24] IndexMut0.index_mut _5 _6);
    goto BB1
  }
  BB1 {
    _4 <- { _4 with current = ([#"../Scratch/src/vsids.rs" 439 27 439 32] false) };
    assume { Resolve0.resolve _4 };
    assume { Resolve1.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Scratch_Logic_Pos_Stub
  use prelude.Int
  use prelude.UInt8
  function pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8
end
module Scratch_Logic_Pos_Interface
  use prelude.Int
  use prelude.UInt8
  function pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8
end
module Scratch_Logic_Pos
  use prelude.Int
  use prelude.UInt8
  function pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8 =
    [#"../Scratch/src/logic.rs" 9 4 9 7] (1 : uint8)
  val pos [#"../Scratch/src/logic.rs" 8 0 8 25] (_1' : ()) : uint8
    ensures { result = pos _1' }
    
end
module Scratch_Logic_Neg_Stub
  use prelude.Int
  use prelude.UInt8
  function neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8
end
module Scratch_Logic_Neg_Interface
  use prelude.Int
  use prelude.UInt8
  function neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8
end
module Scratch_Logic_Neg
  use prelude.Int
  use prelude.UInt8
  function neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8 =
    [#"../Scratch/src/logic.rs" 14 4 14 7] (0 : uint8)
  val neg [#"../Scratch/src/logic.rs" 13 0 13 25] (_1' : ()) : uint8
    ensures { result = neg _1' }
    
end
module Scratch_Logic_BoolToAssignedstate_Stub
  use prelude.UInt8
  use prelude.Int
  function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
end
module Scratch_Logic_BoolToAssignedstate_Interface
  use prelude.UInt8
  use prelude.Int
  function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
  axiom bool_to_assignedstate_spec : forall b : bool . ([#"../Scratch/src/logic.rs" 31 0 31 31] not b -> UInt8.to_int (bool_to_assignedstate b) = 0) && ([#"../Scratch/src/logic.rs" 30 0 30 30] b -> UInt8.to_int (bool_to_assignedstate b) = 1)
end
module Scratch_Logic_BoolToAssignedstate
  use prelude.UInt8
  use prelude.Int
  function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8 =
    [#"../Scratch/src/logic.rs" 29 0 29 8] if b then (1 : uint8) else (0 : uint8)
  val bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
    ensures { result = bool_to_assignedstate b }
    
  axiom bool_to_assignedstate_spec : forall b : bool . ([#"../Scratch/src/logic.rs" 31 0 31 31] not b -> UInt8.to_int (bool_to_assignedstate b) = 0) && ([#"../Scratch/src/logic.rs" 30 0 30 30] b -> UInt8.to_int (bool_to_assignedstate b) = 1)
end
module Scratch_Logic_BoolToAssignedstate_Impl
  use prelude.UInt8
  use prelude.Int
  let rec ghost function bool_to_assignedstate [#"../Scratch/src/logic.rs" 32 0 32 54] (b : bool) : uint8
    ensures { [#"../Scratch/src/logic.rs" 30 0 30 30] b -> UInt8.to_int result = 1 }
    ensures { [#"../Scratch/src/logic.rs" 31 0 31 31] not b -> UInt8.to_int result = 0 }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
    [#"../Scratch/src/logic.rs" 29 0 29 8] if b then (1 : uint8) else (0 : uint8)
end
module Scratch_Logic_FlipV_Stub
  use prelude.Int
  use prelude.UInt8
  function flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8
end
module Scratch_Logic_FlipV_Interface
  use prelude.Int
  use prelude.UInt8
  function flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8
end
module Scratch_Logic_FlipV
  use prelude.Int
  use prelude.UInt8
  function flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8 =
    [#"../Scratch/src/logic.rs" 42 4 50 5] if UInt8.to_int v = 0 then
      (1 : uint8)
    else
      if UInt8.to_int v = 1 then (0 : uint8) else v
    
  val flip_v [#"../Scratch/src/logic.rs" 41 0 41 44] (v : uint8) : uint8
    ensures { result = flip_v v }
    
end
module Scratch_Assignments_Impl0
  
end
module Scratch_Clause_Impl0
  
end
module Scratch_Formula_Impl0
  
end
module Scratch_Lit_Impl0
  
end
module Scratch_Clause_Impl3
  use prelude.Borrow
  use Scratch_Clause_Clause_Type as Scratch_Clause_Clause_Type
  goal clone'_refn : [#"../Scratch/src/clause.rs" 6 9 6 14] forall self : Scratch_Clause_Clause_Type.t_clause . forall result : Scratch_Clause_Clause_Type.t_clause . result = self -> result = self
end
module Scratch_Lit_Impl4
  use prelude.Borrow
  use Scratch_Lit_Lit_Type as Scratch_Lit_Lit_Type
  goal clone'_refn : [#"../Scratch/src/lit.rs" 10 9 10 14] forall self : Scratch_Lit_Lit_Type.t_lit . forall result : Scratch_Lit_Lit_Type.t_lit . result = self -> result = self
end
module Scratch_Lit_Impl5
  
end
module Scratch_Lit_Impl1
  
end
module Scratch_Restart_Impl0
  
end
module Scratch_Restart_Impl2
  
end
module Scratch_Restart_Impl5
  
end
module Scratch_Restart_Impl8
  
end
module Scratch_Vsids_Impl1
  
end
