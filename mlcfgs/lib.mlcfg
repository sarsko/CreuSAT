module Type
  use Ref
  use mach.int.Int
  use prelude.Int8
  use prelude.Int16
  use mach.int.Int32
  use mach.int.Int64
  use prelude.UInt8
  use prelude.UInt16
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  type creusotcontracts_std1_vec_vec 't  
  type lib_decision_decisions  = 
    | Lib_Decision_Decisions (creusotcontracts_std1_vec_vec usize)
    
  function lib_decision_decisions_Decisions_lit_order (self : lib_decision_decisions) : creusotcontracts_std1_vec_vec usize
    
  val lib_decision_decisions_Decisions_lit_order (self : lib_decision_decisions) : creusotcontracts_std1_vec_vec usize
    ensures { result = lib_decision_decisions_Decisions_lit_order self }
    
  axiom lib_decision_decisions_Decisions_lit_order_acc : forall a : creusotcontracts_std1_vec_vec usize . lib_decision_decisions_Decisions_lit_order (Lib_Decision_Decisions a : lib_decision_decisions) = a
  type lib_assignments_assignments  = 
    | Lib_Assignments_Assignments (creusotcontracts_std1_vec_vec uint8) usize
    
  function lib_assignments_assignments_Assignments_0 (self : lib_assignments_assignments) : creusotcontracts_std1_vec_vec uint8
    
  val lib_assignments_assignments_Assignments_0 (self : lib_assignments_assignments) : creusotcontracts_std1_vec_vec uint8
    ensures { result = lib_assignments_assignments_Assignments_0 self }
    
  axiom lib_assignments_assignments_Assignments_0_acc : forall a : creusotcontracts_std1_vec_vec uint8, b : usize . lib_assignments_assignments_Assignments_0 (Lib_Assignments_Assignments a b : lib_assignments_assignments) = a
  function lib_assignments_assignments_Assignments_1 (self : lib_assignments_assignments) : usize
  val lib_assignments_assignments_Assignments_1 (self : lib_assignments_assignments) : usize
    ensures { result = lib_assignments_assignments_Assignments_1 self }
    
  axiom lib_assignments_assignments_Assignments_1_acc : forall a : creusotcontracts_std1_vec_vec uint8, b : usize . lib_assignments_assignments_Assignments_1 (Lib_Assignments_Assignments a b : lib_assignments_assignments) = b
  type core_option_option 't = 
    | Core_Option_Option_None
    | Core_Option_Option_Some 't
    
  function core_option_option_Some_0 (self : core_option_option 't) : 't
  val core_option_option_Some_0 (self : core_option_option 't) : 't
    ensures { result = core_option_option_Some_0 self }
    
  axiom core_option_option_Some_0_acc : forall a : 't . core_option_option_Some_0 (Core_Option_Option_Some a : core_option_option 't) = a
  type lib_formula_satstate  = 
    | Lib_Formula_SatState_Unknown
    | Lib_Formula_SatState_Sat
    | Lib_Formula_SatState_Unsat
    
  type lib_lit_lit  = 
    | Lib_Lit_Lit usize bool
    
  function lib_lit_lit_Lit_idx (self : lib_lit_lit) : usize
  val lib_lit_lit_Lit_idx (self : lib_lit_lit) : usize
    ensures { result = lib_lit_lit_Lit_idx self }
    
  axiom lib_lit_lit_Lit_idx_acc : forall a : usize, b : bool . lib_lit_lit_Lit_idx (Lib_Lit_Lit a b : lib_lit_lit) = a
  function lib_lit_lit_Lit_polarity (self : lib_lit_lit) : bool
  val lib_lit_lit_Lit_polarity (self : lib_lit_lit) : bool
    ensures { result = lib_lit_lit_Lit_polarity self }
    
  axiom lib_lit_lit_Lit_polarity_acc : forall a : usize, b : bool . lib_lit_lit_Lit_polarity (Lib_Lit_Lit a b : lib_lit_lit) = b
  type lib_trail_reason  = 
    | Lib_Trail_Reason_Decision
    | Lib_Trail_Reason_Unit usize
    | Lib_Trail_Reason_Long usize
    
  function lib_trail_reason_Long_0 (self : lib_trail_reason) : usize
  val lib_trail_reason_Long_0 (self : lib_trail_reason) : usize
    ensures { result = lib_trail_reason_Long_0 self }
    
  axiom lib_trail_reason_Long_0_acc : forall a : usize . lib_trail_reason_Long_0 (Lib_Trail_Reason_Long a : lib_trail_reason) = a
  function lib_trail_reason_Unit_0 (self : lib_trail_reason) : usize
  val lib_trail_reason_Unit_0 (self : lib_trail_reason) : usize
    ensures { result = lib_trail_reason_Unit_0 self }
    
  axiom lib_trail_reason_Unit_0_acc : forall a : usize . lib_trail_reason_Unit_0 (Lib_Trail_Reason_Unit a : lib_trail_reason) = a
  type lib_trail_step  = 
    | Lib_Trail_Step (lib_lit_lit) usize (lib_trail_reason)
    
  function lib_trail_step_Step_lit (self : lib_trail_step) : lib_lit_lit
  val lib_trail_step_Step_lit (self : lib_trail_step) : lib_lit_lit
    ensures { result = lib_trail_step_Step_lit self }
    
  axiom lib_trail_step_Step_lit_acc : forall a : lib_lit_lit, b : usize, c : lib_trail_reason . lib_trail_step_Step_lit (Lib_Trail_Step a b c : lib_trail_step) = a
  function lib_trail_step_Step_reason (self : lib_trail_step) : lib_trail_reason
  val lib_trail_step_Step_reason (self : lib_trail_step) : lib_trail_reason
    ensures { result = lib_trail_step_Step_reason self }
    
  axiom lib_trail_step_Step_reason_acc : forall a : lib_lit_lit, b : usize, c : lib_trail_reason . lib_trail_step_Step_reason (Lib_Trail_Step a b c : lib_trail_step) = c
  type lib_clause_clause  = 
    | Lib_Clause_Clause (creusotcontracts_std1_vec_vec (lib_lit_lit))
    
  function lib_clause_clause_Clause_rest (self : lib_clause_clause) : creusotcontracts_std1_vec_vec (lib_lit_lit)
  val lib_clause_clause_Clause_rest (self : lib_clause_clause) : creusotcontracts_std1_vec_vec (lib_lit_lit)
    ensures { result = lib_clause_clause_Clause_rest self }
    
  axiom lib_clause_clause_Clause_rest_acc : forall a : creusotcontracts_std1_vec_vec (lib_lit_lit) . lib_clause_clause_Clause_rest (Lib_Clause_Clause a : lib_clause_clause) = a
  type lib_formula_formula  = 
    | Lib_Formula_Formula (creusotcontracts_std1_vec_vec (lib_clause_clause)) usize
    
  function lib_formula_formula_Formula_clauses (self : lib_formula_formula) : creusotcontracts_std1_vec_vec (lib_clause_clause)
    
  val lib_formula_formula_Formula_clauses (self : lib_formula_formula) : creusotcontracts_std1_vec_vec (lib_clause_clause)
    ensures { result = lib_formula_formula_Formula_clauses self }
    
  axiom lib_formula_formula_Formula_clauses_acc : forall a : creusotcontracts_std1_vec_vec (lib_clause_clause), b : usize . lib_formula_formula_Formula_clauses (Lib_Formula_Formula a b : lib_formula_formula) = a
  function lib_formula_formula_Formula_num_vars (self : lib_formula_formula) : usize
  val lib_formula_formula_Formula_num_vars (self : lib_formula_formula) : usize
    ensures { result = lib_formula_formula_Formula_num_vars self }
    
  axiom lib_formula_formula_Formula_num_vars_acc : forall a : creusotcontracts_std1_vec_vec (lib_clause_clause), b : usize . lib_formula_formula_Formula_num_vars (Lib_Formula_Formula a b : lib_formula_formula) = b
  type creusotcontracts_logic_ghost_ghost 't = 
    | CreusotContracts_Logic_Ghost_Ghost opaque_ptr
    
  type lib_trail_trail  = 
    | Lib_Trail_Trail (lib_assignments_assignments) (creusotcontracts_std1_vec_vec usize) (creusotcontracts_std1_vec_vec (lib_trail_step)) usize (creusotcontracts_std1_vec_vec usize)
    
  function lib_trail_trail_Trail_trail (self : lib_trail_trail) : creusotcontracts_std1_vec_vec (lib_trail_step)
  val lib_trail_trail_Trail_trail (self : lib_trail_trail) : creusotcontracts_std1_vec_vec (lib_trail_step)
    ensures { result = lib_trail_trail_Trail_trail self }
    
  axiom lib_trail_trail_Trail_trail_acc : forall a : lib_assignments_assignments, b : creusotcontracts_std1_vec_vec usize, c : creusotcontracts_std1_vec_vec (lib_trail_step), d : usize, e : creusotcontracts_std1_vec_vec usize . lib_trail_trail_Trail_trail (Lib_Trail_Trail a b c d e : lib_trail_trail) = c
  function lib_trail_trail_Trail_assignments (self : lib_trail_trail) : lib_assignments_assignments
  val lib_trail_trail_Trail_assignments (self : lib_trail_trail) : lib_assignments_assignments
    ensures { result = lib_trail_trail_Trail_assignments self }
    
  axiom lib_trail_trail_Trail_assignments_acc : forall a : lib_assignments_assignments, b : creusotcontracts_std1_vec_vec usize, c : creusotcontracts_std1_vec_vec (lib_trail_step), d : usize, e : creusotcontracts_std1_vec_vec usize . lib_trail_trail_Trail_assignments (Lib_Trail_Trail a b c d e : lib_trail_trail) = a
  function lib_trail_trail_Trail_lit_to_level (self : lib_trail_trail) : creusotcontracts_std1_vec_vec usize
  val lib_trail_trail_Trail_lit_to_level (self : lib_trail_trail) : creusotcontracts_std1_vec_vec usize
    ensures { result = lib_trail_trail_Trail_lit_to_level self }
    
  axiom lib_trail_trail_Trail_lit_to_level_acc : forall a : lib_assignments_assignments, b : creusotcontracts_std1_vec_vec usize, c : creusotcontracts_std1_vec_vec (lib_trail_step), d : usize, e : creusotcontracts_std1_vec_vec usize . lib_trail_trail_Trail_lit_to_level (Lib_Trail_Trail a b c d e : lib_trail_trail) = b
  function lib_trail_trail_Trail_decisions (self : lib_trail_trail) : creusotcontracts_std1_vec_vec usize
  val lib_trail_trail_Trail_decisions (self : lib_trail_trail) : creusotcontracts_std1_vec_vec usize
    ensures { result = lib_trail_trail_Trail_decisions self }
    
  axiom lib_trail_trail_Trail_decisions_acc : forall a : lib_assignments_assignments, b : creusotcontracts_std1_vec_vec usize, c : creusotcontracts_std1_vec_vec (lib_trail_step), d : usize, e : creusotcontracts_std1_vec_vec usize . lib_trail_trail_Trail_decisions (Lib_Trail_Trail a b c d e : lib_trail_trail) = e
  function lib_trail_trail_Trail_curr_i (self : lib_trail_trail) : usize
  val lib_trail_trail_Trail_curr_i (self : lib_trail_trail) : usize
    ensures { result = lib_trail_trail_Trail_curr_i self }
    
  axiom lib_trail_trail_Trail_curr_i_acc : forall a : lib_assignments_assignments, b : creusotcontracts_std1_vec_vec usize, c : creusotcontracts_std1_vec_vec (lib_trail_step), d : usize, e : creusotcontracts_std1_vec_vec usize . lib_trail_trail_Trail_curr_i (Lib_Trail_Trail a b c d e : lib_trail_trail) = d
  type lib_conflictanalysis_conflict  = 
    | Lib_ConflictAnalysis_Conflict_Ground
    | Lib_ConflictAnalysis_Conflict_Unit (lib_clause_clause)
    | Lib_ConflictAnalysis_Conflict_Learned usize (lib_clause_clause)
    | Lib_ConflictAnalysis_Conflict_Panic
    
  function lib_conflictanalysis_conflict_Learned_0 (self : lib_conflictanalysis_conflict) : usize
  val lib_conflictanalysis_conflict_Learned_0 (self : lib_conflictanalysis_conflict) : usize
    ensures { result = lib_conflictanalysis_conflict_Learned_0 self }
    
  axiom lib_conflictanalysis_conflict_Learned_0_acc : forall a : usize, b : lib_clause_clause . lib_conflictanalysis_conflict_Learned_0 (Lib_ConflictAnalysis_Conflict_Learned a b : lib_conflictanalysis_conflict) = a
  function lib_conflictanalysis_conflict_Learned_1 (self : lib_conflictanalysis_conflict) : lib_clause_clause
  val lib_conflictanalysis_conflict_Learned_1 (self : lib_conflictanalysis_conflict) : lib_clause_clause
    ensures { result = lib_conflictanalysis_conflict_Learned_1 self }
    
  axiom lib_conflictanalysis_conflict_Learned_1_acc : forall a : usize, b : lib_clause_clause . lib_conflictanalysis_conflict_Learned_1 (Lib_ConflictAnalysis_Conflict_Learned a b : lib_conflictanalysis_conflict) = b
  function lib_conflictanalysis_conflict_Unit_0 (self : lib_conflictanalysis_conflict) : lib_clause_clause
  val lib_conflictanalysis_conflict_Unit_0 (self : lib_conflictanalysis_conflict) : lib_clause_clause
    ensures { result = lib_conflictanalysis_conflict_Unit_0 self }
    
  axiom lib_conflictanalysis_conflict_Unit_0_acc : forall a : lib_clause_clause . lib_conflictanalysis_conflict_Unit_0 (Lib_ConflictAnalysis_Conflict_Unit a : lib_conflictanalysis_conflict) = a
  type lib_watches_watcher  = 
    | Lib_Watches_Watcher usize
    
  function lib_watches_watcher_Watcher_cref (self : lib_watches_watcher) : usize
  val lib_watches_watcher_Watcher_cref (self : lib_watches_watcher) : usize
    ensures { result = lib_watches_watcher_Watcher_cref self }
    
  axiom lib_watches_watcher_Watcher_cref_acc : forall a : usize . lib_watches_watcher_Watcher_cref (Lib_Watches_Watcher a : lib_watches_watcher) = a
  type lib_watches_watches  = 
    | Lib_Watches_Watches (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher)))
    
  function lib_watches_watches_Watches_watches (self : lib_watches_watches) : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher))
    
  val lib_watches_watches_Watches_watches (self : lib_watches_watches) : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher))
    ensures { result = lib_watches_watches_Watches_watches self }
    
  axiom lib_watches_watches_Watches_watches_acc : forall a : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher)) . lib_watches_watches_Watches_watches (Lib_Watches_Watches a : lib_watches_watches) = a
  type core_result_result 't 'e = 
    | Core_Result_Result_Ok 't
    | Core_Result_Result_Err 'e
    
  function core_result_result_Err_0 (self : core_result_result 't 'e) : 'e
  val core_result_result_Err_0 (self : core_result_result 't 'e) : 'e
    ensures { result = core_result_result_Err_0 self }
    
  axiom core_result_result_Err_0_acc : forall a : 'e . core_result_result_Err_0 (Core_Result_Result_Err a : core_result_result 't 'e) = a
  function core_result_result_Ok_0 (self : core_result_result 't 'e) : 't
  val core_result_result_Ok_0 (self : core_result_result 't 'e) : 't
    ensures { result = core_result_result_Ok_0 self }
    
  axiom core_result_result_Ok_0_acc : forall a : 't . core_result_result_Ok_0 (Core_Result_Result_Ok a : core_result_result 't 'e) = a
  type lib_solver_conflictresult  = 
    | Lib_Solver_ConflictResult_Ok
    | Lib_Solver_ConflictResult_Err
    | Lib_Solver_ConflictResult_Ground
    | Lib_Solver_ConflictResult_Continue
    
  type lib_solver_satresult  = 
    | Lib_Solver_SatResult_Sat (creusotcontracts_std1_vec_vec uint8)
    | Lib_Solver_SatResult_Unsat
    | Lib_Solver_SatResult_Unknown
    | Lib_Solver_SatResult_Err
    
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve_Interface
  type t   
  use prelude.Prelude
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve
  type t   
  use prelude.Prelude
  predicate resolve (self : borrowed t) = 
     ^ self =  * self
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve_Interface
  type t   
  predicate resolve (self : t)
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve
  type t   
  predicate resolve (self : t) = 
    true
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface
  type self   
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve
  type self   
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Impl1
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = t
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = borrowed t,
  predicate resolve = Resolve0.resolve
end
module CreusotContracts_Logic_Resolve_Impl2
  type t   
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = t
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = t,
  predicate resolve = Resolve0.resolve
end
module Lib_Decision_Impl0_MoveToFront_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val move_to_front [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (tomove : usize) : ()
end
module Lib_Decision_Impl0_MoveToFront
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = Type.lib_decision_decisions
  let rec cfg move_to_front [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (tomove : usize) : () = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_decision_decisions);
  var tomove_2 : usize;
  {
    self_1 <- self;
    tomove_2 <- tomove;
    goto BB0
  }
  BB0 {
    _0 <- ();
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve tomove_2 };
    return _0
  }
  
end
module Lib_Decision_Impl0_GetNext_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val get_next [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (a : Type.lib_assignments_assignments) : Type.core_option_option usize
    
end
module Lib_Decision_Impl0_GetNext
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = Type.lib_decision_decisions
  let rec cfg get_next [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (a : Type.lib_assignments_assignments) : Type.core_option_option usize
    
   = 
  var _0 : Type.core_option_option usize;
  var self_1 : borrowed (Type.lib_decision_decisions);
  var a_2 : Type.lib_assignments_assignments;
  var _3 : ();
  {
    self_1 <- self;
    a_2 <- a;
    goto BB0
  }
  BB0 {
    _0 <- Type.Core_Option_Option_None;
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve a_2 };
    return _0
  }
  
end
module CreusotContracts_Logic_Resolve_Impl0_Resolve_Interface
  type t1   
  type t2   
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Logic_Resolve_Impl0_Resolve
  type t1   
  type t2   
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface as Resolve1 with type self = t2
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface as Resolve0 with type self = t1
  predicate resolve (self : (t1, t2)) = 
    Resolve0.resolve (let (a, _) = self in a) && Resolve1.resolve (let (_, a) = self in a)
end
module CreusotContracts_Logic_Resolve_Impl0
  type t1   
  type t2   
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve3 with type self = t2
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve2 with type self = t1
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with type t1 = t1, type t2 = t2,
  predicate Resolve0.resolve = Resolve2.resolve, predicate Resolve1.resolve = Resolve3.resolve
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = (t1, t2),
  predicate resolve = Resolve0.resolve
end
module Lib_Formula_Impl0_Eq_Interface
  use prelude.Prelude
  use Type
  val eq [@cfg:stackify] (self : Type.lib_formula_satstate) (other : Type.lib_formula_satstate) : bool
end
module Lib_Formula_Impl0_Eq
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_formula_satstate
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve1 with type t1 = Type.lib_formula_satstate,
  type t2 = Type.lib_formula_satstate, predicate Resolve0.resolve = Resolve0.resolve,
  predicate Resolve1.resolve = Resolve0.resolve
  let rec cfg eq [@cfg:stackify] (self : Type.lib_formula_satstate) (other : Type.lib_formula_satstate) : bool = 
  var _0 : bool;
  var self_1 : Type.lib_formula_satstate;
  var other_2 : Type.lib_formula_satstate;
  var _3 : ();
  var _4 : (Type.lib_formula_satstate, Type.lib_formula_satstate);
  var _5 : Type.lib_formula_satstate;
  var _6 : Type.lib_formula_satstate;
  var _7 : isize;
  var _8 : isize;
  var _9 : isize;
  var _10 : isize;
  {
    self_1 <- self;
    other_2 <- other;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _5 };
    _5 <- self_1;
    assume { Resolve0.resolve self_1 };
    assume { Resolve0.resolve _6 };
    _6 <- other_2;
    assume { Resolve0.resolve other_2 };
    _4 <- (_5, _6);
    switch (let (a, _) = _4 in a)
      | Type.Lib_Formula_SatState_Unknown -> goto BB1
      | Type.Lib_Formula_SatState_Sat -> goto BB3
      | Type.Lib_Formula_SatState_Unsat -> goto BB4
      end
  }
  BB1 {
    assume { Resolve1.resolve _4 };
    switch (let (_, a) = _4 in a)
      | Type.Lib_Formula_SatState_Unknown -> goto BB5
      | _ -> goto BB2
      end
  }
  BB2 {
    _0 <- false;
    goto BB8
  }
  BB3 {
    assume { Resolve1.resolve _4 };
    switch (let (_, a) = _4 in a)
      | Type.Lib_Formula_SatState_Sat -> goto BB6
      | _ -> goto BB2
      end
  }
  BB4 {
    assume { Resolve1.resolve _4 };
    switch (let (_, a) = _4 in a)
      | Type.Lib_Formula_SatState_Unsat -> goto BB7
      | _ -> goto BB2
      end
  }
  BB5 {
    _0 <- true;
    goto BB8
  }
  BB6 {
    _0 <- true;
    goto BB8
  }
  BB7 {
    _0 <- true;
    goto BB8
  }
  BB8 {
    return _0
  }
  BB9 {
    assume { Resolve1.resolve _4 };
    goto BB2
  }
  
end
module Lib_Assignments_RandInRange_Interface
  use mach.int.UInt64
  use prelude.UInt8
  use mach.int.Int
  use prelude.Prelude
  val rand_in_range [@cfg:stackify] (l : usize) (u : usize) : uint8
    ensures { UInt64.to_int l <= UInt8.to_int result && UInt8.to_int result < UInt64.to_int u }
    
end
module Lib_Assignments_RandInRange
  use mach.int.UInt64
  use prelude.UInt8
  use mach.int.Int
  use prelude.Prelude
  val rand_in_range [@cfg:stackify] (l : usize) (u : usize) : uint8
    ensures { UInt64.to_int l <= UInt8.to_int result && UInt8.to_int result < UInt64.to_int u }
    
end
module CreusotContracts_Logic_Model_Model_ModelTy
  type self   
  type modelTy   
end
module CreusotContracts_Logic_Model_Model_Model_Interface
  type self   
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Model_Model
  type self   
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0_Model_Interface
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  function model (self : t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0_Model
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : t) : ModelTy0.modelTy = 
    Model0.model self
end
module Lib_Logic_LogicAssignments_Impl0_ModelTy
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  type modelTy  = 
    Seq.seq uint8
end
module CreusotContracts_Logic_Model_Impl0_ModelTy
  type t   
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  type modelTy  = 
    ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy2 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model as Model2 with type self = t, type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = t, type ModelTy0.modelTy = ModelTy2.modelTy,
  function Model0.model = Model2.model
  clone CreusotContracts_Logic_Model_Impl0_ModelTy as ModelTy0 with type t = t, type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = t, function model = Model0.model,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = t, type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Std1_Vec_Impl0_Model_Interface
  type t   
  use Type
  use seq.Seq
  function model (self : Type.creusotcontracts_std1_vec_vec t) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_Model
  type t   
  use Type
  use seq.Seq
  function model (self : Type.creusotcontracts_std1_vec_vec t) : Seq.seq t
end
module Lib_Logic_LogicAssignments_Impl0_Model_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function model (self : Type.lib_assignments_assignments) : Seq.seq uint8
end
module Lib_Logic_LogicAssignments_Impl0_Model
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = uint8
  function model (self : Type.lib_assignments_assignments) : Seq.seq uint8 = 
    Model0.model (Type.lib_assignments_assignments_Assignments_0 self)
end
module Lib_Logic_LogicAssignments_Impl0
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.lib_assignments_assignments,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.lib_assignments_assignments,
  type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Std1_Vec_Impl0_ModelTy
  type t   
  use seq.Seq
  type modelTy  = 
    Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0
  type t   
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.creusotcontracts_std1_vec_vec t,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.creusotcontracts_std1_vec_vec t,
  type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Std1_Vec_Impl1_Len_Interface
  type t   
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val len [@cfg:stackify] (self : Type.creusotcontracts_std1_vec_vec t) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model self) }
    
end
module CreusotContracts_Std1_Vec_Impl1_Len
  type t   
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val len [@cfg:stackify] (self : Type.creusotcontracts_std1_vec_vec t) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model self) }
    
end
module Lib_Assignments_Impl0_Len_Interface
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val len [@cfg:stackify] (self : Type.lib_assignments_assignments) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model self) }
    
end
module Lib_Assignments_Impl0_Len
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Model_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = uint8, function Model0.model = Model3.model
  let rec cfg len [@cfg:stackify] (self : Type.lib_assignments_assignments) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model self) }
    
   = 
  var _0 : usize;
  var self_1 : Type.lib_assignments_assignments;
  var _2 : Type.creusotcontracts_std1_vec_vec uint8;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _2 <- Type.lib_assignments_assignments_Assignments_0 self_1;
    assume { Resolve0.resolve self_1 };
    _0 <- Len0.len _2;
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CreusotContracts_Logic_Model_Impl1_Model_Interface
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  function model (self : borrowed t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl1_Model
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : borrowed t) : ModelTy0.modelTy = 
    Model0.model ( * self)
end
module Lib_Logic_LogicClause_Impl0_Model_Interface
  use Type
  use seq.Seq
  function model (self : Type.lib_clause_clause) : Seq.seq (Type.lib_lit_lit)
end
module Lib_Logic_LogicClause_Impl0_Model
  use Type
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_lit_lit
  function model (self : Type.lib_clause_clause) : Seq.seq (Type.lib_lit_lit) = 
    Model0.model (Type.lib_clause_clause_Clause_rest self)
end
module Lib_Logic_LogicLit_Impl1_SatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate sat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8)
end
module Lib_Logic_LogicLit_Impl1_SatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  use mach.int.Int32
  predicate sat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8) = 
    if Type.lib_lit_lit_Lit_polarity self then
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 1
    else
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 0
    
end
module Lib_Logic_LogicLit_Impl1_UnsatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unsat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8)
end
module Lib_Logic_LogicLit_Impl1_UnsatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  use mach.int.Int32
  predicate unsat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8) = 
    if Type.lib_lit_lit_Lit_polarity self then
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 0
    else
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 1
    
end
module Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate post_unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl1_PostUnitInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate post_unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && SatInner0.sat_inner (Seq.get (Model0.model self) i) a && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> i -> UnsatInner0.unsat_inner (Seq.get (Model0.model self) j) a)
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsToInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate clause_post_with_regards_to_inner (c : Type.lib_clause_clause) (a : Seq.seq uint8) (j : int)
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsToInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  predicate clause_post_with_regards_to_inner (c : Type.lib_clause_clause) (a : Seq.seq uint8) (j : int) = 
    PostUnitInner0.post_unit_inner c a && (exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) = j && SatInner0.sat_inner (Seq.get (Model0.model c) i) a)
end
module Lib_Logic_LogicTrail_LongArePostUnitInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate long_are_post_unit_inner (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Seq.seq uint8)
    
end
module Lib_Logic_LogicTrail_LongArePostUnitInner
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner_Interface as ClausePostWithRegardsToInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate long_are_post_unit_inner (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Seq.seq uint8)
    
   = 
    forall j : (int) . 0 <= j && j < Seq.length trail -> match (Type.lib_trail_step_Step_reason (Seq.get trail j)) with
      | Type.Lib_Trail_Reason_Long k -> ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) a (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get trail j))))
      | _ -> true
      end
end
module Lib_Logic_Logic_Unset_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unset (v : uint8)
end
module Lib_Logic_Logic_Unset
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  predicate unset (v : uint8) = 
    if UInt8.to_int v >= 2 then true else false
end
module Lib_Logic_LogicLit_Impl1_Invariant_Interface
  use Type
  use mach.int.Int
  predicate invariant' (self : Type.lib_lit_lit) (n : int)
end
module Lib_Logic_LogicLit_Impl1_Invariant
  use Type
  use mach.int.Int
  use mach.int.UInt64
  predicate invariant' (self : Type.lib_lit_lit) (n : int) = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < n
end
module Lib_Logic_LogicTrail_Impl0_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_trail_reason) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_Impl0_Invariant
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate invariant' (self : Type.lib_trail_reason) (f : Type.lib_formula_formula) = 
    match (self) with
      | Type.Lib_Trail_Reason_Long i -> 0 <= UInt64.to_int i && UInt64.to_int i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) && Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int i))) > 1
      | Type.Lib_Trail_Reason_Unit i -> 0 <= UInt64.to_int i && UInt64.to_int i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) && Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int i))) = 1
      | _ -> true
      end
end
module Lib_Logic_LogicTrail_Impl1_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_trail_step) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_Impl1_Invariant
  use Type
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_Impl0_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  predicate invariant' (self : Type.lib_trail_step) (f : Type.lib_formula_formula) = 
    Invariant0.invariant' (Type.lib_trail_step_Step_lit self) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && Invariant1.invariant' (Type.lib_trail_step_Step_reason self) f
end
module Lib_Logic_LogicTrail_CrefsInRange_Interface
  use seq.Seq
  use Type
  predicate crefs_in_range (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_CrefsInRange
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicTrail_Impl1_Invariant_Interface as Invariant0
  predicate crefs_in_range (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) = 
    forall i : (int) . 0 <= i && i < Seq.length trail -> Invariant0.invariant' (Seq.get trail i) f
end
module Lib_Logic_LogicTrail_TrailInvariant_Interface
  use seq.Seq
  use Type
  predicate trail_invariant (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_TrailInvariant
  use seq.Seq
  use Type
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  predicate trail_invariant (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) = 
    CrefsInRange0.crefs_in_range trail f
end
module Lib_Logic_LogicClause_VarsInRangeInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate vars_in_range_inner (s : Seq.seq (Type.lib_lit_lit)) (n : int)
end
module Lib_Logic_LogicClause_VarsInRangeInner
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  predicate vars_in_range_inner (s : Seq.seq (Type.lib_lit_lit)) (n : int) = 
    forall i : (int) . 0 <= i && i < Seq.length s -> Invariant0.invariant' (Seq.get s i) n
end
module Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface
  use seq.Seq
  use Type
  predicate no_duplicate_indexes_inner (s : Seq.seq (Type.lib_lit_lit))
end
module Lib_Logic_LogicClause_NoDuplicateIndexesInner
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  predicate no_duplicate_indexes_inner (s : Seq.seq (Type.lib_lit_lit)) = 
    forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length s && 0 <= k && k < j -> not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get s k)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get s j)))
end
module Lib_Logic_LogicClause_InvariantInternal_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate invariant_internal (s : Seq.seq (Type.lib_lit_lit)) (n : int)
end
module Lib_Logic_LogicClause_InvariantInternal
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  predicate invariant_internal (s : Seq.seq (Type.lib_lit_lit)) (n : int) = 
    VarsInRangeInner0.vars_in_range_inner s n && NoDuplicateIndexesInner0.no_duplicate_indexes_inner s
end
module Lib_Logic_LogicClause_Impl2_Invariant_Interface
  use Type
  use mach.int.Int
  predicate invariant' (self : Type.lib_clause_clause) (n : int)
end
module Lib_Logic_LogicClause_Impl2_Invariant
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate invariant' (self : Type.lib_clause_clause) (n : int) = 
    InvariantInternal0.invariant_internal (Model0.model self) n
end
module Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface
  use Type
  predicate invariant_old (self : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_InvariantOld
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate invariant_old (self : Type.lib_formula_formula) = 
    (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) -> Invariant0.invariant' (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self))) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) -> Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i)) >= 1)
end
module Lib_Logic_LogicFormula_Impl0_Model_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  function model (self : Type.lib_formula_formula) : (Seq.seq (Type.lib_clause_clause), int)
end
module Lib_Logic_LogicFormula_Impl0_Model
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function model (self : Type.lib_formula_formula) : (Seq.seq (Type.lib_clause_clause), int) = 
    (Model0.model (Type.lib_formula_formula_Formula_clauses self), UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self))
end
module Lib_Logic_LogicFormula_FormulaInvariant_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate formula_invariant (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicFormula_FormulaInvariant
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  predicate formula_invariant (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    (forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Invariant0.invariant' (Seq.get (let (a, _) = f in a) i) (let (_, a) = f in a)) && (forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Seq.length (Model0.model (Seq.get (let (a, _) = f in a) i)) > 0)
end
module Lib_Logic_LogicFormula_Impl0_ModelTy
  use seq.Seq
  use Type
  use mach.int.Int
  type modelTy  = 
    (Seq.seq (Type.lib_clause_clause), int)
end
module Lib_Logic_LogicFormula_Impl0
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.lib_formula_formula,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.lib_formula_formula,
  type modelTy = ModelTy0.modelTy
end
module Lib_Logic_LogicClause_Impl0_ModelTy
  use seq.Seq
  use Type
  type modelTy  = 
    Seq.seq (Type.lib_lit_lit)
end
module Lib_Logic_LogicClause_Impl0
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.lib_clause_clause,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.lib_clause_clause,
  type modelTy = ModelTy0.modelTy
end
module Lib_Logic_LogicFormula_Impl1_Invariant_Interface
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  predicate invariant' (self : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_Invariant
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicFormula_Impl0_Model_Interface as Model0
  predicate invariant' (self : Type.lib_formula_formula) = 
    FormulaInvariant0.formula_invariant (Model0.model self)
  axiom invariant'_spec : forall self : Type.lib_formula_formula . invariant' self = InvariantOld0.invariant_old self
end
module Lib_Logic_LogicFormula_Impl1_Invariant_Impl
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model1.model = Model2.model
  let rec ghost function invariant' (self : Type.lib_formula_formula) : bool
    ensures { result = InvariantOld0.invariant_old self }
    
   = 
    let a' = Model0.model self in FormulaInvariant0.formula_invariant a'
end
module Lib_Logic_LogicAssignments_Impl1_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_assignments_assignments) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicAssignments_Impl1_Invariant
  use Type
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.UInt8
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate invariant' (self : Type.lib_assignments_assignments) (f : Type.lib_formula_formula) = 
    UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length (Model0.model self) && UInt64.to_int (Type.lib_assignments_assignments_Assignments_1 self) <= UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> UInt8.to_int (Seq.get (Model0.model self) i) <= 3)
end
module Lib_Logic_LogicLit_Impl1_Sat_Interface
  use Type
  predicate sat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicLit_Impl1_Sat
  use Type
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) = 
    SatInner0.sat_inner self (Model0.model a)
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsPostForEach_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_assign_maintains_post_for_each (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsPostForEach
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_assign_maintains_post_for_each (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
   = 
    ()
  axiom lemma_assign_maintains_post_for_each_spec : forall f : Type.lib_formula_formula, a : Type.lib_assignments_assignments, lit : Type.lib_lit_lit . Unset0.unset (Seq.get (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> Invariant1.invariant' f -> Invariant2.invariant' a f -> (forall i : (int) . 0 <= i && i < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model0.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8))) && (forall i : (int) . 0 <= i && i < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model0.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8)))
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsPostForEach_Impl
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model3 with function Model0.model = Model1.model
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant3 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant3.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model3.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant2 with function Model0.model = Model0.model
  let rec ghost function lemma_assign_maintains_post_for_each (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    requires {Unset0.unset (Seq.get (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)))}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {Invariant1.invariant' f}
    requires {Invariant2.invariant' a f}
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model0.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8)) }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model0.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8)) }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsForEachToPost_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_assign_maintains_for_each_to_post (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsForEachToPost
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_assign_maintains_for_each_to_post (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
   = 
    ()
  axiom lemma_assign_maintains_for_each_to_post_spec : forall v : Seq.seq (Type.lib_trail_step), f : Type.lib_formula_formula, a : Type.lib_assignments_assignments, lit : Type.lib_lit_lit . (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model1.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8))) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model1.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8))) -> LongArePostUnitInner0.long_are_post_unit_inner v f (Model1.model a) -> Unset0.unset (Seq.get (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> CrefsInRange0.crefs_in_range v f -> TrailInvariant0.trail_invariant v f -> Invariant1.invariant' f -> Invariant2.invariant' a f -> LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8))
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsForEachToPost_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant5 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model3.model
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model3.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant2 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant4 with function Model0.model = Model0.model,
  function Model1.model = Model3.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant3 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl0_Model as Model4 with function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant5.invariant', function Model1.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model4.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model0.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  let rec ghost function lemma_assign_maintains_for_each_to_post (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    requires {forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model1.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8))}
    requires {forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model1.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8))}
    requires {LongArePostUnitInner0.long_are_post_unit_inner v f (Model1.model a)}
    requires {Unset0.unset (Seq.get (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)))}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {CrefsInRange0.crefs_in_range v f}
    requires {TrailInvariant0.trail_invariant v f}
    requires {Invariant1.invariant' f}
    requires {Invariant2.invariant' a f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8)) }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8)) }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsLongArePostUnit_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_assign_maintains_long_are_post_unit (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsLongArePostUnit
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LemmaAssignMaintainsForEachToPost_Interface as LemmaAssignMaintainsForEachToPost0 with function Model0.model = Model1.model,
  function Model1.model = Model0.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range,
  predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  axiom .
  clone Lib_Logic_LogicTrail_LemmaAssignMaintainsPostForEach_Interface as LemmaAssignMaintainsPostForEach0 with function Model0.model = Model0.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Model1.model = Model1.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  axiom .
  function lemma_assign_maintains_long_are_post_unit (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
   = 
    let _ = LemmaAssignMaintainsPostForEach0.lemma_assign_maintains_post_for_each f a lit in let _ = LemmaAssignMaintainsForEachToPost0.lemma_assign_maintains_for_each_to_post v f a lit in ()
  axiom lemma_assign_maintains_long_are_post_unit_spec : forall v : Seq.seq (Type.lib_trail_step), f : Type.lib_formula_formula, a : Type.lib_assignments_assignments, lit : Type.lib_lit_lit . LongArePostUnitInner0.long_are_post_unit_inner v f (Model0.model a) -> Unset0.unset (Seq.get (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> CrefsInRange0.crefs_in_range v f -> TrailInvariant0.trail_invariant v f -> Invariant1.invariant' f -> Invariant2.invariant' a f -> LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8))
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsLongArePostUnit_Impl
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model4.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant5 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model4.model
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant4 with function Model0.model = Model2.model,
  function Model1.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant3 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl0_Model as Model3 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant5.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model3.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant2 with function Model0.model = Model0.model
  clone Lib_Logic_LogicTrail_LemmaAssignMaintainsForEachToPost as LemmaAssignMaintainsForEachToPost0 with function Model0.model = Model2.model,
  function Model1.model = Model0.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range,
  predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaAssignMaintainsPostForEach as LemmaAssignMaintainsPostForEach0 with function Model0.model = Model0.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Model1.model = Model2.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  let rec ghost function lemma_assign_maintains_long_are_post_unit (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner v f (Model0.model a)}
    requires {Unset0.unset (Seq.get (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)))}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {CrefsInRange0.crefs_in_range v f}
    requires {TrailInvariant0.trail_invariant v f}
    requires {Invariant1.invariant' f}
    requires {Invariant2.invariant' a f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8)) }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8)) }
    
   = 
    let _ = LemmaAssignMaintainsPostForEach0.lemma_assign_maintains_post_for_each f a lit in let _ = LemmaAssignMaintainsForEachToPost0.lemma_assign_maintains_for_each_to_post v f a lit in ()
end
module CreusotContracts_Logic_Ghost_Impl0_Model_Interface
  type t   
  use Type
  function model (self : Type.creusotcontracts_logic_ghost_ghost t) : t
end
module CreusotContracts_Logic_Ghost_Impl0_Model
  type t   
  use Type
  function model (self : Type.creusotcontracts_logic_ghost_ghost t) : t
end
module CreusotContracts_Logic_Model_Impl1_ModelTy
  type t   
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  type modelTy  = 
    ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl1
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy2 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model as Model2 with type self = t, type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Impl1_Model as Model0 with type t = t, type ModelTy0.modelTy = ModelTy2.modelTy,
  function Model0.model = Model2.model
  clone CreusotContracts_Logic_Model_Impl1_ModelTy as ModelTy0 with type t = t, type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = borrowed t, function model = Model0.model,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = borrowed t,
  type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Logic_Ghost_Impl0_ModelTy
  type t   
  type modelTy  = 
    t
end
module CreusotContracts_Logic_Ghost_Impl0
  type t   
  use Type
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = t
  clone CreusotContracts_Logic_Ghost_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.creusotcontracts_logic_ghost_ghost t,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.creusotcontracts_logic_ghost_ghost t,
  type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Logic_Ghost_Impl1_Record_Interface
  type t   
  use prelude.Prelude
  use Type
  clone CreusotContracts_Logic_Ghost_Impl0_Model_Interface as Model0 with type t = t
  val record [@cfg:stackify] (a : t) : Type.creusotcontracts_logic_ghost_ghost t
    ensures { Model0.model result = a }
    
end
module CreusotContracts_Logic_Ghost_Impl1_Record
  type t   
  use prelude.Prelude
  use Type
  clone CreusotContracts_Logic_Ghost_Impl0_Model_Interface as Model0 with type t = t
  val record [@cfg:stackify] (a : t) : Type.creusotcontracts_logic_ghost_ghost t
    ensures { Model0.model result = a }
    
end
module Core_Ops_Index_Index_Output
  type self   
  type idx   
  type output   
end
module Core_Ops_Index_IndexMut_IndexMut_Interface
  type self   
  type idx   
  use prelude.Prelude
  clone Core_Ops_Index_Index_Output as Output0 with type self = self, type idx = idx
  val index_mut [@cfg:stackify] (self : borrowed self) (index : idx) : borrowed Output0.output
    requires {false}
    
end
module Core_Ops_Index_IndexMut_IndexMut
  type self   
  type idx   
  use prelude.Prelude
  clone Core_Ops_Index_Index_Output as Output0 with type self = self, type idx = idx
  val index_mut [@cfg:stackify] (self : borrowed self) (index : idx) : borrowed Output0.output
    requires {false}
    
end
module CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val index_mut [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (ix : usize) : borrowed t
    requires {UInt64.to_int ix < Seq.length (Model0.model ( * self))}
    ensures { Seq.length (Model0.model ( * self)) = Seq.length (Model0.model ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model0.model ( ^ self)) -> not (j = UInt64.to_int ix) -> Seq.get (Model0.model ( ^ self)) j = Seq.get (Model0.model ( * self)) j }
    ensures {  ^ result = Seq.get (Model0.model ( ^ self)) (UInt64.to_int ix) }
    ensures {  * result = Seq.get (Model1.model self) (UInt64.to_int ix) }
    
end
module CreusotContracts_Std1_Vec_Impl2_IndexMut
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val index_mut [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (ix : usize) : borrowed t
    requires {UInt64.to_int ix < Seq.length (Model0.model ( * self))}
    ensures { Seq.length (Model0.model ( * self)) = Seq.length (Model0.model ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model0.model ( ^ self)) -> not (j = UInt64.to_int ix) -> Seq.get (Model0.model ( ^ self)) j = Seq.get (Model0.model ( * self)) j }
    ensures {  ^ result = Seq.get (Model0.model ( ^ self)) (UInt64.to_int ix) }
    ensures {  * result = Seq.get (Model1.model self) (UInt64.to_int ix) }
    
end
module CreusotContracts_Std1_Vec_Impl3_Output
  type t   
  type output  = 
    t
end
module CreusotContracts_Std1_Vec_Impl2
  type t   
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl3_Output as Output0 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = t,
  function Model0.model = Model0.model, function Model1.model = Model1.model
  clone Core_Ops_Index_IndexMut_IndexMut_Interface as IndexMut1 with type self = Type.creusotcontracts_std1_vec_vec t,
  type idx = usize, val index_mut = IndexMut0.index_mut, type Output0.output = Output0.output
end
module Lib_Assignments_Impl0_SetAssignment_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.UInt8
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy0.modelTy
  val set_assignment [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) (_t : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step)) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model _t) _f (Model1.model self)}
    requires {Unset0.unset (Seq.get (Model1.model self) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)))}
    requires {TrailInvariant0.trail_invariant (Model0.model _t) _f}
    requires {Invariant0.invariant' _f}
    requires {Invariant1.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant2.invariant' ( * self) _f}
    ensures { Sat0.sat lit ( ^ self) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model self) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model2.model ( * self)) j = Seq.get (Model2.model ( ^ self)) j }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model _t) _f (Model2.model ( ^ self)) }
    ensures { Seq.length (Model2.model ( ^ self)) = Seq.length (Model1.model self) }
    ensures { UInt8.to_int (Seq.get (Model2.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 1 || UInt8.to_int (Seq.get (Model2.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 0 }
    ensures { Invariant2.invariant' ( ^ self) _f }
    
end
module Lib_Assignments_Impl0_SetAssignment
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use seq.Seq
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model8 with function Model0.model = Model9.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model3 with function Model0.model = Model7.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model8.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model8.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model2 with type t = borrowed (Type.lib_assignments_assignments)
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant5 with function Model0.model = Model5.model,
  function Model1.model = Model8.model
  clone Lib_Logic_LogicFormula_Impl0_Model as Model6 with function Model0.model = Model5.model
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model5.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model8.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model8.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model8.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model6.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant3 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Invariant1.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicTrail_LemmaAssignMaintainsForEachToPost as LemmaAssignMaintainsForEachToPost0 with function Model0.model = Model5.model,
  function Model1.model = Model3.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant1.invariant',
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range,
  predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaAssignMaintainsPostForEach as LemmaAssignMaintainsPostForEach0 with function Model0.model = Model3.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Model1.model = Model5.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaAssignMaintainsLongArePostUnit as LemmaAssignMaintainsLongArePostUnit0 with function Model0.model = Model3.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant1.invariant',
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range,
  predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function LemmaAssignMaintainsPostForEach0.lemma_assign_maintains_post_for_each = LemmaAssignMaintainsPostForEach0.lemma_assign_maintains_post_for_each,
  function LemmaAssignMaintainsForEachToPost0.lemma_assign_maintains_for_each_to_post = LemmaAssignMaintainsForEachToPost0.lemma_assign_maintains_for_each_to_post,
  function Model1.model = Model5.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_trail_step
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve9 with type t = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve6 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_assignments_assignments))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = borrowed (Type.lib_assignments_assignments)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Model_Impl1_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model7.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = uint8,
  function Model0.model = Model7.model, function Model1.model = Model10.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_assignments_assignments),
  function Model0.model = Model2.model
  let rec cfg set_assignment [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) (_t : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step)) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model _t) _f (Model1.model self)}
    requires {Unset0.unset (Seq.get (Model1.model self) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)))}
    requires {TrailInvariant0.trail_invariant (Model0.model _t) _f}
    requires {Invariant0.invariant' _f}
    requires {Invariant1.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant2.invariant' ( * self) _f}
    ensures { Sat0.sat lit ( ^ self) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model self) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model3.model ( * self)) j = Seq.get (Model3.model ( ^ self)) j }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model _t) _f (Model3.model ( ^ self)) }
    ensures { Seq.length (Model3.model ( ^ self)) = Seq.length (Model1.model self) }
    ensures { UInt8.to_int (Seq.get (Model3.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 1 || UInt8.to_int (Seq.get (Model3.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 0 }
    ensures { Invariant2.invariant' ( ^ self) _f }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_assignments_assignments);
  var lit_2 : Type.lib_lit_lit;
  var _f_3 : Type.lib_formula_formula;
  var _t_4 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var old_self_5 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_assignments_assignments));
  var _6 : borrowed (Type.lib_assignments_assignments);
  var _7 : borrowed (Type.lib_assignments_assignments);
  var _8 : ();
  var _9 : ();
  var _10 : bool;
  var _11 : borrowed uint8;
  var _12 : borrowed (Type.creusotcontracts_std1_vec_vec uint8);
  var _13 : usize;
  var _14 : ();
  var _15 : borrowed uint8;
  var _16 : borrowed (Type.creusotcontracts_std1_vec_vec uint8);
  var _17 : usize;
  var _18 : ();
  var _19 : ();
  var _20 : ();
  var _21 : ();
  {
    self_1 <- self;
    lit_2 <- lit;
    _f_3 <- _f;
    _t_4 <- _t;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _f_3 };
    assume { Resolve1.resolve _t_4 };
    _7 <- self_1;
    _6 <- _7;
    assume { Resolve2.resolve _7 };
    old_self_5 <- Record0.record _6;
    goto BB1
  }
  BB1 {
    assume { Resolve3.resolve old_self_5 };
    assert { let _ = LemmaAssignMaintainsLongArePostUnit0.lemma_assign_maintains_long_are_post_unit (Model0.model _t_4) _f_3 ( * self_1) lit_2 in true };
    _8 <- ();
    assume { Resolve4.resolve _8 };
    assume { Resolve5.resolve _10 };
    _10 <- Type.lib_lit_lit_Lit_polarity lit_2;
    switch (_10)
      | False -> goto BB4
      | _ -> goto BB2
      end
  }
  BB2 {
    _12 <- borrow_mut (Type.lib_assignments_assignments_Assignments_0 ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Assignments_Assignments a b =  * self_1 in Type.Lib_Assignments_Assignments ( ^ _12) b) };
    assume { Resolve6.resolve self_1 };
    assume { Resolve7.resolve _13 };
    _13 <- Type.lib_lit_lit_Lit_idx lit_2;
    assume { Resolve8.resolve lit_2 };
    _11 <- IndexMut0.index_mut _12 _13;
    goto BB3
  }
  BB3 {
    _11 <- { _11 with current = (1 : uint8) };
    assume { Resolve9.resolve _11 };
    assert { Seq.(==) (Model1.model self_1) (Seq.set (Model1.model (Model2.model old_self_5)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit_2)) (1 : uint8)) };
    _14 <- ();
    assume { Resolve4.resolve _14 };
    _9 <- ();
    assume { Resolve4.resolve _9 };
    goto BB6
  }
  BB4 {
    _16 <- borrow_mut (Type.lib_assignments_assignments_Assignments_0 ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Assignments_Assignments a b =  * self_1 in Type.Lib_Assignments_Assignments ( ^ _16) b) };
    assume { Resolve6.resolve self_1 };
    assume { Resolve7.resolve _17 };
    _17 <- Type.lib_lit_lit_Lit_idx lit_2;
    assume { Resolve8.resolve lit_2 };
    _15 <- IndexMut0.index_mut _16 _17;
    goto BB5
  }
  BB5 {
    _15 <- { _15 with current = (0 : uint8) };
    assume { Resolve9.resolve _15 };
    assert { Seq.(==) (Model1.model self_1) (Seq.set (Model1.model (Model2.model old_self_5)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit_2)) (0 : uint8)) };
    _18 <- ();
    assume { Resolve4.resolve _18 };
    _9 <- ();
    assume { Resolve4.resolve _9 };
    goto BB6
  }
  BB6 {
    assert { let _ = LemmaAssignMaintainsLongArePostUnit0.lemma_assign_maintains_long_are_post_unit (Model0.model _t_4) _f_3 ( * Model2.model old_self_5) lit_2 in true };
    _19 <- ();
    assume { Resolve4.resolve _19 };
    assert {  ^ Model2.model old_self_5 =  ^ self_1 };
    _20 <- ();
    assume { Resolve4.resolve _20 };
    assert { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model _t_4) _f_3 (Model1.model self_1) };
    _21 <- ();
    assume { Resolve4.resolve _21 };
    _0 <- ();
    return _0
  }
  
end
module CreusotContracts_Std1_Vec_Impl1_New_Interface
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val new [@cfg:stackify] () : Type.creusotcontracts_std1_vec_vec t
    ensures { Seq.length (Model0.model result) = 0 }
    
end
module CreusotContracts_Std1_Vec_Impl1_New
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val new [@cfg:stackify] () : Type.creusotcontracts_std1_vec_vec t
    ensures { Seq.length (Model0.model result) = 0 }
    
end
module CreusotContracts_Std1_Vec_Impl1_Push_Interface
  type t   
  use seq.Seq
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val push [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (v : t) : ()
    ensures { Model0.model ( ^ self) = Seq.snoc (Model1.model self) v }
    
end
module CreusotContracts_Std1_Vec_Impl1_Push
  type t   
  use seq.Seq
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val push [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (v : t) : ()
    ensures { Model0.model ( ^ self) = Seq.snoc (Model1.model self) v }
    
end
module CreusotContracts_Std1_Vec_Impl5_Resolve_Interface
  type t   
  use Type
  predicate resolve (self : Type.creusotcontracts_std1_vec_vec t)
end
module CreusotContracts_Std1_Vec_Impl5_Resolve
  type t   
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface as Resolve0 with type self = t
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  predicate resolve (self : Type.creusotcontracts_std1_vec_vec t) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> Resolve0.resolve (Seq.get (Model0.model self) i)
end
module CreusotContracts_Std1_Vec_Impl5
  type t   
  use Type
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve2 with type self = t
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t
  clone CreusotContracts_Std1_Vec_Impl5_Resolve as Resolve0 with type t = t, function Model0.model = Model0.model,
  predicate Resolve0.resolve = Resolve2.resolve
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = Type.creusotcontracts_std1_vec_vec t,
  predicate resolve = Resolve0.resolve
end
module Lib_Assignments_Impl0_New_Interface
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_assignments_assignments
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result f }
    
end
module Lib_Assignments_Impl0_New
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.UInt8
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant2.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model1.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model2 with function Model0.model = Model0.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant1 with function Model0.model = Model2.model
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = ()
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Logic_Model_Impl1_Model as Model6 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = uint8,
  function Model0.model = Model0.model, function Model1.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl5_Resolve as Resolve4 with type t = uint8, function Model0.model = Model0.model,
  predicate Resolve0.resolve = Resolve1.resolve
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New0 with type t = uint8, function Model0.model = Model0.model
  let rec cfg new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_assignments_assignments
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result f }
    
   = 
  var _0 : Type.lib_assignments_assignments;
  var f_1 : Type.lib_formula_formula;
  var assign_2 : Type.creusotcontracts_std1_vec_vec uint8;
  var i_3 : usize;
  var _4 : ();
  var _5 : ();
  var _6 : bool;
  var _7 : usize;
  var _8 : usize;
  var n_9 : uint8;
  var _10 : ();
  var _11 : borrowed (Type.creusotcontracts_std1_vec_vec uint8);
  var _12 : uint8;
  var _13 : ();
  var _14 : ();
  var _15 : ();
  var _16 : Type.creusotcontracts_std1_vec_vec uint8;
  {
    f_1 <- f;
    goto BB0
  }
  BB0 {
    assign_2 <- New0.new ();
    goto BB1
  }
  BB1 {
    i_3 <- (0 : usize);
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    invariant loop_invariant { 0 <= UInt64.to_int i_3 && UInt64.to_int i_3 <= UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    invariant length_invariant { Seq.length (Model0.model assign_2) = UInt64.to_int i_3 };
    invariant all_less { forall j : (int) . 0 <= j && j < UInt64.to_int i_3 -> UInt8.to_int (Seq.get (Model0.model assign_2) j) <= 3 };
    assume { Resolve0.resolve _7 };
    _7 <- i_3;
    assume { Resolve0.resolve _8 };
    _8 <- Type.lib_formula_formula_Formula_num_vars f_1;
    _6 <- _7 < _8;
    switch (_6)
      | False -> goto BB7
      | _ -> goto BB5
      end
  }
  BB5 {
    n_9 <- (2 : uint8);
    _11 <- borrow_mut assign_2;
    assign_2 <-  ^ _11;
    assume { Resolve1.resolve _12 };
    _12 <- n_9;
    assume { Resolve1.resolve n_9 };
    _10 <- Push0.push _11 _12;
    goto BB6
  }
  BB6 {
    i_3 <- i_3 + (1 : usize);
    _5 <- ();
    assume { Resolve2.resolve _5 };
    goto BB4
  }
  BB7 {
    assume { Resolve3.resolve f_1 };
    assume { Resolve0.resolve i_3 };
    _4 <- ();
    assume { Resolve2.resolve _4 };
    assume { Resolve4.resolve _16 };
    _16 <- assign_2;
    _0 <- Type.Lib_Assignments_Assignments _16 (0 : usize);
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module Lib_Logic_LogicDecision_Impl0_Invariant_Interface
  use Type
  use mach.int.Int
  predicate invariant' (self : Type.lib_decision_decisions) (n : int)
end
module Lib_Logic_LogicDecision_Impl0_Invariant
  use Type
  use mach.int.Int
  use seq.Seq
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = usize
  predicate invariant' (self : Type.lib_decision_decisions) (n : int) = 
    Seq.length (Model0.model (Type.lib_decision_decisions_Decisions_lit_order self)) = n && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_decision_decisions_Decisions_lit_order self)) -> UInt64.to_int (Seq.get (Model0.model (Type.lib_decision_decisions_Decisions_lit_order self)) i) < n)
end
module Lib_Logic_LogicAssignments_Impl1_Complete_Interface
  use Type
  predicate complete (self : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicAssignments_Impl1_Complete
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate complete (self : Type.lib_assignments_assignments) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> not (Unset0.unset (Seq.get (Model0.model self) i))
end
module Core_Ops_Index_Index_Index_Interface
  type self   
  type idx   
  use prelude.Prelude
  clone Core_Ops_Index_Index_Output as Output0 with type self = self, type idx = idx
  val index [@cfg:stackify] (self : self) (index : idx) : Output0.output
    requires {false}
    
end
module Core_Ops_Index_Index_Index
  type self   
  type idx   
  use prelude.Prelude
  clone Core_Ops_Index_Index_Output as Output0 with type self = self, type idx = idx
  val index [@cfg:stackify] (self : self) (index : idx) : Output0.output
    requires {false}
    
end
module CreusotContracts_Std1_Vec_Impl3_Index_Interface
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val index [@cfg:stackify] (self : Type.creusotcontracts_std1_vec_vec t) (ix : usize) : t
    requires {UInt64.to_int ix < Seq.length (Model0.model self)}
    ensures { result = Seq.get (Model0.model self) (UInt64.to_int ix) }
    
end
module CreusotContracts_Std1_Vec_Impl3_Index
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val index [@cfg:stackify] (self : Type.creusotcontracts_std1_vec_vec t) (ix : usize) : t
    requires {UInt64.to_int ix < Seq.length (Model0.model self)}
    ensures { result = Seq.get (Model0.model self) (UInt64.to_int ix) }
    
end
module CreusotContracts_Std1_Vec_Impl3
  type t   
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = t, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl3_Output as Output0 with type t = t
  clone Core_Ops_Index_Index_Index_Interface as Index1 with type self = Type.creusotcontracts_std1_vec_vec t,
  type idx = usize, val index = Index0.index, type Output0.output = Output0.output
  clone Core_Ops_Index_Index_Output as Output1 with type self = Type.creusotcontracts_std1_vec_vec t, type idx = usize,
  type output = Output0.output
end
module Lib_Assignments_Impl0_FindUnassigned_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Logic_LogicAssignments_Impl1_Complete_Interface as Complete0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicDecision_Impl0_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val find_unassigned [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (_f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Invariant0.invariant' d (Seq.length (Model0.model self))}
    requires {Invariant1.invariant' ( * self) _f}
    ensures { Model0.model self = Model1.model ( ^ self) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some res -> UInt64.to_int res < Seq.length (Model0.model self) && Unset0.unset (Seq.get (Model0.model self) (UInt64.to_int res))
      | Type.Core_Option_Option_None -> Complete0.complete ( * self)
      end }
    ensures { Invariant1.invariant' ( ^ self) _f }
    
end
module Lib_Assignments_Impl0_FindUnassigned
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant1 with function Model0.model = Model2.model
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_Impl1_Complete as Complete0 with function Model0.model = Model2.model,
  predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = usize
  clone Lib_Logic_LogicDecision_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.lib_decision_decisions
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve5 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Model_Impl0_Model as Model5 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len1 with type t = uint8, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = uint8,
  function Model0.model = Model5.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model4 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = usize,
  function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = usize, function Model0.model = Model4.model
  let rec cfg find_unassigned [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (_f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Invariant0.invariant' d (Seq.length (Model1.model self))}
    requires {Invariant1.invariant' ( * self) _f}
    ensures { Model1.model self = Model2.model ( ^ self) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some res -> UInt64.to_int res < Seq.length (Model1.model self) && Unset0.unset (Seq.get (Model1.model self) (UInt64.to_int res))
      | Type.Core_Option_Option_None -> Complete0.complete ( * self)
      end }
    ensures { Invariant1.invariant' ( ^ self) _f }
    
   = 
  var _0 : Type.core_option_option usize;
  var self_1 : borrowed (Type.lib_assignments_assignments);
  var d_2 : Type.lib_decision_decisions;
  var _f_3 : Type.lib_formula_formula;
  var i_4 : usize;
  var _5 : ();
  var _6 : ();
  var _7 : bool;
  var _8 : usize;
  var _9 : usize;
  var _10 : Type.creusotcontracts_std1_vec_vec usize;
  var curr_11 : uint8;
  var _12 : uint8;
  var _13 : Type.creusotcontracts_std1_vec_vec uint8;
  var _14 : usize;
  var _15 : usize;
  var _16 : Type.creusotcontracts_std1_vec_vec usize;
  var _17 : usize;
  var _18 : ();
  var _19 : bool;
  var _20 : uint8;
  var _21 : ();
  var _22 : usize;
  var _23 : usize;
  var _24 : usize;
  var _25 : Type.creusotcontracts_std1_vec_vec usize;
  var _26 : usize;
  var _27 : ();
  var _28 : ();
  var _29 : ();
  var _30 : ();
  var _31 : bool;
  var _32 : usize;
  var _33 : usize;
  var _34 : Type.creusotcontracts_std1_vec_vec uint8;
  var _35 : ();
  var _36 : bool;
  var _37 : uint8;
  var _38 : uint8;
  var _39 : Type.creusotcontracts_std1_vec_vec uint8;
  var _40 : usize;
  var _41 : ();
  var _42 : usize;
  var _43 : ();
  var _44 : ();
  var _45 : ();
  {
    self_1 <- self;
    d_2 <- d;
    _f_3 <- _f;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _f_3 };
    assume { Resolve1.resolve i_4 };
    i_4 <- Type.lib_assignments_assignments_Assignments_1 ( * self_1);
    goto BB1
  }
  BB1 {
    invariant i_bound { UInt64.to_int i_4 <= Seq.length (Model0.model (Type.lib_decision_decisions_Decisions_lit_order d_2)) };
    assume { Resolve1.resolve _8 };
    _8 <- i_4;
    _10 <- Type.lib_decision_decisions_Decisions_lit_order d_2;
    _9 <- Len0.len _10;
    goto BB2
  }
  BB2 {
    _7 <- _8 < _9;
    switch (_7)
      | False -> goto BB9
      | _ -> goto BB3
      end
  }
  BB3 {
    _13 <- Type.lib_assignments_assignments_Assignments_0 ( * self_1);
    _16 <- Type.lib_decision_decisions_Decisions_lit_order d_2;
    assume { Resolve1.resolve _17 };
    _17 <- i_4;
    _15 <- Index0.index _16 _17;
    goto BB4
  }
  BB4 {
    assume { Resolve1.resolve _14 };
    _14 <- _15;
    assume { Resolve2.resolve _15 };
    _12 <- Index1.index _13 _14;
    goto BB5
  }
  BB5 {
    assume { Resolve3.resolve curr_11 };
    curr_11 <- _12;
    assume { Resolve4.resolve _12 };
    assume { Resolve3.resolve _20 };
    _20 <- curr_11;
    assume { Resolve3.resolve curr_11 };
    _19 <- _20 >= (2 : uint8);
    switch (_19)
      | False -> goto BB8
      | _ -> goto BB6
      end
  }
  BB6 {
    assume { Resolve1.resolve _22 };
    _22 <- i_4;
    self_1 <- { self_1 with current = (let Type.Lib_Assignments_Assignments a b =  * self_1 in Type.Lib_Assignments_Assignments a (_22 + (1 : usize))) };
    assume { Resolve5.resolve self_1 };
    _25 <- Type.lib_decision_decisions_Decisions_lit_order d_2;
    assume { Resolve6.resolve d_2 };
    assume { Resolve1.resolve _26 };
    _26 <- i_4;
    assume { Resolve1.resolve i_4 };
    _24 <- Index0.index _25 _26;
    goto BB7
  }
  BB7 {
    assume { Resolve1.resolve _23 };
    _23 <- _24;
    assume { Resolve2.resolve _24 };
    _0 <- Type.Core_Option_Option_Some _23;
    goto BB17
  }
  BB8 {
    _18 <- ();
    assume { Resolve7.resolve _18 };
    i_4 <- i_4 + (1 : usize);
    _6 <- ();
    assume { Resolve7.resolve _6 };
    goto BB1
  }
  BB9 {
    assume { Resolve6.resolve d_2 };
    assume { Resolve1.resolve i_4 };
    _5 <- ();
    assume { Resolve7.resolve _5 };
    i_4 <- (0 : usize);
    goto BB10
  }
  BB10 {
    invariant prev { forall j : (int) . 0 <= j && j < UInt64.to_int i_4 -> not (Unset0.unset (Seq.get (Model1.model self_1) j)) };
    assume { Resolve1.resolve _32 };
    _32 <- i_4;
    _34 <- Type.lib_assignments_assignments_Assignments_0 ( * self_1);
    _33 <- Len1.len _34;
    goto BB11
  }
  BB11 {
    _31 <- _32 < _33;
    switch (_31)
      | False -> goto BB16
      | _ -> goto BB12
      end
  }
  BB12 {
    _39 <- Type.lib_assignments_assignments_Assignments_0 ( * self_1);
    assume { Resolve1.resolve _40 };
    _40 <- i_4;
    _38 <- Index1.index _39 _40;
    goto BB13
  }
  BB13 {
    assume { Resolve3.resolve _37 };
    _37 <- _38;
    assume { Resolve4.resolve _38 };
    _36 <- _37 >= (2 : uint8);
    switch (_36)
      | False -> goto BB15
      | _ -> goto BB14
      end
  }
  BB14 {
    assume { Resolve5.resolve self_1 };
    assume { Resolve1.resolve _42 };
    _42 <- i_4;
    assume { Resolve1.resolve i_4 };
    _0 <- Type.Core_Option_Option_Some _42;
    goto BB17
  }
  BB15 {
    _35 <- ();
    assume { Resolve7.resolve _35 };
    i_4 <- i_4 + (1 : usize);
    _6 <- ();
    assume { Resolve7.resolve _6 };
    goto BB10
  }
  BB16 {
    assume { Resolve5.resolve self_1 };
    assume { Resolve1.resolve i_4 };
    _30 <- ();
    assume { Resolve7.resolve _30 };
    _0 <- Type.Core_Option_Option_None;
    goto BB18
  }
  BB17 {
    goto BB18
  }
  BB18 {
    return _0
  }
  
end
module Lib_Clause_Impl0_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.lib_clause_clause) : Type.lib_clause_clause
    ensures { result = self }
    
end
module Lib_Clause_Impl0_Clone
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.lib_clause_clause) : Type.lib_clause_clause
    ensures { result = self }
    
end
module Lib_Clause_Impl1_ClauseFromVec_Interface
  use prelude.Prelude
  use Type
  val clause_from_vec [@cfg:stackify] (vec : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : Type.lib_clause_clause
    
end
module Lib_Clause_Impl1_ClauseFromVec
  use prelude.Prelude
  use Type
  val clause_from_vec [@cfg:stackify] (vec : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : Type.lib_clause_clause
    
end
module Lib_Logic_LogicClause_Impl2_VarsInRange_Interface
  use Type
  use mach.int.Int
  predicate vars_in_range (self : Type.lib_clause_clause) (n : int)
end
module Lib_Logic_LogicClause_Impl2_VarsInRange
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate vars_in_range (self : Type.lib_clause_clause) (n : int) = 
    VarsInRangeInner0.vars_in_range_inner (Model0.model self) n
end
module Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes_Interface
  use Type
  predicate no_duplicate_indexes (self : Type.lib_clause_clause)
end
module Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate no_duplicate_indexes (self : Type.lib_clause_clause) = 
    NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model0.model self)
end
module Lib_Logic_LogicClause_Impl2_InvariantUnaryOk_Interface
  use Type
  use mach.int.Int
  predicate invariant_unary_ok (self : Type.lib_clause_clause) (n : int)
end
module Lib_Logic_LogicClause_Impl2_InvariantUnaryOk
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes_Interface as NoDuplicateIndexes0
  clone Lib_Logic_LogicClause_Impl2_VarsInRange_Interface as VarsInRange0
  predicate invariant_unary_ok (self : Type.lib_clause_clause) (n : int) = 
    VarsInRange0.vars_in_range self n && NoDuplicateIndexes0.no_duplicate_indexes self
end
module CreusotContracts_Std1_Vec_Impl1_Swap_Interface
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use seq.Permut
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val swap [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (i : usize) (j : usize) : ()
    requires {UInt64.to_int j < Seq.length (Model0.model self)}
    requires {UInt64.to_int i < Seq.length (Model0.model self)}
    ensures { Permut.exchange (Model1.model ( ^ self)) (Model1.model ( * self)) (UInt64.to_int i) (UInt64.to_int j) }
    
end
module CreusotContracts_Std1_Vec_Impl1_Swap
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use seq.Permut
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val swap [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (i : usize) (j : usize) : ()
    requires {UInt64.to_int j < Seq.length (Model0.model self)}
    requires {UInt64.to_int i < Seq.length (Model0.model self)}
    ensures { Permut.exchange (Model1.model ( ^ self)) (Model1.model ( * self)) (UInt64.to_int i) (UInt64.to_int j) }
    
end
module Lib_Clause_Impl1_MoveToEnd_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model2
  clone Lib_Logic_LogicClause_Impl2_InvariantUnaryOk_Interface as InvariantUnaryOk0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_lit_lit
  val move_to_end [@cfg:stackify] (self : borrowed (Type.lib_clause_clause)) (idx : usize) (_f : Type.lib_formula_formula) : ()
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( * self)))}
    requires {Seq.length (Model1.model self) > 0}
    requires {InvariantUnaryOk0.invariant_unary_ok ( * self) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    ensures { Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( ^ self))) = Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( * self))) }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( * self))) -> (exists j : (int) . 0 <= j && j < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( ^ self))) && Seq.get (Model2.model ( ^ self)) i = Seq.get (Model1.model self) j) }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( ^ self))) -> (exists j : (int) . 0 <= j && j < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( * self))) && Seq.get (Model2.model ( ^ self)) i = Seq.get (Model1.model self) j) }
    ensures { InvariantUnaryOk0.invariant_unary_ok ( ^ self) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    
end
module Lib_Clause_Impl1_MoveToEnd
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model3.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model3.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_InvariantUnaryOk as InvariantUnaryOk0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone CreusotContracts_Logic_Model_Impl1_Model as Model2 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = borrowed (Type.lib_clause_clause)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_clause_clause))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = borrowed (Type.lib_clause_clause)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Model_Impl1_Model as Model5 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl1_Swap_Interface as Swap0 with type t = Type.lib_lit_lit,
  function Model0.model = Model5.model, function Model1.model = Model1.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model4 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_lit_lit,
  function Model0.model = Model4.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_clause_clause),
  function Model0.model = Model0.model
  let rec cfg move_to_end [@cfg:stackify] (self : borrowed (Type.lib_clause_clause)) (idx : usize) (_f : Type.lib_formula_formula) : ()
    requires {UInt64.to_int idx < Seq.length (Model1.model (Type.lib_clause_clause_Clause_rest ( * self)))}
    requires {Seq.length (Model2.model self) > 0}
    requires {InvariantUnaryOk0.invariant_unary_ok ( * self) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    ensures { Seq.length (Model1.model (Type.lib_clause_clause_Clause_rest ( ^ self))) = Seq.length (Model1.model (Type.lib_clause_clause_Clause_rest ( * self))) }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model1.model (Type.lib_clause_clause_Clause_rest ( * self))) -> (exists j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_clause_clause_Clause_rest ( ^ self))) && Seq.get (Model3.model ( ^ self)) i = Seq.get (Model2.model self) j) }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model1.model (Type.lib_clause_clause_Clause_rest ( ^ self))) -> (exists j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_clause_clause_Clause_rest ( * self))) && Seq.get (Model3.model ( ^ self)) i = Seq.get (Model2.model self) j) }
    ensures { InvariantUnaryOk0.invariant_unary_ok ( ^ self) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_clause_clause);
  var idx_2 : usize;
  var _f_3 : Type.lib_formula_formula;
  var old_self_4 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_clause_clause));
  var _5 : borrowed (Type.lib_clause_clause);
  var _6 : borrowed (Type.lib_clause_clause);
  var end'_7 : usize;
  var _8 : usize;
  var _9 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _10 : ();
  var _11 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _12 : usize;
  var _13 : usize;
  var _14 : ();
  {
    self_1 <- self;
    idx_2 <- idx;
    _f_3 <- _f;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _f_3 };
    _6 <- self_1;
    _5 <- _6;
    assume { Resolve1.resolve _6 };
    old_self_4 <- Record0.record _5;
    goto BB1
  }
  BB1 {
    assume { Resolve2.resolve old_self_4 };
    _9 <- Type.lib_clause_clause_Clause_rest ( * self_1);
    _8 <- Len0.len _9;
    goto BB2
  }
  BB2 {
    end'_7 <- _8 - (1 : usize);
    _11 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Clause_Clause a =  * self_1 in Type.Lib_Clause_Clause ( ^ _11)) };
    assume { Resolve3.resolve _12 };
    _12 <- idx_2;
    assume { Resolve3.resolve idx_2 };
    assume { Resolve3.resolve _13 };
    _13 <- end'_7;
    assume { Resolve3.resolve end'_7 };
    _10 <- Swap0.swap _11 _12 _13;
    goto BB3
  }
  BB3 {
    assume { Resolve4.resolve self_1 };
    assert {  ^ Model0.model old_self_4 =  ^ self_1 };
    _14 <- ();
    assume { Resolve5.resolve _14 };
    _0 <- ();
    return _0
  }
  
end
module CreusotContracts_Std1_Vec_Impl1_Pop_Interface
  type t   
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val pop [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) : Type.core_option_option t
    ensures { match (result) with
      | Type.Core_Option_Option_Some t -> Model0.model self = Seq.snoc (Model1.model ( ^ self)) t
      | Type.Core_Option_Option_None -> Seq.length (Model0.model self) = Seq.length (Model1.model ( ^ self)) && Seq.length (Model0.model self) = 0
      end }
    
end
module CreusotContracts_Std1_Vec_Impl1_Pop
  type t   
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val pop [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) : Type.core_option_option t
    ensures { match (result) with
      | Type.Core_Option_Option_Some t -> Model0.model self = Seq.snoc (Model1.model ( ^ self)) t
      | Type.Core_Option_Option_None -> Seq.length (Model0.model self) = Seq.length (Model1.model ( ^ self)) && Seq.length (Model0.model self) = 0
      end }
    
end
module Lib_Clause_Impl1_RemoveFromClause_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model2
  clone Lib_Logic_LogicClause_Impl2_InvariantUnaryOk_Interface as InvariantUnaryOk0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_lit_lit
  val remove_from_clause [@cfg:stackify] (self : borrowed (Type.lib_clause_clause)) (idx : usize) (_f : Type.lib_formula_formula) : ()
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( * self)))}
    requires {Seq.length (Model1.model self) > 0}
    requires {InvariantUnaryOk0.invariant_unary_ok ( * self) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    ensures { Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( ^ self))) + 1 = Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( * self))) }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( ^ self))) -> (exists j : (int) . 0 <= j && j < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( * self))) && Seq.get (Model2.model ( ^ self)) i = Seq.get (Model1.model self) j) }
    ensures { InvariantUnaryOk0.invariant_unary_ok ( ^ self) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    
end
module Lib_Clause_Impl1_RemoveFromClause
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model2.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model2.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_InvariantUnaryOk as InvariantUnaryOk0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Logic_Model_Impl1_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl1_Pop_Interface as Pop0 with type t = Type.lib_lit_lit,
  function Model0.model = Model3.model, function Model1.model = Model0.model
  clone Lib_Clause_Impl1_MoveToEnd_Interface as MoveToEnd0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate InvariantUnaryOk0.invariant_unary_ok = InvariantUnaryOk0.invariant_unary_ok,
  function Model2.model = Model2.model
  let rec cfg remove_from_clause [@cfg:stackify] (self : borrowed (Type.lib_clause_clause)) (idx : usize) (_f : Type.lib_formula_formula) : ()
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( * self)))}
    requires {Seq.length (Model1.model self) > 0}
    requires {InvariantUnaryOk0.invariant_unary_ok ( * self) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    ensures { Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( ^ self))) + 1 = Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( * self))) }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( ^ self))) -> (exists j : (int) . 0 <= j && j < Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest ( * self))) && Seq.get (Model2.model ( ^ self)) i = Seq.get (Model1.model self) j) }
    ensures { InvariantUnaryOk0.invariant_unary_ok ( ^ self) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_clause_clause);
  var idx_2 : usize;
  var _f_3 : Type.lib_formula_formula;
  var _4 : ();
  var _5 : borrowed (Type.lib_clause_clause);
  var _6 : usize;
  var _7 : Type.lib_formula_formula;
  var _8 : Type.core_option_option (Type.lib_lit_lit);
  var _9 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  {
    self_1 <- self;
    idx_2 <- idx;
    _f_3 <- _f;
    goto BB0
  }
  BB0 {
    _5 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _5) };
    assume { Resolve0.resolve _6 };
    _6 <- idx_2;
    assume { Resolve0.resolve idx_2 };
    _7 <- _f_3;
    assume { Resolve1.resolve _f_3 };
    _4 <- MoveToEnd0.move_to_end _5 _6 _7;
    goto BB1
  }
  BB1 {
    _9 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Clause_Clause a =  * self_1 in Type.Lib_Clause_Clause ( ^ _9)) };
    _8 <- Pop0.pop _9;
    goto BB2
  }
  BB2 {
    assume { Resolve2.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Lib_ConflictAnalysis_IdxIn_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy0.modelTy
  val idx_in [@cfg:stackify] (v : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) (idx : usize) : bool
    ensures { result = (exists i : (int) . 0 <= i && i < Seq.length (Model0.model v) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model v) i)) = UInt64.to_int idx) }
    
end
module Lib_ConflictAnalysis_IdxIn
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_lit_lit,
  function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_lit_lit,
  function Model0.model = Model0.model
  let rec cfg idx_in [@cfg:stackify] (v : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) (idx : usize) : bool
    ensures { result = (exists i : (int) . 0 <= i && i < Seq.length (Model0.model v) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model v) i)) = UInt64.to_int idx) }
    
   = 
  var _0 : bool;
  var v_1 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var idx_2 : usize;
  var i_3 : usize;
  var _4 : ();
  var _5 : ();
  var _6 : bool;
  var _7 : usize;
  var _8 : usize;
  var _9 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var lit_10 : Type.lib_lit_lit;
  var _11 : Type.lib_lit_lit;
  var _12 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _13 : usize;
  var _14 : ();
  var _15 : bool;
  var _16 : usize;
  var _17 : usize;
  var _18 : ();
  var _19 : ();
  var _20 : ();
  var _21 : ();
  {
    v_1 <- v;
    idx_2 <- idx;
    goto BB0
  }
  BB0 {
    i_3 <- (0 : usize);
    goto BB1
  }
  BB1 {
    invariant i_less { 0 <= UInt64.to_int i_3 && UInt64.to_int i_3 <= Seq.length (Model0.model v_1) };
    invariant not_idx { forall j : (int) . 0 <= j && j < UInt64.to_int i_3 -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model v_1) j)) <> UInt64.to_int idx_2 };
    assume { Resolve0.resolve _7 };
    _7 <- i_3;
    _9 <- v_1;
    _8 <- Len0.len _9;
    goto BB2
  }
  BB2 {
    _6 <- _7 < _8;
    switch (_6)
      | False -> goto BB7
      | _ -> goto BB3
      end
  }
  BB3 {
    _12 <- v_1;
    assume { Resolve0.resolve _13 };
    _13 <- i_3;
    _11 <- Index0.index _12 _13;
    goto BB4
  }
  BB4 {
    lit_10 <- _11;
    assume { Resolve1.resolve _11 };
    assume { Resolve0.resolve _16 };
    _16 <- Type.lib_lit_lit_Lit_idx lit_10;
    assume { Resolve1.resolve lit_10 };
    assume { Resolve0.resolve _17 };
    _17 <- idx_2;
    _15 <- _16 = _17;
    switch (_15)
      | False -> goto BB6
      | _ -> goto BB5
      end
  }
  BB5 {
    assume { Resolve2.resolve v_1 };
    assume { Resolve0.resolve idx_2 };
    assume { Resolve0.resolve i_3 };
    _0 <- true;
    goto BB8
  }
  BB6 {
    _14 <- ();
    assume { Resolve3.resolve _14 };
    i_3 <- i_3 + (1 : usize);
    _5 <- ();
    assume { Resolve3.resolve _5 };
    goto BB1
  }
  BB7 {
    assume { Resolve2.resolve v_1 };
    assume { Resolve0.resolve idx_2 };
    assume { Resolve0.resolve i_3 };
    _4 <- ();
    assume { Resolve3.resolve _4 };
    _0 <- false;
    goto BB8
  }
  BB8 {
    return _0
  }
  
end
module Lib_Logic_LogicClause_Impl2_UnsatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unsat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl2_UnsatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate unsat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> UnsatInner0.unsat_inner (Seq.get (Model0.model self) i) a
end
module Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept_Interface
  use Type
  use mach.int.Int
  predicate same_idx_same_polarity_except (self : Type.lib_clause_clause) (other : Type.lib_clause_clause) (exception' : int)
    
end
module Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate same_idx_same_polarity_except (self : Type.lib_clause_clause) (other : Type.lib_clause_clause) (exception' : int)
    
   = 
    forall j : (int) . forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) && 0 <= j && j < Seq.length (Model0.model other) -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model self) i)) <> exception' && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model self) i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model other) j)) -> Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model self) i) = Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model other) j)
end
module Lib_Logic_LogicLit_Impl1_IsOpp_Interface
  use Type
  predicate is_opp (self : Type.lib_lit_lit) (o : Type.lib_lit_lit)
end
module Lib_Logic_LogicLit_Impl1_IsOpp
  use Type
  use mach.int.UInt64
  predicate is_opp (self : Type.lib_lit_lit) (o : Type.lib_lit_lit) = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) = UInt64.to_int (Type.lib_lit_lit_Lit_idx o) && Type.lib_lit_lit_Lit_polarity self <> Type.lib_lit_lit_Lit_polarity o
end
module Lib_Logic_LogicClause_Impl2_InFormula_Interface
  use Type
  predicate in_formula (self : Type.lib_clause_clause) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicClause_Impl2_InFormula
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate in_formula (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) && Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i = self
end
module Lib_Logic_LogicAssignments_CompleteInner_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate complete_inner (a : Seq.seq uint8)
end
module Lib_Logic_LogicAssignments_CompleteInner
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  predicate complete_inner (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length a -> not (Unset0.unset (Seq.get a i))
end
module Lib_Logic_LogicClause_Impl2_SatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate sat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl2_SatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate sat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && SatInner0.sat_inner (Seq.get (Model0.model self) i) a
end
module Lib_Logic_LogicFormula_FormulaSatInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate formula_sat_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (a : Seq.seq uint8)
end
module Lib_Logic_LogicFormula_FormulaSatInner
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  predicate formula_sat_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> SatInner0.sat_inner (Seq.get (let (a, _) = f in a) i) a
end
module Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate eventually_sat_complete_no_ass (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicFormula_EventuallySatCompleteNoAss
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_FormulaSatInner_Interface as FormulaSatInner0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  predicate eventually_sat_complete_no_ass (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = (let (_, a) = f in a) && CompleteInner0.complete_inner a2 && FormulaSatInner0.formula_sat_inner f a2
end
module Lib_Logic_LogicClause_EquisatExtensionInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  predicate equisat_extension_inner (c : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicClause_EquisatExtensionInner
  use Type
  use seq.Seq
  use mach.int.Int
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  predicate equisat_extension_inner (c : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c, let (_, a) = f in a)
end
module Lib_Logic_LogicLit_Impl1_LitInInternal_Interface
  use Type
  use seq.Seq
  predicate lit_in_internal (self : Type.lib_lit_lit) (c : Seq.seq (Type.lib_lit_lit))
end
module Lib_Logic_LogicLit_Impl1_LitInInternal
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  predicate lit_in_internal (self : Type.lib_lit_lit) (c : Seq.seq (Type.lib_lit_lit)) = 
    exists i : (int) . 0 <= i && i < Seq.length c && Seq.get c i = self
end
module Lib_Logic_LogicLit_Impl1_LitIn_Interface
  use Type
  predicate lit_in (self : Type.lib_lit_lit) (c : Type.lib_clause_clause)
end
module Lib_Logic_LogicLit_Impl1_LitIn
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate lit_in (self : Type.lib_lit_lit) (c : Type.lib_clause_clause) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && Seq.get (Model0.model c) i = self
end
module Lib_Logic_LogicConflictAnalysis_LemmaIdx_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Logic_LogicLit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_LogicConflictAnalysis_LemmaIdx
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Logic_LogicLit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
   = 
    ()
  axiom lemma_idx_spec : forall c : Seq.seq (Type.lib_lit_lit), o : Seq.seq (Type.lib_lit_lit), new : Seq.seq (Type.lib_lit_lit), i : int, idx : int, c_idx : int, _f : Type.lib_formula_formula . (exists k : (int) . 0 <= k && k < Seq.length new && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get new k))) -> (forall j : (int) . 0 <= j && j < Seq.length new -> LitInInternal0.lit_in_internal (Seq.get new j) c || LitInInternal0.lit_in_internal (Seq.get new j) o) -> (forall j : (int) . 0 <= j && j < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c j)) <> idx -> LitInInternal0.lit_in_internal (Seq.get c j) new) -> InvariantInternal0.invariant_internal c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> InvariantInternal0.invariant_internal o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> 0 <= i && i < Seq.length o && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) <> idx -> (forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length o && 0 <= k && k < Seq.length c && k <> c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o j)) <> idx -> not (IsOpp0.is_opp (Seq.get c k) (Seq.get o j))) -> 0 <= c_idx && c_idx < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length o && k <> i && IsOpp0.is_opp (Seq.get o k) (Seq.get c c_idx)) -> (exists k : (int) . 0 <= k && k < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c k)) || LitInInternal0.lit_in_internal (Seq.get o i) new) && (exists k : (int) . 0 <= k && k < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c k)) && Type.lib_lit_lit_Lit_polarity (Seq.get o i) = Type.lib_lit_lit_Lit_polarity (Seq.get c k) || LitInInternal0.lit_in_internal (Seq.get o i) new)
end
module Lib_Logic_LogicConflictAnalysis_LemmaIdx_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_LitInInternal as LitInInternal0
  let rec ghost function lemma_idx (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    requires {exists k : (int) . 0 <= k && k < Seq.length new && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get new k))}
    requires {forall j : (int) . 0 <= j && j < Seq.length new -> LitInInternal0.lit_in_internal (Seq.get new j) c || LitInInternal0.lit_in_internal (Seq.get new j) o}
    requires {forall j : (int) . 0 <= j && j < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c j)) <> idx -> LitInInternal0.lit_in_internal (Seq.get c j) new}
    requires {InvariantInternal0.invariant_internal c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {InvariantInternal0.invariant_internal o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {0 <= i && i < Seq.length o && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) <> idx}
    requires {forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length o && 0 <= k && k < Seq.length c && k <> c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o j)) <> idx -> not (IsOpp0.is_opp (Seq.get c k) (Seq.get o j))}
    requires {0 <= c_idx && c_idx < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length o && k <> i && IsOpp0.is_opp (Seq.get o k) (Seq.get c c_idx))}
    ensures { exists k : (int) . 0 <= k && k < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c k)) && Type.lib_lit_lit_Lit_polarity (Seq.get o i) = Type.lib_lit_lit_Lit_polarity (Seq.get c k) || LitInInternal0.lit_in_internal (Seq.get o i) new }
    ensures { exists k : (int) . 0 <= k && k < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c k)) || LitInInternal0.lit_in_internal (Seq.get o i) new }
    
   = 
    ()
end
module Lib_Logic_LogicConflictAnalysis_LemmaIdx2_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Logic_LogicLit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx2 (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_LogicConflictAnalysis_LemmaIdx2
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Logic_LogicLit_Impl1_LitInInternal_Interface as LitInInternal0
  clone Lib_Logic_LogicConflictAnalysis_LemmaIdx_Interface as LemmaIdx0 with predicate LitInInternal0.lit_in_internal = LitInInternal0.lit_in_internal,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal,
  predicate IsOpp0.is_opp = IsOpp0.is_opp, axiom .
  function lemma_idx2 (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
   = 
    let _ = LemmaIdx0.lemma_idx c o new i idx c_idx _f in ()
  axiom lemma_idx2_spec : forall c : Seq.seq (Type.lib_lit_lit), o : Seq.seq (Type.lib_lit_lit), new : Seq.seq (Type.lib_lit_lit), i : int, idx : int, c_idx : int, _f : Type.lib_formula_formula . (exists k : (int) . 0 <= k && k < Seq.length new && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get new k))) -> (forall j : (int) . 0 <= j && j < Seq.length new -> LitInInternal0.lit_in_internal (Seq.get new j) c || LitInInternal0.lit_in_internal (Seq.get new j) o) -> (forall j : (int) . 0 <= j && j < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c j)) <> idx -> LitInInternal0.lit_in_internal (Seq.get c j) new) -> InvariantInternal0.invariant_internal c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> InvariantInternal0.invariant_internal o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> 0 <= i && i < Seq.length o && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) <> idx -> (forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length o && 0 <= k && k < Seq.length c && k <> c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o j)) <> idx -> not (IsOpp0.is_opp (Seq.get c k) (Seq.get o j))) -> 0 <= c_idx && c_idx < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length o && k <> i && IsOpp0.is_opp (Seq.get o k) (Seq.get c c_idx)) -> LitInInternal0.lit_in_internal (Seq.get o i) new
end
module Lib_Logic_LogicConflictAnalysis_LemmaIdx2_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_LitInInternal as LitInInternal0
  clone Lib_Logic_LogicConflictAnalysis_LemmaIdx as LemmaIdx0 with predicate LitInInternal0.lit_in_internal = LitInInternal0.lit_in_internal,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal,
  predicate IsOpp0.is_opp = IsOpp0.is_opp, axiom .
  let rec ghost function lemma_idx2 (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    requires {exists k : (int) . 0 <= k && k < Seq.length new && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get new k))}
    requires {forall j : (int) . 0 <= j && j < Seq.length new -> LitInInternal0.lit_in_internal (Seq.get new j) c || LitInInternal0.lit_in_internal (Seq.get new j) o}
    requires {forall j : (int) . 0 <= j && j < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c j)) <> idx -> LitInInternal0.lit_in_internal (Seq.get c j) new}
    requires {InvariantInternal0.invariant_internal c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {InvariantInternal0.invariant_internal o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {0 <= i && i < Seq.length o && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) <> idx}
    requires {forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length o && 0 <= k && k < Seq.length c && k <> c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o j)) <> idx -> not (IsOpp0.is_opp (Seq.get c k) (Seq.get o j))}
    requires {0 <= c_idx && c_idx < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length o && k <> i && IsOpp0.is_opp (Seq.get o k) (Seq.get c c_idx))}
    ensures { LitInInternal0.lit_in_internal (Seq.get o i) new }
    
   = 
    let _ = LemmaIdx0.lemma_idx c o new i idx c_idx _f in ()
end
module Lib_Logic_LogicClause_Impl2_ResolventOfIdx_Interface
  use Type
  use mach.int.Int
  predicate resolvent_of_idx (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int)
    
end
module Lib_Logic_LogicClause_Impl2_ResolventOfIdx
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicLit_Impl1_LitIn_Interface as LitIn0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate resolvent_of_idx (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int)
    
   = 
    (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c2) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c2) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c2) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> LitIn0.lit_in (Seq.get (Model0.model self) i) c || LitIn0.lit_in (Seq.get (Model0.model self) i) c2) && (exists m : (int) . exists k : (int) . 0 <= k && k < Seq.length (Model0.model c2) && 0 <= m && m < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) m)) = idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c2) k)) = idx && IsOpp0.is_opp (Seq.get (Model0.model c2) k) (Seq.get (Model0.model c) m))
end
module Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  predicate in_formula_inner (self : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicClause_Impl2_InFormulaInner
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  predicate in_formula_inner (self : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    exists i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) && Seq.get (let (a, _) = f in a) i = self
end
module Lib_Logic_LogicClause_Impl2_ResolventOf_Interface
  use Type
  use mach.int.Int
  predicate resolvent_of (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (k : int) (m : int)
    
end
module Lib_Logic_LogicClause_Impl2_ResolventOf
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicLit_Impl1_LitIn_Interface as LitIn0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate resolvent_of (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (k : int) (m : int)
    
   = 
    (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) && i <> m -> LitIn0.lit_in (Seq.get (Model0.model c) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c2) && i <> k -> LitIn0.lit_in (Seq.get (Model0.model c2) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> LitIn0.lit_in (Seq.get (Model0.model self) i) c || LitIn0.lit_in (Seq.get (Model0.model self) i) c2) && not (LitIn0.lit_in (Seq.get (Model0.model c) m) self) && not (LitIn0.lit_in (Seq.get (Model0.model c2) k) self) && IsOpp0.is_opp (Seq.get (Model0.model c2) k) (Seq.get (Model0.model c) m)
end
module Lib_Logic_LogicClause_Impl2_Equals_Interface
  use Type
  predicate equals (self : Type.lib_clause_clause) (o : Type.lib_clause_clause)
end
module Lib_Logic_LogicClause_Impl2_Equals
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate equals (self : Type.lib_clause_clause) (o : Type.lib_clause_clause) = 
    Seq.length (Model0.model self) = Seq.length (Model0.model o) && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) -> Seq.get (Model0.model self) j = Seq.get (Model0.model o) j)
end
module Lib_Logic_Logic_LemmaEqFormulas_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  function lemma_eq_formulas (f : (Seq.seq (Type.lib_clause_clause), int)) (f2 : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
end
module Lib_Logic_Logic_LemmaEqFormulas
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  function lemma_eq_formulas (f : (Seq.seq (Type.lib_clause_clause), int)) (f2 : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
   = 
    ()
  axiom lemma_eq_formulas_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), f2 : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause . FormulaInvariant0.formula_invariant f -> (let (a, _) = f2 in a) = Seq.snoc (let (a, _) = f in a) c -> Seq.length (let (a, _) = f in a) + 1 = Seq.length (let (a, _) = f2 in a) && (forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Equals0.equals (Seq.get (let (a, _) = f in a) i) (Seq.get (let (a, _) = f2 in a) i)) && Model0.model (Seq.get (let (a, _) = f2 in a) (Seq.length (let (a, _) = f2 in a) - 1)) = Model0.model c
end
module Lib_Logic_Logic_LemmaEqFormulas_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model0.model
  let rec ghost function lemma_eq_formulas (f : (Seq.seq (Type.lib_clause_clause), int)) (f2 : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    requires {FormulaInvariant0.formula_invariant f}
    requires {(let (a, _) = f2 in a) = Seq.snoc (let (a, _) = f in a) c}
    ensures { Model0.model (Seq.get (let (a, _) = f2 in a) (Seq.length (let (a, _) = f2 in a) - 1)) = Model0.model c }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Equals0.equals (Seq.get (let (a, _) = f in a) i) (Seq.get (let (a, _) = f2 in a) i) }
    ensures { Seq.length (let (a, _) = f in a) + 1 = Seq.length (let (a, _) = f2 in a) }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaNotSatGivesNotSat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  function lemma_not_sat_gives_not_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) : ()
    
end
module Lib_Logic_Logic_LemmaNotSatGivesNotSat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_Logic_LemmaEqFormulas_Interface as LemmaEqFormulas0 with predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  function lemma_not_sat_gives_not_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) : ()
    
   = 
    let _ = LemmaEqFormulas0.lemma_eq_formulas f (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a) c3 in ()
  axiom lemma_not_sat_gives_not_sat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause . not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f) -> FormulaInvariant0.formula_invariant f -> not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a))
end
module Lib_Logic_Logic_LemmaNotSatGivesNotSat_Impl
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model0.model
  clone Lib_Logic_Logic_LemmaEqFormulas as LemmaEqFormulas0 with predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  let rec ghost function lemma_not_sat_gives_not_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) : ()
    requires {not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f)}
    requires {FormulaInvariant0.formula_invariant f}
    ensures { not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a)) }
    
   = 
    let _ = LemmaEqFormulas0.lemma_eq_formulas f (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a) c3 in ()
end
module Lib_Logic_Logic_LemmaSatGivesSat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  function lemma_sat_gives_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
end
module Lib_Logic_Logic_LemmaSatGivesSat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_Logic_LemmaEqFormulas_Interface as LemmaEqFormulas0 with predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  function lemma_sat_gives_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
   = 
    let _ = LemmaEqFormulas0.lemma_eq_formulas f (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a) c3 in ()
  axiom lemma_sat_gives_sat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, k : int, m : int . EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f -> ResolventOf0.resolvent_of c3 c c2 k m -> EquisatExtensionInner0.equisat_extension_inner c2 f -> InFormulaInner0.in_formula_inner c f -> FormulaInvariant0.formula_invariant f -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a)
end
module Lib_Logic_Logic_LemmaSatGivesSat_Impl
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model0.model
  clone Lib_Logic_Logic_LemmaEqFormulas as LemmaEqFormulas0 with predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_LogicLit_Impl1_LitIn as LitIn0 with function Model0.model = Model0.model
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner as InFormulaInner0
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf as ResolventOf0 with function Model0.model = Model0.model,
  predicate LitIn0.lit_in = LitIn0.lit_in, predicate IsOpp0.is_opp = IsOpp0.is_opp
  let rec ghost function lemma_sat_gives_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    requires {EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f}
    requires {ResolventOf0.resolvent_of c3 c c2 k m}
    requires {EquisatExtensionInner0.equisat_extension_inner c2 f}
    requires {InFormulaInner0.in_formula_inner c f}
    requires {FormulaInvariant0.formula_invariant f}
    ensures { EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a) }
    
   = 
    let _ = LemmaEqFormulas0.lemma_eq_formulas f (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a) c3 in ()
end
module Lib_Logic_Logic_LemmaExtendedFormulaIsEquisatCompatible_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  function lemma_extended_formula_is_equisat_compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
end
module Lib_Logic_Logic_LemmaExtendedFormulaIsEquisatCompatible
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_Logic_LemmaEqFormulas_Interface as LemmaEqFormulas0 with predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  function lemma_extended_formula_is_equisat_compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
   = 
    let _ = LemmaEqFormulas0.lemma_eq_formulas f (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a) c3 in ()
  axiom lemma_extended_formula_is_equisat_compatible_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, k : int, m : int . ResolventOf0.resolvent_of c3 c c2 k m -> InFormulaInner0.in_formula_inner c2 f -> InFormulaInner0.in_formula_inner c f -> FormulaInvariant0.formula_invariant f -> EquisatExtensionInner0.equisat_extension_inner c3 f
end
module Lib_Logic_Logic_LemmaExtendedFormulaIsEquisatCompatible_Impl
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model0.model
  clone Lib_Logic_Logic_LemmaEqFormulas as LemmaEqFormulas0 with predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_LogicLit_Impl1_LitIn as LitIn0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner as InFormulaInner0
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf as ResolventOf0 with function Model0.model = Model0.model,
  predicate LitIn0.lit_in = LitIn0.lit_in, predicate IsOpp0.is_opp = IsOpp0.is_opp
  let rec ghost function lemma_extended_formula_is_equisat_compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    requires {ResolventOf0.resolvent_of c3 c c2 k m}
    requires {InFormulaInner0.in_formula_inner c2 f}
    requires {InFormulaInner0.in_formula_inner c f}
    requires {FormulaInvariant0.formula_invariant f}
    ensures { EquisatExtensionInner0.equisat_extension_inner c3 f }
    
   = 
    let _ = LemmaEqFormulas0.lemma_eq_formulas f (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a) c3 in ()
end
module Lib_Logic_Logic_LemmaResolventOfEquisatExtensionIsEquisat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  function lemma_resolvent_of_equisat_extension_is_equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
end
module Lib_Logic_Logic_LemmaResolventOfEquisatExtensionIsEquisat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_Logic_LemmaNotSatGivesNotSat_Interface as LemmaNotSatGivesNotSat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_Logic_LemmaEqFormulas_Interface as LemmaEqFormulas0 with predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_Logic_LemmaExtendedFormulaIsEquisatCompatible_Interface as LemmaExtendedFormulaIsEquisatCompatible0 with predicate ResolventOf0.resolvent_of = ResolventOf0.resolvent_of,
  predicate InFormulaInner0.in_formula_inner = InFormulaInner0.in_formula_inner,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner, axiom .
  clone Lib_Logic_Logic_LemmaSatGivesSat_Interface as LemmaSatGivesSat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass,
  predicate ResolventOf0.resolvent_of = ResolventOf0.resolvent_of,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  predicate InFormulaInner0.in_formula_inner = InFormulaInner0.in_formula_inner,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  function lemma_resolvent_of_equisat_extension_is_equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
   = 
    let _ = LemmaEqFormulas0.lemma_eq_formulas f (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a) c3 in let _ = LemmaNotSatGivesNotSat0.lemma_not_sat_gives_not_sat f c c2 c3 in let _ = LemmaSatGivesSat0.lemma_sat_gives_sat f c c2 c3 k m in let _ = LemmaExtendedFormulaIsEquisatCompatible0.lemma_extended_formula_is_equisat_compatible f c c2 c3 k m in ()
  axiom lemma_resolvent_of_equisat_extension_is_equisat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, k : int, m : int . ResolventOf0.resolvent_of c3 c c2 k m -> InFormulaInner0.in_formula_inner c2 f -> EquisatExtensionInner0.equisat_extension_inner c f -> FormulaInvariant0.formula_invariant f -> EquisatExtensionInner0.equisat_extension_inner c3 f
end
module Lib_Logic_Logic_LemmaResolventOfEquisatExtensionIsEquisat_Impl
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model0.model
  clone Lib_Logic_Logic_LemmaEqFormulas as LemmaEqFormulas0 with predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_Logic_LemmaNotSatGivesNotSat as LemmaNotSatGivesNotSat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function LemmaEqFormulas0.lemma_eq_formulas = LemmaEqFormulas0.lemma_eq_formulas,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_LogicLit_Impl1_LitIn as LitIn0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner as InFormulaInner0
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf as ResolventOf0 with function Model0.model = Model0.model,
  predicate LitIn0.lit_in = LitIn0.lit_in, predicate IsOpp0.is_opp = IsOpp0.is_opp
  clone Lib_Logic_Logic_LemmaExtendedFormulaIsEquisatCompatible as LemmaExtendedFormulaIsEquisatCompatible0 with predicate ResolventOf0.resolvent_of = ResolventOf0.resolvent_of,
  predicate InFormulaInner0.in_formula_inner = InFormulaInner0.in_formula_inner,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  function LemmaEqFormulas0.lemma_eq_formulas = LemmaEqFormulas0.lemma_eq_formulas,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_Logic_LemmaSatGivesSat as LemmaSatGivesSat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass,
  predicate ResolventOf0.resolvent_of = ResolventOf0.resolvent_of,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  predicate InFormulaInner0.in_formula_inner = InFormulaInner0.in_formula_inner,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function LemmaEqFormulas0.lemma_eq_formulas = LemmaEqFormulas0.lemma_eq_formulas,
  function Model0.model = Model0.model, predicate Equals0.equals = Equals0.equals, axiom .
  let rec ghost function lemma_resolvent_of_equisat_extension_is_equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    requires {ResolventOf0.resolvent_of c3 c c2 k m}
    requires {InFormulaInner0.in_formula_inner c2 f}
    requires {EquisatExtensionInner0.equisat_extension_inner c f}
    requires {FormulaInvariant0.formula_invariant f}
    ensures { EquisatExtensionInner0.equisat_extension_inner c3 f }
    
   = 
    let _ = LemmaEqFormulas0.lemma_eq_formulas f (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a) c3 in let _ = LemmaNotSatGivesNotSat0.lemma_not_sat_gives_not_sat f c c2 c3 in let _ = LemmaSatGivesSat0.lemma_sat_gives_sat f c c2 c3 k m in let _ = LemmaExtendedFormulaIsEquisatCompatible0.lemma_extended_formula_is_equisat_compatible f c c2 c3 k m in ()
end
module Lib_ConflictAnalysis_Resolve_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicClause_Impl2_VarsInRange_Interface as VarsInRange0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model2 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy2.modelTy
  clone Lib_Logic_LogicClause_Impl2_InFormula_Interface as InFormula0
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept_Interface as SameIdxSamePolarityExcept0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  val resolve [@cfg:stackify] (_f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (o : Type.lib_clause_clause) (idx : usize) (c_idx : usize) (_a : Type.lib_assignments_assignments) : Type.lib_clause_clause
    requires {Invariant0.invariant' o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant0.invariant' c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {UnsatInner0.unsat_inner c (Model0.model _a)}
    requires {PostUnitInner0.post_unit_inner o (Model0.model _a)}
    requires {UInt64.to_int idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {SameIdxSamePolarityExcept0.same_idx_same_polarity_except c o (UInt64.to_int idx)}
    requires {forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length (Model1.model o) && 0 <= k && k < Seq.length (Model1.model c) && k <> UInt64.to_int c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o) j)) <> UInt64.to_int idx -> not (IsOpp0.is_opp (Seq.get (Model1.model c) k) (Seq.get (Model1.model o) j))}
    requires {UInt64.to_int c_idx < Seq.length (Model1.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c) (UInt64.to_int c_idx))) = UInt64.to_int idx && (exists k : (int) . 0 <= k && k < Seq.length (Model1.model o) && IsOpp0.is_opp (Seq.get (Model1.model o) k) (Seq.get (Model1.model c) (UInt64.to_int c_idx)))}
    requires {InFormula0.in_formula o _f}
    requires {EquisatExtensionInner0.equisat_extension_inner c (Model2.model _f)}
    requires {Invariant1.invariant' _f}
    ensures { EquisatExtensionInner0.equisat_extension_inner result (Model2.model _f) }
    ensures { VarsInRange0.vars_in_range result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    ensures { Invariant0.invariant' result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    ensures { UnsatInner0.unsat_inner result (Model0.model _a) }
    
end
module Lib_ConflictAnalysis_Resolve
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model7 with function Model0.model = Model9.model
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model6 with function Model0.model = Model8.model
  clone Lib_Logic_LogicClause_Impl2_InFormula as InFormula0 with function Model0.model = Model8.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Logic_Model_Impl0_Model as Model5 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model7.model
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner as InFormulaInner0
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model as Model4 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model6.model
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Logic_LogicLit_Impl1_LitInInternal as LitInInternal0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicConflictAnalysis_LemmaIdx as LemmaIdx0 with predicate LitInInternal0.lit_in_internal = LitInInternal0.lit_in_internal,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal,
  predicate IsOpp0.is_opp = IsOpp0.is_opp, axiom .
  clone Lib_Logic_LogicConflictAnalysis_LemmaIdx2 as LemmaIdx20 with predicate LitInInternal0.lit_in_internal = LitInInternal0.lit_in_internal,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal,
  predicate IsOpp0.is_opp = IsOpp0.is_opp, function LemmaIdx0.lemma_idx = LemmaIdx0.lemma_idx, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model3.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model3.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_InvariantUnaryOk as InvariantUnaryOk0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept as SameIdxSamePolarityExcept0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant1 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model8.model,
  predicate Invariant0.invariant' = Invariant1.invariant', function Model1.model = Model3.model
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model3.model
  clone Lib_Logic_Logic_LemmaEqFormulas as LemmaEqFormulas0 with predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function Model0.model = Model3.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_Logic_LemmaNotSatGivesNotSat as LemmaNotSatGivesNotSat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function LemmaEqFormulas0.lemma_eq_formulas = LemmaEqFormulas0.lemma_eq_formulas,
  function Model0.model = Model3.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model6.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicLit_Impl1_LitIn as LitIn0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_ResolventOf as ResolventOf0 with function Model0.model = Model3.model,
  predicate LitIn0.lit_in = LitIn0.lit_in, predicate IsOpp0.is_opp = IsOpp0.is_opp
  clone Lib_Logic_Logic_LemmaExtendedFormulaIsEquisatCompatible as LemmaExtendedFormulaIsEquisatCompatible0 with predicate ResolventOf0.resolvent_of = ResolventOf0.resolvent_of,
  predicate InFormulaInner0.in_formula_inner = InFormulaInner0.in_formula_inner,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  function LemmaEqFormulas0.lemma_eq_formulas = LemmaEqFormulas0.lemma_eq_formulas,
  function Model0.model = Model3.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_Logic_LemmaSatGivesSat as LemmaSatGivesSat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass,
  predicate ResolventOf0.resolvent_of = ResolventOf0.resolvent_of,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  predicate InFormulaInner0.in_formula_inner = InFormulaInner0.in_formula_inner,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function LemmaEqFormulas0.lemma_eq_formulas = LemmaEqFormulas0.lemma_eq_formulas,
  function Model0.model = Model3.model, predicate Equals0.equals = Equals0.equals, axiom .
  clone Lib_Logic_Logic_LemmaResolventOfEquisatExtensionIsEquisat as LemmaResolventOfEquisatExtensionIsEquisat0 with predicate ResolventOf0.resolvent_of = ResolventOf0.resolvent_of,
  predicate InFormulaInner0.in_formula_inner = InFormulaInner0.in_formula_inner,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant,
  function LemmaEqFormulas0.lemma_eq_formulas = LemmaEqFormulas0.lemma_eq_formulas,
  function LemmaNotSatGivesNotSat0.lemma_not_sat_gives_not_sat = LemmaNotSatGivesNotSat0.lemma_not_sat_gives_not_sat,
  function LemmaSatGivesSat0.lemma_sat_gives_sat = LemmaSatGivesSat0.lemma_sat_gives_sat,
  function LemmaExtendedFormulaIsEquisatCompatible0.lemma_extended_formula_is_equisat_compatible = LemmaExtendedFormulaIsEquisatCompatible0.lemma_extended_formula_is_equisat_compatible,
  function Model0.model = Model3.model, predicate Equals0.equals = Equals0.equals,
  predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass,
  axiom .
  clone Lib_Logic_LogicClause_Impl2_ResolventOfIdx as ResolventOfIdx0 with function Model0.model = Model3.model,
  predicate LitIn0.lit_in = LitIn0.lit_in, predicate IsOpp0.is_opp = IsOpp0.is_opp
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model3.model
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve11 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = Type.core_option_option usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.creusotcontracts_logic_ghost_ghost (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy3 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  function Model0.model = Model2.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = Type.lib_lit_lit,
  function Model0.model = Model0.model, function Model1.model = Model11.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model0.model
  clone Lib_ConflictAnalysis_IdxIn_Interface as IdxIn0 with function Model0.model = Model10.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_lit_lit,
  function Model0.model = Model10.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_lit_lit,
  function Model0.model = Model10.model
  clone CreusotContracts_Std1_Vec_Impl5_Resolve as Resolve10 with type t = Type.lib_lit_lit,
  function Model0.model = Model0.model, predicate Resolve0.resolve = Resolve7.resolve
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New0 with type t = Type.lib_lit_lit,
  function Model0.model = Model0.model
  let rec cfg resolve [@cfg:stackify] (_f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (o : Type.lib_clause_clause) (idx : usize) (c_idx : usize) (_a : Type.lib_assignments_assignments) : Type.lib_clause_clause
    requires {Invariant1.invariant' o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant1.invariant' c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {UnsatInner0.unsat_inner c (Model5.model _a)}
    requires {PostUnitInner0.post_unit_inner o (Model5.model _a)}
    requires {UInt64.to_int idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {SameIdxSamePolarityExcept0.same_idx_same_polarity_except c o (UInt64.to_int idx)}
    requires {forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length (Model1.model o) && 0 <= k && k < Seq.length (Model1.model c) && k <> UInt64.to_int c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o) j)) <> UInt64.to_int idx -> not (IsOpp0.is_opp (Seq.get (Model1.model c) k) (Seq.get (Model1.model o) j))}
    requires {UInt64.to_int c_idx < Seq.length (Model1.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c) (UInt64.to_int c_idx))) = UInt64.to_int idx && (exists k : (int) . 0 <= k && k < Seq.length (Model1.model o) && IsOpp0.is_opp (Seq.get (Model1.model o) k) (Seq.get (Model1.model c) (UInt64.to_int c_idx)))}
    requires {InFormula0.in_formula o _f}
    requires {EquisatExtensionInner0.equisat_extension_inner c (Model4.model _f)}
    requires {Invariant2.invariant' _f}
    ensures { EquisatExtensionInner0.equisat_extension_inner result (Model4.model _f) }
    ensures { VarsInRange0.vars_in_range result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    ensures { Invariant1.invariant' result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    ensures { UnsatInner0.unsat_inner result (Model5.model _a) }
    
   = 
  var _0 : Type.lib_clause_clause;
  var _f_1 : Type.lib_formula_formula;
  var c_2 : Type.lib_clause_clause;
  var o_3 : Type.lib_clause_clause;
  var idx_4 : usize;
  var c_idx_5 : usize;
  var _a_6 : Type.lib_assignments_assignments;
  var new_7 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var i_8 : usize;
  var _9 : ();
  var _10 : ();
  var _11 : bool;
  var _12 : usize;
  var _13 : usize;
  var _14 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var old_new_15 : Type.creusotcontracts_logic_ghost_ghost (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _16 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _17 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _18 : ();
  var _19 : bool;
  var _20 : usize;
  var _21 : Type.lib_lit_lit;
  var _22 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _23 : usize;
  var _24 : usize;
  var _25 : ();
  var _26 : ();
  var _27 : ();
  var _28 : bool;
  var _29 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _30 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _31 : usize;
  var _32 : Type.lib_lit_lit;
  var _33 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _34 : usize;
  var _35 : ();
  var _36 : ();
  var _37 : ();
  var _38 : ();
  var _39 : ();
  var _40 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _41 : Type.lib_lit_lit;
  var _42 : Type.lib_lit_lit;
  var _43 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _44 : usize;
  var _45 : ();
  var _46 : ();
  var _47 : ();
  var _48 : ();
  var _49 : ();
  var _50 : ();
  var _51 : ();
  var _52 : ();
  var _o_idx_53 : Type.core_option_option usize;
  var old_new_54 : Type.creusotcontracts_logic_ghost_ghost (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _55 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _56 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _57 : ();
  var _58 : ();
  var _59 : ();
  var _60 : bool;
  var _61 : usize;
  var _62 : usize;
  var _63 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var old_new2_64 : Type.creusotcontracts_logic_ghost_ghost (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _65 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _66 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _67 : ();
  var _68 : ();
  var _69 : ();
  var _70 : ();
  var _71 : bool;
  var _72 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _73 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _74 : usize;
  var _75 : Type.lib_lit_lit;
  var _76 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _77 : usize;
  var _78 : ();
  var _79 : ();
  var _80 : ();
  var _81 : ();
  var _82 : ();
  var _83 : ();
  var _84 : ();
  var _85 : ();
  var _86 : ();
  var _87 : ();
  var _88 : ();
  var _89 : bool;
  var _90 : usize;
  var _91 : Type.lib_lit_lit;
  var _92 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _93 : usize;
  var _94 : usize;
  var _95 : ();
  var _96 : ();
  var _97 : Type.core_option_option usize;
  var _98 : usize;
  var _99 : ();
  var _100 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _101 : Type.lib_lit_lit;
  var _102 : Type.lib_lit_lit;
  var _103 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _104 : usize;
  var _105 : ();
  var _106 : ();
  var _107 : ();
  var _108 : ();
  var _109 : ();
  var _110 : ();
  var _111 : ();
  var _112 : ();
  var _113 : ();
  var _114 : ();
  var _115 : ();
  var out_116 : Type.lib_clause_clause;
  var _117 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _118 : ();
  var _119 : ();
  var _120 : ();
  var _121 : ();
  var _122 : ();
  var _123 : isize;
  var o_idx_124 : usize;
  var _125 : ();
  var _126 : ();
  var _127 : ();
  var _128 : ();
  var _129 : ();
  var _130 : ();
  var _131 : ();
  var _132 : ();
  var _133 : ();
  {
    _f_1 <- _f;
    c_2 <- c;
    o_3 <- o;
    idx_4 <- idx;
    c_idx_5 <- c_idx;
    _a_6 <- _a;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _f_1 };
    assume { Resolve1.resolve c_idx_5 };
    assume { Resolve2.resolve _a_6 };
    new_7 <- New0.new ();
    goto BB1
  }
  BB1 {
    i_8 <- (0 : usize);
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    invariant i_less { UInt64.to_int i_8 <= Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest c_2)) };
    invariant new_elems { forall j : (int) . 0 <= j && j < Seq.length (Model0.model new_7) -> Invariant0.invariant' (Seq.get (Model0.model new_7) j) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f_1)) };
    invariant no_dups { forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length (Model0.model new_7) && 0 <= k && k < j -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model new_7) j)) <> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model new_7) k)) };
    invariant not_idx { forall j : (int) . 0 <= j && j < Seq.length (Model0.model new_7) -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model new_7) j)) <> UInt64.to_int idx_4 };
    invariant reso { forall j : (int) . 0 <= j && j < UInt64.to_int i_8 && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) j)) <> UInt64.to_int idx_4 -> LitInInternal0.lit_in_internal (Seq.get (Model1.model c_2) j) (Model0.model new_7) && true && true && true };
    invariant from_c { forall j : (int) . 0 <= j && j < Seq.length (Model0.model new_7) -> LitIn0.lit_in (Seq.get (Model0.model new_7) j) c_2 };
    assume { Resolve1.resolve _12 };
    _12 <- i_8;
    _14 <- Type.lib_clause_clause_Clause_rest c_2;
    _13 <- Len0.len _14;
    goto BB8
  }
  BB8 {
    _11 <- _12 < _13;
    switch (_11)
      | False -> goto BB31
      | _ -> goto BB9
      end
  }
  BB9 {
    _17 <- new_7;
    _16 <- _17;
    assume { Resolve3.resolve _17 };
    old_new_15 <- Record0.record _16;
    goto BB10
  }
  BB10 {
    assume { Resolve4.resolve old_new_15 };
    _22 <- Type.lib_clause_clause_Clause_rest c_2;
    assume { Resolve1.resolve _23 };
    _23 <- i_8;
    _21 <- Index0.index _22 _23;
    goto BB11
  }
  BB11 {
    assume { Resolve1.resolve _20 };
    _20 <- Type.lib_lit_lit_Lit_idx _21;
    assume { Resolve5.resolve _21 };
    assume { Resolve1.resolve _24 };
    _24 <- idx_4;
    _19 <- _20 = _24;
    switch (_19)
      | False -> goto BB15
      | _ -> goto BB12
      end
  }
  BB12 {
    assert { Model0.model new_7 = Model0.model (Model2.model old_new_15) };
    goto BB13
  }
  BB13 {
    _25 <- ();
    assume { Resolve6.resolve _25 };
    assert { UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) (UInt64.to_int i_8))) = UInt64.to_int idx_4 };
    _26 <- ();
    assume { Resolve6.resolve _26 };
    assert { forall j : (int) . 0 <= j && j < UInt64.to_int i_8 && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) j)) <> UInt64.to_int idx_4 -> LitInInternal0.lit_in_internal (Seq.get (Model1.model c_2) j) (Model0.model new_7) };
    goto BB14
  }
  BB14 {
    _27 <- ();
    assume { Resolve6.resolve _27 };
    _18 <- ();
    assume { Resolve6.resolve _18 };
    goto BB30
  }
  BB15 {
    _30 <- new_7;
    _29 <- _30;
    assume { Resolve3.resolve _30 };
    _33 <- Type.lib_clause_clause_Clause_rest c_2;
    assume { Resolve1.resolve _34 };
    _34 <- i_8;
    _32 <- Index0.index _33 _34;
    goto BB16
  }
  BB16 {
    assume { Resolve1.resolve _31 };
    _31 <- Type.lib_lit_lit_Lit_idx _32;
    assume { Resolve5.resolve _32 };
    _28 <- IdxIn0.idx_in _29 _31;
    goto BB17
  }
  BB17 {
    switch (_28)
      | False -> goto BB22
      | _ -> goto BB18
      end
  }
  BB18 {
    assert { Model0.model new_7 = Model0.model (Model2.model old_new_15) };
    goto BB19
  }
  BB19 {
    _35 <- ();
    assume { Resolve6.resolve _35 };
    assert { LitInInternal0.lit_in_internal (Seq.get (Model1.model c_2) (UInt64.to_int i_8)) (Model0.model new_7) };
    goto BB20
  }
  BB20 {
    _36 <- ();
    assume { Resolve6.resolve _36 };
    assert { UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) (UInt64.to_int i_8))) <> UInt64.to_int idx_4 };
    _37 <- ();
    assume { Resolve6.resolve _37 };
    assert { forall j : (int) . 0 <= j && j < UInt64.to_int i_8 && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) j)) <> UInt64.to_int idx_4 -> LitInInternal0.lit_in_internal (Seq.get (Model1.model c_2) j) (Model0.model new_7) };
    goto BB21
  }
  BB21 {
    _38 <- ();
    assume { Resolve6.resolve _38 };
    _18 <- ();
    assume { Resolve6.resolve _18 };
    goto BB29
  }
  BB22 {
    _40 <- borrow_mut new_7;
    new_7 <-  ^ _40;
    _43 <- Type.lib_clause_clause_Clause_rest c_2;
    assume { Resolve1.resolve _44 };
    _44 <- i_8;
    _42 <- Index0.index _43 _44;
    goto BB23
  }
  BB23 {
    assume { Resolve7.resolve _41 };
    _41 <- _42;
    assume { Resolve5.resolve _42 };
    _39 <- Push0.push _40 _41;
    goto BB24
  }
  BB24 {
    assert { Seq.get (Model0.model new_7) (Seq.length (Model0.model new_7) - 1) = Seq.get (Model0.model (Type.lib_clause_clause_Clause_rest c_2)) (UInt64.to_int i_8) };
    goto BB25
  }
  BB25 {
    _45 <- ();
    assume { Resolve6.resolve _45 };
    assert { LitIn0.lit_in (Seq.get (Model0.model new_7) (Seq.length (Model0.model new_7) - 1)) c_2 };
    goto BB26
  }
  BB26 {
    _46 <- ();
    assume { Resolve6.resolve _46 };
    assert { LitInInternal0.lit_in_internal (Seq.get (Model1.model c_2) (UInt64.to_int i_8)) (Model0.model new_7) };
    goto BB27
  }
  BB27 {
    _47 <- ();
    assume { Resolve6.resolve _47 };
    assert { UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) (UInt64.to_int i_8))) <> UInt64.to_int idx_4 };
    _48 <- ();
    assume { Resolve6.resolve _48 };
    assert { forall j : (int) . 0 <= j && j < UInt64.to_int i_8 && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) j)) <> UInt64.to_int idx_4 -> LitInInternal0.lit_in_internal (Seq.get (Model1.model c_2) j) (Model0.model new_7) };
    goto BB28
  }
  BB28 {
    _49 <- ();
    assume { Resolve6.resolve _49 };
    _18 <- ();
    assume { Resolve6.resolve _18 };
    goto BB29
  }
  BB29 {
    goto BB30
  }
  BB30 {
    i_8 <- i_8 + (1 : usize);
    _10 <- ();
    assume { Resolve6.resolve _10 };
    goto BB7
  }
  BB31 {
    assume { Resolve8.resolve c_2 };
    assume { Resolve1.resolve i_8 };
    _9 <- ();
    assume { Resolve6.resolve _9 };
    _o_idx_53 <- Type.Core_Option_Option_None;
    _56 <- new_7;
    _55 <- _56;
    assume { Resolve3.resolve _56 };
    old_new_54 <- Record0.record _55;
    goto BB32
  }
  BB32 {
    assume { Resolve4.resolve old_new_54 };
    assert { Model0.model new_7 = Model0.model (Model2.model old_new_54) };
    goto BB33
  }
  BB33 {
    _57 <- ();
    assume { Resolve6.resolve _57 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Model2.model old_new_54)) -> Seq.get (Model0.model new_7) j = Seq.get (Model0.model (Model2.model old_new_54)) j };
    goto BB34
  }
  BB34 {
    _58 <- ();
    assume { Resolve6.resolve _58 };
    i_8 <- (0 : usize);
    goto BB35
  }
  BB35 {
    goto BB36
  }
  BB36 {
    goto BB37
  }
  BB37 {
    goto BB38
  }
  BB38 {
    goto BB39
  }
  BB39 {
    goto BB40
  }
  BB40 {
    goto BB41
  }
  BB41 {
    goto BB42
  }
  BB42 {
    goto BB43
  }
  BB43 {
    goto BB44
  }
  BB44 {
    goto BB45
  }
  BB45 {
    goto BB46
  }
  BB46 {
    invariant i_less { UInt64.to_int i_8 <= Seq.length (Model0.model (Type.lib_clause_clause_Clause_rest o_3)) };
    invariant new_elems { forall j : (int) . 0 <= j && j < Seq.length (Model0.model new_7) -> Invariant0.invariant' (Seq.get (Model0.model new_7) j) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f_1)) };
    invariant no_dups { forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length (Model0.model new_7) && 0 <= k && k < j -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model new_7) j)) <> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model new_7) k)) };
    invariant not_idx { forall j : (int) . 0 <= j && j < Seq.length (Model0.model new_7) -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model new_7) j)) <> UInt64.to_int idx_4 };
    invariant resolve { forall j : (int) . 0 <= j && j < UInt64.to_int i_8 && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o_3) j)) <> UInt64.to_int idx_4 -> LitInInternal0.lit_in_internal (Seq.get (Model1.model o_3) j) (Model0.model new_7) };
    invariant from_o { forall j : (int) . 0 <= j && j < Seq.length (Model0.model new_7) - Seq.length (Model0.model (Model2.model old_new_54)) -> LitIn0.lit_in (Seq.get (Model0.model new_7) (Seq.length (Model0.model (Model2.model old_new_54)) + j)) o_3 };
    invariant from_c { forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Model2.model old_new_54)) -> LitIn0.lit_in (Seq.get (Model0.model new_7) j) c_2 };
    invariant old_unchanged { forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Model2.model old_new_54)) -> Seq.get (Model0.model new_7) j = Seq.get (Model0.model (Model2.model old_new_54)) j };
    invariant maintains { forall j : (int) . 0 <= j && j < Seq.length (Model1.model c_2) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) j)) <> UInt64.to_int idx_4 -> LitInInternal0.lit_in_internal (Seq.get (Model1.model c_2) j) (Model0.model new_7) };
    invariant new_sourced { forall j : (int) . 0 <= j && j < Seq.length (Model0.model new_7) -> LitInInternal0.lit_in_internal (Seq.get (Model0.model new_7) j) (Model1.model c_2) || LitInInternal0.lit_in_internal (Seq.get (Model0.model new_7) j) (Model1.model o_3) };
    invariant confl_idx { match (_o_idx_53) with
      | Type.Core_Option_Option_None -> forall j : (int) . 0 <= j && j < UInt64.to_int i_8 -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o_3) j)) <> UInt64.to_int idx_4
      | Type.Core_Option_Option_Some j -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o_3) (UInt64.to_int j))) = UInt64.to_int idx_4
      end };
    invariant res2 { match (_o_idx_53) with
      | Type.Core_Option_Option_None -> forall j : (int) . 0 <= j && j < UInt64.to_int i_8 -> LitInInternal0.lit_in_internal (Seq.get (Model1.model o_3) j) (Model0.model new_7)
      | Type.Core_Option_Option_Some k -> UInt64.to_int k < UInt64.to_int i_8 && (forall j : (int) . 0 <= j && j < UInt64.to_int i_8 && j <> UInt64.to_int k -> LitInInternal0.lit_in_internal (Seq.get (Model1.model o_3) j) (Model0.model new_7))
      end };
    invariant res { forall j : (int) . 0 <= j && j < Seq.length (Model1.model c_2) && j <> UInt64.to_int c_idx_5 -> LitInInternal0.lit_in_internal (Seq.get (Model1.model c_2) j) (Model0.model new_7) && true };
    assume { Resolve1.resolve _61 };
    _61 <- i_8;
    _63 <- Type.lib_clause_clause_Clause_rest o_3;
    _62 <- Len0.len _63;
    goto BB47
  }
  BB47 {
    _60 <- _61 < _62;
    switch (_60)
      | False -> goto BB76
      | _ -> goto BB48
      end
  }
  BB48 {
    _66 <- new_7;
    _65 <- _66;
    assume { Resolve3.resolve _66 };
    old_new2_64 <- Record0.record _65;
    goto BB49
  }
  BB49 {
    assume { Resolve4.resolve old_new2_64 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Model2.model old_new_54)) -> Seq.get (Model0.model (Model2.model old_new2_64)) j = Seq.get (Model0.model (Model2.model old_new_54)) j };
    _67 <- ();
    assume { Resolve6.resolve _67 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Model2.model old_new_54)) -> Seq.get (Model0.model new_7) j = Seq.get (Model0.model (Model2.model old_new_54)) j };
    goto BB50
  }
  BB50 {
    _68 <- ();
    assume { Resolve6.resolve _68 };
    assert { Model0.model new_7 = Model0.model (Model2.model old_new2_64) };
    goto BB51
  }
  BB51 {
    _69 <- ();
    assume { Resolve6.resolve _69 };
    _73 <- new_7;
    _72 <- _73;
    assume { Resolve3.resolve _73 };
    _76 <- Type.lib_clause_clause_Clause_rest o_3;
    assume { Resolve1.resolve _77 };
    _77 <- i_8;
    _75 <- Index0.index _76 _77;
    goto BB52
  }
  BB52 {
    assume { Resolve1.resolve _74 };
    _74 <- Type.lib_lit_lit_Lit_idx _75;
    assume { Resolve5.resolve _75 };
    _71 <- IdxIn0.idx_in _72 _74;
    goto BB53
  }
  BB53 {
    switch (_71)
      | False -> goto BB61
      | _ -> goto BB54
      end
  }
  BB54 {
    assert { Model0.model new_7 = Model0.model (Model2.model old_new2_64) };
    goto BB55
  }
  BB55 {
    _78 <- ();
    assume { Resolve6.resolve _78 };
    assert { UInt64.to_int c_idx_5 < Seq.length (Model1.model c_2) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) (UInt64.to_int c_idx_5))) = UInt64.to_int idx_4 && (exists k : (int) . 0 <= k && k < Seq.length (Model1.model o_3) && k <> UInt64.to_int i_8 && IsOpp0.is_opp (Seq.get (Model1.model o_3) k) (Seq.get (Model1.model c_2) (UInt64.to_int c_idx_5))) };
    _79 <- ();
    assume { Resolve6.resolve _79 };
    assert { forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length (Model1.model o_3) && 0 <= k && k < Seq.length (Model1.model c_2) && k <> UInt64.to_int c_idx_5 && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o_3) j)) <> UInt64.to_int idx_4 -> not (IsOpp0.is_opp (Seq.get (Model1.model c_2) k) (Seq.get (Model1.model o_3) j)) };
    _80 <- ();
    assume { Resolve6.resolve _80 };
    assert { InvariantUnaryOk0.invariant_unary_ok o_3 (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f_1)) };
    _81 <- ();
    assume { Resolve6.resolve _81 };
    assert { InvariantUnaryOk0.invariant_unary_ok c_2 (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f_1)) };
    _82 <- ();
    assume { Resolve6.resolve _82 };
    assert { 0 <= UInt64.to_int i_8 && UInt64.to_int i_8 < Seq.length (Model1.model o_3) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o_3) (UInt64.to_int i_8))) <> UInt64.to_int idx_4 };
    _83 <- ();
    assume { Resolve6.resolve _83 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model1.model c_2) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) j)) <> UInt64.to_int idx_4 -> LitInInternal0.lit_in_internal (Seq.get (Model1.model c_2) j) (Model0.model new_7) };
    goto BB56
  }
  BB56 {
    _84 <- ();
    assume { Resolve6.resolve _84 };
    assert { let _ = LemmaIdx0.lemma_idx (Model1.model c_2) (Model1.model o_3) (Model0.model new_7) (UInt64.to_int i_8) (UInt64.to_int idx_4) (UInt64.to_int c_idx_5) _f_1 in true };
    goto BB57
  }
  BB57 {
    _85 <- ();
    assume { Resolve6.resolve _85 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model0.model new_7) -> LitInInternal0.lit_in_internal (Seq.get (Model0.model new_7) j) (Model1.model c_2) || LitInInternal0.lit_in_internal (Seq.get (Model0.model new_7) j) (Model1.model o_3) };
    goto BB58
  }
  BB58 {
    _86 <- ();
    assume { Resolve6.resolve _86 };
    assert { exists k : (int) . 0 <= k && k < Seq.length (Model0.model new_7) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o_3) (UInt64.to_int i_8))) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model new_7) k)) };
    goto BB59
  }
  BB59 {
    _87 <- ();
    assume { Resolve6.resolve _87 };
    assert { let _ = LemmaIdx20.lemma_idx2 (Model1.model c_2) (Model1.model o_3) (Model0.model new_7) (UInt64.to_int i_8) (UInt64.to_int idx_4) (UInt64.to_int c_idx_5) _f_1 in LitInInternal0.lit_in_internal (Seq.get (Model1.model o_3) (UInt64.to_int i_8)) (Model0.model new_7) };
    goto BB60
  }
  BB60 {
    _88 <- ();
    assume { Resolve6.resolve _88 };
    _70 <- ();
    assume { Resolve6.resolve _70 };
    goto BB74
  }
  BB61 {
    _92 <- Type.lib_clause_clause_Clause_rest o_3;
    assume { Resolve1.resolve _93 };
    _93 <- i_8;
    _91 <- Index0.index _92 _93;
    goto BB62
  }
  BB62 {
    assume { Resolve1.resolve _90 };
    _90 <- Type.lib_lit_lit_Lit_idx _91;
    assume { Resolve5.resolve _91 };
    assume { Resolve1.resolve _94 };
    _94 <- idx_4;
    _89 <- _90 = _94;
    switch (_89)
      | False -> goto BB65
      | _ -> goto BB63
      end
  }
  BB63 {
    assume { Resolve9.resolve _o_idx_53 };
    assert { Model0.model new_7 = Model0.model (Model2.model old_new2_64) };
    goto BB64
  }
  BB64 {
    _95 <- ();
    assume { Resolve6.resolve _95 };
    assert { UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o_3) (UInt64.to_int i_8))) = UInt64.to_int idx_4 };
    _96 <- ();
    assume { Resolve6.resolve _96 };
    assume { Resolve1.resolve _98 };
    _98 <- i_8;
    _97 <- Type.Core_Option_Option_Some _98;
    assume { Resolve9.resolve _o_idx_53 };
    _o_idx_53 <- _97;
    _70 <- ();
    assume { Resolve6.resolve _70 };
    goto BB73
  }
  BB65 {
    _100 <- borrow_mut new_7;
    new_7 <-  ^ _100;
    _103 <- Type.lib_clause_clause_Clause_rest o_3;
    assume { Resolve1.resolve _104 };
    _104 <- i_8;
    _102 <- Index0.index _103 _104;
    goto BB66
  }
  BB66 {
    assume { Resolve7.resolve _101 };
    _101 <- _102;
    assume { Resolve5.resolve _102 };
    _99 <- Push0.push _100 _101;
    goto BB67
  }
  BB67 {
    assert { Seq.get (Model0.model new_7) (Seq.length (Model0.model new_7) - 1) = Seq.get (Model0.model (Type.lib_clause_clause_Clause_rest o_3)) (UInt64.to_int i_8) };
    goto BB68
  }
  BB68 {
    _105 <- ();
    assume { Resolve6.resolve _105 };
    assert { LitIn0.lit_in (Seq.get (Model0.model new_7) (Seq.length (Model0.model new_7) - 1)) o_3 };
    goto BB69
  }
  BB69 {
    _106 <- ();
    assume { Resolve6.resolve _106 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Model2.model old_new2_64)) -> Seq.get (Model0.model new_7) j = Seq.get (Model0.model (Model2.model old_new2_64)) j };
    goto BB70
  }
  BB70 {
    _107 <- ();
    assume { Resolve6.resolve _107 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Model2.model old_new_54)) -> Seq.get (Model0.model new_7) j = Seq.get (Model0.model (Model2.model old_new_54)) j };
    goto BB71
  }
  BB71 {
    _108 <- ();
    assume { Resolve6.resolve _108 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Model2.model old_new_54)) -> Seq.get (Model0.model (Model2.model old_new2_64)) j = Seq.get (Model0.model (Model2.model old_new_54)) j };
    _109 <- ();
    assume { Resolve6.resolve _109 };
    assert { LitInInternal0.lit_in_internal (Seq.get (Model1.model o_3) (UInt64.to_int i_8)) (Model0.model new_7) };
    goto BB72
  }
  BB72 {
    _110 <- ();
    assume { Resolve6.resolve _110 };
    _70 <- ();
    assume { Resolve6.resolve _70 };
    goto BB73
  }
  BB73 {
    goto BB74
  }
  BB74 {
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Model2.model old_new_54)) -> Seq.get (Model0.model (Model2.model old_new2_64)) j = Seq.get (Model0.model (Model2.model old_new_54)) j };
    _111 <- ();
    assume { Resolve6.resolve _111 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Model2.model old_new_54)) -> Seq.get (Model0.model new_7) j = Seq.get (Model0.model (Model2.model old_new_54)) j };
    goto BB75
  }
  BB75 {
    _112 <- ();
    assume { Resolve6.resolve _112 };
    i_8 <- i_8 + (1 : usize);
    _10 <- ();
    assume { Resolve6.resolve _10 };
    goto BB46
  }
  BB76 {
    assume { Resolve8.resolve o_3 };
    assume { Resolve1.resolve idx_4 };
    assume { Resolve1.resolve i_8 };
    _59 <- ();
    assume { Resolve6.resolve _59 };
    assume { Resolve10.resolve _117 };
    _117 <- new_7;
    out_116 <- Type.Lib_Clause_Clause _117;
    goto BB77
  }
  BB77 {
    assert { Model3.model out_116 = Model0.model new_7 };
    goto BB78
  }
  BB78 {
    _118 <- ();
    assume { Resolve6.resolve _118 };
    assert { forall i : (int) . 0 <= i && i < Seq.length (Model1.model o_3) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o_3) i)) <> UInt64.to_int idx_4 -> LitInInternal0.lit_in_internal (Seq.get (Model1.model o_3) i) (Model0.model new_7) };
    goto BB79
  }
  BB79 {
    _119 <- ();
    assume { Resolve6.resolve _119 };
    assert { exists m : (int) . exists k : (int) . 0 <= k && k < Seq.length (Model1.model o_3) && 0 <= m && m < Seq.length (Model1.model c_2) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c_2) m)) = UInt64.to_int idx_4 && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o_3) k)) = UInt64.to_int idx_4 && IsOpp0.is_opp (Seq.get (Model1.model o_3) k) (Seq.get (Model1.model c_2) m) };
    _120 <- ();
    assume { Resolve6.resolve _120 };
    assert { ResolventOfIdx0.resolvent_of_idx out_116 c_2 o_3 (UInt64.to_int idx_4) };
    goto BB80
  }
  BB80 {
    _121 <- ();
    assume { Resolve6.resolve _121 };
    switch (_o_idx_53)
      | Type.Core_Option_Option_None -> goto BB81
      | Type.Core_Option_Option_Some _ -> goto BB83
      end
  }
  BB81 {
    assume { Resolve9.resolve _o_idx_53 };
    absurd
  }
  BB82 {
    assume { Resolve9.resolve _o_idx_53 };
    assume { Resolve11.resolve out_116 };
    absurd
  }
  BB83 {
    assume { Resolve1.resolve o_idx_124 };
    o_idx_124 <- Type.core_option_option_Some_0 _o_idx_53;
    assume { Resolve9.resolve _o_idx_53 };
    assume { Resolve1.resolve o_idx_124 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model1.model c_2) && j <> UInt64.to_int c_idx_5 -> LitIn0.lit_in (Seq.get (Model1.model c_2) j) out_116 };
    goto BB84
  }
  BB84 {
    _125 <- ();
    assume { Resolve6.resolve _125 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model1.model o_3) && j <> UInt64.to_int o_idx_124 -> LitIn0.lit_in (Seq.get (Model1.model o_3) j) out_116 };
    goto BB85
  }
  BB85 {
    _126 <- ();
    assume { Resolve6.resolve _126 };
    assert { FormulaInvariant0.formula_invariant (Model4.model _f_1) };
    _127 <- ();
    assume { Resolve6.resolve _127 };
    assert { EquisatExtensionInner0.equisat_extension_inner c_2 (Model4.model _f_1) };
    _128 <- ();
    assume { Resolve6.resolve _128 };
    assert { InFormulaInner0.in_formula_inner o_3 (Model4.model _f_1) };
    _129 <- ();
    assume { Resolve6.resolve _129 };
    assert { ResolventOf0.resolvent_of out_116 c_2 o_3 (UInt64.to_int o_idx_124) (UInt64.to_int c_idx_5) };
    goto BB86
  }
  BB86 {
    _130 <- ();
    assume { Resolve6.resolve _130 };
    assert { let _ = LemmaResolventOfEquisatExtensionIsEquisat0.lemma_resolvent_of_equisat_extension_is_equisat (Model4.model _f_1) c_2 o_3 out_116 (UInt64.to_int c_idx_5) (UInt64.to_int o_idx_124) in true };
    goto BB87
  }
  BB87 {
    _131 <- ();
    assume { Resolve6.resolve _131 };
    assert { EquisatExtensionInner0.equisat_extension_inner out_116 (Model4.model _f_1) };
    goto BB88
  }
  BB88 {
    _132 <- ();
    assume { Resolve6.resolve _132 };
    _122 <- ();
    assume { Resolve6.resolve _122 };
    assume { Resolve11.resolve _0 };
    _0 <- out_116;
    goto BB89
  }
  BB89 {
    goto BB90
  }
  BB90 {
    return _0
  }
  
end
module Lib_Logic_LogicClause_Impl2_Unsat_Interface
  use Type
  predicate unsat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl2_Unsat
  use Type
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unsat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    UnsatInner0.unsat_inner self (Model0.model a)
end
module Lib_Logic_LogicTrail_LitToLevelInvariant_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  predicate lit_to_level_invariant (lit_to_level : Seq.seq usize) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_LitToLevelInvariant
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  predicate lit_to_level_invariant (lit_to_level : Seq.seq usize) (f : Type.lib_formula_formula) = 
    Seq.length lit_to_level = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)
end
module Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface
  use Type
  predicate lit_idx_in (self : Type.lib_lit_lit) (c : Type.lib_clause_clause)
end
module Lib_Logic_LogicLit_Impl1_LitIdxIn
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate lit_idx_in (self : Type.lib_lit_lit) (c : Type.lib_clause_clause) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i) = Type.lib_lit_lit_Lit_idx self
end
module Lib_Logic_LogicTrail_LitNotInLessInner_Interface
  use seq.Seq
  use Type
  predicate lit_not_in_less_inner (t : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_LitNotInLessInner
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate lit_not_in_less_inner (t : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) = 
    forall i : (int) . 0 <= i && i < Seq.length t -> (forall j : (int) . 0 <= j && j < i -> match (Type.lib_trail_step_Step_reason (Seq.get t j)) with
      | Type.Lib_Trail_Reason_Long cref -> not (LitIdxIn0.lit_idx_in (Type.lib_trail_step_Step_lit (Seq.get t i)) (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)))
      | _ -> true
      end)
end
module Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface
  use Type
  predicate lit_not_in_less (self : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_Impl2_LitNotInLess
  use Type
  clone Lib_Logic_LogicTrail_LitNotInLessInner_Interface as LitNotInLessInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  predicate lit_not_in_less (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    LitNotInLessInner0.lit_not_in_less_inner (Model0.model (Type.lib_trail_trail_Trail_trail self)) f
end
module Lib_Logic_LogicTrail_LitIsUniqueInner_Interface
  use seq.Seq
  use Type
  predicate lit_is_unique_inner (trail : Seq.seq (Type.lib_trail_step))
end
module Lib_Logic_LogicTrail_LitIsUniqueInner
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use mach.int.UInt64
  predicate lit_is_unique_inner (trail : Seq.seq (Type.lib_trail_step)) = 
    forall i : (int) . 0 <= i && i < Seq.length trail -> (forall j : (int) . 0 <= j && j < i -> Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get trail j)) <> Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get trail i)))
end
module Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface
  use Type
  predicate lit_is_unique (self : Type.lib_trail_trail)
end
module Lib_Logic_LogicTrail_Impl2_LitIsUnique
  use Type
  clone Lib_Logic_LogicTrail_LitIsUniqueInner_Interface as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  predicate lit_is_unique (self : Type.lib_trail_trail) = 
    LitIsUniqueInner0.lit_is_unique_inner (Model0.model (Type.lib_trail_trail_Trail_trail self))
end
module Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate trail_entries_are_assigned_inner (t : Seq.seq (Type.lib_trail_step)) (a : Seq.seq uint8)
end
module Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  predicate trail_entries_are_assigned_inner (t : Seq.seq (Type.lib_trail_step)) (a : Seq.seq uint8) = 
    forall j : (int) . 0 <= j && j < Seq.length t -> SatInner0.sat_inner (Type.lib_trail_step_Step_lit (Seq.get t j)) a
end
module Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned_Interface
  use Type
  predicate trail_entries_are_assigned (self : Type.lib_trail_trail)
end
module Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned
  use Type
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner_Interface as TrailEntriesAreAssignedInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  predicate trail_entries_are_assigned (self : Type.lib_trail_trail) = 
    TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner (Model0.model (Type.lib_trail_trail_Trail_trail self)) (Model1.model (Type.lib_trail_trail_Trail_assignments self))
end
module Lib_Logic_LogicUtil_SortedRange_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_range (s : Seq.seq usize) (l : int) (u : int)
end
module Lib_Logic_LogicUtil_SortedRange
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_range (s : Seq.seq usize) (l : int) (u : int) = 
    forall j : (int) . forall i : (int) . l <= i && i < j && j < u -> Seq.get s i <= Seq.get s j
end
module Lib_Logic_LogicUtil_Sorted_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted (s : Seq.seq usize)
end
module Lib_Logic_LogicUtil_Sorted
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use mach.int.Int32
  clone Lib_Logic_LogicUtil_SortedRange_Interface as SortedRange0
  predicate sorted (s : Seq.seq usize) = 
    SortedRange0.sorted_range s 0 (Seq.length s)
end
module Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted_Interface
  use Type
  predicate decisions_are_sorted (self : Type.lib_trail_trail)
end
module Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Logic_LogicUtil_Sorted_Interface as Sorted0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = usize
  predicate decisions_are_sorted (self : Type.lib_trail_trail) = 
    Sorted0.sorted (Model0.model (Type.lib_trail_trail_Trail_decisions self))
end
module Lib_Logic_LogicTrail_UnitAreSat_Interface
  use seq.Seq
  use Type
  predicate unit_are_sat (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
    
end
module Lib_Logic_LogicTrail_UnitAreSat
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate unit_are_sat (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
    
   = 
    forall j : (int) . 0 <= j && j < Seq.length trail -> match (Type.lib_trail_step_Step_reason (Seq.get trail j)) with
      | Type.Lib_Trail_Reason_Unit k -> Type.lib_trail_step_Step_lit (Seq.get trail j) = Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) 0 && Sat0.sat (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) 0) a
      | _ -> true
      end
end
module Lib_Logic_LogicTrail_Impl2_InvariantNoDecision_Interface
  use Type
  predicate invariant_no_decision (self : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_Impl2_InvariantNoDecision
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_UnitAreSat_Interface as UnitAreSat0
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted_Interface as DecisionsAreSorted0
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned_Interface as TrailEntriesAreAssigned0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant_Interface as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = usize
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant0
  predicate invariant_no_decision (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    Invariant0.invariant' (Type.lib_trail_trail_Trail_assignments self) f && TrailInvariant0.trail_invariant (Model0.model (Type.lib_trail_trail_Trail_trail self)) f && LitToLevelInvariant0.lit_to_level_invariant (Model1.model (Type.lib_trail_trail_Trail_lit_to_level self)) f && LitNotInLess0.lit_not_in_less self f && LitIsUnique0.lit_is_unique self && LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail self)) f (Model2.model (Type.lib_trail_trail_Trail_assignments self)) && TrailEntriesAreAssigned0.trail_entries_are_assigned self && DecisionsAreSorted0.decisions_are_sorted self && UnitAreSat0.unit_are_sat (Model0.model (Type.lib_trail_trail_Trail_trail self)) f (Type.lib_trail_trail_Trail_assignments self)
end
module Lib_Logic_LogicTrail_DecisionsInvariant_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  predicate decisions_invariant (decisions : Seq.seq usize) (trail : Seq.seq (Type.lib_trail_step))
end
module Lib_Logic_LogicTrail_DecisionsInvariant
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  use mach.int.Int32
  predicate decisions_invariant (decisions : Seq.seq usize) (trail : Seq.seq (Type.lib_trail_step)) = 
    forall i : (int) . 0 <= i && i < Seq.length decisions -> UInt64.to_int (Seq.get decisions i) <= Seq.length trail
end
module Lib_Logic_LogicTrail_Impl2_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_Impl2_Invariant
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_DecisionsInvariant_Interface as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_trail_step
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision_Interface as InvariantNoDecision0
  predicate invariant' (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    InvariantNoDecision0.invariant_no_decision self f && DecisionsInvariant0.decisions_invariant (Model0.model (Type.lib_trail_trail_Trail_decisions self)) (Model1.model (Type.lib_trail_trail_Trail_trail self))
end
module CreusotContracts_Logic_Int_Impl9_ModelTy
  use mach.int.Int
  type modelTy  = 
    int
end
module CreusotContracts_Logic_Int_Impl9_Model_Interface
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  function model (self : usize) : int
end
module CreusotContracts_Logic_Int_Impl9_Model
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  function model (self : usize) : int = 
    UInt64.to_int self
end
module CreusotContracts_Logic_Int_Impl9
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone CreusotContracts_Logic_Int_Impl9_Model as Model0
  clone CreusotContracts_Logic_Int_Impl9_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = usize, function model = Model0.model,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = usize, type modelTy = ModelTy0.modelTy
end
module Lib_ConflictAnalysis_ChooseLiteral_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone CreusotContracts_Logic_Int_Impl9_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = usize,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val choose_literal [@cfg:stackify] (c : Type.lib_clause_clause) (trail : Type.lib_trail_trail) (i : borrowed usize) (_f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {Model1.model i <= Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail))}
    requires {Unsat0.unsat c (Type.lib_trail_trail_Trail_assignments trail)}
    requires {Invariant0.invariant' trail _f}
    ensures { UInt64.to_int ( ^ i) < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail)) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some r -> UInt64.to_int r < Seq.length (Model2.model c) && IsOpp0.is_opp (Seq.get (Model2.model c) (UInt64.to_int r)) (Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail trail)) (UInt64.to_int ( ^ i)))) && Type.lib_lit_lit_Lit_idx (Seq.get (Model2.model c) (UInt64.to_int r)) = Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail trail)) (UInt64.to_int ( ^ i))))
      | Type.Core_Option_Option_None -> true
      end }
    
end
module Lib_ConflictAnalysis_ChooseLiteral
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model10 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model6 with function Model0.model = Model9.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant1 with function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model8.model
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant4 with function Model0.model = Model10.model,
  function Model1.model = Model5.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant2 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model5.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model10.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model5.model
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model10.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model10.model,
  function Model1.model = Model5.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model7.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model as Model3 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model2 with type t = borrowed usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model6.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model7.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model6.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model7.model, function Model1.model = Model1.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone CreusotContracts_Logic_Int_Impl9_Model as Model4
  clone CreusotContracts_Logic_Int_Impl9_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model0 with type t = usize,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve8 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.lib_trail_step
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy3 with type t = Type.lib_trail_step
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed usize)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = borrowed usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Model_Impl0_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model8.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_lit_lit,
  function Model0.model = Model11.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_lit_lit,
  function Model0.model = Model11.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed usize,
  function Model0.model = Model2.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model12 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_trail_step,
  function Model0.model = Model12.model
  let rec cfg choose_literal [@cfg:stackify] (c : Type.lib_clause_clause) (trail : Type.lib_trail_trail) (i : borrowed usize) (_f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {Model0.model i <= Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail))}
    requires {Unsat0.unsat c (Type.lib_trail_trail_Trail_assignments trail)}
    requires {Invariant0.invariant' trail _f}
    ensures { UInt64.to_int ( ^ i) < Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail)) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some r -> UInt64.to_int r < Seq.length (Model3.model c) && IsOpp0.is_opp (Seq.get (Model3.model c) (UInt64.to_int r)) (Type.lib_trail_step_Step_lit (Seq.get (Model1.model (Type.lib_trail_trail_Trail_trail trail)) (UInt64.to_int ( ^ i)))) && Type.lib_lit_lit_Lit_idx (Seq.get (Model3.model c) (UInt64.to_int r)) = Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get (Model1.model (Type.lib_trail_trail_Trail_trail trail)) (UInt64.to_int ( ^ i))))
      | Type.Core_Option_Option_None -> true
      end }
    
   = 
  var _0 : Type.core_option_option usize;
  var c_1 : Type.lib_clause_clause;
  var trail_2 : Type.lib_trail_trail;
  var i_3 : borrowed usize;
  var _f_4 : Type.lib_formula_formula;
  var old_i_5 : Type.creusotcontracts_logic_ghost_ghost (borrowed usize);
  var _6 : borrowed usize;
  var _7 : borrowed usize;
  var _8 : ();
  var _9 : ();
  var _10 : bool;
  var _11 : usize;
  var k_12 : usize;
  var _13 : bool;
  var _14 : usize;
  var _15 : usize;
  var _16 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _17 : ();
  var _18 : bool;
  var _19 : usize;
  var _20 : Type.lib_trail_step;
  var _21 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var _22 : usize;
  var _23 : usize;
  var _24 : Type.lib_lit_lit;
  var _25 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _26 : usize;
  var _27 : ();
  var _28 : usize;
  var _29 : ();
  var _30 : ();
  var _31 : ();
  var _32 : ();
  var _33 : ();
  var _34 : ();
  {
    c_1 <- c;
    trail_2 <- trail;
    i_3 <- i;
    _f_4 <- _f;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _f_4 };
    _7 <- i_3;
    _6 <- _7;
    assume { Resolve1.resolve _7 };
    old_i_5 <- Record0.record _6;
    goto BB1
  }
  BB1 {
    assume { Resolve2.resolve old_i_5 };
    goto BB2
  }
  BB2 {
    invariant i_bound { 0 <= Model0.model i_3 && Model0.model i_3 <= Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail_2)) };
    invariant proph_i {  ^ i_3 =  ^ Model2.model old_i_5 };
    assume { Resolve3.resolve _11 };
    _11 <-  * i_3;
    _10 <- _11 > (0 : usize);
    switch (_10)
      | False -> goto BB12
      | _ -> goto BB3
      end
  }
  BB3 {
    i_3 <- { i_3 with current = ( * i_3 - (1 : usize)) };
    k_12 <- (0 : usize);
    goto BB4
  }
  BB4 {
    invariant i_bound2 { 0 <= Model0.model i_3 && Model0.model i_3 < Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail_2)) };
    invariant k_bound { 0 <= UInt64.to_int k_12 && UInt64.to_int k_12 <= Seq.length (Model3.model c_1) };
    invariant proph_i2 {  ^ i_3 =  ^ Model2.model old_i_5 };
    assume { Resolve3.resolve _14 };
    _14 <- k_12;
    _16 <- Type.lib_clause_clause_Clause_rest c_1;
    _15 <- Len0.len _16;
    goto BB5
  }
  BB5 {
    _13 <- _14 < _15;
    switch (_13)
      | False -> goto BB11
      | _ -> goto BB6
      end
  }
  BB6 {
    _21 <- Type.lib_trail_trail_Trail_trail trail_2;
    assume { Resolve3.resolve _22 };
    _22 <-  * i_3;
    _20 <- Index0.index _21 _22;
    goto BB7
  }
  BB7 {
    assume { Resolve3.resolve _19 };
    _19 <- Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit _20);
    assume { Resolve4.resolve _20 };
    _25 <- Type.lib_clause_clause_Clause_rest c_1;
    assume { Resolve3.resolve _26 };
    _26 <- k_12;
    _24 <- Index1.index _25 _26;
    goto BB8
  }
  BB8 {
    assume { Resolve3.resolve _23 };
    _23 <- Type.lib_lit_lit_Lit_idx _24;
    assume { Resolve5.resolve _24 };
    _18 <- _19 = _23;
    switch (_18)
      | False -> goto BB10
      | _ -> goto BB9
      end
  }
  BB9 {
    assume { Resolve6.resolve c_1 };
    assume { Resolve7.resolve trail_2 };
    assume { Resolve8.resolve i_3 };
    assume { Resolve3.resolve _28 };
    _28 <- k_12;
    assume { Resolve3.resolve k_12 };
    _0 <- Type.Core_Option_Option_Some _28;
    goto BB13
  }
  BB10 {
    _17 <- ();
    assume { Resolve9.resolve _17 };
    k_12 <- k_12 + (1 : usize);
    _9 <- ();
    assume { Resolve9.resolve _9 };
    goto BB4
  }
  BB11 {
    assume { Resolve3.resolve k_12 };
    _9 <- ();
    assume { Resolve9.resolve _9 };
    goto BB2
  }
  BB12 {
    assume { Resolve6.resolve c_1 };
    assume { Resolve7.resolve trail_2 };
    assume { Resolve8.resolve i_3 };
    _8 <- ();
    assume { Resolve9.resolve _8 };
    _0 <- Type.Core_Option_Option_None;
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module Lib_Logic_LogicClause_Impl2_EquisatExtension_Interface
  use Type
  predicate equisat_extension (self : Type.lib_clause_clause) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicClause_Impl2_EquisatExtension
  use Type
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_Impl0_Model_Interface as Model0
  predicate equisat_extension (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) = 
    EquisatExtensionInner0.equisat_extension_inner self (Model0.model f)
end
module Lib_Logic_LogicFormula_Impl1_NotSatisfiable_Interface
  use Type
  predicate not_satisfiable (self : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_NotSatisfiable
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_EquisatExtension_Interface as EquisatExtension0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate not_satisfiable (self : Type.lib_formula_formula) = 
    exists c : (Type.lib_clause_clause) . Seq.length (Model0.model c) = 0 && EquisatExtension0.equisat_extension c self
end
module Lib_Trail_Impl0_DecisionLevel_Interface
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = usize
  val decision_level [@cfg:stackify] (self : Type.lib_trail_trail) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model (Type.lib_trail_trail_Trail_decisions self)) }
    
end
module Lib_Trail_Impl0_DecisionLevel
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = usize, function Model0.model = Model1.model
  let rec cfg decision_level [@cfg:stackify] (self : Type.lib_trail_trail) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model (Type.lib_trail_trail_Trail_decisions self)) }
    
   = 
  var _0 : usize;
  var self_1 : Type.lib_trail_trail;
  var _2 : Type.creusotcontracts_std1_vec_vec usize;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    _2 <- Type.lib_trail_trail_Trail_decisions self_1;
    assume { Resolve0.resolve self_1 };
    _0 <- Len0.len _2;
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module CreusotContracts_Std1_Clone_Clone_Clone_Interface
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    ensures { result = self }
    
end
module CreusotContracts_Std1_Clone_Clone_Clone
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    ensures { result = self }
    
end
module Lib_Clause_Impl0
  use Type
  clone Lib_Clause_Impl0_Clone_Interface as Clone0
  clone CreusotContracts_Std1_Clone_Clone_Clone_Interface as Clone1 with type self = Type.lib_clause_clause,
  val clone' = Clone0.clone'
end
module Lib_ConflictAnalysis_DeriveEmptyFormula_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable_Interface as NotSatisfiable0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val derive_empty_formula [@cfg:stackify] (f : Type.lib_formula_formula) (trail : Type.lib_trail_trail) (cref : usize) : bool
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments trail)}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' f}
    ensures { if result then NotSatisfiable0.not_satisfiable f else true }
    
end
module Lib_ConflictAnalysis_DeriveEmptyFormula
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant4
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model5 with function Model0.model = Model8.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant2 with function Model0.model = Model5.model
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model7.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model4 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model2.model,
  function Model1.model = Model5.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model2.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model6.model
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model3.model,
  function Model1.model = Model1.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant4.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model1.model, predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model3.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model3.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model2.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_EquisatExtension as EquisatExtension0 with function Model0.model = Model4.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable as NotSatisfiable0 with function Model0.model = Model1.model,
  predicate EquisatExtension0.equisat_extension = EquisatExtension0.equisat_extension
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant3 with function Model0.model = Model1.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant3.invariant', function Model1.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model4.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model3.model,
  function Model1.model = Model1.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model2.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model7.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model5.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model7.model, function Model1.model = Model2.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model1.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model1.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_InvariantUnaryOk as InvariantUnaryOk0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept as SameIdxSamePolarityExcept0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model4.model
  use mach.int.Int64
  clone CreusotContracts_Logic_Int_Impl9_Model as Model15
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy5
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve12 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve11 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve10 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = Type.lib_trail_reason
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = Type.core_option_option usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve3 with type t = usize
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy4
  clone CreusotContracts_Logic_Int_Impl9_ModelTy as ModelTy3
  clone CreusotContracts_Logic_Model_Impl1_Model as Model11 with type t = usize,
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model15.model
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = ()
  clone Lib_Clause_Impl0_Clone_Interface as Clone0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Model_Impl0_Model as Model13 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy5.modelTy, function Model0.model = Model5.model
  clone Lib_Logic_LogicClause_Impl2_InFormula as InFormula0 with function Model0.model = Model3.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_clause_clause,
  function Model0.model = Model10.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_trail_step,
  function Model0.model = Model9.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_trail_step,
  function Model0.model = Model9.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model14 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy6.modelTy, function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len1 with type t = Type.lib_lit_lit,
  function Model0.model = Model14.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model12 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy4.modelTy, function Model0.model = Model1.model
  clone Lib_ConflictAnalysis_ChooseLiteral_Interface as ChooseLiteral0 with function Model0.model = Model2.model,
  function Model1.model = Model11.model, predicate Unsat0.unsat = Unsat0.unsat,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model2.model = Model12.model,
  predicate IsOpp0.is_opp = IsOpp0.is_opp
  clone Lib_ConflictAnalysis_Resolve_Interface as Resolve13 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model13.model, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate SameIdxSamePolarityExcept0.same_idx_same_polarity_except = SameIdxSamePolarityExcept0.same_idx_same_polarity_except,
  function Model1.model = Model12.model, predicate IsOpp0.is_opp = IsOpp0.is_opp,
  predicate InFormula0.in_formula = InFormula0.in_formula, function Model2.model = Model0.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  predicate Invariant1.invariant' = Invariant1.invariant',
  predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg derive_empty_formula [@cfg:stackify] (f : Type.lib_formula_formula) (trail : Type.lib_trail_trail) (cref : usize) : bool
    requires {Unsat0.unsat (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments trail)}
    requires {UInt64.to_int cref < Seq.length (Model3.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' f}
    ensures { if result then NotSatisfiable0.not_satisfiable f else true }
    
   = 
  var _0 : bool;
  var f_1 : Type.lib_formula_formula;
  var trail_2 : Type.lib_trail_trail;
  var cref_3 : usize;
  var _4 : ();
  var i_5 : usize;
  var _6 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var clause_7 : Type.lib_clause_clause;
  var _8 : Type.lib_clause_clause;
  var _9 : Type.lib_clause_clause;
  var _10 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _11 : usize;
  var _12 : ();
  var _13 : ();
  var _14 : bool;
  var _15 : usize;
  var _16 : ();
  var c_idx_17 : usize;
  var _18 : Type.core_option_option usize;
  var _19 : Type.lib_clause_clause;
  var _20 : Type.lib_clause_clause;
  var _21 : Type.lib_trail_trail;
  var _22 : borrowed usize;
  var _23 : borrowed usize;
  var _24 : Type.lib_formula_formula;
  var _25 : isize;
  var _26 : ();
  var b_27 : usize;
  var _28 : ();
  var ante_29 : Type.lib_clause_clause;
  var _30 : Type.lib_trail_reason;
  var _31 : Type.lib_trail_step;
  var _32 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var _33 : usize;
  var _34 : isize;
  var c_35 : usize;
  var _36 : Type.lib_clause_clause;
  var _37 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _38 : usize;
  var c_39 : usize;
  var _40 : Type.lib_clause_clause;
  var _41 : Type.lib_clause_clause;
  var _42 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _43 : usize;
  var o_44 : Type.lib_trail_reason;
  var _45 : ();
  var _46 : ();
  var _47 : Type.lib_clause_clause;
  var _48 : Type.lib_formula_formula;
  var _49 : Type.lib_clause_clause;
  var _50 : Type.lib_clause_clause;
  var _51 : Type.lib_clause_clause;
  var _52 : Type.lib_clause_clause;
  var _53 : usize;
  var _54 : Type.lib_trail_step;
  var _55 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var _56 : usize;
  var _57 : usize;
  var _58 : Type.lib_assignments_assignments;
  var _59 : Type.lib_assignments_assignments;
  var _60 : bool;
  var _61 : usize;
  var _62 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _63 : ();
  var _64 : ();
  var _65 : ();
  var _66 : ();
  {
    f_1 <- f;
    trail_2 <- trail;
    cref_3 <- cref;
    goto BB0
  }
  BB0 {
    _6 <- Type.lib_trail_trail_Trail_trail trail_2;
    i_5 <- Len0.len _6;
    goto BB1
  }
  BB1 {
    _10 <- Type.lib_formula_formula_Formula_clauses f_1;
    assume { Resolve0.resolve _11 };
    _11 <- cref_3;
    assume { Resolve0.resolve cref_3 };
    _9 <- Index0.index _10 _11;
    goto BB2
  }
  BB2 {
    _8 <- _9;
    assume { Resolve1.resolve _9 };
    clause_7 <- Clone0.clone' _8;
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    invariant clause_vars { InvariantUnaryOk0.invariant_unary_ok clause_7 (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1)) };
    invariant clause_equi { EquisatExtensionInner0.equisat_extension_inner clause_7 (Model0.model f_1) };
    invariant clause_unsat { Unsat0.unsat clause_7 (Type.lib_trail_trail_Trail_assignments trail_2) };
    invariant clause_len { Seq.length (Model1.model clause_7) > 0 };
    invariant i_bound { 0 <= UInt64.to_int i_5 && UInt64.to_int i_5 <= Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail trail_2)) };
    assume { Resolve0.resolve _15 };
    _15 <- i_5;
    _14 <- _15 > (0 : usize);
    switch (_14)
      | False -> goto BB29
      | _ -> goto BB9
      end
  }
  BB9 {
    assert { Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail trail_2)) > 0 };
    _16 <- ();
    assume { Resolve2.resolve _16 };
    _20 <- clause_7;
    _19 <- _20;
    assume { Resolve1.resolve _20 };
    _21 <- trail_2;
    _23 <- borrow_mut i_5;
    i_5 <-  ^ _23;
    _22 <- borrow_mut ( * _23);
    _23 <- { _23 with current = ( ^ _22) };
    _24 <- f_1;
    _18 <- ChooseLiteral0.choose_literal _19 _21 _22 _24;
    goto BB10
  }
  BB10 {
    assume { Resolve3.resolve _23 };
    switch (_18)
      | Type.Core_Option_Option_None -> goto BB13
      | Type.Core_Option_Option_Some _ -> goto BB11
      end
  }
  BB11 {
    assume { Resolve0.resolve b_27 };
    b_27 <- Type.core_option_option_Some_0 _18;
    assume { Resolve7.resolve _18 };
    assume { Resolve0.resolve c_idx_17 };
    c_idx_17 <- b_27;
    assume { Resolve0.resolve b_27 };
    assert { UInt64.to_int i_5 < Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail trail_2)) };
    _28 <- ();
    assume { Resolve2.resolve _28 };
    _32 <- Type.lib_trail_trail_Trail_trail trail_2;
    assume { Resolve0.resolve _33 };
    _33 <- i_5;
    _31 <- Index1.index _32 _33;
    goto BB14
  }
  BB12 {
    assume { Resolve4.resolve f_1 };
    assume { Resolve5.resolve trail_2 };
    assume { Resolve0.resolve i_5 };
    assume { Resolve6.resolve clause_7 };
    assume { Resolve7.resolve _18 };
    absurd
  }
  BB13 {
    assume { Resolve4.resolve f_1 };
    assume { Resolve5.resolve trail_2 };
    assume { Resolve0.resolve i_5 };
    assume { Resolve7.resolve _18 };
    _0 <- false;
    goto BB31
  }
  BB14 {
    _30 <- Type.lib_trail_step_Step_reason _31;
    assume { Resolve8.resolve _31 };
    switch (_30)
      | Type.Lib_Trail_Reason_Unit _ -> goto BB18
      | Type.Lib_Trail_Reason_Long _ -> goto BB16
      | _ -> goto BB15
      end
  }
  BB15 {
    assume { Resolve4.resolve f_1 };
    assume { Resolve5.resolve trail_2 };
    assume { Resolve0.resolve i_5 };
    assume { Resolve0.resolve c_idx_17 };
    assume { Resolve9.resolve o_44 };
    o_44 <- _30;
    assume { Resolve9.resolve _30 };
    assume { Resolve9.resolve o_44 };
    _0 <- false;
    goto BB30
  }
  BB16 {
    c_35 <- Type.lib_trail_reason_Long_0 _30;
    assume { Resolve9.resolve _30 };
    _37 <- Type.lib_formula_formula_Formula_clauses f_1;
    assume { Resolve0.resolve _38 };
    _38 <- c_35;
    assume { Resolve10.resolve c_35 };
    _36 <- Index0.index _37 _38;
    goto BB17
  }
  BB17 {
    ante_29 <- _36;
    assume { Resolve1.resolve _36 };
    goto BB20
  }
  BB18 {
    c_39 <- Type.lib_trail_reason_Unit_0 _30;
    assume { Resolve9.resolve _30 };
    _42 <- Type.lib_formula_formula_Formula_clauses f_1;
    assume { Resolve0.resolve _43 };
    _43 <- c_39;
    assume { Resolve10.resolve c_39 };
    _41 <- Index0.index _42 _43;
    goto BB19
  }
  BB19 {
    _40 <- _41;
    assume { Resolve1.resolve _41 };
    ante_29 <- _40;
    assume { Resolve1.resolve _40 };
    goto BB20
  }
  BB20 {
    assert { SameIdxSamePolarityExcept0.same_idx_same_polarity_except clause_7 ante_29 (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get (Model2.model (Type.lib_trail_trail_Trail_trail trail_2)) (UInt64.to_int i_5))))) };
    goto BB21
  }
  BB21 {
    _46 <- ();
    assume { Resolve2.resolve _46 };
    _48 <- f_1;
    _50 <- clause_7;
    _49 <- _50;
    assume { Resolve1.resolve _50 };
    _52 <- ante_29;
    assume { Resolve1.resolve ante_29 };
    _51 <- _52;
    assume { Resolve11.resolve _52 };
    _55 <- Type.lib_trail_trail_Trail_trail trail_2;
    assume { Resolve0.resolve _56 };
    _56 <- i_5;
    _54 <- Index1.index _55 _56;
    goto BB22
  }
  BB22 {
    assume { Resolve0.resolve _53 };
    _53 <- Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit _54);
    assume { Resolve8.resolve _54 };
    assume { Resolve0.resolve _57 };
    _57 <- c_idx_17;
    assume { Resolve0.resolve c_idx_17 };
    _59 <- Type.lib_trail_trail_Trail_assignments trail_2;
    _58 <- _59;
    assume { Resolve12.resolve _59 };
    _47 <- Resolve13.resolve _48 _49 _51 _53 _57 _58;
    goto BB23
  }
  BB23 {
    assume { Resolve6.resolve clause_7 };
    clause_7 <- _47;
    goto BB24
  }
  BB24 {
    goto BB25
  }
  BB25 {
    _62 <- Type.lib_clause_clause_Clause_rest clause_7;
    _61 <- Len1.len _62;
    goto BB26
  }
  BB26 {
    _60 <- _61 = (0 : usize);
    switch (_60)
      | False -> goto BB28
      | _ -> goto BB27
      end
  }
  BB27 {
    assume { Resolve4.resolve f_1 };
    assume { Resolve5.resolve trail_2 };
    assume { Resolve0.resolve i_5 };
    _0 <- true;
    goto BB30
  }
  BB28 {
    _13 <- ();
    assume { Resolve2.resolve _13 };
    goto BB8
  }
  BB29 {
    assume { Resolve4.resolve f_1 };
    assume { Resolve5.resolve trail_2 };
    assume { Resolve0.resolve i_5 };
    _12 <- ();
    assume { Resolve2.resolve _12 };
    _0 <- false;
    goto BB32
  }
  BB30 {
    goto BB31
  }
  BB31 {
    goto BB32
  }
  BB32 {
    goto BB33
  }
  BB33 {
    assume { Resolve6.resolve clause_7 };
    return _0
  }
  
end
module Lib_ConflictAnalysis_AnalyzeConflict_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use Type
  use mach.int.Int32
  use prelude.Prelude
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model3 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model2
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable_Interface as NotSatisfiable0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = usize
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val analyze_conflict [@cfg:stackify] (f : Type.lib_formula_formula) (trail : Type.lib_trail_trail) (cref : usize) : Type.lib_conflictanalysis_conflict
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments trail)}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' f}
    ensures { match (result) with
      | Type.Lib_ConflictAnalysis_Conflict_Ground -> Seq.length (Model1.model (Type.lib_trail_trail_Trail_decisions trail)) = 0
      | Type.Lib_ConflictAnalysis_Conflict_Panic -> true
      | _ -> Seq.length (Model1.model (Type.lib_trail_trail_Trail_decisions trail)) > 0
      end }
    ensures { match (result) with
      | Type.Lib_ConflictAnalysis_Conflict_Ground -> NotSatisfiable0.not_satisfiable f
      | Type.Lib_ConflictAnalysis_Conflict_Unit clause -> Invariant2.invariant' clause (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && Seq.length (Model2.model clause) = 1 && VarsInRangeInner0.vars_in_range_inner (Model2.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model2.model clause) && EquisatExtensionInner0.equisat_extension_inner clause (Model3.model f)
      | Type.Lib_ConflictAnalysis_Conflict_Learned level clause -> Invariant2.invariant' clause (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && UInt64.to_int level < Seq.length (Model1.model (Type.lib_trail_trail_Trail_decisions trail)) && Seq.length (Model2.model clause) > 1 && VarsInRangeInner0.vars_in_range_inner (Model2.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model2.model clause) && EquisatExtensionInner0.equisat_extension_inner clause (Model3.model f)
      | _ -> true
      end }
    
end
module Lib_ConflictAnalysis_AnalyzeConflict
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model7 with function Model0.model = Model8.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant4 with function Model0.model = Model7.model
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model4.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model6 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model2.model
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model3.model,
  function Model1.model = Model5.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model5.model, predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model3.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model5.model
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model3.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_EquisatExtension as EquisatExtension0 with function Model0.model = Model6.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable as NotSatisfiable0 with function Model0.model = Model5.model,
  predicate EquisatExtension0.equisat_extension = EquisatExtension0.equisat_extension
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model3.model,
  function Model1.model = Model5.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model7.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model5.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model5.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_InvariantUnaryOk as InvariantUnaryOk0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model5.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model5.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant2.invariant', function Model1.model = Model5.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model6.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept as SameIdxSamePolarityExcept0 with function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model7.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model4.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model7.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model4.model, function Model1.model = Model1.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model6.model
  use mach.int.Int64
  clone CreusotContracts_Logic_Int_Impl9_Model as Model16
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy7 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve16 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy5
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve14 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve13 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve12 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve11 with type t = Type.lib_trail_reason
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve10 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = Type.core_option_option usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = usize
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy4
  clone CreusotContracts_Logic_Int_Impl9_ModelTy as ModelTy3
  clone CreusotContracts_Logic_Model_Impl1_Model as Model11 with type t = usize,
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model16.model
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = int32
  clone Lib_Clause_Impl0_Clone_Interface as Clone0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Logic_Model_Impl0_Model as Model13 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy5.modelTy, function Model0.model = Model7.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model15 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy7.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index3 with type t = usize,
  function Model0.model = Model15.model
  clone Lib_Trail_Impl0_DecisionLevel_Interface as DecisionLevel0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_InFormula as InFormula0 with function Model0.model = Model3.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_clause_clause,
  function Model0.model = Model10.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model14 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy6.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index2 with type t = Type.lib_lit_lit,
  function Model0.model = Model14.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len1 with type t = Type.lib_lit_lit,
  function Model0.model = Model14.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model12 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy4.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_trail_step,
  function Model0.model = Model9.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_trail_step,
  function Model0.model = Model9.model
  clone Lib_ConflictAnalysis_ChooseLiteral_Interface as ChooseLiteral0 with function Model0.model = Model1.model,
  function Model1.model = Model11.model, predicate Unsat0.unsat = Unsat0.unsat,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model2.model = Model12.model,
  predicate IsOpp0.is_opp = IsOpp0.is_opp
  clone Lib_ConflictAnalysis_DeriveEmptyFormula_Interface as DeriveEmptyFormula0 with function Model0.model = Model3.model,
  predicate Unsat0.unsat = Unsat0.unsat, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant',
  predicate NotSatisfiable0.not_satisfiable = NotSatisfiable0.not_satisfiable,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_ConflictAnalysis_Resolve_Interface as Resolve15 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model13.model, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate SameIdxSamePolarityExcept0.same_idx_same_polarity_except = SameIdxSamePolarityExcept0.same_idx_same_polarity_except,
  function Model1.model = Model12.model, predicate IsOpp0.is_opp = IsOpp0.is_opp,
  predicate InFormula0.in_formula = InFormula0.in_formula, function Model2.model = Model0.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  predicate Invariant1.invariant' = Invariant1.invariant',
  predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg analyze_conflict [@cfg:stackify] (f : Type.lib_formula_formula) (trail : Type.lib_trail_trail) (cref : usize) : Type.lib_conflictanalysis_conflict
    requires {Unsat0.unsat (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments trail)}
    requires {UInt64.to_int cref < Seq.length (Model3.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' f}
    ensures { match (result) with
      | Type.Lib_ConflictAnalysis_Conflict_Ground -> Seq.length (Model4.model (Type.lib_trail_trail_Trail_decisions trail)) = 0
      | Type.Lib_ConflictAnalysis_Conflict_Panic -> true
      | _ -> Seq.length (Model4.model (Type.lib_trail_trail_Trail_decisions trail)) > 0
      end }
    ensures { match (result) with
      | Type.Lib_ConflictAnalysis_Conflict_Ground -> NotSatisfiable0.not_satisfiable f
      | Type.Lib_ConflictAnalysis_Conflict_Unit clause -> Invariant2.invariant' clause (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && Seq.length (Model5.model clause) = 1 && VarsInRangeInner0.vars_in_range_inner (Model5.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model5.model clause) && EquisatExtensionInner0.equisat_extension_inner clause (Model0.model f)
      | Type.Lib_ConflictAnalysis_Conflict_Learned level clause -> Invariant2.invariant' clause (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && UInt64.to_int level < Seq.length (Model4.model (Type.lib_trail_trail_Trail_decisions trail)) && Seq.length (Model5.model clause) > 1 && VarsInRangeInner0.vars_in_range_inner (Model5.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model5.model clause) && EquisatExtensionInner0.equisat_extension_inner clause (Model0.model f)
      | _ -> true
      end }
    
   = 
  var _0 : Type.lib_conflictanalysis_conflict;
  var f_1 : Type.lib_formula_formula;
  var trail_2 : Type.lib_trail_trail;
  var cref_3 : usize;
  var decisionlevel_4 : usize;
  var _5 : Type.lib_trail_trail;
  var _6 : ();
  var _7 : bool;
  var _8 : usize;
  var _9 : ();
  var _10 : bool;
  var _11 : Type.lib_formula_formula;
  var _12 : Type.lib_trail_trail;
  var _13 : usize;
  var i_14 : usize;
  var _15 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var clause_16 : Type.lib_clause_clause;
  var _17 : Type.lib_clause_clause;
  var _18 : Type.lib_clause_clause;
  var _19 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _20 : usize;
  var s_idx_21 : int32;
  var _22 : ();
  var _23 : ();
  var _24 : bool;
  var _25 : usize;
  var _26 : ();
  var c_idx_27 : usize;
  var _28 : Type.core_option_option usize;
  var _29 : Type.lib_clause_clause;
  var _30 : Type.lib_clause_clause;
  var _31 : Type.lib_trail_trail;
  var _32 : borrowed usize;
  var _33 : borrowed usize;
  var _34 : Type.lib_formula_formula;
  var _35 : isize;
  var _36 : ();
  var b_37 : usize;
  var _38 : ();
  var ante_39 : Type.lib_clause_clause;
  var _40 : Type.lib_trail_reason;
  var _41 : Type.lib_trail_step;
  var _42 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var _43 : usize;
  var _44 : isize;
  var c_45 : usize;
  var _46 : Type.lib_clause_clause;
  var _47 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _48 : usize;
  var o_49 : Type.lib_trail_reason;
  var _50 : ();
  var _51 : ();
  var _52 : Type.lib_clause_clause;
  var _53 : Type.lib_formula_formula;
  var _54 : Type.lib_clause_clause;
  var _55 : Type.lib_clause_clause;
  var _56 : Type.lib_clause_clause;
  var _57 : Type.lib_clause_clause;
  var _58 : usize;
  var _59 : Type.lib_trail_step;
  var _60 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var _61 : usize;
  var _62 : usize;
  var _63 : Type.lib_assignments_assignments;
  var _64 : Type.lib_assignments_assignments;
  var k_65 : usize;
  var cnt_66 : usize;
  var _67 : ();
  var _68 : bool;
  var _69 : usize;
  var _70 : usize;
  var _71 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _72 : ();
  var _73 : bool;
  var _74 : usize;
  var _75 : usize;
  var _76 : Type.creusotcontracts_std1_vec_vec usize;
  var _77 : usize;
  var _78 : Type.lib_lit_lit;
  var _79 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _80 : usize;
  var _81 : usize;
  var _82 : bool;
  var _83 : usize;
  var _84 : ();
  var _85 : ();
  var _86 : ();
  var _87 : ();
  var _88 : bool;
  var _89 : usize;
  var _90 : ();
  var _91 : ();
  var _92 : ();
  var _93 : ();
  var _94 : ();
  var _95 : bool;
  var _96 : usize;
  var _97 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _98 : ();
  var _99 : bool;
  var _100 : usize;
  var _101 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _102 : Type.lib_clause_clause;
  var _103 : Type.lib_clause_clause;
  {
    f_1 <- f;
    trail_2 <- trail;
    cref_3 <- cref;
    goto BB0
  }
  BB0 {
    _5 <- trail_2;
    decisionlevel_4 <- DecisionLevel0.decision_level _5;
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _8 };
    _8 <- decisionlevel_4;
    _7 <- _8 = (0 : usize);
    switch (_7)
      | False -> goto BB6
      | _ -> goto BB2
      end
  }
  BB2 {
    assume { Resolve0.resolve decisionlevel_4 };
    _11 <- f_1;
    assume { Resolve1.resolve f_1 };
    _12 <- trail_2;
    assume { Resolve2.resolve trail_2 };
    assume { Resolve0.resolve _13 };
    _13 <- cref_3;
    assume { Resolve0.resolve cref_3 };
    _10 <- DeriveEmptyFormula0.derive_empty_formula _11 _12 _13;
    goto BB3
  }
  BB3 {
    switch (_10)
      | False -> goto BB4
      | _ -> goto BB5
      end
  }
  BB4 {
    assume { Resolve3.resolve _10 };
    _0 <- Type.Lib_ConflictAnalysis_Conflict_Panic;
    goto BB58
  }
  BB5 {
    assume { Resolve3.resolve _10 };
    _0 <- Type.Lib_ConflictAnalysis_Conflict_Ground;
    goto BB58
  }
  BB6 {
    _6 <- ();
    assume { Resolve4.resolve _6 };
    _15 <- Type.lib_trail_trail_Trail_trail trail_2;
    i_14 <- Len0.len _15;
    goto BB7
  }
  BB7 {
    _19 <- Type.lib_formula_formula_Formula_clauses f_1;
    assume { Resolve0.resolve _20 };
    _20 <- cref_3;
    assume { Resolve0.resolve cref_3 };
    _18 <- Index0.index _19 _20;
    goto BB8
  }
  BB8 {
    _17 <- _18;
    assume { Resolve5.resolve _18 };
    clause_16 <- Clone0.clone' _17;
    goto BB9
  }
  BB9 {
    s_idx_21 <- (0 : int32);
    assume { Resolve6.resolve s_idx_21 };
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    invariant clause_vars { InvariantUnaryOk0.invariant_unary_ok clause_16 (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1)) };
    invariant clause_equi { EquisatExtensionInner0.equisat_extension_inner clause_16 (Model0.model f_1) };
    invariant clause_unsat { Unsat0.unsat clause_16 (Type.lib_trail_trail_Trail_assignments trail_2) };
    invariant i_bound { 0 <= UInt64.to_int i_14 && UInt64.to_int i_14 <= Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail_2)) };
    assume { Resolve0.resolve _25 };
    _25 <- i_14;
    _24 <- _25 > (0 : usize);
    switch (_24)
      | False -> goto BB43
      | _ -> goto BB14
      end
  }
  BB14 {
    assert { Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail_2)) > 0 };
    _26 <- ();
    assume { Resolve4.resolve _26 };
    _30 <- clause_16;
    _29 <- _30;
    assume { Resolve5.resolve _30 };
    _31 <- trail_2;
    _33 <- borrow_mut i_14;
    i_14 <-  ^ _33;
    _32 <- borrow_mut ( * _33);
    _33 <- { _33 with current = ( ^ _32) };
    _34 <- f_1;
    _28 <- ChooseLiteral0.choose_literal _29 _31 _32 _34;
    goto BB15
  }
  BB15 {
    assume { Resolve7.resolve _33 };
    switch (_28)
      | Type.Core_Option_Option_None -> goto BB18
      | Type.Core_Option_Option_Some _ -> goto BB16
      end
  }
  BB16 {
    assume { Resolve0.resolve b_37 };
    b_37 <- Type.core_option_option_Some_0 _28;
    assume { Resolve9.resolve _28 };
    assume { Resolve0.resolve c_idx_27 };
    c_idx_27 <- b_37;
    assume { Resolve0.resolve b_37 };
    assert { UInt64.to_int i_14 < Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail_2)) };
    _38 <- ();
    assume { Resolve4.resolve _38 };
    _42 <- Type.lib_trail_trail_Trail_trail trail_2;
    assume { Resolve0.resolve _43 };
    _43 <- i_14;
    _41 <- Index1.index _42 _43;
    goto BB19
  }
  BB17 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve trail_2 };
    assume { Resolve0.resolve decisionlevel_4 };
    assume { Resolve0.resolve i_14 };
    assume { Resolve8.resolve clause_16 };
    assume { Resolve9.resolve _28 };
    absurd
  }
  BB18 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve trail_2 };
    assume { Resolve0.resolve decisionlevel_4 };
    assume { Resolve0.resolve i_14 };
    assume { Resolve9.resolve _28 };
    _0 <- Type.Lib_ConflictAnalysis_Conflict_Panic;
    goto BB55
  }
  BB19 {
    _40 <- Type.lib_trail_step_Step_reason _41;
    assume { Resolve10.resolve _41 };
    switch (_40)
      | Type.Lib_Trail_Reason_Long _ -> goto BB21
      | _ -> goto BB20
      end
  }
  BB20 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve trail_2 };
    assume { Resolve0.resolve decisionlevel_4 };
    assume { Resolve0.resolve i_14 };
    assume { Resolve0.resolve c_idx_27 };
    assume { Resolve11.resolve o_49 };
    o_49 <- _40;
    assume { Resolve11.resolve _40 };
    assume { Resolve11.resolve o_49 };
    _0 <- Type.Lib_ConflictAnalysis_Conflict_Panic;
    goto BB55
  }
  BB21 {
    c_45 <- Type.lib_trail_reason_Long_0 _40;
    assume { Resolve11.resolve _40 };
    _47 <- Type.lib_formula_formula_Formula_clauses f_1;
    assume { Resolve0.resolve _48 };
    _48 <- c_45;
    assume { Resolve12.resolve c_45 };
    _46 <- Index0.index _47 _48;
    goto BB22
  }
  BB22 {
    ante_39 <- _46;
    assume { Resolve5.resolve _46 };
    assert { SameIdxSamePolarityExcept0.same_idx_same_polarity_except clause_16 ante_39 (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get (Model1.model (Type.lib_trail_trail_Trail_trail trail_2)) (UInt64.to_int i_14))))) };
    goto BB23
  }
  BB23 {
    _51 <- ();
    assume { Resolve4.resolve _51 };
    _53 <- f_1;
    _55 <- clause_16;
    _54 <- _55;
    assume { Resolve5.resolve _55 };
    _57 <- ante_39;
    assume { Resolve5.resolve ante_39 };
    _56 <- _57;
    assume { Resolve13.resolve _57 };
    _60 <- Type.lib_trail_trail_Trail_trail trail_2;
    assume { Resolve0.resolve _61 };
    _61 <- i_14;
    _59 <- Index1.index _60 _61;
    goto BB24
  }
  BB24 {
    assume { Resolve0.resolve _58 };
    _58 <- Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit _59);
    assume { Resolve10.resolve _59 };
    assume { Resolve0.resolve _62 };
    _62 <- c_idx_27;
    assume { Resolve0.resolve c_idx_27 };
    _64 <- Type.lib_trail_trail_Trail_assignments trail_2;
    _63 <- _64;
    assume { Resolve14.resolve _64 };
    _52 <- Resolve15.resolve _53 _54 _56 _58 _62 _63;
    goto BB25
  }
  BB25 {
    assume { Resolve8.resolve clause_16 };
    clause_16 <- _52;
    goto BB26
  }
  BB26 {
    goto BB27
  }
  BB27 {
    k_65 <- (0 : usize);
    cnt_66 <- (0 : usize);
    goto BB28
  }
  BB28 {
    goto BB29
  }
  BB29 {
    invariant k_bound { UInt64.to_int k_65 <= Seq.length (Model2.model (Type.lib_clause_clause_Clause_rest clause_16)) };
    invariant cnt_bound { UInt64.to_int cnt_66 <= UInt64.to_int k_65 };
    assume { Resolve0.resolve _69 };
    _69 <- k_65;
    _71 <- Type.lib_clause_clause_Clause_rest clause_16;
    _70 <- Len1.len _71;
    goto BB30
  }
  BB30 {
    _68 <- _69 < _70;
    switch (_68)
      | False -> goto BB39
      | _ -> goto BB31
      end
  }
  BB31 {
    _76 <- Type.lib_trail_trail_Trail_lit_to_level trail_2;
    _79 <- Type.lib_clause_clause_Clause_rest clause_16;
    assume { Resolve0.resolve _80 };
    _80 <- k_65;
    _78 <- Index2.index _79 _80;
    goto BB32
  }
  BB32 {
    assume { Resolve0.resolve _77 };
    _77 <- Type.lib_lit_lit_Lit_idx _78;
    assume { Resolve16.resolve _78 };
    _75 <- Index3.index _76 _77;
    goto BB33
  }
  BB33 {
    assume { Resolve0.resolve _74 };
    _74 <- _75;
    assume { Resolve12.resolve _75 };
    assume { Resolve0.resolve _81 };
    _81 <- decisionlevel_4;
    _73 <- _74 = _81;
    switch (_73)
      | False -> goto BB37
      | _ -> goto BB34
      end
  }
  BB34 {
    cnt_66 <- cnt_66 + (1 : usize);
    assume { Resolve0.resolve _83 };
    _83 <- cnt_66;
    _82 <- _83 > (1 : usize);
    switch (_82)
      | False -> goto BB36
      | _ -> goto BB35
      end
  }
  BB35 {
    assume { Resolve0.resolve k_65 };
    _67 <- ();
    assume { Resolve4.resolve _67 };
    goto BB40
  }
  BB36 {
    _72 <- ();
    assume { Resolve4.resolve _72 };
    goto BB38
  }
  BB37 {
    _72 <- ();
    assume { Resolve4.resolve _72 };
    goto BB38
  }
  BB38 {
    k_65 <- k_65 + (1 : usize);
    _23 <- ();
    assume { Resolve4.resolve _23 };
    goto BB29
  }
  BB39 {
    assume { Resolve0.resolve k_65 };
    _67 <- ();
    assume { Resolve4.resolve _67 };
    goto BB40
  }
  BB40 {
    assume { Resolve0.resolve _89 };
    _89 <- cnt_66;
    assume { Resolve0.resolve cnt_66 };
    _88 <- _89 = (1 : usize);
    switch (_88)
      | False -> goto BB42
      | _ -> goto BB41
      end
  }
  BB41 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve trail_2 };
    assume { Resolve0.resolve decisionlevel_4 };
    assume { Resolve0.resolve i_14 };
    _22 <- ();
    assume { Resolve4.resolve _22 };
    goto BB44
  }
  BB42 {
    _23 <- ();
    assume { Resolve4.resolve _23 };
    goto BB13
  }
  BB43 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve trail_2 };
    assume { Resolve0.resolve decisionlevel_4 };
    assume { Resolve0.resolve i_14 };
    _22 <- ();
    assume { Resolve4.resolve _22 };
    goto BB44
  }
  BB44 {
    _97 <- Type.lib_clause_clause_Clause_rest clause_16;
    _96 <- Len1.len _97;
    goto BB45
  }
  BB45 {
    _95 <- _96 = (0 : usize);
    switch (_95)
      | False -> goto BB47
      | _ -> goto BB46
      end
  }
  BB46 {
    _0 <- Type.Lib_ConflictAnalysis_Conflict_Panic;
    goto BB56
  }
  BB47 {
    _94 <- ();
    assume { Resolve4.resolve _94 };
    _101 <- Type.lib_clause_clause_Clause_rest clause_16;
    _100 <- Len1.len _101;
    goto BB48
  }
  BB48 {
    _99 <- _100 = (1 : usize);
    switch (_99)
      | False -> goto BB51
      | _ -> goto BB49
      end
  }
  BB49 {
    assume { Resolve8.resolve _102 };
    _102 <- clause_16;
    _0 <- Type.Lib_ConflictAnalysis_Conflict_Unit _102;
    goto BB50
  }
  BB50 {
    goto BB53
  }
  BB51 {
    assume { Resolve8.resolve _103 };
    _103 <- clause_16;
    _0 <- Type.Lib_ConflictAnalysis_Conflict_Learned (0 : usize) _103;
    goto BB52
  }
  BB52 {
    goto BB53
  }
  BB53 {
    goto BB54
  }
  BB54 {
    goto BB60
  }
  BB55 {
    goto BB56
  }
  BB56 {
    goto BB57
  }
  BB57 {
    assume { Resolve8.resolve clause_16 };
    goto BB59
  }
  BB58 {
    goto BB59
  }
  BB59 {
    goto BB60
  }
  BB60 {
    return _0
  }
  
end
module CreusotContracts_Std1_Vec_FromElem_Interface
  type t   
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val from_elem [@cfg:stackify] (elem : t) (n : usize) : Type.creusotcontracts_std1_vec_vec t
    ensures { forall i : (int) . 0 <= i && i < UInt64.to_int n -> Seq.get (Model0.model result) i = elem }
    ensures { Seq.length (Model0.model result) = UInt64.to_int n }
    
end
module CreusotContracts_Std1_Vec_FromElem
  type t   
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val from_elem [@cfg:stackify] (elem : t) (n : usize) : Type.creusotcontracts_std1_vec_vec t
    ensures { forall i : (int) . 0 <= i && i < UInt64.to_int n -> Seq.get (Model0.model result) i = elem }
    ensures { Seq.length (Model0.model result) = UInt64.to_int n }
    
end
module CreusotContracts_Logic_Seq_Impl1_PermutationOf_Interface
  type t   
  use seq.Seq
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t)
end
module CreusotContracts_Logic_Seq_Impl1_PermutationOf
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t) = 
    Permut.permut self o 0 (Seq.length self)
end
module Lib_Logic_LogicUtil_SortedRangeRev_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_range_rev (s : Seq.seq (usize, usize)) (l : int) (u : int)
end
module Lib_Logic_LogicUtil_SortedRangeRev
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_range_rev (s : Seq.seq (usize, usize)) (l : int) (u : int) = 
    forall j : (int) . forall i : (int) . l <= i && i < j && j < u -> (let (a, _) = Seq.get s i in a) >= (let (a, _) = Seq.get s j in a)
end
module Lib_Logic_LogicUtil_SortedRev_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_rev (s : Seq.seq (usize, usize))
end
module Lib_Logic_LogicUtil_SortedRev
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use mach.int.Int32
  clone Lib_Logic_LogicUtil_SortedRangeRev_Interface as SortedRangeRev0
  predicate sorted_rev (s : Seq.seq (usize, usize)) = 
    SortedRangeRev0.sorted_range_rev s 0 (Seq.length s)
end
module Lib_Logic_LogicUtil_PartitionRev_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate partition_rev (v : Seq.seq (usize, usize)) (i : int)
end
module Lib_Logic_LogicUtil_PartitionRev
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use mach.int.Int32
  predicate partition_rev (v : Seq.seq (usize, usize)) (i : int) = 
    forall k2 : (int) . forall k1 : (int) . 0 <= k1 && k1 < i && i <= k2 && k2 < Seq.length v -> (let (a, _) = Seq.get v k1 in a) >= (let (a, _) = Seq.get v k2 in a)
end
module Lib_Util_SortReverse_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone Lib_Logic_LogicUtil_SortedRev_Interface as SortedRev0
  clone CreusotContracts_Logic_Seq_Impl1_PermutationOf_Interface as PermutationOf0 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = (usize, usize)
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize),
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = (usize, usize)
  val sort_reverse [@cfg:stackify] (v : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize))) : ()
    ensures { PermutationOf0.permutation_of (Model0.model ( ^ v)) (Model1.model v) }
    ensures { SortedRev0.sorted_rev (Model0.model ( ^ v)) }
    
end
module Lib_Util_SortReverse
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicUtil_PartitionRev as PartitionRev0
  clone Lib_Logic_LogicUtil_SortedRangeRev as SortedRangeRev0
  clone Lib_Logic_LogicUtil_SortedRev as SortedRev0 with predicate SortedRangeRev0.sorted_range_rev = SortedRangeRev0.sorted_range_rev
  clone CreusotContracts_Logic_Seq_Impl1_PermutationOf as PermutationOf0 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = (usize, usize)
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize))
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve5 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = (usize, usize)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize)))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize))
  clone CreusotContracts_Logic_Model_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = (usize, usize),
  function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = (usize, usize),
  function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl1_Swap_Interface as Swap0 with type t = (usize, usize),
  function Model0.model = Model1.model, function Model1.model = Model2.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize)),
  function Model0.model = Model0.model
  let rec cfg sort_reverse [@cfg:stackify] (v : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize))) : ()
    ensures { PermutationOf0.permutation_of (Model2.model ( ^ v)) (Model1.model v) }
    ensures { SortedRev0.sorted_rev (Model2.model ( ^ v)) }
    
   = 
  var _0 : ();
  var v_1 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize));
  var i_2 : usize;
  var old_v_3 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize)));
  var _4 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize));
  var _5 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize));
  var _6 : ();
  var _7 : bool;
  var _8 : usize;
  var _9 : usize;
  var _10 : Type.creusotcontracts_std1_vec_vec (usize, usize);
  var max_11 : usize;
  var j_12 : usize;
  var _13 : usize;
  var _14 : ();
  var _15 : bool;
  var _16 : usize;
  var _17 : usize;
  var _18 : Type.creusotcontracts_std1_vec_vec (usize, usize);
  var _19 : ();
  var _20 : bool;
  var _21 : usize;
  var _22 : (usize, usize);
  var _23 : Type.creusotcontracts_std1_vec_vec (usize, usize);
  var _24 : usize;
  var _25 : usize;
  var _26 : (usize, usize);
  var _27 : Type.creusotcontracts_std1_vec_vec (usize, usize);
  var _28 : usize;
  var _29 : usize;
  var _30 : ();
  var _31 : ();
  var _32 : ();
  var _33 : ();
  var _34 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize));
  var _35 : usize;
  var _36 : usize;
  var _37 : ();
  var _38 : ();
  var _39 : ();
  {
    v_1 <- v;
    goto BB0
  }
  BB0 {
    i_2 <- (0 : usize);
    _5 <- v_1;
    _4 <- _5;
    assume { Resolve0.resolve _5 };
    old_v_3 <- Record0.record _4;
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve old_v_3 };
    goto BB2
  }
  BB2 {
    invariant proph_const {  ^ v_1 =  ^ Model0.model old_v_3 };
    invariant permutation { PermutationOf0.permutation_of (Model1.model v_1) (Model2.model ( * Model0.model old_v_3)) };
    invariant i_bound { UInt64.to_int i_2 <= Seq.length (Model1.model v_1) };
    invariant sorted { SortedRangeRev0.sorted_range_rev (Model1.model v_1) 0 (UInt64.to_int i_2) };
    invariant partition { PartitionRev0.partition_rev (Model1.model v_1) (UInt64.to_int i_2) };
    assume { Resolve2.resolve _8 };
    _8 <- i_2;
    _10 <-  * v_1;
    _9 <- Len0.len _10;
    goto BB3
  }
  BB3 {
    _7 <- _8 < _9;
    switch (_7)
      | False -> goto BB15
      | _ -> goto BB4
      end
  }
  BB4 {
    assume { Resolve2.resolve max_11 };
    max_11 <- i_2;
    assume { Resolve2.resolve _13 };
    _13 <- i_2;
    j_12 <- _13 + (1 : usize);
    goto BB5
  }
  BB5 {
    invariant max_is_max { forall k : (int) . UInt64.to_int i_2 <= k && k < UInt64.to_int j_12 -> (let (a, _) = Seq.get (Model1.model v_1) (UInt64.to_int max_11) in a) >= (let (a, _) = Seq.get (Model1.model v_1) k in a) };
    invariant j_bound { UInt64.to_int i_2 <= UInt64.to_int j_12 && UInt64.to_int j_12 <= Seq.length (Model1.model v_1) };
    invariant max_bound { UInt64.to_int i_2 <= UInt64.to_int max_11 && UInt64.to_int max_11 < UInt64.to_int j_12 };
    assume { Resolve2.resolve _16 };
    _16 <- j_12;
    _18 <-  * v_1;
    _17 <- Len0.len _18;
    goto BB6
  }
  BB6 {
    _15 <- _16 < _17;
    switch (_15)
      | False -> goto BB13
      | _ -> goto BB7
      end
  }
  BB7 {
    _23 <-  * v_1;
    assume { Resolve2.resolve _24 };
    _24 <- j_12;
    _22 <- Index0.index _23 _24;
    goto BB8
  }
  BB8 {
    assume { Resolve2.resolve _21 };
    _21 <- (let (a, _) = _22 in a);
    assume { Resolve3.resolve _22 };
    _27 <-  * v_1;
    assume { Resolve2.resolve _28 };
    _28 <- max_11;
    _26 <- Index0.index _27 _28;
    goto BB9
  }
  BB9 {
    assume { Resolve2.resolve _25 };
    _25 <- (let (a, _) = _26 in a);
    assume { Resolve3.resolve _26 };
    _20 <- _21 > _25;
    switch (_20)
      | False -> goto BB11
      | _ -> goto BB10
      end
  }
  BB10 {
    assume { Resolve2.resolve max_11 };
    assume { Resolve2.resolve _29 };
    _29 <- j_12;
    assume { Resolve2.resolve max_11 };
    max_11 <- _29;
    _19 <- ();
    assume { Resolve4.resolve _19 };
    goto BB12
  }
  BB11 {
    _19 <- ();
    assume { Resolve4.resolve _19 };
    goto BB12
  }
  BB12 {
    j_12 <- j_12 + (1 : usize);
    _6 <- ();
    assume { Resolve4.resolve _6 };
    goto BB5
  }
  BB13 {
    assume { Resolve2.resolve j_12 };
    _14 <- ();
    assume { Resolve4.resolve _14 };
    _34 <- borrow_mut ( * v_1);
    v_1 <- { v_1 with current = ( ^ _34) };
    assume { Resolve2.resolve _35 };
    _35 <- i_2;
    assume { Resolve2.resolve _36 };
    _36 <- max_11;
    assume { Resolve2.resolve max_11 };
    _33 <- Swap0.swap _34 _35 _36;
    goto BB14
  }
  BB14 {
    i_2 <- i_2 + (1 : usize);
    _6 <- ();
    assume { Resolve4.resolve _6 };
    goto BB2
  }
  BB15 {
    assume { Resolve5.resolve v_1 };
    assume { Resolve2.resolve i_2 };
    _0 <- ();
    return _0
  }
  
end
module Lib_Decision_Impl0_New_Interface
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicDecision_Impl0_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_decision_decisions
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) }
    
end
module Lib_Decision_Impl0_New
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model5.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = usize
  clone Lib_Logic_LogicDecision_Impl0_Invariant as Invariant1 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model4 with function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant2.invariant', function Model1.model = Model5.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model4.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicUtil_SortedRangeRev as SortedRangeRev0
  clone Lib_Logic_LogicUtil_SortedRev as SortedRev0 with predicate SortedRangeRev0.sorted_range_rev = SortedRangeRev0.sorted_range_rev
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = (usize, usize)
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize)
  clone CreusotContracts_Logic_Seq_Impl1_PermutationOf as PermutationOf0 with type t = (usize, usize)
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve6 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy3 with type t = (usize, usize)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve12 with type t1 = usize, type t2 = usize,
  predicate Resolve0.resolve = Resolve0.resolve, predicate Resolve1.resolve = Resolve0.resolve
  clone CreusotContracts_Logic_Model_Impl0_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index3 with type t = (usize, usize),
  function Model0.model = Model11.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model3.model
  clone Lib_Util_SortReverse_Interface as SortReverse0 with function Model0.model = Model3.model,
  function Model1.model = Model10.model, predicate PermutationOf0.permutation_of = PermutationOf0.permutation_of,
  predicate SortedRev0.sorted_rev = SortedRev0.sorted_rev
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut1 with type t = (usize, usize),
  function Model0.model = Model3.model, function Model1.model = Model10.model
  clone CreusotContracts_Std1_Vec_Impl5_Resolve as Resolve11 with type t = (usize, usize),
  function Model0.model = Model3.model, predicate Resolve0.resolve = Resolve12.resolve
  clone CreusotContracts_Std1_Vec_FromElem_Interface as FromElem1 with type t = (usize, usize),
  function Model0.model = Model3.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model7 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_lit_lit,
  function Model0.model = Model7.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len1 with type t = Type.lib_lit_lit,
  function Model0.model = Model7.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = usize,
  function Model0.model = Model1.model, function Model1.model = Model9.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model8 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index2 with type t = usize,
  function Model0.model = Model8.model
  clone CreusotContracts_Std1_Vec_Impl5_Resolve as Resolve10 with type t = usize, function Model0.model = Model1.model,
  predicate Resolve0.resolve = Resolve0.resolve
  clone CreusotContracts_Std1_Vec_FromElem_Interface as FromElem0 with type t = usize,
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model6 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_clause_clause,
  function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_clause_clause,
  function Model0.model = Model6.model
  let rec cfg new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_decision_decisions
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) }
    
   = 
  var _0 : Type.lib_decision_decisions;
  var f_1 : Type.lib_formula_formula;
  var lit_order_2 : Type.creusotcontracts_std1_vec_vec usize;
  var _3 : usize;
  var counts_4 : Type.creusotcontracts_std1_vec_vec usize;
  var _5 : usize;
  var counts_with_index_6 : Type.creusotcontracts_std1_vec_vec (usize, usize);
  var _7 : (usize, usize);
  var _8 : usize;
  var i_9 : usize;
  var _10 : ();
  var _11 : ();
  var _12 : bool;
  var _13 : usize;
  var _14 : usize;
  var _15 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var curr_clause_16 : Type.lib_clause_clause;
  var _17 : Type.lib_clause_clause;
  var _18 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _19 : usize;
  var j_20 : usize;
  var _21 : ();
  var _22 : bool;
  var _23 : usize;
  var _24 : usize;
  var _25 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _26 : ();
  var _27 : bool;
  var _28 : usize;
  var _29 : usize;
  var _30 : Type.creusotcontracts_std1_vec_vec usize;
  var _31 : usize;
  var _32 : Type.lib_lit_lit;
  var _33 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _34 : usize;
  var _35 : usize;
  var _36 : borrowed usize;
  var _37 : borrowed (Type.creusotcontracts_std1_vec_vec usize);
  var _38 : usize;
  var _39 : Type.lib_lit_lit;
  var _40 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _41 : usize;
  var _42 : ();
  var _43 : ();
  var _44 : ();
  var _45 : ();
  var _46 : ();
  var _47 : ();
  var _48 : ();
  var _49 : bool;
  var _50 : usize;
  var _51 : usize;
  var _52 : usize;
  var _53 : usize;
  var _54 : Type.creusotcontracts_std1_vec_vec usize;
  var _55 : usize;
  var _56 : usize;
  var _57 : borrowed (usize, usize);
  var _58 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize));
  var _59 : usize;
  var _60 : ();
  var _61 : ();
  var _62 : ();
  var _63 : ();
  var _64 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize));
  var _65 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize));
  var _66 : ();
  var _67 : ();
  var _68 : bool;
  var _69 : usize;
  var _70 : usize;
  var _71 : usize;
  var _72 : (usize, usize);
  var _73 : Type.creusotcontracts_std1_vec_vec (usize, usize);
  var _74 : usize;
  var _75 : borrowed usize;
  var _76 : borrowed (Type.creusotcontracts_std1_vec_vec usize);
  var _77 : usize;
  var _78 : ();
  var _79 : ();
  var _80 : ();
  var _81 : Type.creusotcontracts_std1_vec_vec usize;
  {
    f_1 <- f;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _3 };
    _3 <- Type.lib_formula_formula_Formula_num_vars f_1;
    lit_order_2 <- FromElem0.from_elem (0 : usize) _3;
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _5 };
    _5 <- Type.lib_formula_formula_Formula_num_vars f_1;
    counts_4 <- FromElem0.from_elem (0 : usize) _5;
    goto BB2
  }
  BB2 {
    _7 <- ((0 : usize), (0 : usize));
    assume { Resolve0.resolve _8 };
    _8 <- Type.lib_formula_formula_Formula_num_vars f_1;
    counts_with_index_6 <- FromElem1.from_elem _7 _8;
    goto BB3
  }
  BB3 {
    i_9 <- (0 : usize);
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    invariant i_bound { UInt64.to_int i_9 <= Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f_1)) };
    invariant counts_len1 { Seq.length (Model1.model counts_4) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    assume { Resolve0.resolve _13 };
    _13 <- i_9;
    _15 <- Type.lib_formula_formula_Formula_clauses f_1;
    _14 <- Len0.len _15;
    goto BB6
  }
  BB6 {
    _12 <- _13 < _14;
    switch (_12)
      | False -> goto BB21
      | _ -> goto BB7
      end
  }
  BB7 {
    _18 <- Type.lib_formula_formula_Formula_clauses f_1;
    assume { Resolve0.resolve _19 };
    _19 <- i_9;
    _17 <- Index0.index _18 _19;
    goto BB8
  }
  BB8 {
    curr_clause_16 <- _17;
    assume { Resolve1.resolve _17 };
    j_20 <- (0 : usize);
    goto BB9
  }
  BB9 {
    goto BB10
  }
  BB10 {
    invariant i_bound2 { UInt64.to_int i_9 <= Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f_1)) };
    invariant j_bound { UInt64.to_int j_20 <= Seq.length (Model2.model (Type.lib_clause_clause_Clause_rest curr_clause_16)) };
    invariant counts_len { Seq.length (Model1.model counts_4) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    assume { Resolve0.resolve _23 };
    _23 <- j_20;
    _25 <- Type.lib_clause_clause_Clause_rest curr_clause_16;
    _24 <- Len1.len _25;
    goto BB11
  }
  BB11 {
    _22 <- _23 < _24;
    switch (_22)
      | False -> goto BB20
      | _ -> goto BB12
      end
  }
  BB12 {
    _30 <- counts_4;
    _33 <- Type.lib_clause_clause_Clause_rest curr_clause_16;
    assume { Resolve0.resolve _34 };
    _34 <- j_20;
    _32 <- Index1.index _33 _34;
    goto BB13
  }
  BB13 {
    assume { Resolve0.resolve _31 };
    _31 <- Type.lib_lit_lit_Lit_idx _32;
    assume { Resolve2.resolve _32 };
    _29 <- Index2.index _30 _31;
    goto BB14
  }
  BB14 {
    assume { Resolve0.resolve _28 };
    _28 <- _29;
    assume { Resolve3.resolve _29 };
    _35 <- (18446744073709551615 : usize) - (1 : usize);
    _27 <- _28 < _35;
    switch (_27)
      | False -> goto BB18
      | _ -> goto BB15
      end
  }
  BB15 {
    _37 <- borrow_mut counts_4;
    counts_4 <-  ^ _37;
    _40 <- Type.lib_clause_clause_Clause_rest curr_clause_16;
    assume { Resolve0.resolve _41 };
    _41 <- j_20;
    _39 <- Index1.index _40 _41;
    goto BB16
  }
  BB16 {
    assume { Resolve0.resolve _38 };
    _38 <- Type.lib_lit_lit_Lit_idx _39;
    assume { Resolve2.resolve _39 };
    _36 <- IndexMut0.index_mut _37 _38;
    goto BB17
  }
  BB17 {
    _36 <- { _36 with current = ( * _36 + (1 : usize)) };
    assume { Resolve4.resolve _36 };
    _26 <- ();
    assume { Resolve5.resolve _26 };
    goto BB19
  }
  BB18 {
    _26 <- ();
    assume { Resolve5.resolve _26 };
    goto BB19
  }
  BB19 {
    j_20 <- j_20 + (1 : usize);
    _11 <- ();
    assume { Resolve5.resolve _11 };
    goto BB10
  }
  BB20 {
    assume { Resolve1.resolve curr_clause_16 };
    assume { Resolve0.resolve j_20 };
    _21 <- ();
    assume { Resolve5.resolve _21 };
    i_9 <- i_9 + (1 : usize);
    _11 <- ();
    assume { Resolve5.resolve _11 };
    goto BB5
  }
  BB21 {
    assume { Resolve0.resolve i_9 };
    _10 <- ();
    assume { Resolve5.resolve _10 };
    i_9 <- (0 : usize);
    goto BB22
  }
  BB22 {
    goto BB23
  }
  BB23 {
    goto BB24
  }
  BB24 {
    invariant i_bound { UInt64.to_int i_9 <= UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    invariant counts_with_idx_len { Seq.length (Model3.model counts_with_index_6) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    invariant second_ok { forall j : (int) . 0 <= j && j < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) -> UInt64.to_int (let (_, a) = Seq.get (Model3.model counts_with_index_6) j in a) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    assume { Resolve0.resolve _50 };
    _50 <- i_9;
    assume { Resolve0.resolve _51 };
    _51 <- Type.lib_formula_formula_Formula_num_vars f_1;
    _49 <- _50 < _51;
    switch (_49)
      | False -> goto BB28
      | _ -> goto BB25
      end
  }
  BB25 {
    _54 <- counts_4;
    assume { Resolve0.resolve _55 };
    _55 <- i_9;
    _53 <- Index2.index _54 _55;
    goto BB26
  }
  BB26 {
    assume { Resolve0.resolve _52 };
    _52 <- _53;
    assume { Resolve3.resolve _53 };
    assume { Resolve0.resolve _56 };
    _56 <- i_9;
    _58 <- borrow_mut counts_with_index_6;
    counts_with_index_6 <-  ^ _58;
    assume { Resolve0.resolve _59 };
    _59 <- i_9;
    _57 <- IndexMut1.index_mut _58 _59;
    goto BB27
  }
  BB27 {
    _57 <- { _57 with current = (_52, _56) };
    assume { Resolve6.resolve _57 };
    i_9 <- i_9 + (1 : usize);
    _11 <- ();
    assume { Resolve5.resolve _11 };
    goto BB24
  }
  BB28 {
    assume { Resolve0.resolve i_9 };
    _48 <- ();
    assume { Resolve5.resolve _48 };
    _65 <- borrow_mut counts_with_index_6;
    counts_with_index_6 <-  ^ _65;
    _64 <- borrow_mut ( * _65);
    _65 <- { _65 with current = ( ^ _64) };
    _63 <- SortReverse0.sort_reverse _64;
    goto BB29
  }
  BB29 {
    assume { Resolve7.resolve _65 };
    assert { forall j : (int) . 0 <= j && j < Seq.length (Model3.model counts_with_index_6) -> UInt64.to_int (let (_, a) = Seq.get (Model3.model counts_with_index_6) j in a) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    goto BB30
  }
  BB30 {
    _66 <- ();
    assume { Resolve5.resolve _66 };
    i_9 <- (0 : usize);
    goto BB31
  }
  BB31 {
    goto BB32
  }
  BB32 {
    goto BB33
  }
  BB33 {
    invariant i_bound { 0 <= UInt64.to_int i_9 && UInt64.to_int i_9 <= UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    invariant lit_order_len { Seq.length (Model1.model lit_order_2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    invariant second_ok { forall j : (int) . 0 <= j && j < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) -> UInt64.to_int (Seq.get (Model1.model lit_order_2) j) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    assume { Resolve0.resolve _69 };
    _69 <- i_9;
    assume { Resolve0.resolve _70 };
    _70 <- Type.lib_formula_formula_Formula_num_vars f_1;
    _68 <- _69 < _70;
    switch (_68)
      | False -> goto BB37
      | _ -> goto BB34
      end
  }
  BB34 {
    _73 <- counts_with_index_6;
    assume { Resolve0.resolve _74 };
    _74 <- i_9;
    _72 <- Index3.index _73 _74;
    goto BB35
  }
  BB35 {
    assume { Resolve0.resolve _71 };
    _71 <- (let (_, a) = _72 in a);
    assume { Resolve8.resolve _72 };
    _76 <- borrow_mut lit_order_2;
    lit_order_2 <-  ^ _76;
    assume { Resolve0.resolve _77 };
    _77 <- i_9;
    _75 <- IndexMut0.index_mut _76 _77;
    goto BB36
  }
  BB36 {
    assume { Resolve0.resolve ( * _75) };
    _75 <- { _75 with current = _71 };
    assume { Resolve4.resolve _75 };
    i_9 <- i_9 + (1 : usize);
    _11 <- ();
    assume { Resolve5.resolve _11 };
    goto BB33
  }
  BB37 {
    assume { Resolve9.resolve f_1 };
    assume { Resolve0.resolve i_9 };
    _67 <- ();
    assume { Resolve5.resolve _67 };
    assume { Resolve10.resolve _81 };
    _81 <- lit_order_2;
    _0 <- Type.Lib_Decision_Decisions _81;
    goto BB38
  }
  BB38 {
    goto BB39
  }
  BB39 {
    assume { Resolve11.resolve counts_with_index_6 };
    goto BB40
  }
  BB40 {
    assume { Resolve10.resolve counts_4 };
    goto BB41
  }
  BB41 {
    return _0
  }
  
end
module Lib_Logic_LogicClause_Impl2_Sat_Interface
  use Type
  predicate sat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl2_Sat
  use Type
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    SatInner0.sat_inner self (Model0.model a)
end
module Lib_Lit_Impl0_LitSat_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val lit_sat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Sat0.sat self a }
    
end
module Lib_Lit_Impl0_LitSat
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  use mach.int.UInt64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Model_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = uint8,
  function Model0.model = Model3.model
  let rec cfg lit_sat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Sat0.sat self a }
    
   = 
  var _0 : bool;
  var self_1 : Type.lib_lit_lit;
  var a_2 : Type.lib_assignments_assignments;
  var _3 : uint8;
  var _4 : uint8;
  var _5 : Type.creusotcontracts_std1_vec_vec uint8;
  var _6 : usize;
  var _7 : uint8;
  var _8 : uint8;
  var _9 : Type.creusotcontracts_std1_vec_vec uint8;
  var _10 : usize;
  {
    self_1 <- self;
    a_2 <- a;
    goto BB0
  }
  BB0 {
    switch (Type.lib_lit_lit_Lit_polarity self_1)
      | False -> goto BB1
      | _ -> goto BB2
      end
  }
  BB1 {
    _9 <- Type.lib_assignments_assignments_Assignments_0 a_2;
    assume { Resolve0.resolve a_2 };
    assume { Resolve1.resolve _10 };
    _10 <- Type.lib_lit_lit_Lit_idx self_1;
    assume { Resolve2.resolve self_1 };
    _8 <- Index0.index _9 _10;
    goto BB4
  }
  BB2 {
    _5 <- Type.lib_assignments_assignments_Assignments_0 a_2;
    assume { Resolve0.resolve a_2 };
    assume { Resolve1.resolve _6 };
    _6 <- Type.lib_lit_lit_Lit_idx self_1;
    assume { Resolve2.resolve self_1 };
    _4 <- Index0.index _5 _6;
    goto BB3
  }
  BB3 {
    assume { Resolve3.resolve _3 };
    _3 <- _4;
    assume { Resolve4.resolve _4 };
    _0 <- _3 = (1 : uint8);
    goto BB5
  }
  BB4 {
    assume { Resolve3.resolve _7 };
    _7 <- _8;
    assume { Resolve4.resolve _8 };
    _0 <- _7 = (0 : uint8);
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Lib_Formula_Impl1_IsClauseSat_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicClause_Impl2_Sat_Interface as Sat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val is_clause_sat [@cfg:stackify] (self : Type.lib_formula_formula) (idx : usize) (a : Type.lib_assignments_assignments) : bool
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self))}
    requires {Invariant0.invariant' a self}
    requires {Invariant1.invariant' self}
    ensures { result = Sat0.sat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) (UInt64.to_int idx)) a }
    
end
module Lib_Formula_Impl1_IsClauseSat
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model3 with function Model0.model = Model6.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant0 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model5.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model4 with function Model0.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant2.invariant', function Model1.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model4.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Sat as Sat1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_assignments_assignments
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy3
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Model_Impl0_Model as Model9 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model8 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_lit_lit,
  function Model0.model = Model8.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_lit_lit,
  function Model0.model = Model8.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model7 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_clause_clause,
  function Model0.model = Model7.model
  clone Lib_Lit_Impl0_LitSat_Interface as LitSat0 with function Model0.model = Model9.model,
  predicate Invariant0.invariant' = Invariant3.invariant', predicate Sat0.sat = Sat0.sat
  let rec cfg is_clause_sat [@cfg:stackify] (self : Type.lib_formula_formula) (idx : usize) (a : Type.lib_assignments_assignments) : bool
    requires {UInt64.to_int idx < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses self))}
    requires {Invariant0.invariant' a self}
    requires {Invariant1.invariant' self}
    ensures { result = Sat1.sat (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses self)) (UInt64.to_int idx)) a }
    
   = 
  var _0 : bool;
  var self_1 : Type.lib_formula_formula;
  var idx_2 : usize;
  var a_3 : Type.lib_assignments_assignments;
  var _4 : ();
  var clause_5 : Type.lib_clause_clause;
  var _6 : Type.lib_clause_clause;
  var _7 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _8 : usize;
  var i_9 : usize;
  var _10 : ();
  var _11 : ();
  var _12 : bool;
  var _13 : usize;
  var _14 : usize;
  var _15 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _16 : ();
  var _17 : bool;
  var _18 : Type.lib_lit_lit;
  var _19 : Type.lib_lit_lit;
  var _20 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _21 : usize;
  var _22 : Type.lib_assignments_assignments;
  var _23 : ();
  var _24 : ();
  var _25 : ();
  var _26 : ();
  {
    self_1 <- self;
    idx_2 <- idx;
    a_3 <- a;
    goto BB0
  }
  BB0 {
    _7 <- Type.lib_formula_formula_Formula_clauses self_1;
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve _8 };
    _8 <- idx_2;
    assume { Resolve1.resolve idx_2 };
    _6 <- Index0.index _7 _8;
    goto BB1
  }
  BB1 {
    clause_5 <- _6;
    assume { Resolve2.resolve _6 };
    i_9 <- (0 : usize);
    goto BB2
  }
  BB2 {
    invariant previous { forall j : (int) . 0 <= j && j < UInt64.to_int i_9 -> not (Sat0.sat (Seq.get (Model0.model clause_5) j) a_3) };
    assume { Resolve1.resolve _13 };
    _13 <- i_9;
    _15 <- Type.lib_clause_clause_Clause_rest clause_5;
    _14 <- Len0.len _15;
    goto BB3
  }
  BB3 {
    _12 <- _13 < _14;
    switch (_12)
      | False -> goto BB9
      | _ -> goto BB4
      end
  }
  BB4 {
    _20 <- Type.lib_clause_clause_Clause_rest clause_5;
    assume { Resolve1.resolve _21 };
    _21 <- i_9;
    _19 <- Index1.index _20 _21;
    goto BB5
  }
  BB5 {
    assume { Resolve3.resolve _18 };
    _18 <- _19;
    assume { Resolve4.resolve _19 };
    _22 <- a_3;
    _17 <- LitSat0.lit_sat _18 _22;
    goto BB6
  }
  BB6 {
    switch (_17)
      | False -> goto BB8
      | _ -> goto BB7
      end
  }
  BB7 {
    assume { Resolve5.resolve a_3 };
    assume { Resolve2.resolve clause_5 };
    assume { Resolve1.resolve i_9 };
    _0 <- true;
    goto BB10
  }
  BB8 {
    _16 <- ();
    assume { Resolve6.resolve _16 };
    i_9 <- i_9 + (1 : usize);
    _11 <- ();
    assume { Resolve6.resolve _11 };
    goto BB2
  }
  BB9 {
    assume { Resolve5.resolve a_3 };
    assume { Resolve2.resolve clause_5 };
    assume { Resolve1.resolve i_9 };
    _10 <- ();
    assume { Resolve6.resolve _10 };
    _0 <- false;
    goto BB10
  }
  BB10 {
    return _0
  }
  
end
module Lib_Logic_LogicWatches_WatchesInvariantInternal_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate watches_invariant_internal (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (n : int) (f : Type.lib_formula_formula)
    
end
module Lib_Logic_LogicWatches_WatchesInvariantInternal
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_watches_watcher
  predicate watches_invariant_internal (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (n : int) (f : Type.lib_formula_formula)
    
   = 
    2 * n = Seq.length w && (forall i : (int) . 0 <= i && i < Seq.length w -> (forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Seq.get w i)) -> UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get (Model0.model (Seq.get w i)) j)) < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses f)) && Seq.length (Model2.model (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get (Model0.model (Seq.get w i)) j))))) > 1))
end
module Lib_Logic_LogicWatches_Impl0_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_watches_watches) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicWatches_Impl0_Invariant
  use Type
  use mach.int.UInt64
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal_Interface as WatchesInvariantInternal0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  predicate invariant' (self : Type.lib_watches_watches) (f : Type.lib_formula_formula) = 
    WatchesInvariantInternal0.watches_invariant_internal (Model0.model (Type.lib_watches_watches_Watches_watches self)) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) f
end
module Lib_Logic_LogicFormula_Impl1_SatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Logic_LogicFormula_Impl1_SatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) -> SatInner0.sat_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) a
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface
  use Type
  predicate eventually_sat_complete_no_ass (self : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  predicate eventually_sat_complete_no_ass (self : Type.lib_formula_formula) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) && CompleteInner0.complete_inner a2 && SatInner0.sat_inner self a2
end
module Lib_Logic_LogicFormula_Impl1_Equisat_Interface
  use Type
  predicate equisat (self : Type.lib_formula_formula) (o : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_Equisat
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  predicate equisat (self : Type.lib_formula_formula) (o : Type.lib_formula_formula) = 
    EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass self = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass o
end
module Lib_Logic_LogicFormula_Compatible_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicFormula_Compatible
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  predicate compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int)) = 
    (let (_, a) = f in a) = (let (_, a) = o in a) && Seq.length (let (a, _) = o in a) >= Seq.length (let (a, _) = f in a) && (forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Equals0.equals (Seq.get (let (a, _) = f in a) i) (Seq.get (let (a, _) = o in a) i))
end
module Lib_Logic_LogicFormula_Equisat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicFormula_Equisat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  predicate equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int)) = 
    EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass o
end
module Lib_Logic_LogicFormula_EquisatCompatibleInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate equisat_compatible_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
    
end
module Lib_Logic_LogicFormula_EquisatCompatibleInner
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_Compatible_Interface as Compatible0
  predicate equisat_compatible_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
    
   = 
    Compatible0.compatible f o && Equisat0.equisat f o
end
module Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface
  use Type
  predicate equisat_compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_EquisatCompatible
  use Type
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner_Interface as EquisatCompatibleInner0
  clone Lib_Logic_LogicFormula_Impl0_Model_Interface as Model0
  predicate equisat_compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula) = 
    EquisatCompatibleInner0.equisat_compatible_inner (Model0.model self) (Model0.model o)
end
module Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  function to_neg_watchidx_logic (self : Type.lib_lit_lit) : int
end
module Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  use mach.int.Int32
  function to_neg_watchidx_logic (self : Type.lib_lit_lit) : int = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then 1 else 0)
end
module Lib_Lit_Impl0_ToNegWatchidx_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic_Interface as ToNegWatchidxLogic0
  val to_neg_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      1
    else
      0
    ) }
    ensures { UInt64.to_int result = ToNegWatchidxLogic0.to_neg_watchidx_logic self }
    
end
module Lib_Lit_Impl0_ToNegWatchidx
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  let rec cfg to_neg_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      1
    else
      0
    ) }
    ensures { UInt64.to_int result = ToNegWatchidxLogic0.to_neg_watchidx_logic self }
    
   = 
  var _0 : usize;
  var self_1 : Type.lib_lit_lit;
  var _2 : usize;
  var _3 : usize;
  var _4 : usize;
  var _5 : bool;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _3 };
    _3 <- Type.lib_lit_lit_Lit_idx self_1;
    _2 <- _3 * (2 : usize);
    assume { Resolve1.resolve _5 };
    _5 <- Type.lib_lit_lit_Lit_polarity self_1;
    assume { Resolve2.resolve self_1 };
    switch (_5)
      | False -> goto BB2
      | _ -> goto BB1
      end
  }
  BB1 {
    _4 <- (1 : usize);
    goto BB3
  }
  BB2 {
    _4 <- (0 : usize);
    goto BB3
  }
  BB3 {
    _0 <- _2 + _4;
    return _0
  }
  
end
module Lib_Watches_Impl0_AddWatcher_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic_Interface as ToNegWatchidxLogic0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val add_watcher [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (lit : Type.lib_lit_lit) (cref : usize) (_f : Type.lib_formula_formula) : ()
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int cref))) > 1}
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic lit < Seq.length (Model2.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < div 18446744073709551615 2}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses _f))}
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model2.model (Type.lib_watches_watches_Watches_watches ( * self))) = Seq.length (Model2.model (Type.lib_watches_watches_Watches_watches ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl0_AddWatcher
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model4.model,
  function Model1.model = Model0.model, function Model2.model = Model1.model
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model2.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve1 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Model_Impl1_Model as Model6 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model4.model, function Model1.model = Model6.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model5 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model2.model, function Model1.model = Model5.model
  clone Lib_Lit_Impl0_ToNegWatchidx_Interface as ToNegWatchidx0 with function ToNegWatchidxLogic0.to_neg_watchidx_logic = ToNegWatchidxLogic0.to_neg_watchidx_logic
  let rec cfg add_watcher [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (lit : Type.lib_lit_lit) (cref : usize) (_f : Type.lib_formula_formula) : ()
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int cref))) > 1}
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic lit < Seq.length (Model2.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < div 18446744073709551615 2}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses _f))}
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model2.model (Type.lib_watches_watches_Watches_watches ( * self))) = Seq.length (Model2.model (Type.lib_watches_watches_Watches_watches ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_watches_watches);
  var lit_2 : Type.lib_lit_lit;
  var cref_3 : usize;
  var _f_4 : Type.lib_formula_formula;
  var _5 : ();
  var _6 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _7 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _8 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)));
  var _9 : usize;
  var _10 : Type.lib_lit_lit;
  var _11 : Type.lib_watches_watcher;
  var _12 : usize;
  {
    self_1 <- self;
    lit_2 <- lit;
    cref_3 <- cref;
    _f_4 <- _f;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _f_4 };
    _8 <- borrow_mut (Type.lib_watches_watches_Watches_watches ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Watches_Watches a =  * self_1 in Type.Lib_Watches_Watches ( ^ _8)) };
    assume { Resolve1.resolve self_1 };
    _10 <- lit_2;
    assume { Resolve2.resolve lit_2 };
    _9 <- ToNegWatchidx0.to_neg_watchidx _10;
    goto BB1
  }
  BB1 {
    _7 <- IndexMut0.index_mut _8 _9;
    goto BB2
  }
  BB2 {
    _6 <- borrow_mut ( * _7);
    _7 <- { _7 with current = ( ^ _6) };
    assume { Resolve3.resolve _12 };
    _12 <- cref_3;
    assume { Resolve3.resolve cref_3 };
    _11 <- Type.Lib_Watches_Watcher _12;
    _5 <- Push0.push _6 _11;
    goto BB3
  }
  BB3 {
    assume { Resolve4.resolve _7 };
    _0 <- ();
    return _0
  }
  
end
module Lib_Formula_Impl1_AddClause_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use seq.Seq
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val add_clause [@cfg:stackify] (self : borrowed (Type.lib_formula_formula)) (clause : Type.lib_clause_clause) (watches : borrowed (Type.lib_watches_watches)) (_t : Type.lib_trail_trail) : usize
    requires {EquisatExtensionInner0.equisat_extension_inner clause (Model0.model self)}
    requires {NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model1.model clause)}
    requires {VarsInRangeInner0.vars_in_range_inner (Model1.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) < div 18446744073709551615 2}
    requires {Seq.length (Model1.model clause) >= 2}
    requires {Invariant0.invariant' ( * watches) ( * self)}
    requires {Invariant1.invariant' _t ( * self)}
    requires {Invariant2.invariant' ( * self)}
    ensures { Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) + 1 = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ self))) }
    ensures { UInt64.to_int result = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) }
    ensures { Equisat0.equisat ( * self) ( ^ self) }
    ensures { EquisatCompatible0.equisat_compatible ( * self) ( ^ self) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ self)) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ self) }
    ensures { Invariant1.invariant' _t ( ^ self) }
    ensures { Invariant2.invariant' ( ^ self) }
    
end
module Lib_Formula_Impl1_AddClause
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model11 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model10 with function Model0.model = Model11.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model10.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant5 with function Model0.model = Model10.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model5 with function Model0.model = Model4.model
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model8.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model3.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model4.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model4.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss1 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss1.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicFormula_Equisat as Equisat1 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model4.model,
  function Model1.model = Model3.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant4 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat1.equisat
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model5.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant6 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant6.invariant',
  function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model4.model,
  predicate Invariant0.invariant' = Invariant6.invariant', function Model1.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model5.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model4.model,
  function Model1.model = Model3.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model9.model,
  function Model1.model = Model4.model, function Model2.model = Model3.model
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model7.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model2 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model10.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model8.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model10.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model8.model, function Model1.model = Model1.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve8 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_formula_formula
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Model_Impl1_Model as Model14 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = Type.lib_clause_clause,
  function Model0.model = Model4.model, function Model1.model = Model14.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model12 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_clause_clause,
  function Model0.model = Model12.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model13 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_lit_lit,
  function Model0.model = Model13.model
  clone Lib_Watches_Impl0_AddWatcher_Interface as AddWatcher0 with function Model0.model = Model4.model,
  function Model1.model = Model3.model,
  function ToNegWatchidxLogic0.to_neg_watchidx_logic = ToNegWatchidxLogic0.to_neg_watchidx_logic,
  function Model2.model = Model7.model, predicate Invariant0.invariant' = Invariant0.invariant'
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_formula_formula),
  function Model0.model = Model0.model
  let rec cfg add_clause [@cfg:stackify] (self : borrowed (Type.lib_formula_formula)) (clause : Type.lib_clause_clause) (watches : borrowed (Type.lib_watches_watches)) (_t : Type.lib_trail_trail) : usize
    requires {EquisatExtensionInner0.equisat_extension_inner clause (Model2.model self)}
    requires {NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model3.model clause)}
    requires {VarsInRangeInner0.vars_in_range_inner (Model3.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) < div 18446744073709551615 2}
    requires {Seq.length (Model3.model clause) >= 2}
    requires {Invariant0.invariant' ( * watches) ( * self)}
    requires {Invariant1.invariant' _t ( * self)}
    requires {Invariant2.invariant' ( * self)}
    ensures { Seq.length (Model4.model (Type.lib_formula_formula_Formula_clauses ( * self))) + 1 = Seq.length (Model4.model (Type.lib_formula_formula_Formula_clauses ( ^ self))) }
    ensures { UInt64.to_int result = Seq.length (Model4.model (Type.lib_formula_formula_Formula_clauses ( * self))) }
    ensures { Equisat0.equisat ( * self) ( ^ self) }
    ensures { EquisatCompatible0.equisat_compatible ( * self) ( ^ self) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ self)) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ self) }
    ensures { Invariant1.invariant' _t ( ^ self) }
    ensures { Invariant2.invariant' ( ^ self) }
    
   = 
  var _0 : usize;
  var self_1 : borrowed (Type.lib_formula_formula);
  var clause_2 : Type.lib_clause_clause;
  var watches_3 : borrowed (Type.lib_watches_watches);
  var _t_4 : Type.lib_trail_trail;
  var old_self_5 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula));
  var _6 : borrowed (Type.lib_formula_formula);
  var _7 : borrowed (Type.lib_formula_formula);
  var cref_8 : usize;
  var _9 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var first_lit_10 : Type.lib_lit_lit;
  var _11 : Type.lib_lit_lit;
  var _12 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var second_lit_13 : Type.lib_lit_lit;
  var _14 : Type.lib_lit_lit;
  var _15 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _16 : ();
  var _17 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _18 : Type.lib_clause_clause;
  var _19 : ();
  var _20 : borrowed (Type.lib_watches_watches);
  var _21 : Type.lib_lit_lit;
  var _22 : usize;
  var _23 : Type.lib_formula_formula;
  var _24 : ();
  var _25 : borrowed (Type.lib_watches_watches);
  var _26 : Type.lib_lit_lit;
  var _27 : usize;
  var _28 : Type.lib_formula_formula;
  var _29 : ();
  var _30 : ();
  var _31 : ();
  {
    self_1 <- self;
    clause_2 <- clause;
    watches_3 <- watches;
    _t_4 <- _t;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _t_4 };
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    _7 <- self_1;
    _6 <- _7;
    assume { Resolve1.resolve _7 };
    old_self_5 <- Record0.record _6;
    goto BB5
  }
  BB5 {
    assume { Resolve2.resolve old_self_5 };
    _9 <- Type.lib_formula_formula_Formula_clauses ( * self_1);
    cref_8 <- Len0.len _9;
    goto BB6
  }
  BB6 {
    _12 <- Type.lib_clause_clause_Clause_rest clause_2;
    _11 <- Index0.index _12 (0 : usize);
    goto BB7
  }
  BB7 {
    assume { Resolve3.resolve first_lit_10 };
    first_lit_10 <- _11;
    assume { Resolve4.resolve _11 };
    _15 <- Type.lib_clause_clause_Clause_rest clause_2;
    _14 <- Index0.index _15 (1 : usize);
    goto BB8
  }
  BB8 {
    assume { Resolve3.resolve second_lit_13 };
    second_lit_13 <- _14;
    assume { Resolve4.resolve _14 };
    _17 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Formula_Formula a b =  * self_1 in Type.Lib_Formula_Formula ( ^ _17) b) };
    assume { Resolve5.resolve _18 };
    _18 <- clause_2;
    _16 <- Push0.push _17 _18;
    goto BB9
  }
  BB9 {
    _20 <- borrow_mut ( * watches_3);
    watches_3 <- { watches_3 with current = ( ^ _20) };
    assume { Resolve3.resolve _21 };
    _21 <- first_lit_10;
    assume { Resolve3.resolve first_lit_10 };
    assume { Resolve6.resolve _22 };
    _22 <- cref_8;
    _23 <-  * self_1;
    _19 <- AddWatcher0.add_watcher _20 _21 _22 _23;
    goto BB10
  }
  BB10 {
    _25 <- borrow_mut ( * watches_3);
    watches_3 <- { watches_3 with current = ( ^ _25) };
    assume { Resolve3.resolve _26 };
    _26 <- second_lit_13;
    assume { Resolve3.resolve second_lit_13 };
    assume { Resolve6.resolve _27 };
    _27 <- cref_8;
    _28 <-  * self_1;
    assume { Resolve7.resolve self_1 };
    _24 <- AddWatcher0.add_watcher _25 _26 _27 _28;
    goto BB11
  }
  BB11 {
    assume { Resolve8.resolve watches_3 };
    assert {  ^ Model0.model old_self_5 =  ^ self_1 };
    _29 <- ();
    assume { Resolve9.resolve _29 };
    assert { EquisatCompatible0.equisat_compatible ( * Model0.model old_self_5) ( * self_1) };
    _30 <- ();
    assume { Resolve9.resolve _30 };
    assert { TrailInvariant0.trail_invariant (Model1.model (Type.lib_trail_trail_Trail_trail _t_4)) ( * self_1) };
    _31 <- ();
    assume { Resolve9.resolve _31 };
    assume { Resolve6.resolve _0 };
    _0 <- cref_8;
    assume { Resolve6.resolve cref_8 };
    goto BB12
  }
  BB12 {
    return _0
  }
  
end
module Lib_Formula_Impl1_AddUnit_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use seq.Seq
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val add_unit [@cfg:stackify] (self : borrowed (Type.lib_formula_formula)) (clause : Type.lib_clause_clause) (_t : Type.lib_trail_trail) : usize
    requires {EquisatExtensionInner0.equisat_extension_inner clause (Model0.model self)}
    requires {NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model1.model clause)}
    requires {VarsInRangeInner0.vars_in_range_inner (Model1.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' clause (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)))}
    requires {Seq.length (Model1.model clause) = 1}
    requires {Invariant1.invariant' _t ( * self)}
    requires {Invariant2.invariant' ( * self)}
    ensures { Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) + 1 = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ self))) }
    ensures { Seq.length (Model1.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ self))) (UInt64.to_int result))) = 1 }
    ensures { UInt64.to_int result = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) }
    ensures { Equisat0.equisat ( * self) ( ^ self) }
    ensures { EquisatCompatible0.equisat_compatible ( * self) ( ^ self) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ self)) }
    ensures { Invariant1.invariant' _t ( ^ self) }
    ensures { Invariant2.invariant' ( ^ self) }
    
end
module Lib_Formula_Impl1_AddUnit
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model8 with function Model0.model = Model9.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model8.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant5 with function Model0.model = Model8.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model5 with function Model0.model = Model4.model
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model7.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model3.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model4.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model4.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss1 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss1.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicFormula_Equisat as Equisat1 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model4.model,
  function Model1.model = Model3.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant4 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat1.equisat
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model5.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model4.model,
  function Model1.model = Model3.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model4.model,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model1.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model5.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model2 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model8.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model7.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model8.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model7.model, function Model1.model = Model1.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Model_Impl1_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = Type.lib_clause_clause,
  function Model0.model = Model4.model, function Model1.model = Model11.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_clause_clause,
  function Model0.model = Model10.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_formula_formula),
  function Model0.model = Model0.model
  let rec cfg add_unit [@cfg:stackify] (self : borrowed (Type.lib_formula_formula)) (clause : Type.lib_clause_clause) (_t : Type.lib_trail_trail) : usize
    requires {EquisatExtensionInner0.equisat_extension_inner clause (Model2.model self)}
    requires {NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model3.model clause)}
    requires {VarsInRangeInner0.vars_in_range_inner (Model3.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' clause (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)))}
    requires {Seq.length (Model3.model clause) = 1}
    requires {Invariant1.invariant' _t ( * self)}
    requires {Invariant2.invariant' ( * self)}
    ensures { Seq.length (Model4.model (Type.lib_formula_formula_Formula_clauses ( * self))) + 1 = Seq.length (Model4.model (Type.lib_formula_formula_Formula_clauses ( ^ self))) }
    ensures { Seq.length (Model3.model (Seq.get (Model4.model (Type.lib_formula_formula_Formula_clauses ( ^ self))) (UInt64.to_int result))) = 1 }
    ensures { UInt64.to_int result = Seq.length (Model4.model (Type.lib_formula_formula_Formula_clauses ( * self))) }
    ensures { Equisat0.equisat ( * self) ( ^ self) }
    ensures { EquisatCompatible0.equisat_compatible ( * self) ( ^ self) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ self)) }
    ensures { Invariant1.invariant' _t ( ^ self) }
    ensures { Invariant2.invariant' ( ^ self) }
    
   = 
  var _0 : usize;
  var self_1 : borrowed (Type.lib_formula_formula);
  var clause_2 : Type.lib_clause_clause;
  var _t_3 : Type.lib_trail_trail;
  var old_self_4 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula));
  var _5 : borrowed (Type.lib_formula_formula);
  var _6 : borrowed (Type.lib_formula_formula);
  var cref_7 : usize;
  var _8 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _9 : ();
  var _10 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _11 : Type.lib_clause_clause;
  var _12 : ();
  var _13 : ();
  var _14 : ();
  {
    self_1 <- self;
    clause_2 <- clause;
    _t_3 <- _t;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _t_3 };
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    goto BB5
  }
  BB5 {
    _6 <- self_1;
    _5 <- _6;
    assume { Resolve1.resolve _6 };
    old_self_4 <- Record0.record _5;
    goto BB6
  }
  BB6 {
    assume { Resolve2.resolve old_self_4 };
    _8 <- Type.lib_formula_formula_Formula_clauses ( * self_1);
    cref_7 <- Len0.len _8;
    goto BB7
  }
  BB7 {
    _10 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Formula_Formula a b =  * self_1 in Type.Lib_Formula_Formula ( ^ _10) b) };
    assume { Resolve3.resolve _11 };
    _11 <- clause_2;
    _9 <- Push0.push _10 _11;
    goto BB8
  }
  BB8 {
    assume { Resolve4.resolve self_1 };
    assert {  ^ Model0.model old_self_4 =  ^ self_1 };
    _12 <- ();
    assume { Resolve5.resolve _12 };
    assert { EquisatCompatible0.equisat_compatible ( * Model0.model old_self_4) ( * self_1) };
    _13 <- ();
    assume { Resolve5.resolve _13 };
    assert { TrailInvariant0.trail_invariant (Model1.model (Type.lib_trail_trail_Trail_trail _t_3)) ( * self_1) };
    _14 <- ();
    assume { Resolve5.resolve _14 };
    assume { Resolve6.resolve _0 };
    _0 <- cref_7;
    assume { Resolve6.resolve cref_7 };
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module Lib_Logic_LogicFormula_Impl1_Sat_Interface
  use Type
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicFormula_Impl1_Sat
  use Type
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicFormula_FormulaSatInner_Interface as FormulaSatInner0
  clone Lib_Logic_LogicFormula_Impl0_Model_Interface as Model1
  predicate sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) = 
    FormulaSatInner0.formula_sat_inner (Model1.model self) (Model0.model a)
  axiom sat_spec : forall self : Type.lib_formula_formula, a : Type.lib_assignments_assignments . sat self a = SatInner0.sat_inner self (Model0.model a)
end
module Lib_Logic_LogicFormula_Impl1_Sat_Impl
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model2.model
  let rec ghost function sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : bool
    ensures { result = SatInner0.sat_inner self (Model0.model a) }
    
   = 
    let a' = Model1.model self in let b' = Model0.model a in FormulaSatInner0.formula_sat_inner a' b'
end
module Lib_Formula_Impl1_IsSat_Interface
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicFormula_Impl1_Sat_Interface as Sat0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant0
  val is_sat [@cfg:stackify] (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' a self}
    requires {Invariant1.invariant' self}
    ensures { result = Sat0.sat self a }
    
end
module Lib_Formula_Impl1_IsSat
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner1 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model2 with function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_Sat as Sat1 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, function Model1.model = Model2.model,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant2.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model2.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_formula_formula
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Logic_Model_Impl0_Model as Model6 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_clause_clause,
  function Model0.model = Model6.model
  clone Lib_Formula_Impl1_IsClauseSat_Interface as IsClauseSat0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate Invariant1.invariant' = Invariant1.invariant',
  predicate Sat0.sat = Sat0.sat, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg is_sat [@cfg:stackify] (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' a self}
    requires {Invariant1.invariant' self}
    ensures { result = Sat1.sat self a }
    
   = 
  var _0 : bool;
  var self_1 : Type.lib_formula_formula;
  var a_2 : Type.lib_assignments_assignments;
  var _3 : ();
  var i_4 : usize;
  var _5 : ();
  var _6 : ();
  var _7 : bool;
  var _8 : usize;
  var _9 : usize;
  var _10 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _11 : ();
  var _12 : bool;
  var _13 : bool;
  var _14 : Type.lib_formula_formula;
  var _15 : usize;
  var _16 : Type.lib_assignments_assignments;
  var _17 : ();
  var _18 : ();
  var _19 : ();
  var _20 : ();
  {
    self_1 <- self;
    a_2 <- a;
    goto BB0
  }
  BB0 {
    i_4 <- (0 : usize);
    goto BB1
  }
  BB1 {
    invariant prev { forall k : (int) . 0 <= k && k < UInt64.to_int i_4 -> Sat0.sat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self_1)) k) a_2 };
    assume { Resolve0.resolve _8 };
    _8 <- i_4;
    _10 <- Type.lib_formula_formula_Formula_clauses self_1;
    _9 <- Len0.len _10;
    goto BB2
  }
  BB2 {
    _7 <- _8 < _9;
    switch (_7)
      | False -> goto BB7
      | _ -> goto BB3
      end
  }
  BB3 {
    _14 <- self_1;
    assume { Resolve0.resolve _15 };
    _15 <- i_4;
    _16 <- a_2;
    _13 <- IsClauseSat0.is_clause_sat _14 _15 _16;
    goto BB4
  }
  BB4 {
    _12 <- not _13;
    switch (_12)
      | False -> goto BB6
      | _ -> goto BB5
      end
  }
  BB5 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve a_2 };
    assume { Resolve0.resolve i_4 };
    _0 <- false;
    goto BB8
  }
  BB6 {
    _11 <- ();
    assume { Resolve3.resolve _11 };
    i_4 <- i_4 + (1 : usize);
    _6 <- ();
    assume { Resolve3.resolve _6 };
    goto BB1
  }
  BB7 {
    assume { Resolve1.resolve self_1 };
    assume { Resolve2.resolve a_2 };
    assume { Resolve0.resolve i_4 };
    _5 <- ();
    assume { Resolve3.resolve _5 };
    _0 <- true;
    goto BB8
  }
  BB8 {
    return _0
  }
  
end
module Lib_Lit_Impl3_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit
end
module Lib_Lit_Impl3_Clone
  use prelude.Prelude
  use Type
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_lit_lit
  let rec cfg clone' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit = 
  var _0 : Type.lib_lit_lit;
  var self_1 : Type.lib_lit_lit;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _0 };
    _0 <- self_1;
    assume { Resolve1.resolve self_1 };
    return _0
  }
  
end
module Lib_Logic_LogicLit_Impl1_Unsat_Interface
  use Type
  predicate unsat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicLit_Impl1_Unsat
  use Type
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unsat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) = 
    UnsatInner0.unsat_inner self (Model0.model a)
end
module Lib_Lit_Impl0_LitUnsat_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val lit_unsat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unsat0.unsat self a }
    
end
module Lib_Lit_Impl0_LitUnsat
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Unsat as Unsat0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  use mach.int.UInt64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Model_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = uint8,
  function Model0.model = Model3.model
  let rec cfg lit_unsat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unsat0.unsat self a }
    
   = 
  var _0 : bool;
  var self_1 : Type.lib_lit_lit;
  var a_2 : Type.lib_assignments_assignments;
  var _3 : uint8;
  var _4 : uint8;
  var _5 : Type.creusotcontracts_std1_vec_vec uint8;
  var _6 : usize;
  var _7 : uint8;
  var _8 : uint8;
  var _9 : Type.creusotcontracts_std1_vec_vec uint8;
  var _10 : usize;
  {
    self_1 <- self;
    a_2 <- a;
    goto BB0
  }
  BB0 {
    switch (Type.lib_lit_lit_Lit_polarity self_1)
      | False -> goto BB1
      | _ -> goto BB2
      end
  }
  BB1 {
    _9 <- Type.lib_assignments_assignments_Assignments_0 a_2;
    assume { Resolve0.resolve a_2 };
    assume { Resolve1.resolve _10 };
    _10 <- Type.lib_lit_lit_Lit_idx self_1;
    assume { Resolve2.resolve self_1 };
    _8 <- Index0.index _9 _10;
    goto BB4
  }
  BB2 {
    _5 <- Type.lib_assignments_assignments_Assignments_0 a_2;
    assume { Resolve0.resolve a_2 };
    assume { Resolve1.resolve _6 };
    _6 <- Type.lib_lit_lit_Lit_idx self_1;
    assume { Resolve2.resolve self_1 };
    _4 <- Index0.index _5 _6;
    goto BB3
  }
  BB3 {
    assume { Resolve3.resolve _3 };
    _3 <- _4;
    assume { Resolve4.resolve _4 };
    _0 <- _3 = (0 : uint8);
    goto BB5
  }
  BB4 {
    assume { Resolve3.resolve _7 };
    _7 <- _8;
    assume { Resolve4.resolve _8 };
    _0 <- _7 = (1 : uint8);
    goto BB5
  }
  BB5 {
    return _0
  }
  
end
module Lib_Logic_LogicLit_Impl1_UnsetInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unset_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8)
end
module Lib_Logic_LogicLit_Impl1_UnsetInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  use mach.int.Int32
  predicate unset_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8) = 
    UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) >= 2
end
module Lib_Logic_LogicLit_Impl1_Unset_Interface
  use Type
  predicate unset (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicLit_Impl1_Unset
  use Type
  clone Lib_Logic_LogicLit_Impl1_UnsetInner_Interface as UnsetInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unset (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) = 
    UnsetInner0.unset_inner self (Model0.model a)
end
module Lib_Lit_Impl0_LitUnset_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_Unset_Interface as Unset0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val lit_unset [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unset0.unset self a }
    
end
module Lib_Lit_Impl0_LitUnset
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Logic_LogicLit_Impl1_Unset as Unset0 with function Model0.model = Model1.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  use mach.int.UInt64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Model_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = uint8,
  function Model0.model = Model3.model
  let rec cfg lit_unset [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unset0.unset self a }
    
   = 
  var _0 : bool;
  var self_1 : Type.lib_lit_lit;
  var a_2 : Type.lib_assignments_assignments;
  var _3 : uint8;
  var _4 : uint8;
  var _5 : Type.creusotcontracts_std1_vec_vec uint8;
  var _6 : usize;
  {
    self_1 <- self;
    a_2 <- a;
    goto BB0
  }
  BB0 {
    _5 <- Type.lib_assignments_assignments_Assignments_0 a_2;
    assume { Resolve0.resolve a_2 };
    assume { Resolve1.resolve _6 };
    _6 <- Type.lib_lit_lit_Lit_idx self_1;
    assume { Resolve2.resolve self_1 };
    _4 <- Index0.index _5 _6;
    goto BB1
  }
  BB1 {
    assume { Resolve3.resolve _3 };
    _3 <- _4;
    assume { Resolve4.resolve _4 };
    _0 <- _3 >= (2 : uint8);
    return _0
  }
  
end
module Lib_Lit_Impl0_LitSet_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_Unset_Interface as Unset0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val lit_set [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = not (Unset0.unset self a) }
    
end
module Lib_Lit_Impl0_LitSet
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Logic_LogicLit_Impl1_Unset as Unset0 with function Model0.model = Model1.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  use mach.int.UInt64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Model_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = uint8,
  function Model0.model = Model3.model
  let rec cfg lit_set [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = not (Unset0.unset self a) }
    
   = 
  var _0 : bool;
  var self_1 : Type.lib_lit_lit;
  var a_2 : Type.lib_assignments_assignments;
  var _3 : uint8;
  var _4 : uint8;
  var _5 : Type.creusotcontracts_std1_vec_vec uint8;
  var _6 : usize;
  {
    self_1 <- self;
    a_2 <- a;
    goto BB0
  }
  BB0 {
    _5 <- Type.lib_assignments_assignments_Assignments_0 a_2;
    assume { Resolve0.resolve a_2 };
    assume { Resolve1.resolve _6 };
    _6 <- Type.lib_lit_lit_Lit_idx self_1;
    assume { Resolve2.resolve self_1 };
    _4 <- Index0.index _5 _6;
    goto BB1
  }
  BB1 {
    assume { Resolve3.resolve _3 };
    _3 <- _4;
    assume { Resolve4.resolve _4 };
    _0 <- _3 < (2 : uint8);
    return _0
  }
  
end
module Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  function to_watchidx_logic (self : Type.lib_lit_lit) : int
end
module Lib_Logic_LogicLit_Impl0_ToWatchidxLogic
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  use mach.int.Int32
  function to_watchidx_logic (self : Type.lib_lit_lit) : int = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then 0 else 1)
end
module Lib_Lit_Impl0_ToWatchidx_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  val to_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      0
    else
      1
    ) }
    ensures { UInt64.to_int result = ToWatchidxLogic0.to_watchidx_logic self }
    
end
module Lib_Lit_Impl0_ToWatchidx
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  let rec cfg to_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      0
    else
      1
    ) }
    ensures { UInt64.to_int result = ToWatchidxLogic0.to_watchidx_logic self }
    
   = 
  var _0 : usize;
  var self_1 : Type.lib_lit_lit;
  var _2 : usize;
  var _3 : usize;
  var _4 : usize;
  var _5 : bool;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _3 };
    _3 <- Type.lib_lit_lit_Lit_idx self_1;
    _2 <- _3 * (2 : usize);
    assume { Resolve1.resolve _5 };
    _5 <- Type.lib_lit_lit_Lit_polarity self_1;
    assume { Resolve2.resolve self_1 };
    switch (_5)
      | False -> goto BB2
      | _ -> goto BB1
      end
  }
  BB1 {
    _4 <- (0 : usize);
    goto BB3
  }
  BB2 {
    _4 <- (1 : usize);
    goto BB3
  }
  BB3 {
    _0 <- _2 + _4;
    return _0
  }
  
end
module Lib_Lit_Impl1_Eq_Interface
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  val eq [@cfg:stackify] (self : Type.lib_lit_lit) (other : Type.lib_lit_lit) : bool
    ensures { result = (Type.lib_lit_lit_Lit_idx self = Type.lib_lit_lit_Lit_idx other && Type.lib_lit_lit_Lit_polarity self = Type.lib_lit_lit_Lit_polarity other) }
    
end
module Lib_Lit_Impl1_Eq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  let rec cfg eq [@cfg:stackify] (self : Type.lib_lit_lit) (other : Type.lib_lit_lit) : bool
    ensures { result = (Type.lib_lit_lit_Lit_idx self = Type.lib_lit_lit_Lit_idx other && Type.lib_lit_lit_Lit_polarity self = Type.lib_lit_lit_Lit_polarity other) }
    
   = 
  var _0 : bool;
  var self_1 : Type.lib_lit_lit;
  var other_2 : Type.lib_lit_lit;
  var _3 : bool;
  var _4 : usize;
  var _5 : usize;
  var _6 : bool;
  var _7 : bool;
  var _8 : bool;
  {
    self_1 <- self;
    other_2 <- other;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _4 };
    _4 <- Type.lib_lit_lit_Lit_idx self_1;
    assume { Resolve0.resolve _5 };
    _5 <- Type.lib_lit_lit_Lit_idx other_2;
    _3 <- _4 = _5;
    switch (_3)
      | False -> goto BB1
      | _ -> goto BB2
      end
  }
  BB1 {
    assume { Resolve2.resolve self_1 };
    assume { Resolve2.resolve other_2 };
    _0 <- false;
    goto BB3
  }
  BB2 {
    assume { Resolve1.resolve _7 };
    _7 <- Type.lib_lit_lit_Lit_polarity self_1;
    assume { Resolve2.resolve self_1 };
    assume { Resolve1.resolve _8 };
    _8 <- Type.lib_lit_lit_Lit_polarity other_2;
    assume { Resolve2.resolve other_2 };
    _6 <- Prelude.eqb _7 _8;
    assume { Resolve1.resolve _0 };
    _0 <- _6;
    goto BB3
  }
  BB3 {
    return _0
  }
  
end
module Lib_Lit_Impl2_Not_Interface
  use mach.int.UInt64
  use Type
  val not' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit
    ensures { Type.lib_lit_lit_Lit_polarity result = not (Type.lib_lit_lit_Lit_polarity self) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx result) = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) }
    
end
module Lib_Lit_Impl2_Not
  use mach.int.UInt64
  use Type
  use mach.int.Int
  use prelude.Prelude
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  let rec cfg not' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit
    ensures { Type.lib_lit_lit_Lit_polarity result = not (Type.lib_lit_lit_Lit_polarity self) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx result) = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) }
    
   = 
  var _0 : Type.lib_lit_lit;
  var self_1 : Type.lib_lit_lit;
  var _2 : usize;
  var _3 : bool;
  var _4 : bool;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _2 };
    _2 <- Type.lib_lit_lit_Lit_idx self_1;
    assume { Resolve1.resolve _4 };
    _4 <- Type.lib_lit_lit_Lit_polarity self_1;
    assume { Resolve2.resolve self_1 };
    _3 <- not _4;
    _0 <- Type.Lib_Lit_Lit _2 _3;
    return _0
  }
  
end
module Lib_Logic_LogicAssignments_AssignmentsEquality_Interface
  use Type
  predicate assignments_equality (a : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicAssignments_AssignmentsEquality
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate assignments_equality (a : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments) = 
    Seq.length (Model0.model a) = Seq.length (Model0.model a2) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model a) -> Seq.get (Model0.model a) i = Seq.get (Model0.model a2) i)
end
module Lib_Logic_LogicAssignments_CompatibleInner_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate compatible_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Lib_Logic_LogicAssignments_CompatibleInner
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  predicate compatible_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8) = 
    Seq.length a = Seq.length a2 && (forall i : (int) . 0 <= i && i < Seq.length a -> Unset0.unset (Seq.get a i) || Seq.get a i = Seq.get a2 i)
end
module Lib_Logic_LogicAssignments_CompatibleCompleteInner_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate compatible_complete_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Lib_Logic_LogicAssignments_CompatibleCompleteInner
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Logic_LogicAssignments_CompatibleInner_Interface as CompatibleInner0
  predicate compatible_complete_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8) = 
    CompatibleInner0.compatible_inner a a2 && CompleteInner0.complete_inner a2
end
module Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  predicate assignments_invariant (a : Seq.seq uint8) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicAssignments_AssignmentsInvariant
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  use mach.int.UInt64
  use mach.int.Int32
  predicate assignments_invariant (a : Seq.seq uint8) (f : Type.lib_formula_formula) = 
    UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a && (forall i : (int) . 0 <= i && i < Seq.length a -> UInt8.to_int (Seq.get a i) <= 3)
end
module Lib_Logic_LogicAssignments_Impl1_Compatible_Interface
  use Type
  predicate compatible (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicAssignments_Impl1_Compatible
  use Type
  clone Lib_Logic_LogicAssignments_CompatibleInner_Interface as CompatibleInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate compatible (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments) = 
    CompatibleInner0.compatible_inner (Model0.model self) (Model0.model a2)
end
module Lib_Logic_LogicAssignments_Impl1_CompatibleComplete_Interface
  use Type
  predicate compatible_complete (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicAssignments_Impl1_CompatibleComplete
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Complete_Interface as Complete0
  clone Lib_Logic_LogicAssignments_Impl1_Compatible_Interface as Compatible0
  predicate compatible_complete (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments) = 
    Compatible0.compatible self a2 && Complete0.complete a2
end
module Lib_Logic_LogicClause_InvariantUnaryOkInternal_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate invariant_unary_ok_internal (s : Seq.seq (Type.lib_lit_lit)) (n : int)
end
module Lib_Logic_LogicClause_InvariantUnaryOkInternal
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  predicate invariant_unary_ok_internal (s : Seq.seq (Type.lib_lit_lit)) (n : int) = 
    VarsInRangeInner0.vars_in_range_inner s n && NoDuplicateIndexesInner0.no_duplicate_indexes_inner s
end
module Lib_Logic_LogicClause_Impl1_NoUnsetInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate no_unset_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl1_NoUnsetInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_UnsetInner_Interface as UnsetInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate no_unset_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) -> not (UnsetInner0.unset_inner (Seq.get (Model0.model self) j) a)
end
module Lib_Logic_LogicClause_Impl1_PostUnit_Interface
  use Type
  predicate post_unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl1_PostUnit
  use Type
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate post_unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    PostUnitInner0.post_unit_inner self (Model0.model a)
end
module Lib_Logic_LogicClause_Impl1_EqAssnInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate eq_assn_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl1_EqAssnInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate eq_assn_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model self) i))) = Seq.get a2 (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model self) i)))
end
module Lib_Logic_LogicClause_Impl2_EquisatExtensionDouble_Interface
  use Type
  predicate equisat_extension_double (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula)
    
end
module Lib_Logic_LogicClause_Impl2_EquisatExtensionDouble
  use Type
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  predicate equisat_extension_double (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula)
    
   = 
    Invariant0.invariant' f && Invariant0.invariant' f2 && UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) && Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) + 1 = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> Equals0.equals (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) i)) && Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) - 1)) = Model1.model self && EquisatCompatible0.equisat_compatible f f2
end
module Lib_Logic_LogicClause_Impl2_ResolventOfIdx2_Interface
  use Type
  use mach.int.Int
  predicate resolvent_of_idx2 (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int) (c_idx : int)
    
end
module Lib_Logic_LogicClause_Impl2_ResolventOfIdx2
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicLit_Impl1_LitIn_Interface as LitIn0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate resolvent_of_idx2 (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int) (c_idx : int)
    
   = 
    (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c2) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c2) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c2) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> LitIn0.lit_in (Seq.get (Model0.model self) i) c || LitIn0.lit_in (Seq.get (Model0.model self) i) c2) && 0 <= c_idx && c_idx < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length (Model0.model c2) && IsOpp0.is_opp (Seq.get (Model0.model c2) k) (Seq.get (Model0.model c) c_idx))
end
module Lib_Logic_LogicClause_Impl2_UnitInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl2_UnitInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_UnsetInner_Interface as UnsetInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl2_VarsInRange_Interface as VarsInRange0
  predicate unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    VarsInRange0.vars_in_range self (Seq.length a) && not (SatInner0.sat_inner self a) && (exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && UnsetInner0.unset_inner (Seq.get (Model0.model self) i) a && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> i -> not (UnsetInner0.unset_inner (Seq.get (Model0.model self) j) a)))
end
module Lib_Logic_LogicClause_Impl2_Unit_Interface
  use Type
  predicate unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl2_Unit
  use Type
  clone Lib_Logic_LogicClause_Impl2_UnitInner_Interface as UnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    UnitInner0.unit_inner self (Model0.model a)
end
module Lib_Logic_LogicClause_Impl2_Unknown_Interface
  use Type
  predicate unknown (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl2_Unknown
  use Type
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicClause_Impl2_Sat_Interface as Sat0
  predicate unknown (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    not (Sat0.sat self a) && not (Unsat0.unsat self a)
end
module Lib_Logic_LogicFormula_Impl1_Compatible_Interface
  use Type
  predicate compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_Compatible
  use Type
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula) = 
    UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars o) && Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses o)) >= Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) -> Equals0.equals (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses o)) i))
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate eventually_sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_CompatibleInner_Interface as CompatibleInner0
  predicate eventually_sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) && CompatibleInner0.compatible_inner a a2 && SatInner0.sat_inner self a2
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate eventually_sat_complete_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_CompatibleCompleteInner_Interface as CompatibleCompleteInner0
  predicate eventually_sat_complete_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) && CompatibleCompleteInner0.compatible_complete_inner a a2 && SatInner0.sat_inner self a2
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatComplete_Interface
  use Type
  predicate eventually_sat_complete (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatComplete
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate eventually_sat_complete (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) = 
    EventuallySatCompleteInner0.eventually_sat_complete_inner self (Model0.model a)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySat_Interface
  use Type
  predicate eventually_sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySat
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatInner_Interface as EventuallySatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate eventually_sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) = 
    EventuallySatInner0.eventually_sat_inner self (Model0.model a)
end
module Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unsat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Logic_LogicFormula_Impl1_UnsatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate unsat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) && UnsatInner0.unsat_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) a
end
module Lib_Logic_LogicFormula_Impl1_Unsat_Interface
  use Type
  predicate unsat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicFormula_Impl1_Unsat
  use Type
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unsat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) = 
    UnsatInner0.unsat_inner self (Model0.model a)
end
module Lib_Logic_LogicLit_Impl1_IdxInTrail_Interface
  use Type
  predicate idx_in_trail (self : Type.lib_lit_lit) (t : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step))
end
module Lib_Logic_LogicLit_Impl1_IdxInTrail
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  predicate idx_in_trail (self : Type.lib_lit_lit) (t : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step)) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model t) && Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get (Model0.model t) i)) = Type.lib_lit_lit_Lit_idx self
end
module Lib_Logic_LogicUtil_Pop_Interface
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq_ext.SeqExt
  function pop (s : Seq.seq t) : Seq.seq t
end
module Lib_Logic_LogicUtil_Pop
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq_ext.SeqExt
  function pop (s : Seq.seq t) : Seq.seq t = 
    SeqExt.subsequence s 0 (Seq.length s - 1)
  axiom pop_spec : forall s : Seq.seq t . Seq.length s > 0 -> pop s = SeqExt.subsequence s 0 (Seq.length s - 1) && Seq.length (pop s) = Seq.length s - 1 && (forall i : (int) . 0 <= i && i < Seq.length (pop s) -> Seq.get (pop s) i = Seq.get s i)
end
module Lib_Logic_LogicUtil_Pop_Impl
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq_ext.SeqExt
  let rec ghost function pop (s : Seq.seq t) : Seq.seq t
    requires {Seq.length s > 0}
    ensures { forall i : (int) . 0 <= i && i < Seq.length result -> Seq.get result i = Seq.get s i }
    ensures { Seq.length result = Seq.length s - 1 }
    ensures { result = SeqExt.subsequence s 0 (Seq.length s - 1) }
    
   = 
    SeqExt.subsequence s 0 (Seq.length s - 1)
end
module Lib_Logic_LogicUtil_LastIdx_Interface
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  function last_idx (s : Seq.seq t) : int
end
module Lib_Logic_LogicUtil_LastIdx
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  function last_idx (s : Seq.seq t) : int = 
    Seq.length s - 1
  axiom last_idx_spec : forall s : Seq.seq t . Seq.length s > 0 -> true
end
module Lib_Logic_LogicUtil_LastIdx_Impl
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  let rec ghost function last_idx (s : Seq.seq t) : int
    requires {Seq.length s > 0}
    
   = 
    Seq.length s - 1
end
module Lib_Logic_LogicUtil_LastElem_Interface
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  function last_elem (s : Seq.seq t) : t
end
module Lib_Logic_LogicUtil_LastElem
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  function last_elem (s : Seq.seq t) : t = 
    Seq.get s (Seq.length s - 1)
  axiom last_elem_spec : forall s : Seq.seq t . Seq.length s > 0 -> true
end
module Lib_Logic_LogicUtil_LastElem_Impl
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  let rec ghost function last_elem (s : Seq.seq t) : t
    requires {Seq.length s > 0}
    
   = 
    Seq.get s (Seq.length s - 1)
end
module Lib_Logic_LogicUtil_LemmaPopMaintainsSorted_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = usize, axiom .
  clone Lib_Logic_LogicUtil_Sorted_Interface as Sorted0
  function lemma_pop_maintains_sorted (s : Seq.seq usize) : ()
end
module Lib_Logic_LogicUtil_LemmaPopMaintainsSorted
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = usize, axiom .
  clone Lib_Logic_LogicUtil_Sorted_Interface as Sorted0
  function lemma_pop_maintains_sorted (s : Seq.seq usize) : () = 
    ()
  axiom lemma_pop_maintains_sorted_spec : forall s : Seq.seq usize . Sorted0.sorted s -> Seq.length s > 0 -> Sorted0.sorted (Pop0.pop s)
end
module Lib_Logic_LogicUtil_LemmaPopMaintainsSorted_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Logic_LogicUtil_Pop as Pop0 with type t = usize, axiom .
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  let rec ghost function lemma_pop_maintains_sorted (s : Seq.seq usize) : ()
    requires {Sorted0.sorted s}
    requires {Seq.length s > 0}
    ensures { Sorted0.sorted (Pop0.pop s) }
    
   = 
    ()
end
module Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface
  use seq.Seq
  use Type
  predicate watcher_crefs_in_range (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicWatches_WatcherCrefsInRange
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate watcher_crefs_in_range (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) = 
    forall j : (int) . 0 <= j && j < Seq.length w -> UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get w j)) < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))
end
module Lib_Logic_LogicWatches_WatchesCrefsInRange_Interface
  use seq.Seq
  use Type
  predicate watches_crefs_in_range (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (f : Type.lib_formula_formula)
    
end
module Lib_Logic_LogicWatches_WatchesCrefsInRange
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_watches_watcher
  predicate watches_crefs_in_range (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (f : Type.lib_formula_formula)
    
   = 
    forall i : (int) . 0 <= i && i < Seq.length w -> WatcherCrefsInRange0.watcher_crefs_in_range (Model0.model (Seq.get w i)) f
end
module Lib_Logic_LogicWatches_LemmaPopWatchMaintainsWatcherInvariant_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_watches_watcher, axiom .
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  function lemma_pop_watch_maintains_watcher_invariant (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_LogicWatches_LemmaPopWatchMaintainsWatcherInvariant
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_watches_watcher, axiom .
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  function lemma_pop_watch_maintains_watcher_invariant (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) : ()
    
   = 
    ()
  axiom lemma_pop_watch_maintains_watcher_invariant_spec : forall w : Seq.seq (Type.lib_watches_watcher), f : Type.lib_formula_formula . WatcherCrefsInRange0.watcher_crefs_in_range w f -> Seq.length w > 0 -> WatcherCrefsInRange0.watcher_crefs_in_range (Pop0.pop w) f
end
module Lib_Logic_LogicWatches_LemmaPopWatchMaintainsWatcherInvariant_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicUtil_Pop as Pop0 with type t = Type.lib_watches_watcher, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model0.model
  let rec ghost function lemma_pop_watch_maintains_watcher_invariant (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) : ()
    requires {WatcherCrefsInRange0.watcher_crefs_in_range w f}
    requires {Seq.length w > 0}
    ensures { WatcherCrefsInRange0.watcher_crefs_in_range (Pop0.pop w) f }
    
   = 
    ()
end
module Lib_Logic_LogicWatches_LemmaPushMaintainsWatcherInvariant_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use Type
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_push_maintains_watcher_invariant (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) (o : Type.lib_watches_watcher) : ()
    
end
module Lib_Logic_LogicWatches_LemmaPushMaintainsWatcherInvariant
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use Type
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_push_maintains_watcher_invariant (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) (o : Type.lib_watches_watcher) : ()
    
   = 
    ()
  axiom lemma_push_maintains_watcher_invariant_spec : forall w : Seq.seq (Type.lib_watches_watcher), f : Type.lib_formula_formula, o : Type.lib_watches_watcher . UInt64.to_int (Type.lib_watches_watcher_Watcher_cref o) < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> WatcherCrefsInRange0.watcher_crefs_in_range w f -> WatcherCrefsInRange0.watcher_crefs_in_range (Seq.snoc w o) f
end
module Lib_Logic_LogicWatches_LemmaPushMaintainsWatcherInvariant_Impl
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model0.model
  let rec ghost function lemma_push_maintains_watcher_invariant (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) (o : Type.lib_watches_watcher) : ()
    requires {UInt64.to_int (Type.lib_watches_watcher_Watcher_cref o) < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {WatcherCrefsInRange0.watcher_crefs_in_range w f}
    ensures { WatcherCrefsInRange0.watcher_crefs_in_range (Seq.snoc w o) f }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_Impl2_InvariantSwap_Interface
  use Type
  predicate invariant_swap (self : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_Impl2_InvariantSwap
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned_Interface as TrailEntriesAreAssigned0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_DecisionsInvariant_Interface as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant_Interface as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = usize
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant0
  predicate invariant_swap (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    Invariant0.invariant' (Type.lib_trail_trail_Trail_assignments self) f && TrailInvariant0.trail_invariant (Model0.model (Type.lib_trail_trail_Trail_trail self)) f && LitToLevelInvariant0.lit_to_level_invariant (Model1.model (Type.lib_trail_trail_Trail_lit_to_level self)) f && DecisionsInvariant0.decisions_invariant (Model1.model (Type.lib_trail_trail_Trail_decisions self)) (Model0.model (Type.lib_trail_trail_Trail_trail self)) && LitNotInLess0.lit_not_in_less self f && LitIsUnique0.lit_is_unique self && LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail self)) f (Model2.model (Type.lib_trail_trail_Trail_assignments self)) && TrailEntriesAreAssigned0.trail_entries_are_assigned self
end
module Lib_Logic_Logic_BoolToAssignedstate_Interface
  use prelude.UInt8
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  function bool_to_assignedstate (b : bool) : uint8
end
module Lib_Logic_Logic_BoolToAssignedstate
  use prelude.UInt8
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  function bool_to_assignedstate (b : bool) : uint8 = 
    if b then (1 : uint8) else (0 : uint8)
  axiom bool_to_assignedstate_spec : forall b : bool . (b -> UInt8.to_int (bool_to_assignedstate b) = 1) && (not b -> UInt8.to_int (bool_to_assignedstate b) = 0)
end
module Lib_Logic_Logic_BoolToAssignedstate_Impl
  use prelude.UInt8
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  let rec ghost function bool_to_assignedstate (b : bool) : uint8
    ensures { not b -> UInt8.to_int result = 0 }
    ensures { b -> UInt8.to_int result = 1 }
    
   = 
    if b then (1 : uint8) else (0 : uint8)
end
module Lib_Logic_LogicTrail_AssignmentsAreInTrail_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate assignments_are_in_trail (t : Seq.seq (Type.lib_trail_step)) (a : Seq.seq uint8)
end
module Lib_Logic_LogicTrail_AssignmentsAreInTrail
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  predicate assignments_are_in_trail (t : Seq.seq (Type.lib_trail_step)) (a : Seq.seq uint8) = 
    forall j : (int) . 0 <= j && j < Seq.length a -> (exists i : (int) . 0 <= i && i < Seq.length t && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get t i))) = j && BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Type.lib_trail_step_Step_lit (Seq.get t i))) = Seq.get a j)
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsTo_Interface
  use Type
  use mach.int.Int
  predicate clause_post_with_regards_to (c : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (j : int)
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsTo
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  predicate clause_post_with_regards_to (c : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (j : int) = 
    PostUnit0.post_unit c a && (exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) = j && Sat0.sat (Seq.get (Model0.model c) i) a)
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsToLit_Interface
  use Type
  predicate clause_post_with_regards_to_lit (c : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit)
    
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsToLit
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  predicate clause_post_with_regards_to_lit (c : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit)
    
   = 
    PostUnit0.post_unit c a && (exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model c) i) = Type.lib_lit_lit_Lit_polarity lit && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) && Sat0.sat (Seq.get (Model0.model c) i) a)
end
module Lib_Logic_LogicTrail_LongArePostUnit_Interface
  use Type
  predicate long_are_post_unit (trail : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_LongArePostUnit
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsTo_Interface as ClausePostWithRegardsTo0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  predicate long_are_post_unit (trail : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail trail)) j)) with
      | Type.Lib_Trail_Reason_Long k -> ClausePostWithRegardsTo0.clause_post_with_regards_to (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Type.lib_trail_trail_Trail_assignments trail) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail trail)) j))))
      | _ -> true
      end
end
module Lib_Logic_LogicTrail_LemmaTrailPost_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  function lemma_trail_post (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) (t : Type.lib_trail_trail) : ()
end
module Lib_Logic_LogicTrail_LemmaTrailPost
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  function lemma_trail_post (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) (t : Type.lib_trail_trail) : () = 
    ()
  axiom lemma_trail_post_spec : forall f : Type.lib_formula_formula, lit : Type.lib_lit_lit, t : Type.lib_trail_trail . Invariant0.invariant' t f -> Invariant1.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> Invariant2.invariant' f -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) && not (LitIdxIn0.lit_idx_in lit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
    | _ -> true
    end) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) && not (LitIdxIn0.lit_idx_in lit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
    | _ -> true
    end)
end
module Lib_Logic_LogicTrail_LemmaTrailPost_Impl
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model6 with function Model0.model = Model7.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model6.model
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model6.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model2 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model1.model,
  function Model1.model = Model6.model
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model1.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model1.model,
  function Model1.model = Model6.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model1.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model4 with function Model0.model = Model1.model
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model6.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model6.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model6.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model4.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model3.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model3.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model2.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model3.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  let rec ghost function lemma_trail_post (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) (t : Type.lib_trail_trail) : ()
    requires {Invariant0.invariant' t f}
    requires {Invariant1.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {Invariant2.invariant' f}
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
      | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) && not (LitIdxIn0.lit_idx_in lit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
      | _ -> true
      end }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
      | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) && not (LitIdxIn0.lit_idx_in lit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
      | _ -> true
      end }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_LemmaTrailOnlyLast_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_only_last (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) (t : Type.lib_trail_trail) : ()
end
module Lib_Logic_LogicTrail_LemmaTrailOnlyLast
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_only_last (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) (t : Type.lib_trail_trail) : ()
   = 
    ()
  axiom lemma_trail_only_last_spec : forall f : Type.lib_formula_formula, lit : Type.lib_lit_lit, t : Type.lib_trail_trail . lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant1.invariant' f -> Invariant2.invariant' t f -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> not (LitIdxIn0.lit_idx_in lit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)))
    | _ -> true
    end)
end
module Lib_Logic_LogicTrail_LemmaTrailOnlyLast_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model5 with function Model0.model = Model7.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant4 with function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model4.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model1.model,
  function Model1.model = Model4.model
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model1.model,
  function Model1.model = Model4.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model1.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model2 with function Model0.model = Model1.model
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model1.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model3.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant3 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant3.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model2.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model5.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model3.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model5.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant2 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model3.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  let rec ghost function lemma_trail_only_last (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) (t : Type.lib_trail_trail) : ()
    requires {lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {LitIsUnique0.lit_is_unique t}
    requires {LitNotInLess0.lit_not_in_less t f}
    requires {Invariant1.invariant' f}
    requires {Invariant2.invariant' t f}
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
      | Type.Lib_Trail_Reason_Long k -> not (LitIdxIn0.lit_idx_in lit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)))
      | _ -> true
      end }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_LemmaTrailFin_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_fin (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
end
module Lib_Logic_LogicTrail_LemmaTrailFin
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone Lib_Logic_LogicTrail_LemmaTrailOnlyLast_Interface as LemmaTrailOnlyLast0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant1.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant2.invariant', predicate Invariant2.invariant' = Invariant0.invariant',
  function Model1.model = Model1.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailPost_Interface as LemmaTrailPost0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Model0.model = Model0.model, function Model1.model = Model1.model, function Model2.model = Model2.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in, axiom .
  function lemma_trail_fin (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : () = 
    let _ = LemmaTrailPost0.lemma_trail_post f lit t in let _ = LemmaTrailOnlyLast0.lemma_trail_only_last f lit t in ()
  axiom lemma_trail_fin_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, lit : Type.lib_lit_lit . lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Invariant0.invariant' t f -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> Invariant1.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant2.invariant' f -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
    | _ -> true
    end) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
    | _ -> true
    end)
end
module Lib_Logic_LogicTrail_LemmaTrailFin_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model6 with function Model0.model = Model7.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model6.model
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model6.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model2 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model1.model,
  function Model1.model = Model6.model
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model1.model,
  function Model1.model = Model6.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model1.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model4 with function Model0.model = Model1.model
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model1.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model6.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model6.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model6.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model4.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model3.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model3.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model2.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model3.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicTrail_LemmaTrailOnlyLast as LemmaTrailOnlyLast0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant1.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant2.invariant', predicate Invariant2.invariant' = Invariant0.invariant',
  function Model1.model = Model1.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailPost as LemmaTrailPost0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Model0.model = Model0.model, function Model1.model = Model1.model, function Model2.model = Model2.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  let rec ghost function lemma_trail_fin (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
    requires {lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1))}
    requires {Invariant0.invariant' t f}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0}
    requires {Invariant1.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {LitIsUnique0.lit_is_unique t}
    requires {LitNotInLess0.lit_not_in_less t f}
    requires {Invariant2.invariant' f}
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
      | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
      | _ -> true
      end }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
      | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
      | _ -> true
      end }
    
   = 
    let _ = LemmaTrailPost0.lemma_trail_post f lit t in let _ = LemmaTrailOnlyLast0.lemma_trail_only_last f lit t in ()
end
module Lib_Logic_LogicTrail_LemmaTrailFin2_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_fin2 (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
end
module Lib_Logic_LogicTrail_LemmaTrailFin2
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone Lib_Logic_LogicTrail_LemmaTrailOnlyLast_Interface as LemmaTrailOnlyLast0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant2.invariant', predicate Invariant2.invariant' = Invariant1.invariant',
  function Model1.model = Model2.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailPost_Interface as LemmaTrailPost0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Model0.model = Model0.model, function Model1.model = Model2.model, function Model2.model = Model1.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in, axiom .
  function lemma_trail_fin2 (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : () = 
    let _ = LemmaTrailPost0.lemma_trail_post f lit t in let _ = LemmaTrailOnlyLast0.lemma_trail_only_last f lit t in ()
  axiom lemma_trail_fin2_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, lit : Type.lib_lit_lit . LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
    | _ -> true
    end) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
    | _ -> true
    end) -> lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant1.invariant' t f -> Invariant2.invariant' f -> LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
end
module Lib_Logic_LogicTrail_LemmaTrailFin2_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model7.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicUtil_Pop as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model5.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model4.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model2.model,
  function Model1.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl0_Model as Model6 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model6.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model2.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model2.model,
  function Model1.model = Model4.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model5.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model5.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicTrail_LemmaTrailOnlyLast as LemmaTrailOnlyLast0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant2.invariant', predicate Invariant2.invariant' = Invariant1.invariant',
  function Model1.model = Model2.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailPost as LemmaTrailPost0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Model0.model = Model0.model, function Model1.model = Model2.model, function Model2.model = Model1.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  let rec ghost function lemma_trail_fin2 (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t))}
    requires {forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
      | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
      | _ -> true
      end}
    requires {forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
      | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
      | _ -> true
      end}
    requires {lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {LitIsUnique0.lit_is_unique t}
    requires {LitNotInLess0.lit_not_in_less t f}
    requires {Invariant1.invariant' t f}
    requires {Invariant2.invariant' f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8)) }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8)) }
    
   = 
    let _ = LemmaTrailPost0.lemma_trail_post f lit t in let _ = LemmaTrailOnlyLast0.lemma_trail_only_last f lit t in ()
end
module Lib_Logic_LogicTrail_LemmaTrailFin3_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_fin3 (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
end
module Lib_Logic_LogicTrail_LemmaTrailFin3
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LemmaTrailFin2_Interface as LemmaTrailFin20 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  function Model2.model = Model2.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate Invariant0.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Pop0.pop = Pop0.pop, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailFin_Interface as LemmaTrailFin0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate Invariant1.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant2.invariant' = Invariant2.invariant', function Model1.model = Model2.model,
  function Model2.model = Model1.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  axiom .
  function lemma_trail_fin3 (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : () = 
    let _ = LemmaTrailFin0.lemma_trail_fin t f lit in let _ = LemmaTrailFin20.lemma_trail_fin2 t f lit in ()
  axiom lemma_trail_fin3_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, lit : Type.lib_lit_lit . LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant1.invariant' t f -> Invariant2.invariant' f -> LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
end
module Lib_Logic_LogicTrail_LemmaTrailFin3_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model6 with function Model0.model = Model7.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model6.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model6.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicUtil_Pop as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model4.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model6.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model3.model,
  function Model1.model = Model6.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl0_Model as Model5 with function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model6.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model5.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model3.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model3.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model3.model,
  function Model1.model = Model6.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model4.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model4.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicTrail_LemmaTrailOnlyLast as LemmaTrailOnlyLast0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant2.invariant', predicate Invariant2.invariant' = Invariant1.invariant',
  function Model1.model = Model3.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailPost as LemmaTrailPost0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Model0.model = Model0.model, function Model1.model = Model3.model, function Model2.model = Model1.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailFin2 as LemmaTrailFin20 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  function Model2.model = Model3.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate Invariant0.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Pop0.pop = Pop0.pop, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function LemmaTrailPost0.lemma_trail_post = LemmaTrailPost0.lemma_trail_post,
  function LemmaTrailOnlyLast0.lemma_trail_only_last = LemmaTrailOnlyLast0.lemma_trail_only_last,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailFin as LemmaTrailFin0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate Invariant1.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant2.invariant' = Invariant2.invariant', function Model1.model = Model3.model,
  function Model2.model = Model1.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function LemmaTrailPost0.lemma_trail_post = LemmaTrailPost0.lemma_trail_post,
  function LemmaTrailOnlyLast0.lemma_trail_only_last = LemmaTrailOnlyLast0.lemma_trail_only_last,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in, axiom .
  let rec ghost function lemma_trail_fin3 (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t))}
    requires {lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {LitIsUnique0.lit_is_unique t}
    requires {LitNotInLess0.lit_not_in_less t f}
    requires {Invariant1.invariant' t f}
    requires {Invariant2.invariant' f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8)) }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8)) }
    
   = 
    let _ = LemmaTrailFin0.lemma_trail_fin t f lit in let _ = LemmaTrailFin20.lemma_trail_fin2 t f lit in ()
end
module Lib_Logic_LogicTrail_LemmaPopNoUnassIsOk_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_pop_no_unass_is_ok (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (l : Type.lib_lit_lit) : ()
    
end
module Lib_Logic_LogicTrail_LemmaPopNoUnassIsOk
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_pop_no_unass_is_ok (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (l : Type.lib_lit_lit) : ()
    
   = 
    ()
  axiom lemma_pop_no_unass_is_ok_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, l : Type.lib_lit_lit . LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> l = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant0.invariant' t f -> LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Model1.model (Type.lib_trail_trail_Trail_assignments t))
end
module Lib_Logic_LogicTrail_LemmaPopNoUnassIsOk_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use mach.int.UInt64
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model6.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model5.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicUtil_Pop as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model4.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant4 with function Model0.model = Model3.model,
  function Model1.model = Model5.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant2 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model3.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model3.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model3.model,
  function Model1.model = Model5.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant1 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model4.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model4.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  let rec ghost function lemma_pop_no_unass_is_ok (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (l : Type.lib_lit_lit) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t))}
    requires {l = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0}
    requires {LitIsUnique0.lit_is_unique t}
    requires {LitNotInLess0.lit_not_in_less t f}
    requires {Invariant0.invariant' t f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Model1.model (Type.lib_trail_trail_Trail_assignments t)) }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_LemmaBacktrackOk_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_backtrack_ok (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (l : Type.lib_lit_lit) : ()
end
module Lib_Logic_LogicTrail_LemmaBacktrackOk
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LemmaTrailFin2_Interface as LemmaTrailFin20 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  function Model2.model = Model2.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate Invariant0.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Pop0.pop = Pop0.pop, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailFin_Interface as LemmaTrailFin0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate Invariant1.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant2.invariant' = Invariant2.invariant', function Model1.model = Model2.model,
  function Model2.model = Model1.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  axiom .
  clone Lib_Logic_LogicTrail_LemmaPopNoUnassIsOk_Interface as LemmaPopNoUnassIsOk0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant0.invariant' = Invariant1.invariant', function Pop0.pop = Pop0.pop, axiom .
  function lemma_backtrack_ok (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (l : Type.lib_lit_lit) : () = 
    let _ = LemmaPopNoUnassIsOk0.lemma_pop_no_unass_is_ok t f l in let _ = LemmaTrailFin0.lemma_trail_fin t f l in let _ = LemmaTrailFin20.lemma_trail_fin2 t f l in ()
  axiom lemma_backtrack_ok_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, l : Type.lib_lit_lit . LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> l = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Invariant0.invariant' l (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant1.invariant' t f -> Invariant2.invariant' f -> LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx l)) (3 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx l)) (2 : uint8))
end
module Lib_Logic_LogicTrail_LemmaBacktrackOk_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model6 with function Model0.model = Model7.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model6.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model6.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicUtil_Pop as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model4.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model6.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model3.model,
  function Model1.model = Model6.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl0_Model as Model5 with function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model6.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model5.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model3.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model3.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model3.model,
  function Model1.model = Model6.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model4.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model4.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicTrail_LemmaTrailOnlyLast as LemmaTrailOnlyLast0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant2.invariant', predicate Invariant2.invariant' = Invariant1.invariant',
  function Model1.model = Model3.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailPost as LemmaTrailPost0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Model0.model = Model0.model, function Model1.model = Model3.model, function Model2.model = Model1.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailFin2 as LemmaTrailFin20 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  function Model2.model = Model3.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate Invariant0.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  function Pop0.pop = Pop0.pop, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function LemmaTrailPost0.lemma_trail_post = LemmaTrailPost0.lemma_trail_post,
  function LemmaTrailOnlyLast0.lemma_trail_only_last = LemmaTrailOnlyLast0.lemma_trail_only_last,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailFin as LemmaTrailFin0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate Invariant1.invariant' = Invariant0.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant2.invariant' = Invariant2.invariant', function Model1.model = Model3.model,
  function Model2.model = Model1.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function LemmaTrailPost0.lemma_trail_post = LemmaTrailPost0.lemma_trail_post,
  function LemmaTrailOnlyLast0.lemma_trail_only_last = LemmaTrailOnlyLast0.lemma_trail_only_last,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in, axiom .
  clone Lib_Logic_LogicTrail_LemmaPopNoUnassIsOk as LemmaPopNoUnassIsOk0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant0.invariant' = Invariant1.invariant', function Pop0.pop = Pop0.pop, axiom .
  let rec ghost function lemma_backtrack_ok (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (l : Type.lib_lit_lit) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t))}
    requires {l = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1))}
    requires {Invariant0.invariant' l (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0}
    requires {LitIsUnique0.lit_is_unique t}
    requires {LitNotInLess0.lit_not_in_less t f}
    requires {Invariant1.invariant' t f}
    requires {Invariant2.invariant' f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx l)) (2 : uint8)) }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx l)) (3 : uint8)) }
    
   = 
    let _ = LemmaPopNoUnassIsOk0.lemma_pop_no_unass_is_ok t f l in let _ = LemmaTrailFin0.lemma_trail_fin t f l in let _ = LemmaTrailFin20.lemma_trail_fin2 t f l in ()
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsLongArePostUnit2_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_assign_maintains_long_are_post_unit2 (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (idx : usize) : ()
    
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsLongArePostUnit2
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_assign_maintains_long_are_post_unit2 (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (idx : usize) : ()
    
   = 
    ()
  axiom lemma_assign_maintains_long_are_post_unit2_spec : forall v : Seq.seq (Type.lib_trail_step), f : Type.lib_formula_formula, a : Type.lib_assignments_assignments, idx : usize . LongArePostUnitInner0.long_are_post_unit_inner v f (Model0.model a) -> Unset0.unset (Seq.get (Model0.model a) (UInt64.to_int idx)) -> UInt64.to_int idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> CrefsInRange0.crefs_in_range v f -> TrailInvariant0.trail_invariant v f -> Invariant0.invariant' f -> Invariant1.invariant' a f -> LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model0.model a) (UInt64.to_int idx) (1 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model0.model a) (UInt64.to_int idx) (0 : uint8))
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsLongArePostUnit2_Impl
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant5 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model4.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant4 with function Model0.model = Model2.model,
  function Model1.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant2 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl0_Model as Model3 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant5.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model3.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant1 with function Model0.model = Model0.model
  let rec ghost function lemma_assign_maintains_long_are_post_unit2 (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (idx : usize) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner v f (Model0.model a)}
    requires {Unset0.unset (Seq.get (Model0.model a) (UInt64.to_int idx))}
    requires {UInt64.to_int idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {CrefsInRange0.crefs_in_range v f}
    requires {TrailInvariant0.trail_invariant v f}
    requires {Invariant0.invariant' f}
    requires {Invariant1.invariant' a f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model0.model a) (UInt64.to_int idx) (0 : uint8)) }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model0.model a) (UInt64.to_int idx) (1 : uint8)) }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_LemmaPostUnitNoUnset_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  clone Lib_Logic_LogicLit_Impl1_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  function lemma_post_unit_no_unset (c : Type.lib_clause_clause) (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_LogicTrail_LemmaPostUnitNoUnset
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  clone Lib_Logic_LogicLit_Impl1_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  function lemma_post_unit_no_unset (c : Type.lib_clause_clause) (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) : ()
    
   = 
    ()
  axiom lemma_post_unit_no_unset_spec : forall c : Type.lib_clause_clause, t : Type.lib_trail_trail, f : Type.lib_formula_formula . PostUnit0.post_unit c (Type.lib_trail_trail_Trail_assignments t) -> Invariant0.invariant' c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) -> not (Unset0.unset (Seq.get (Model0.model c) i) (Type.lib_trail_trail_Trail_assignments t)))
end
module Lib_Logic_LogicTrail_LemmaPostUnitNoUnset_Impl
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Logic_LogicLit_Impl1_Unset as Unset0 with function Model0.model = Model1.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnit as PostUnit0 with function Model0.model = Model1.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  let rec ghost function lemma_post_unit_no_unset (c : Type.lib_clause_clause) (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) : ()
    requires {PostUnit0.post_unit c (Type.lib_trail_trail_Trail_assignments t)}
    requires {Invariant0.invariant' c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) -> not (Unset0.unset (Seq.get (Model0.model c) i) (Type.lib_trail_trail_Trail_assignments t)) }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_LemmaIdxNotInPostUnit_Interface
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_idx_not_in_post_unit (c : Type.lib_clause_clause) (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (idx : int) : ()
    
end
module Lib_Logic_LogicTrail_LemmaIdxNotInPostUnit
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_idx_not_in_post_unit (c : Type.lib_clause_clause) (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (idx : int) : ()
    
   = 
    ()
  axiom lemma_idx_not_in_post_unit_spec : forall c : Type.lib_clause_clause, t : Type.lib_trail_trail, f : Type.lib_formula_formula, idx : int . Unset0.unset (Seq.get (Model0.model (Type.lib_trail_trail_Trail_assignments t)) idx) -> idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> PostUnit0.post_unit c (Type.lib_trail_trail_Trail_assignments t) -> Invariant0.invariant' c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> (forall i : (int) . 0 <= i && i < Seq.length (Model1.model c) -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c) i)) <> idx)
end
module Lib_Logic_LogicTrail_LemmaIdxNotInPostUnit_Impl
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model1.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl1_PostUnit as PostUnit0 with function Model0.model = Model0.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  let rec ghost function lemma_idx_not_in_post_unit (c : Type.lib_clause_clause) (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (idx : int) : ()
    requires {Unset0.unset (Seq.get (Model0.model (Type.lib_trail_trail_Trail_assignments t)) idx)}
    requires {idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {PostUnit0.post_unit c (Type.lib_trail_trail_Trail_assignments t)}
    requires {Invariant0.invariant' c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model1.model c) -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c) i)) <> idx }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_LemmaUnsetToForall_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model3
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_unset_to_forall (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (step : Type.lib_trail_step) : ()
    
end
module Lib_Logic_LogicTrail_LemmaUnsetToForall
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model3
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_unset_to_forall (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (step : Type.lib_trail_step) : ()
    
   = 
    ()
  axiom lemma_unset_to_forall_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, step : Type.lib_trail_step . Unset0.unset (Seq.get (Model0.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)))) -> Invariant0.invariant' step f -> Invariant1.invariant' t f -> (forall i : (int) . 0 <= i && i < Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail t)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model1.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long cref -> forall k : (int) . 0 <= k && k < Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) -> Type.lib_lit_lit_Lit_idx (Seq.get (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) k) <> Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)
    | _ -> true
    end)
end
module Lib_Logic_LogicTrail_LemmaUnsetToForall_Impl
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model3.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model2.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant3 with function Model0.model = Model2.model,
  function Model1.model = Model3.model
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model5.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  predicate Invariant1.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model0.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant4 with function Model0.model = Model0.model
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model5.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model0.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model5.model, function Model1.model = Model1.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  let rec ghost function lemma_unset_to_forall (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (step : Type.lib_trail_step) : ()
    requires {Unset0.unset (Seq.get (Model0.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step))))}
    requires {Invariant0.invariant' step f}
    requires {Invariant1.invariant' t f}
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail t)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model1.model (Type.lib_trail_trail_Trail_trail t)) i)) with
      | Type.Lib_Trail_Reason_Long cref -> forall k : (int) . 0 <= k && k < Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) -> Type.lib_lit_lit_Lit_idx (Seq.get (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) k) <> Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)
      | _ -> true
      end }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_LemmaForallToUnsetPush_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use mach.int.UInt64
  use prelude.Prelude
  clone Lib_Logic_LogicTrail_LitNotInLessInner_Interface as LitNotInLessInner0
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model3
  clone Lib_Logic_LogicTrail_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_forall_to_unset_push (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (step : Type.lib_trail_step) : ()
    
end
module Lib_Logic_LogicTrail_LemmaForallToUnsetPush
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use mach.int.UInt64
  use prelude.Prelude
  clone Lib_Logic_LogicTrail_LitNotInLessInner_Interface as LitNotInLessInner0
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model3
  clone Lib_Logic_LogicTrail_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_forall_to_unset_push (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (step : Type.lib_trail_step) : ()
    
   = 
    ()
  axiom lemma_forall_to_unset_push_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, step : Type.lib_trail_step . (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long cref -> forall k : (int) . 0 <= k && k < Seq.length (Model2.model (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) -> Type.lib_lit_lit_Lit_idx (Seq.get (Model2.model (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) k) <> Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)
    | _ -> true
    end) -> Invariant0.invariant' step f -> Unset0.unset (Seq.get (Model3.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)))) -> Invariant1.invariant' t f -> LitNotInLessInner0.lit_not_in_less_inner (Seq.snoc (Model0.model (Type.lib_trail_trail_Trail_trail t)) step) f
end
module Lib_Logic_LogicTrail_LemmaForallToUnsetPush_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model6.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model3 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant4 with function Model0.model = Model3.model
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model2.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model1.model,
  function Model1.model = Model2.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model1.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant3 with function Model0.model = Model1.model,
  function Model1.model = Model2.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  predicate Invariant1.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model1.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model3.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model6.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model3.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model6.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  let rec ghost function lemma_forall_to_unset_push (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (step : Type.lib_trail_step) : ()
    requires {forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
      | Type.Lib_Trail_Reason_Long cref -> forall k : (int) . 0 <= k && k < Seq.length (Model2.model (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) -> Type.lib_lit_lit_Lit_idx (Seq.get (Model2.model (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) k) <> Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)
      | _ -> true
      end}
    requires {Invariant0.invariant' step f}
    requires {Unset0.unset (Seq.get (Model3.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step))))}
    requires {Invariant1.invariant' t f}
    ensures { LitNotInLessInner0.lit_not_in_less_inner (Seq.snoc (Model0.model (Type.lib_trail_trail_Trail_trail t)) step) f }
    
   = 
    ()
end
module Lib_Logic_LogicTrail_LemmaPushMaintainsLitNotInLess_Interface
  use mach.int.UInt64
  use seq.Seq
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicTrail_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LitNotInLessInner_Interface as LitNotInLessInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_push_maintains_lit_not_in_less (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (step : Type.lib_trail_step) : ()
    
end
module Lib_Logic_LogicTrail_LemmaPushMaintainsLitNotInLess
  use mach.int.UInt64
  use seq.Seq
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicTrail_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LitNotInLessInner_Interface as LitNotInLessInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model3
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LemmaForallToUnsetPush_Interface as LemmaForallToUnsetPush0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model, function Model2.model = Model3.model,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model3.model = Model1.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant1.invariant' = Invariant1.invariant',
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner, axiom .
  clone Lib_Logic_LogicTrail_LemmaUnsetToForall_Interface as LemmaUnsetToForall0 with function Model0.model = Model1.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', function Model1.model = Model0.model,
  function Model2.model = Model2.model, function Model3.model = Model3.model, axiom .
  function lemma_push_maintains_lit_not_in_less (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (step : Type.lib_trail_step) : ()
    
   = 
    let _ = LemmaUnsetToForall0.lemma_unset_to_forall t f step in let _ = LemmaForallToUnsetPush0.lemma_forall_to_unset_push t f step in ()
  axiom lemma_push_maintains_lit_not_in_less_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, step : Type.lib_trail_step . LitNotInLessInner0.lit_not_in_less_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f -> Invariant0.invariant' step f -> Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)))) -> Invariant1.invariant' t f -> Invariant2.invariant' f -> LitNotInLessInner0.lit_not_in_less_inner (Seq.snoc (Model0.model (Type.lib_trail_trail_Trail_trail t)) step) f
end
module Lib_Logic_LogicTrail_LemmaPushMaintainsLitNotInLess_Impl
  use mach.int.UInt64
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model6 with function Model0.model = Model7.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model6.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model6.model
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model4.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant5 with function Model0.model = Model1.model
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant6 with function Model0.model = Model6.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant6.invariant',
  function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model2.model,
  function Model1.model = Model6.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model5 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant6.invariant', function Model1.model = Model6.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model5.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant4 with function Model0.model = Model2.model,
  function Model1.model = Model6.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant0 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model2.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model4.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model4.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicTrail_LemmaForallToUnsetPush as LemmaForallToUnsetPush0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model, function Model2.model = Model6.model,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model3.model = Model1.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant1.invariant' = Invariant1.invariant',
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner, axiom .
  clone Lib_Logic_LogicTrail_LemmaUnsetToForall as LemmaUnsetToForall0 with function Model0.model = Model1.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', function Model1.model = Model0.model,
  function Model2.model = Model2.model, function Model3.model = Model6.model, axiom .
  let rec ghost function lemma_push_maintains_lit_not_in_less (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (step : Type.lib_trail_step) : ()
    requires {LitNotInLessInner0.lit_not_in_less_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f}
    requires {Invariant0.invariant' step f}
    requires {Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step))))}
    requires {Invariant1.invariant' t f}
    requires {Invariant2.invariant' f}
    ensures { LitNotInLessInner0.lit_not_in_less_inner (Seq.snoc (Model0.model (Type.lib_trail_trail_Trail_trail t)) step) f }
    
   = 
    let _ = LemmaUnsetToForall0.lemma_unset_to_forall t f step in let _ = LemmaForallToUnsetPush0.lemma_forall_to_unset_push t f step in ()
end
module Lib_Logic_Logic_LemmaPermutClauseOk_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicClause_Impl2_Sat_Interface as Sat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_permut_clause_ok (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) : ()
    
end
module Lib_Logic_Logic_LemmaPermutClauseOk
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicClause_Impl2_Sat_Interface as Sat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_permut_clause_ok (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) : ()
    
   = 
    ()
  axiom lemma_permut_clause_ok_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : Type.lib_assignments_assignments . Permut.permut (Model0.model c2) (Model0.model c) 0 (Seq.length (Model0.model c)) -> Sat0.sat c a -> Sat0.sat c2 a
end
module Lib_Logic_Logic_LemmaPermutClauseOk_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Sat as Sat0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  let rec ghost function lemma_permut_clause_ok (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) : ()
    requires {Permut.permut (Model0.model c2) (Model0.model c) 0 (Seq.length (Model0.model c))}
    requires {Sat0.sat c a}
    ensures { Sat0.sat c2 a }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaPermutClauseOk2_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_permut_clause_ok2 (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) : ()
    
end
module Lib_Logic_Logic_LemmaPermutClauseOk2
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_permut_clause_ok2 (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) : ()
    
   = 
    ()
  axiom lemma_permut_clause_ok2_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : Type.lib_assignments_assignments . Permut.permut (Model0.model c2) (Model0.model c) 0 (Seq.length (Model0.model c)) -> Unsat0.unsat c a -> Unsat0.unsat c2 a
end
module Lib_Logic_Logic_LemmaPermutClauseOk2_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  let rec ghost function lemma_permut_clause_ok2 (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) : ()
    requires {Permut.permut (Model0.model c2) (Model0.model c) 0 (Seq.length (Model0.model c))}
    requires {Unsat0.unsat c a}
    ensures { Unsat0.unsat c2 a }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaSwapClauseNoDups_Interface
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_swap_clause_no_dups (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) : ()
end
module Lib_Logic_Logic_LemmaSwapClauseNoDups
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_swap_clause_no_dups (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) : ()
   = 
    ()
  axiom lemma_swap_clause_no_dups_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : int, b : int . NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model0.model c) -> Permut.exchange (Model0.model c2) (Model0.model c) a b -> Seq.length (Model0.model c2) = Seq.length (Model0.model c) -> Seq.length (Model0.model c) >= 2 -> NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model0.model c2)
end
module Lib_Logic_Logic_LemmaSwapClauseNoDups_Impl
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  let rec ghost function lemma_swap_clause_no_dups (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) : ()
    requires {NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model0.model c)}
    requires {Permut.exchange (Model0.model c2) (Model0.model c) a b}
    requires {Seq.length (Model0.model c2) = Seq.length (Model0.model c)}
    requires {Seq.length (Model0.model c) >= 2}
    ensures { NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model0.model c2) }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaSwapMaintainsPostUnit_Interface
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  function lemma_swap_maintains_post_unit (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) (ass : Type.lib_assignments_assignments) : ()
    
end
module Lib_Logic_Logic_LemmaSwapMaintainsPostUnit
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_Logic_LemmaSwapClauseNoDups_Interface as LemmaSwapClauseNoDups0 with function Model0.model = Model0.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  axiom .
  function lemma_swap_maintains_post_unit (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) (ass : Type.lib_assignments_assignments) : ()
    
   = 
    let _ = LemmaSwapClauseNoDups0.lemma_swap_clause_no_dups c c2 a b in ()
  axiom lemma_swap_maintains_post_unit_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : int, b : int, ass : Type.lib_assignments_assignments . PostUnit0.post_unit c ass -> Permut.exchange (Model0.model c2) (Model0.model c) a b -> Seq.length (Model0.model c2) = Seq.length (Model0.model c) -> Seq.length (Model0.model c) >= 2 -> PostUnit0.post_unit c2 ass
end
module Lib_Logic_Logic_LemmaSwapMaintainsPostUnit_Impl
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnit as PostUnit0 with function Model0.model = Model1.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Logic_Logic_LemmaSwapClauseNoDups as LemmaSwapClauseNoDups0 with function Model0.model = Model0.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  axiom .
  let rec ghost function lemma_swap_maintains_post_unit (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) (ass : Type.lib_assignments_assignments) : ()
    requires {PostUnit0.post_unit c ass}
    requires {Permut.exchange (Model0.model c2) (Model0.model c) a b}
    requires {Seq.length (Model0.model c2) = Seq.length (Model0.model c)}
    requires {Seq.length (Model0.model c) >= 2}
    ensures { PostUnit0.post_unit c2 ass }
    
   = 
    let _ = LemmaSwapClauseNoDups0.lemma_swap_clause_no_dups c c2 a b in ()
end
module Lib_Logic_Logic_LemmaSwapMaintainsPostWithRegardsTo_Interface
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner_Interface as ClausePostWithRegardsToInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsTo_Interface as ClausePostWithRegardsTo0
  function lemma_swap_maintains_post_with_regards_to (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) (ass : Type.lib_assignments_assignments) (j : int) : ()
    
end
module Lib_Logic_Logic_LemmaSwapMaintainsPostWithRegardsTo
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner_Interface as ClausePostWithRegardsToInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsTo_Interface as ClausePostWithRegardsTo0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  clone Lib_Logic_Logic_LemmaSwapMaintainsPostUnit_Interface as LemmaSwapMaintainsPostUnit0 with predicate PostUnit0.post_unit = PostUnit0.post_unit,
  function Model0.model = Model0.model, axiom .
  function lemma_swap_maintains_post_with_regards_to (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) (ass : Type.lib_assignments_assignments) (j : int) : ()
    
   = 
    let _ = LemmaSwapMaintainsPostUnit0.lemma_swap_maintains_post_unit c c2 a b ass in ()
  axiom lemma_swap_maintains_post_with_regards_to_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : int, b : int, ass : Type.lib_assignments_assignments, j : int . ClausePostWithRegardsTo0.clause_post_with_regards_to c ass j -> Permut.exchange (Model0.model c2) (Model0.model c) a b -> Seq.length (Model0.model c2) = Seq.length (Model0.model c) -> Seq.length (Model0.model c) >= 2 -> ClausePostWithRegardsTo0.clause_post_with_regards_to c2 ass j && ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner c2 (Model1.model ass) j
end
module Lib_Logic_Logic_LemmaSwapMaintainsPostWithRegardsTo_Impl
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_Logic_LemmaSwapClauseNoDups as LemmaSwapClauseNoDups0 with function Model0.model = Model0.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  axiom .
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnit as PostUnit0 with function Model0.model = Model1.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Logic_Logic_LemmaSwapMaintainsPostUnit as LemmaSwapMaintainsPostUnit0 with predicate PostUnit0.post_unit = PostUnit0.post_unit,
  function Model0.model = Model0.model,
  function LemmaSwapClauseNoDups0.lemma_swap_clause_no_dups = LemmaSwapClauseNoDups0.lemma_swap_clause_no_dups,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  axiom .
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsTo as ClausePostWithRegardsTo0 with predicate PostUnit0.post_unit = PostUnit0.post_unit,
  function Model0.model = Model0.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model0.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  let rec ghost function lemma_swap_maintains_post_with_regards_to (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) (ass : Type.lib_assignments_assignments) (j : int) : ()
    requires {ClausePostWithRegardsTo0.clause_post_with_regards_to c ass j}
    requires {Permut.exchange (Model0.model c2) (Model0.model c) a b}
    requires {Seq.length (Model0.model c2) = Seq.length (Model0.model c)}
    requires {Seq.length (Model0.model c) >= 2}
    ensures { ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner c2 (Model1.model ass) j }
    ensures { ClausePostWithRegardsTo0.clause_post_with_regards_to c2 ass j }
    
   = 
    let _ = LemmaSwapMaintainsPostUnit0.lemma_swap_maintains_post_unit c c2 a b ass in ()
end
module Lib_Logic_Logic_LemmaPermutFormulaOk_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicFormula_Impl1_Sat_Interface as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : ()
    
end
module Lib_Logic_Logic_LemmaPermutFormulaOk
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicFormula_Impl1_Sat_Interface as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : ()
    
   = 
    ()
  axiom lemma_permut_formula_ok_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, a : Type.lib_assignments_assignments . UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> Permut.permut (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Model0.model (Type.lib_formula_formula_Formula_clauses f)) 0 (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))) -> Sat0.sat f a -> Sat0.sat f2 a
end
module Lib_Logic_Logic_LemmaPermutFormulaOk_Impl
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model2 with function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, function Model1.model = Model2.model,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner, axiom .
  let rec ghost function lemma_permut_formula_ok (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : ()
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {Permut.permut (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Model0.model (Type.lib_formula_formula_Formula_clauses f)) 0 (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)))}
    requires {Sat0.sat f a}
    ensures { Sat0.sat f2 a }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaPermutFormulaOk2_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok2 (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : ()
    
end
module Lib_Logic_Logic_LemmaPermutFormulaOk2
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok2 (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : ()
    
   = 
    ()
  axiom lemma_permut_formula_ok2_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, a : Type.lib_assignments_assignments . UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> Permut.permut (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Model0.model (Type.lib_formula_formula_Formula_clauses f)) 0 (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))) -> Unsat0.unsat f a -> Unsat0.unsat f2 a
end
module Lib_Logic_Logic_LemmaPermutFormulaOk2_Impl
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner0 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicFormula_Impl1_Unsat as Unsat0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  let rec ghost function lemma_permut_formula_ok2 (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : ()
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {Permut.permut (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Model0.model (Type.lib_formula_formula_Formula_clauses f)) 0 (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)))}
    requires {Unsat0.unsat f a}
    ensures { Unsat0.unsat f2 a }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaPermutFormulaOkNoAss_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok_no_ass (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) : ()
end
module Lib_Logic_Logic_LemmaPermutFormulaOkNoAss
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok_no_ass (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) : () = 
    ()
  axiom lemma_permut_formula_ok_no_ass_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula . UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> Permut.permut (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Model0.model (Type.lib_formula_formula_Formula_clauses f)) 0 (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))) -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f2
end
module Lib_Logic_Logic_LemmaPermutFormulaOkNoAss_Impl
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  let rec ghost function lemma_permut_formula_ok_no_ass (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) : ()
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {Permut.permut (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Model0.model (Type.lib_formula_formula_Formula_clauses f)) 0 (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)))}
    requires {EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f}
    ensures { EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f2 }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaPermutClauseInFormulaMaintainsSat_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_clause_in_formula_maintains_sat (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (cref : int) : ()
    
end
module Lib_Logic_Logic_LemmaPermutClauseInFormulaMaintainsSat
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_clause_in_formula_maintains_sat (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (cref : int) : ()
    
   = 
    ()
  axiom lemma_permut_clause_in_formula_maintains_sat_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, cref : int . UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> Permut.permut (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) cref)) (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref)) 0 (Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref))) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) && i <> cref -> Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) i) = Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i)) -> Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f2
end
module Lib_Logic_Logic_LemmaPermutClauseInFormulaMaintainsSat_Impl
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  use Type
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  let rec ghost function lemma_permut_clause_in_formula_maintains_sat (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (cref : int) : ()
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {Permut.permut (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) cref)) (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref)) 0 (Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref)))}
    requires {forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) && i <> cref -> Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) i) = Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i)}
    requires {Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f}
    ensures { EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f2 }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaPermutClauseInFormulaMaintainsUnsat_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_clause_in_formula_maintains_unsat (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (cref : int) : ()
    
end
module Lib_Logic_Logic_LemmaPermutClauseInFormulaMaintainsUnsat
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_clause_in_formula_maintains_unsat (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (cref : int) : ()
    
   = 
    ()
  axiom lemma_permut_clause_in_formula_maintains_unsat_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, cref : int . UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> Permut.permut (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) cref)) (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref)) 0 (Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref))) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) && i <> cref -> Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) i) = Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i)) -> Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f) -> not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f2)
end
module Lib_Logic_Logic_LemmaPermutClauseInFormulaMaintainsUnsat_Impl
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  use Type
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  let rec ghost function lemma_permut_clause_in_formula_maintains_unsat (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (cref : int) : ()
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {Permut.permut (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) cref)) (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref)) 0 (Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref)))}
    requires {forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) && i <> cref -> Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) i) = Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i)}
    requires {Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f)}
    ensures { not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f2) }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaSamePol_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept_Interface as SameIdxSamePolarityExcept0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  function lemma_same_pol (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Seq.seq uint8) (idx : int) : ()
    
end
module Lib_Logic_Logic_LemmaSamePol
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept_Interface as SameIdxSamePolarityExcept0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  function lemma_same_pol (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Seq.seq uint8) (idx : int) : ()
    
   = 
    ()
  axiom lemma_same_pol_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : Seq.seq uint8, idx : int . UnsatInner0.unsat_inner c2 a -> (exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) = idx && SatInner0.sat_inner (Seq.get (Model0.model c) i) a) -> Invariant0.invariant' c2 (Seq.length a) -> Invariant0.invariant' c (Seq.length a) -> PostUnitInner0.post_unit_inner c a -> SameIdxSamePolarityExcept0.same_idx_same_polarity_except c2 c idx
end
module Lib_Logic_Logic_LemmaSamePol_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept as SameIdxSamePolarityExcept0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  let rec ghost function lemma_same_pol (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Seq.seq uint8) (idx : int) : ()
    requires {UnsatInner0.unsat_inner c2 a}
    requires {exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) = idx && SatInner0.sat_inner (Seq.get (Model0.model c) i) a}
    requires {Invariant0.invariant' c2 (Seq.length a)}
    requires {Invariant0.invariant' c (Seq.length a)}
    requires {PostUnitInner0.post_unit_inner c a}
    ensures { SameIdxSamePolarityExcept0.same_idx_same_polarity_except c2 c idx }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaResolvedPostAndUnsatIsUnsat_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  function lemma_resolved_post_and_unsat_is_unsat (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (a : Seq.seq uint8) (c_idx : int) (c2_idx : int) : ()
    
end
module Lib_Logic_Logic_LemmaResolvedPostAndUnsatIsUnsat
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  function lemma_resolved_post_and_unsat_is_unsat (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (a : Seq.seq uint8) (c_idx : int) (c2_idx : int) : ()
    
   = 
    ()
  axiom lemma_resolved_post_and_unsat_is_unsat_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, a : Seq.seq uint8, c_idx : int, c2_idx : int . ResolventOf0.resolvent_of c3 c c2 c2_idx c_idx -> 0 <= c2_idx && c2_idx < Seq.length (Model0.model c2) -> 0 <= c_idx && c_idx < Seq.length (Model0.model c) -> UnsatInner0.unsat_inner c2 a -> SatInner0.sat_inner (Seq.get (Model0.model c) c_idx) a -> Invariant0.invariant' c2 (Seq.length a) -> Invariant0.invariant' c (Seq.length a) -> PostUnitInner0.post_unit_inner c a -> UnsatInner0.unsat_inner c3 a
end
module Lib_Logic_Logic_LemmaResolvedPostAndUnsatIsUnsat_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicLit_Impl1_LitIn as LitIn0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf as ResolventOf0 with function Model0.model = Model0.model,
  predicate LitIn0.lit_in = LitIn0.lit_in, predicate IsOpp0.is_opp = IsOpp0.is_opp
  let rec ghost function lemma_resolved_post_and_unsat_is_unsat (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (a : Seq.seq uint8) (c_idx : int) (c2_idx : int) : ()
    requires {ResolventOf0.resolvent_of c3 c c2 c2_idx c_idx}
    requires {0 <= c2_idx && c2_idx < Seq.length (Model0.model c2)}
    requires {0 <= c_idx && c_idx < Seq.length (Model0.model c)}
    requires {UnsatInner0.unsat_inner c2 a}
    requires {SatInner0.sat_inner (Seq.get (Model0.model c) c_idx) a}
    requires {Invariant0.invariant' c2 (Seq.length a)}
    requires {Invariant0.invariant' c (Seq.length a)}
    requires {PostUnitInner0.post_unit_inner c a}
    ensures { UnsatInner0.unsat_inner c3 a }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaExtendingWithEquiExtIsEquiCompat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner_Interface as EquisatCompatibleInner0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  function lemma_extending_with_equi_ext_is_equi_compat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
end
module Lib_Logic_Logic_LemmaExtendingWithEquiExtIsEquiCompat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner_Interface as EquisatCompatibleInner0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  function lemma_extending_with_equi_ext_is_equi_compat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
   = 
    ()
  axiom lemma_extending_with_equi_ext_is_equi_compat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause . EquisatExtensionInner0.equisat_extension_inner c f -> FormulaInvariant0.formula_invariant f -> EquisatCompatibleInner0.equisat_compatible_inner f (Seq.snoc (let (a, _) = f in a) c, let (_, a) = f in a)
end
module Lib_Logic_Logic_LemmaExtendingWithEquiExtIsEquiCompat_Impl
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicFormula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model0.model
  let rec ghost function lemma_extending_with_equi_ext_is_equi_compat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    requires {EquisatExtensionInner0.equisat_extension_inner c f}
    requires {FormulaInvariant0.formula_invariant f}
    ensures { EquisatCompatibleInner0.equisat_compatible_inner f (Seq.snoc (let (a, _) = f in a) c, let (_, a) = f in a) }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaEquisatIsTrans_Interface
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface as EquisatCompatible0
  function lemma_equisat_is_trans (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (f3 : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_Logic_LemmaEquisatIsTrans
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface as EquisatCompatible0
  function lemma_equisat_is_trans (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (f3 : Type.lib_formula_formula) : ()
    
   = 
    ()
  axiom lemma_equisat_is_trans_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, f3 : Type.lib_formula_formula . EquisatCompatible0.equisat_compatible f2 f3 -> EquisatCompatible0.equisat_compatible f f2 -> Invariant0.invariant' f3 -> Invariant0.invariant' f2 -> Invariant0.invariant' f -> EquisatCompatible0.equisat_compatible f f3
end
module Lib_Logic_Logic_LemmaEquisatIsTrans_Impl
  use Type
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicFormula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant1 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant1.invariant', function Model1.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model0.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model0.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  let rec ghost function lemma_equisat_is_trans (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (f3 : Type.lib_formula_formula) : ()
    requires {EquisatCompatible0.equisat_compatible f2 f3}
    requires {EquisatCompatible0.equisat_compatible f f2}
    requires {Invariant0.invariant' f3}
    requires {Invariant0.invariant' f2}
    requires {Invariant0.invariant' f}
    ensures { EquisatCompatible0.equisat_compatible f f3 }
    
   = 
    ()
end
module Lib_Logic_Logic_FlipV_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function flip_v (v : uint8) : uint8
end
module Lib_Logic_Logic_FlipV
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  function flip_v (v : uint8) : uint8 = 
    if UInt8.to_int v = 0 then (1 : uint8) else if UInt8.to_int v = 1 then (0 : uint8) else v
end
module Lib_Logic_Logic_Pos_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function pos () : uint8
end
module Lib_Logic_Logic_Pos
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function pos () : uint8 = 
    (1 : uint8)
end
module Lib_Logic_Logic_Neg_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function neg () : uint8
end
module Lib_Logic_Logic_Neg
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function neg () : uint8 = 
    (0 : uint8)
end
module Lib_Logic_Logic_LemmaCompleteImpliesSatOrUnsat_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  function lemma_complete_implies_sat_or_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_Logic_LemmaCompleteImpliesSatOrUnsat
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  function lemma_complete_implies_sat_or_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : () = 
    ()
  axiom lemma_complete_implies_sat_or_unsat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . CompleteInner0.complete_inner a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> UnsatInner0.unsat_inner f a || SatInner0.sat_inner f a
end
module Lib_Logic_Logic_LemmaCompleteImpliesSatOrUnsat_Impl
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant1 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant1.invariant', function Model1.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model0.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant as AssignmentsInvariant0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  let rec ghost function lemma_complete_implies_sat_or_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
    requires {CompleteInner0.complete_inner a}
    requires {AssignmentsInvariant0.assignments_invariant a f}
    requires {Invariant0.invariant' f}
    ensures { UnsatInner0.unsat_inner f a || SatInner0.sat_inner f a }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaCompleteAndNotSatImpliesUnsat_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  function lemma_complete_and_not_sat_implies_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_Logic_LemmaCompleteAndNotSatImpliesUnsat
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_Logic_LemmaCompleteImpliesSatOrUnsat_Interface as LemmaCompleteImpliesSatOrUnsat0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate AssignmentsInvariant0.assignments_invariant = AssignmentsInvariant0.assignments_invariant,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  function lemma_complete_and_not_sat_implies_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : () = 
    let _ = LemmaCompleteImpliesSatOrUnsat0.lemma_complete_implies_sat_or_unsat f a in ()
  axiom lemma_complete_and_not_sat_implies_unsat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . not (SatInner0.sat_inner f a) -> CompleteInner0.complete_inner a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> UnsatInner0.unsat_inner f a
end
module Lib_Logic_Logic_LemmaCompleteAndNotSatImpliesUnsat_Impl
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant1 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant as AssignmentsInvariant0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model1 with function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant1.invariant', function Model1.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model1.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner0 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_Logic_LemmaCompleteImpliesSatOrUnsat as LemmaCompleteImpliesSatOrUnsat0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate AssignmentsInvariant0.assignments_invariant = AssignmentsInvariant0.assignments_invariant,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  let rec ghost function lemma_complete_and_not_sat_implies_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
    requires {not (SatInner0.sat_inner f a)}
    requires {CompleteInner0.complete_inner a}
    requires {AssignmentsInvariant0.assignments_invariant a f}
    requires {Invariant0.invariant' f}
    ensures { UnsatInner0.unsat_inner f a }
    
   = 
    let _ = LemmaCompleteImpliesSatOrUnsat0.lemma_complete_implies_sat_or_unsat f a in ()
end
module Lib_Logic_Logic_LemmaCompleteAndNotUnsatImpliesSat_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  function lemma_complete_and_not_unsat_implies_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_Logic_LemmaCompleteAndNotUnsatImpliesSat
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_Logic_LemmaCompleteImpliesSatOrUnsat_Interface as LemmaCompleteImpliesSatOrUnsat0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate AssignmentsInvariant0.assignments_invariant = AssignmentsInvariant0.assignments_invariant,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  function lemma_complete_and_not_unsat_implies_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : () = 
    let _ = LemmaCompleteImpliesSatOrUnsat0.lemma_complete_implies_sat_or_unsat f a in ()
  axiom lemma_complete_and_not_unsat_implies_sat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . not (UnsatInner0.unsat_inner f a) -> CompleteInner0.complete_inner a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> SatInner0.sat_inner f a
end
module Lib_Logic_Logic_LemmaCompleteAndNotUnsatImpliesSat_Impl
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant1 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant as AssignmentsInvariant0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model1 with function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant1.invariant', function Model1.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model1.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner0 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_Logic_LemmaCompleteImpliesSatOrUnsat as LemmaCompleteImpliesSatOrUnsat0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate AssignmentsInvariant0.assignments_invariant = AssignmentsInvariant0.assignments_invariant,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  let rec ghost function lemma_complete_and_not_unsat_implies_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
    requires {not (UnsatInner0.unsat_inner f a)}
    requires {CompleteInner0.complete_inner a}
    requires {AssignmentsInvariant0.assignments_invariant a f}
    requires {Invariant0.invariant' f}
    ensures { SatInner0.sat_inner f a }
    
   = 
    let _ = LemmaCompleteImpliesSatOrUnsat0.lemma_complete_implies_sat_or_unsat f a in ()
end
module Lib_Logic_Logic_LemmaNotSatFormulaImpliesUnsatFormula_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  function lemma_not_sat_formula_implies_unsat_formula (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_Logic_LemmaNotSatFormulaImpliesUnsatFormula
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  function lemma_not_sat_formula_implies_unsat_formula (f : Type.lib_formula_formula) (a : Seq.seq uint8) : () = 
    ()
  axiom lemma_not_sat_formula_implies_unsat_formula_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . UnsatInner0.unsat_inner f a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f a)
end
module Lib_Logic_Logic_LemmaNotSatFormulaImpliesUnsatFormula_Impl
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_CompatibleInner as CompatibleInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_CompatibleCompleteInner as CompatibleCompleteInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant1 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant as AssignmentsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner as EventuallySatCompleteInner0 with predicate CompatibleCompleteInner0.compatible_complete_inner = CompatibleCompleteInner0.compatible_complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model1 with function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant1.invariant', function Model1.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model1.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner0 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  let rec ghost function lemma_not_sat_formula_implies_unsat_formula (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
    requires {UnsatInner0.unsat_inner f a}
    requires {AssignmentsInvariant0.assignments_invariant a f}
    requires {Invariant0.invariant' f}
    ensures { not (EventuallySatCompleteInner0.eventually_sat_complete_inner f a) }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaNotSatClauseImpliesUnsatFormula_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl2_InFormula_Interface as InFormula0
  function lemma_not_sat_clause_implies_unsat_formula (f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
    
end
module Lib_Logic_Logic_LemmaNotSatClauseImpliesUnsatFormula
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl2_InFormula_Interface as InFormula0
  function lemma_not_sat_clause_implies_unsat_formula (f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
    
   = 
    ()
  axiom lemma_not_sat_clause_implies_unsat_formula_spec : forall f : Type.lib_formula_formula, c : Type.lib_clause_clause, a : Seq.seq uint8 . InFormula0.in_formula c f -> UnsatInner0.unsat_inner c a -> UnsatInner1.unsat_inner f a
end
module Lib_Logic_Logic_LemmaNotSatClauseImpliesUnsatFormula_Impl
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner1 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_InFormula as InFormula0 with function Model0.model = Model0.model
  let rec ghost function lemma_not_sat_clause_implies_unsat_formula (f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
    requires {InFormula0.in_formula c f}
    requires {UnsatInner0.unsat_inner c a}
    ensures { UnsatInner1.unsat_inner f a }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaUnitForces_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  function lemma_unit_forces (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_Logic_LemmaUnitForces
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_Logic_LemmaNotSatFormulaImpliesUnsatFormula_Interface as LemmaNotSatFormulaImpliesUnsatFormula0 with predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner,
  predicate AssignmentsInvariant0.assignments_invariant = AssignmentsInvariant0.assignments_invariant,
  predicate Invariant0.invariant' = Invariant0.invariant',
  predicate EventuallySatCompleteInner0.eventually_sat_complete_inner = EventuallySatCompleteInner0.eventually_sat_complete_inner,
  axiom .
  function lemma_unit_forces (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
   = 
    let _ = LemmaNotSatFormulaImpliesUnsatFormula0.lemma_not_sat_formula_implies_unsat_formula f a in ()
  axiom lemma_unit_forces_spec : forall c : Type.lib_clause_clause, f : Type.lib_formula_formula, a : Seq.seq uint8, ix : int, v : uint8 . not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (FlipV0.flip_v v))) -> EventuallySatCompleteInner0.eventually_sat_complete_inner f a -> not (Unset0.unset v) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a -> Invariant0.invariant' f -> EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix v)
end
module Lib_Logic_Logic_LemmaUnitForces_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner2
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant1 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant1.invariant', function Model1.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model0.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant as AssignmentsInvariant0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_CompatibleInner as CompatibleInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_CompatibleCompleteInner as CompatibleCompleteInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner as EventuallySatCompleteInner0 with predicate CompatibleCompleteInner0.compatible_complete_inner = CompatibleCompleteInner0.compatible_complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_Logic_LemmaNotSatFormulaImpliesUnsatFormula as LemmaNotSatFormulaImpliesUnsatFormula0 with predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner,
  predicate AssignmentsInvariant0.assignments_invariant = AssignmentsInvariant0.assignments_invariant,
  predicate Invariant0.invariant' = Invariant0.invariant',
  predicate EventuallySatCompleteInner0.eventually_sat_complete_inner = EventuallySatCompleteInner0.eventually_sat_complete_inner,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_Logic_FlipV as FlipV0
  let rec ghost function lemma_unit_forces (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    requires {not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (FlipV0.flip_v v)))}
    requires {EventuallySatCompleteInner0.eventually_sat_complete_inner f a}
    requires {not (Unset0.unset v)}
    requires {0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix)}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a}
    requires {Invariant0.invariant' f}
    ensures { EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix v) }
    
   = 
    let _ = LemmaNotSatFormulaImpliesUnsatFormula0.lemma_not_sat_formula_implies_unsat_formula f a in ()
end
module Lib_Logic_Logic_LemmaCorrectPolarityMakesClauseSat_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone Lib_Logic_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_correct_polarity_makes_clause_sat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_Logic_LemmaCorrectPolarityMakesClauseSat
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone Lib_Logic_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_correct_polarity_makes_clause_sat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
   = 
    ()
  axiom lemma_correct_polarity_makes_clause_sat_spec : forall c : Type.lib_clause_clause, a : Seq.seq uint8, ix : int, v : uint8 . (exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model c) j)) = v) -> 0 <= ix && ix < Seq.length a -> SatInner0.sat_inner c (Seq.set a ix v)
end
module Lib_Logic_Logic_LemmaCorrectPolarityMakesClauseSat_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_Logic_BoolToAssignedstate as BoolToAssignedstate0 with axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  let rec ghost function lemma_correct_polarity_makes_clause_sat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    requires {exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model c) j)) = v}
    requires {0 <= ix && ix < Seq.length a}
    ensures { SatInner0.sat_inner c (Seq.set a ix v) }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaIncorrectPolarityMakesClauseUnsat_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl2_UnitInner_Interface as UnitInner0
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner1
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_incorrect_polarity_makes_clause_unsat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_Logic_LemmaIncorrectPolarityMakesClauseUnsat
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl2_UnitInner_Interface as UnitInner0
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner1
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_incorrect_polarity_makes_clause_unsat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
   = 
    ()
  axiom lemma_incorrect_polarity_makes_clause_unsat_spec : forall c : Type.lib_clause_clause, a : Seq.seq uint8, ix : int, v : uint8 . (forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) && not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix) -> UnsatInner0.unsat_inner (Seq.get (Model0.model c) j) a) -> Invariant0.invariant' c (Seq.length a) -> (exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && SatInner0.sat_inner (Seq.get (Model0.model c) j) a) -> not (SatInner1.sat_inner c a) -> UnitInner0.unit_inner c a -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> not (Unset0.unset v) -> (forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) -> not (Unset0.unset (Seq.get (Seq.set a ix v) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)))))) && not (Unset0.unset (Seq.get (Seq.set a ix (FlipV0.flip_v v)) ix)) && UnsatInner1.unsat_inner c (Seq.set a ix (FlipV0.flip_v v)) && not (SatInner1.sat_inner c (Seq.set a ix (FlipV0.flip_v v)))
end
module Lib_Logic_Logic_LemmaIncorrectPolarityMakesClauseUnsat_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_Logic_FlipV as FlipV0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model0.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl2_UnitInner as UnitInner0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, function Model0.model = Model0.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  let rec ghost function lemma_incorrect_polarity_makes_clause_unsat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    requires {forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) && not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix) -> UnsatInner0.unsat_inner (Seq.get (Model0.model c) j) a}
    requires {Invariant0.invariant' c (Seq.length a)}
    requires {exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && SatInner0.sat_inner (Seq.get (Model0.model c) j) a}
    requires {not (SatInner1.sat_inner c a)}
    requires {UnitInner0.unit_inner c a}
    requires {0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix)}
    requires {not (Unset0.unset v)}
    ensures { not (SatInner1.sat_inner c (Seq.set a ix (FlipV0.flip_v v))) }
    ensures { UnsatInner1.unsat_inner c (Seq.set a ix (FlipV0.flip_v v)) }
    ensures { not (Unset0.unset (Seq.get (Seq.set a ix (FlipV0.flip_v v)) ix)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) -> not (Unset0.unset (Seq.get (Seq.set a ix v) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j))))) }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaUnitWrongPolarityUnsatFormula_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl2_UnitInner_Interface as UnitInner0
  clone Lib_Logic_LogicClause_Impl2_InFormula_Interface as InFormula0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_unit_wrong_polarity_unsat_formula (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_Logic_LemmaUnitWrongPolarityUnsatFormula
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl2_UnitInner_Interface as UnitInner0
  clone Lib_Logic_LogicClause_Impl2_InFormula_Interface as InFormula0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner2
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner1
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_Logic_LemmaNotSatFormulaImpliesUnsatFormula_Interface as LemmaNotSatFormulaImpliesUnsatFormula0 with predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner,
  predicate AssignmentsInvariant0.assignments_invariant = AssignmentsInvariant0.assignments_invariant,
  predicate Invariant0.invariant' = Invariant1.invariant',
  predicate EventuallySatCompleteInner0.eventually_sat_complete_inner = EventuallySatCompleteInner0.eventually_sat_complete_inner,
  axiom .
  clone Lib_Logic_Logic_LemmaNotSatClauseImpliesUnsatFormula_Interface as LemmaNotSatClauseImpliesUnsatFormula0 with predicate InFormula0.in_formula = InFormula0.in_formula,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner,
  predicate UnsatInner1.unsat_inner = UnsatInner1.unsat_inner, axiom .
  clone Lib_Logic_Logic_LemmaIncorrectPolarityMakesClauseUnsat_Interface as LemmaIncorrectPolarityMakesClauseUnsat0 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate SatInner0.sat_inner = SatInner1.sat_inner, predicate SatInner1.sat_inner = SatInner0.sat_inner,
  predicate UnitInner0.unit_inner = UnitInner0.unit_inner, predicate Unset0.unset = Unset0.unset,
  function FlipV0.flip_v = FlipV0.flip_v, predicate UnsatInner1.unsat_inner = UnsatInner2.unsat_inner, axiom .
  clone Lib_Logic_Logic_LemmaCorrectPolarityMakesClauseSat_Interface as LemmaCorrectPolarityMakesClauseSat0 with function Model0.model = Model0.model,
  function BoolToAssignedstate0.bool_to_assignedstate = BoolToAssignedstate0.bool_to_assignedstate,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  function lemma_unit_wrong_polarity_unsat_formula (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
   = 
    let _ = LemmaNotSatFormulaImpliesUnsatFormula0.lemma_not_sat_formula_implies_unsat_formula f a in let _ = LemmaCorrectPolarityMakesClauseSat0.lemma_correct_polarity_makes_clause_sat c a ix v in let _ = LemmaIncorrectPolarityMakesClauseUnsat0.lemma_incorrect_polarity_makes_clause_unsat c a ix v in let _ = LemmaNotSatClauseImpliesUnsatFormula0.lemma_not_sat_clause_implies_unsat_formula f c (Seq.set a ix (FlipV0.flip_v v)) in ()
  axiom lemma_unit_wrong_polarity_unsat_formula_spec : forall c : Type.lib_clause_clause, f : Type.lib_formula_formula, a : Seq.seq uint8, ix : int, v : uint8 . (forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) && not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix) -> UnsatInner0.unsat_inner (Seq.get (Model0.model c) j) a) -> (exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model c) j)) = v) -> Invariant0.invariant' c (Seq.length a) -> InFormula0.in_formula c f -> UnitInner0.unit_inner c a -> not (Unset0.unset v) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a -> Invariant1.invariant' f -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (FlipV0.flip_v v))) && UnsatInner1.unsat_inner f (Seq.set a ix (FlipV0.flip_v v))
end
module Lib_Logic_Logic_LemmaUnitWrongPolarityUnsatFormula_Impl
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant as AssignmentsInvariant0
  clone Lib_Logic_Logic_FlipV as FlipV0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_CompatibleInner as CompatibleInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_CompatibleCompleteInner as CompatibleCompleteInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model3 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_InFormula as InFormula0 with function Model0.model = Model2.model
  clone Lib_Logic_Logic_BoolToAssignedstate as BoolToAssignedstate0 with axiom .
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner2 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner1 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_Logic_LemmaNotSatClauseImpliesUnsatFormula as LemmaNotSatClauseImpliesUnsatFormula0 with predicate InFormula0.in_formula = InFormula0.in_formula,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner,
  predicate UnsatInner1.unsat_inner = UnsatInner1.unsat_inner, axiom .
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner1 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner as EventuallySatCompleteInner0 with predicate CompatibleCompleteInner0.compatible_complete_inner = CompatibleCompleteInner0.compatible_complete_inner,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_Logic_LemmaCorrectPolarityMakesClauseSat as LemmaCorrectPolarityMakesClauseSat0 with function Model0.model = Model0.model,
  function BoolToAssignedstate0.bool_to_assignedstate = BoolToAssignedstate0.bool_to_assignedstate,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model0.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_UnitInner as UnitInner0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, function Model0.model = Model0.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model1.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model3.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_Logic_LemmaNotSatFormulaImpliesUnsatFormula as LemmaNotSatFormulaImpliesUnsatFormula0 with predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner,
  predicate AssignmentsInvariant0.assignments_invariant = AssignmentsInvariant0.assignments_invariant,
  predicate Invariant0.invariant' = Invariant1.invariant',
  predicate EventuallySatCompleteInner0.eventually_sat_complete_inner = EventuallySatCompleteInner0.eventually_sat_complete_inner,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_Logic_LemmaIncorrectPolarityMakesClauseUnsat as LemmaIncorrectPolarityMakesClauseUnsat0 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate SatInner1.sat_inner = SatInner0.sat_inner,
  predicate UnitInner0.unit_inner = UnitInner0.unit_inner, predicate Unset0.unset = Unset0.unset,
  function FlipV0.flip_v = FlipV0.flip_v, predicate UnsatInner1.unsat_inner = UnsatInner2.unsat_inner, axiom .
  let rec ghost function lemma_unit_wrong_polarity_unsat_formula (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    requires {forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) && not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix) -> UnsatInner0.unsat_inner (Seq.get (Model0.model c) j) a}
    requires {exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model c) j)) = v}
    requires {Invariant0.invariant' c (Seq.length a)}
    requires {InFormula0.in_formula c f}
    requires {UnitInner0.unit_inner c a}
    requires {not (Unset0.unset v)}
    requires {0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix)}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a}
    requires {Invariant1.invariant' f}
    ensures { UnsatInner1.unsat_inner f (Seq.set a ix (FlipV0.flip_v v)) }
    ensures { not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (FlipV0.flip_v v))) }
    
   = 
    let _ = LemmaNotSatFormulaImpliesUnsatFormula0.lemma_not_sat_formula_implies_unsat_formula f a in let _ = LemmaCorrectPolarityMakesClauseSat0.lemma_correct_polarity_makes_clause_sat c a ix v in let _ = LemmaIncorrectPolarityMakesClauseUnsat0.lemma_incorrect_polarity_makes_clause_unsat c a ix v in let _ = let c' = let c' = FlipV0.flip_v v in Seq.set a ix c' in LemmaNotSatClauseImpliesUnsatFormula0.lemma_not_sat_clause_implies_unsat_formula f c c' in ()
end
module Lib_Logic_Logic_LemmaExtensionSatBaseSat_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  function lemma_extension_sat_base_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
end
module Lib_Logic_Logic_LemmaExtensionSatBaseSat
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  function lemma_extension_sat_base_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
   = 
    ()
  axiom lemma_extension_sat_base_sat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8, ix : int, v : uint8 . EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix v) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> EventuallySatCompleteInner0.eventually_sat_complete_inner f a
end
module Lib_Logic_Logic_LemmaExtensionSatBaseSat_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_CompatibleInner as CompatibleInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_CompatibleCompleteInner as CompatibleCompleteInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner as EventuallySatCompleteInner0 with predicate CompatibleCompleteInner0.compatible_complete_inner = CompatibleCompleteInner0.compatible_complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  let rec ghost function lemma_extension_sat_base_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    requires {EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix v)}
    requires {0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix)}
    ensures { EventuallySatCompleteInner0.eventually_sat_complete_inner f a }
    
   = 
    ()
end
module Lib_Logic_Logic_LemmaExtensionsUnsatBaseUnsat_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_Logic_Neg_Interface as Neg0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_Logic_Pos_Interface as Pos0
  function lemma_extensions_unsat_base_unsat (a : Seq.seq uint8) (ix : int) (f : Type.lib_formula_formula) : ()
end
module Lib_Logic_Logic_LemmaExtensionsUnsatBaseUnsat
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_Logic_Neg_Interface as Neg0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_Logic_Pos_Interface as Pos0
  clone Lib_Logic_LogicAssignments_CompatibleInner_Interface as CompatibleInner0
  function lemma_extensions_unsat_base_unsat (a : Seq.seq uint8) (ix : int) (f : Type.lib_formula_formula) : () = 
    let _ = CompatibleInner0.compatible_inner a (Seq.set a ix (Pos0.pos ())) in let _ = CompatibleInner0.compatible_inner a (Seq.set a ix (Neg0.neg ())) in ()
  axiom lemma_extensions_unsat_base_unsat_spec : forall a : Seq.seq uint8, ix : int, f : Type.lib_formula_formula . not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (Pos0.pos ()))) -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (Neg0.neg ()))) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f a)
end
module Lib_Logic_Logic_LemmaExtensionsUnsatBaseUnsat_Impl
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_CompatibleInner as CompatibleInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_CompatibleCompleteInner as CompatibleCompleteInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner as EventuallySatCompleteInner0 with predicate CompatibleCompleteInner0.compatible_complete_inner = CompatibleCompleteInner0.compatible_complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_Logic_Neg as Neg0
  clone Lib_Logic_Logic_Pos as Pos0
  let rec ghost function lemma_extensions_unsat_base_unsat (a : Seq.seq uint8) (ix : int) (f : Type.lib_formula_formula) : ()
    requires {not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (Pos0.pos ())))}
    requires {not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (Neg0.neg ())))}
    requires {0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix)}
    ensures { not (EventuallySatCompleteInner0.eventually_sat_complete_inner f a) }
    
   = 
    let _ = let b' = let c' = Pos0.pos () in Seq.set a ix c' in CompatibleInner0.compatible_inner a b' in let _ = let b' = let c' = Neg0.neg () in Seq.set a ix c' in CompatibleInner0.compatible_inner a b' in ()
end
module Lib_Trail_Impl0_Backstep_Interface
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision_Interface as InvariantNoDecision0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val backstep [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {InvariantNoDecision0.invariant_no_decision ( * self) f}
    requires {Invariant0.invariant' f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { InvariantNoDecision0.invariant_no_decision ( ^ self) f }
    
end
module Lib_Trail_Impl0_Backstep
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use seq.Seq
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model7 with function Model0.model = Model8.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model7.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model7.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model3.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model5.model,
  function Model1.model = Model7.model
  clone Lib_Logic_LogicFormula_Impl0_Model as Model6 with function Model0.model = Model5.model
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model5.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model5.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model7.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model7.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model7.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model6.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant2.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicUtil_Pop as Pop0 with type t = Type.lib_trail_step, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model2.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model2.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model1 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model5.model,
  function Model1.model = Model7.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model2.model,
  function Model1.model = Model0.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model2.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model3.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model0.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant3 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model3.model, function Model1.model = Model2.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicTrail_LemmaTrailOnlyLast as LemmaTrailOnlyLast0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant2.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant3.invariant',
  function Model1.model = Model5.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailPost as LemmaTrailPost0 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant2.invariant', predicate Invariant2.invariant' = Invariant1.invariant',
  function Model0.model = Model2.model, function Model1.model = Model5.model, function Model2.model = Model0.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailFin2 as LemmaTrailFin20 with function Model0.model = Model2.model,
  function Model1.model = Model0.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  function Model2.model = Model5.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate Invariant0.invariant' = Invariant2.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant3.invariant', predicate Invariant2.invariant' = Invariant1.invariant',
  function Pop0.pop = Pop0.pop, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function LemmaTrailPost0.lemma_trail_post = LemmaTrailPost0.lemma_trail_post,
  function LemmaTrailOnlyLast0.lemma_trail_only_last = LemmaTrailOnlyLast0.lemma_trail_only_last,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in, axiom .
  clone Lib_Logic_LogicTrail_LemmaTrailFin as LemmaTrailFin0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant3.invariant', predicate Invariant1.invariant' = Invariant2.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant2.invariant' = Invariant1.invariant', function Model1.model = Model5.model,
  function Model2.model = Model0.model, predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function LemmaTrailPost0.lemma_trail_post = LemmaTrailPost0.lemma_trail_post,
  function LemmaTrailOnlyLast0.lemma_trail_only_last = LemmaTrailOnlyLast0.lemma_trail_only_last,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in, axiom .
  clone Lib_Logic_LogicTrail_LemmaPopNoUnassIsOk as LemmaPopNoUnassIsOk0 with function Model0.model = Model2.model,
  function Model1.model = Model0.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant0.invariant' = Invariant3.invariant', function Pop0.pop = Pop0.pop, axiom .
  clone Lib_Logic_LogicTrail_LemmaBacktrackOk as LemmaBacktrackOk0 with function Model0.model = Model2.model,
  function Model1.model = Model0.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Invariant0.invariant' = Invariant2.invariant',
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate Invariant1.invariant' = Invariant3.invariant', predicate Invariant2.invariant' = Invariant1.invariant',
  function Pop0.pop = Pop0.pop, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function LemmaPopNoUnassIsOk0.lemma_pop_no_unass_is_ok = LemmaPopNoUnassIsOk0.lemma_pop_no_unass_is_ok,
  function LemmaTrailFin0.lemma_trail_fin = LemmaTrailFin0.lemma_trail_fin,
  function LemmaTrailFin20.lemma_trail_fin2 = LemmaTrailFin20.lemma_trail_fin2, function Model2.model = Model5.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner, axiom .
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve11 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve10 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve9 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.core_option_option (Type.lib_trail_step)
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve3 with type t = Type.lib_trail_trail
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Model_Impl1_Model as Model12 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut1 with type t = usize,
  function Model0.model = Model3.model, function Model1.model = Model12.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl1_Pop_Interface as Pop1 with type t = Type.lib_trail_step,
  function Model0.model = Model9.model, function Model1.model = Model2.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_trail_trail),
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = uint8,
  function Model0.model = Model4.model, function Model1.model = Model11.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = uint8,
  function Model0.model = Model10.model
  let rec cfg backstep [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) f (Model0.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {InvariantNoDecision0.invariant_no_decision ( * self) f}
    requires {Invariant1.invariant' f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model2.model (Type.lib_trail_trail_Trail_trail ( ^ self))) f (Model0.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { InvariantNoDecision0.invariant_no_decision ( ^ self) f }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_trail_trail);
  var f_2 : Type.lib_formula_formula;
  var old_t_3 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _4 : borrowed (Type.lib_trail_trail);
  var _5 : borrowed (Type.lib_trail_trail);
  var last_6 : Type.core_option_option (Type.lib_trail_step);
  var _7 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step));
  var _8 : ();
  var _9 : isize;
  var step_10 : Type.lib_trail_step;
  var _11 : ();
  var _12 : bool;
  var _13 : uint8;
  var _14 : uint8;
  var _15 : Type.creusotcontracts_std1_vec_vec uint8;
  var _16 : usize;
  var _17 : borrowed uint8;
  var _18 : borrowed (Type.creusotcontracts_std1_vec_vec uint8);
  var _19 : usize;
  var _20 : borrowed uint8;
  var _21 : borrowed (Type.creusotcontracts_std1_vec_vec uint8);
  var _22 : usize;
  var _23 : ();
  var _24 : ();
  var _25 : ();
  var _26 : ();
  var _27 : borrowed usize;
  var _28 : borrowed (Type.creusotcontracts_std1_vec_vec usize);
  var _29 : usize;
  var _30 : ();
  var _31 : ();
  var _32 : ();
  var _33 : ();
  var _34 : ();
  var _35 : ();
  var _36 : ();
  var _37 : ();
  var _38 : ();
  var _39 : ();
  {
    self_1 <- self;
    f_2 <- f;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve f_2 };
    _5 <- self_1;
    _4 <- _5;
    assume { Resolve1.resolve _5 };
    old_t_3 <- Record0.record _4;
    goto BB1
  }
  BB1 {
    assume { Resolve2.resolve old_t_3 };
    _7 <- borrow_mut (Type.lib_trail_trail_Trail_trail ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail a b ( ^ _7) d e) };
    last_6 <- Pop1.pop _7;
    goto BB2
  }
  BB2 {
    switch (last_6)
      | Type.Core_Option_Option_None -> goto BB3
      | Type.Core_Option_Option_Some _ -> goto BB5
      end
  }
  BB3 {
    assume { Resolve3.resolve self_1 };
    assume { Resolve4.resolve last_6 };
    assert { Seq.(==) (Model2.model (Type.lib_trail_trail_Trail_trail ( * self_1))) (Model2.model (Type.lib_trail_trail_Trail_trail ( * Model1.model old_t_3))) };
    _31 <- ();
    assume { Resolve10.resolve _31 };
    assert { LongArePostUnitInner0.long_are_post_unit_inner (Model2.model (Type.lib_trail_trail_Trail_trail ( * self_1))) f_2 (Model0.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) };
    _32 <- ();
    assume { Resolve10.resolve _32 };
    _8 <- ();
    assume { Resolve10.resolve _8 };
    goto BB13
  }
  BB4 {
    assume { Resolve3.resolve self_1 };
    assume { Resolve4.resolve last_6 };
    absurd
  }
  BB5 {
    assume { Resolve5.resolve step_10 };
    step_10 <- Type.core_option_option_Some_0 last_6;
    assume { Resolve4.resolve last_6 };
    _15 <- Type.lib_assignments_assignments_Assignments_0 (Type.lib_trail_trail_Trail_assignments ( * self_1));
    assume { Resolve6.resolve _16 };
    _16 <- Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step_10);
    _14 <- Index0.index _15 _16;
    goto BB6
  }
  BB6 {
    assume { Resolve7.resolve _13 };
    _13 <- _14;
    assume { Resolve8.resolve _14 };
    _12 <- _13 < (2 : uint8);
    switch (_12)
      | False -> goto BB9
      | _ -> goto BB7
      end
  }
  BB7 {
    _18 <- borrow_mut (Type.lib_assignments_assignments_Assignments_0 (Type.lib_trail_trail_Trail_assignments ( * self_1)));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail (let Type.Lib_Assignments_Assignments a b = Type.lib_trail_trail_Trail_assignments ( * self_1) in Type.Lib_Assignments_Assignments ( ^ _18) b) b c d e) };
    assume { Resolve6.resolve _19 };
    _19 <- Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step_10);
    _17 <- IndexMut0.index_mut _18 _19;
    goto BB8
  }
  BB8 {
    _17 <- { _17 with current = ( * _17 + (2 : uint8)) };
    assume { Resolve9.resolve _17 };
    _11 <- ();
    assume { Resolve10.resolve _11 };
    goto BB11
  }
  BB9 {
    _21 <- borrow_mut (Type.lib_assignments_assignments_Assignments_0 (Type.lib_trail_trail_Trail_assignments ( * self_1)));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail (let Type.Lib_Assignments_Assignments a b = Type.lib_trail_trail_Trail_assignments ( * self_1) in Type.Lib_Assignments_Assignments ( ^ _21) b) b c d e) };
    assume { Resolve6.resolve _22 };
    _22 <- Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step_10);
    _20 <- IndexMut0.index_mut _21 _22;
    goto BB10
  }
  BB10 {
    _20 <- { _20 with current = (3 : uint8) };
    assume { Resolve9.resolve _20 };
    _11 <- ();
    assume { Resolve10.resolve _11 };
    goto BB11
  }
  BB11 {
    assert { Seq.(==) (Model0.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) (Seq.set (Model0.model (Type.lib_trail_trail_Trail_assignments ( * Model1.model old_t_3))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step_10))) (3 : uint8)) || Seq.(==) (Model0.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) (Seq.set (Model0.model (Type.lib_trail_trail_Trail_assignments ( * Model1.model old_t_3))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step_10))) (2 : uint8)) };
    _23 <- ();
    assume { Resolve10.resolve _23 };
    assert { Model2.model (Type.lib_trail_trail_Trail_trail ( * self_1)) = Pop0.pop (Model2.model (Type.lib_trail_trail_Trail_trail ( * Model1.model old_t_3))) };
    _24 <- ();
    assume { Resolve10.resolve _24 };
    assert {  ^ Model1.model old_t_3 =  ^ self_1 };
    _25 <- ();
    assume { Resolve10.resolve _25 };
    assert { let _ = LemmaBacktrackOk0.lemma_backtrack_ok ( * self_1) f_2 (Type.lib_trail_step_Step_lit step_10) in true };
    _26 <- ();
    assume { Resolve10.resolve _26 };
    _28 <- borrow_mut (Type.lib_trail_trail_Trail_lit_to_level ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail a ( ^ _28) c d e) };
    assume { Resolve3.resolve self_1 };
    assume { Resolve6.resolve _29 };
    _29 <- Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step_10);
    assume { Resolve5.resolve step_10 };
    _27 <- IndexMut1.index_mut _28 _29;
    goto BB12
  }
  BB12 {
    _27 <- { _27 with current = (18446744073709551615 : usize) };
    assume { Resolve11.resolve _27 };
    assert { LongArePostUnitInner0.long_are_post_unit_inner (Model2.model (Type.lib_trail_trail_Trail_trail ( * self_1))) f_2 (Model0.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) };
    _30 <- ();
    assume { Resolve10.resolve _30 };
    _8 <- ();
    assume { Resolve10.resolve _8 };
    goto BB13
  }
  BB13 {
    assert { Invariant0.invariant' (Type.lib_trail_trail_Trail_assignments ( * self_1)) f_2 };
    _33 <- ();
    assume { Resolve10.resolve _33 };
    assert { TrailInvariant0.trail_invariant (Model2.model (Type.lib_trail_trail_Trail_trail ( * self_1))) f_2 };
    _34 <- ();
    assume { Resolve10.resolve _34 };
    assert { LitToLevelInvariant0.lit_to_level_invariant (Model3.model (Type.lib_trail_trail_Trail_lit_to_level ( * self_1))) f_2 };
    _35 <- ();
    assume { Resolve10.resolve _35 };
    assert { LitNotInLess0.lit_not_in_less ( * self_1) f_2 };
    _36 <- ();
    assume { Resolve10.resolve _36 };
    assert { LitIsUnique0.lit_is_unique ( * self_1) };
    _37 <- ();
    assume { Resolve10.resolve _37 };
    assert { LongArePostUnitInner0.long_are_post_unit_inner (Model2.model (Type.lib_trail_trail_Trail_trail ( * self_1))) f_2 (Model0.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) };
    _38 <- ();
    assume { Resolve10.resolve _38 };
    assert { TrailEntriesAreAssigned0.trail_entries_are_assigned ( * self_1) };
    _39 <- ();
    assume { Resolve10.resolve _39 };
    _0 <- ();
    return _0
  }
  
end
module Lib_Trail_Impl0_BacktrackTo_Interface
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = usize
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val backtrack_to [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (level : usize) (f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Invariant0.invariant' ( * self) f}
    requires {Invariant1.invariant' f}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_decisions ( * self))) > UInt64.to_int level}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) f }
    
end
module Lib_Trail_Impl0_BacktrackTo
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant5
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model7 with function Model0.model = Model8.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model7.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model7.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model7.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model7.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicUtil_Pop as Pop0 with type t = usize, axiom .
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicUtil_LemmaPopMaintainsSorted as LemmaPopMaintainsSorted0 with predicate Sorted0.sorted = Sorted0.sorted,
  function Pop0.pop = Pop0.pop, axiom .
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model3.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model5.model,
  function Model1.model = Model7.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant3 with predicate Invariant0.invariant' = Invariant5.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl0_Model as Model6 with function Model0.model = Model5.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model7.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model6.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model5.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model5.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model2 with function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model5.model,
  function Model1.model = Model7.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant0 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model2.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model3.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model2.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model3.model, function Model1.model = Model1.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = borrowed (Type.lib_trail_trail)
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = bool
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.core_option_option usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Model_Impl1_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl1_Pop_Interface as Pop1 with type t = usize,
  function Model0.model = Model11.model, function Model1.model = Model3.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len1 with type t = usize, function Model0.model = Model10.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = usize,
  function Model0.model = Model10.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_trail_step,
  function Model0.model = Model9.model
  clone Lib_Trail_Impl0_Backstep_Interface as Backstep0 with function Model0.model = Model1.model,
  function Model1.model = Model2.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  predicate Invariant0.invariant' = Invariant2.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_trail_trail),
  function Model0.model = Model0.model
  let rec cfg backtrack_to [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (level : usize) (f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model1.model (Type.lib_trail_trail_Trail_trail ( * self))) f (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Invariant1.invariant' ( * self) f}
    requires {Invariant2.invariant' f}
    requires {Seq.length (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self))) > UInt64.to_int level}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model1.model (Type.lib_trail_trail_Trail_trail ( ^ self))) f (Model2.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Invariant1.invariant' ( ^ self) f }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_trail_trail);
  var level_2 : usize;
  var f_3 : Type.lib_formula_formula;
  var old_t_4 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _5 : borrowed (Type.lib_trail_trail);
  var _6 : borrowed (Type.lib_trail_trail);
  var how_many_7 : usize;
  var _8 : usize;
  var _9 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var _10 : usize;
  var _11 : usize;
  var _12 : Type.creusotcontracts_std1_vec_vec usize;
  var _13 : usize;
  var des_14 : usize;
  var _15 : usize;
  var _16 : Type.creusotcontracts_std1_vec_vec usize;
  var _17 : usize;
  var i_18 : usize;
  var _19 : ();
  var _20 : ();
  var _21 : bool;
  var _22 : usize;
  var _23 : usize;
  var _24 : ();
  var _25 : borrowed (Type.lib_trail_trail);
  var _26 : Type.lib_formula_formula;
  var _27 : ();
  var _28 : ();
  var _29 : ();
  var _30 : ();
  var _31 : bool;
  var _32 : usize;
  var _33 : Type.creusotcontracts_std1_vec_vec usize;
  var _34 : usize;
  var old_t2_35 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _36 : borrowed (Type.lib_trail_trail);
  var _37 : borrowed (Type.lib_trail_trail);
  var _38 : ();
  var _39 : ();
  var _40 : ();
  var _41 : ();
  var _42 : Type.core_option_option usize;
  var _43 : borrowed (Type.creusotcontracts_std1_vec_vec usize);
  var _44 : isize;
  var _45 : ();
  var _46 : ();
  var _47 : ();
  var _48 : ();
  var _49 : ();
  var _50 : ();
  var _51 : ();
  var _52 : ();
  var _53 : ();
  var _54 : bool;
  var _55 : bool;
  var _56 : usize;
  var _57 : Type.creusotcontracts_std1_vec_vec usize;
  var _58 : bool;
  var _59 : usize;
  var _60 : usize;
  var _61 : Type.creusotcontracts_std1_vec_vec usize;
  var _62 : usize;
  var _63 : usize;
  var _64 : Type.creusotcontracts_std1_vec_vec usize;
  var _65 : usize;
  var _66 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var old_t3_67 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _68 : borrowed (Type.lib_trail_trail);
  var _69 : borrowed (Type.lib_trail_trail);
  var _70 : ();
  var _71 : ();
  var _72 : ();
  var _73 : ();
  var _74 : Type.core_option_option usize;
  var _75 : borrowed (Type.creusotcontracts_std1_vec_vec usize);
  var _76 : isize;
  var _77 : ();
  var _78 : ();
  var _79 : ();
  var _80 : ();
  var _81 : ();
  var _82 : ();
  var _83 : ();
  var _84 : ();
  var _85 : ();
  var _86 : ();
  var _87 : ();
  var _88 : ();
  var _89 : ();
  var _90 : ();
  var _91 : ();
  var _92 : ();
  var _93 : ();
  var _94 : ();
  {
    self_1 <- self;
    level_2 <- level;
    f_3 <- f;
    goto BB0
  }
  BB0 {
    _6 <- self_1;
    _5 <- _6;
    assume { Resolve0.resolve _6 };
    old_t_4 <- Record0.record _5;
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve old_t_4 };
    _9 <- Type.lib_trail_trail_Trail_trail ( * self_1);
    _8 <- Len0.len _9;
    goto BB2
  }
  BB2 {
    _12 <- Type.lib_trail_trail_Trail_decisions ( * self_1);
    assume { Resolve2.resolve _13 };
    _13 <- level_2;
    _11 <- Index0.index _12 _13;
    goto BB3
  }
  BB3 {
    assume { Resolve2.resolve _10 };
    _10 <- _11;
    assume { Resolve3.resolve _11 };
    how_many_7 <- _8 - _10;
    _16 <- Type.lib_trail_trail_Trail_decisions ( * self_1);
    assume { Resolve2.resolve _17 };
    _17 <- level_2;
    _15 <- Index0.index _16 _17;
    goto BB4
  }
  BB4 {
    assume { Resolve2.resolve des_14 };
    des_14 <- _15;
    assume { Resolve3.resolve _15 };
    assume { Resolve2.resolve des_14 };
    i_18 <- (0 : usize);
    goto BB5
  }
  BB5 {
    invariant i_less2 { UInt64.to_int i_18 <= Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail ( * Model0.model old_t_4))) };
    invariant i_less { i_18 <= how_many_7 };
    invariant post_unit { LongArePostUnitInner0.long_are_post_unit_inner (Model1.model (Type.lib_trail_trail_Trail_trail ( * self_1))) f_3 (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) };
    invariant inv { InvariantNoDecision0.invariant_no_decision ( * self_1) f_3 };
    invariant proph {  ^ Model0.model old_t_4 =  ^ self_1 };
    assume { Resolve2.resolve _22 };
    _22 <- i_18;
    assume { Resolve2.resolve _23 };
    _23 <- how_many_7;
    _21 <- _22 < _23;
    switch (_21)
      | False -> goto BB8
      | _ -> goto BB6
      end
  }
  BB6 {
    _25 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _25) };
    _26 <- f_3;
    _24 <- Backstep0.backstep _25 _26;
    goto BB7
  }
  BB7 {
    i_18 <- i_18 + (1 : usize);
    _20 <- ();
    assume { Resolve4.resolve _20 };
    goto BB5
  }
  BB8 {
    assume { Resolve5.resolve f_3 };
    assume { Resolve2.resolve how_many_7 };
    assume { Resolve2.resolve i_18 };
    _19 <- ();
    assume { Resolve4.resolve _19 };
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail (let Type.Lib_Assignments_Assignments a b = Type.lib_trail_trail_Trail_assignments ( * self_1) in Type.Lib_Assignments_Assignments a (0 : usize)) b c d e) };
    goto BB9
  }
  BB9 {
    invariant post_unit { LongArePostUnitInner0.long_are_post_unit_inner (Model1.model (Type.lib_trail_trail_Trail_trail ( * self_1))) f_3 (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) };
    invariant inv { InvariantNoDecision0.invariant_no_decision ( * self_1) f_3 };
    invariant proph {  ^ Model0.model old_t_4 =  ^ self_1 };
    _33 <- Type.lib_trail_trail_Trail_decisions ( * self_1);
    _32 <- Len1.len _33;
    goto BB10
  }
  BB10 {
    assume { Resolve2.resolve _34 };
    _34 <- level_2;
    _31 <- _32 > _34;
    switch (_31)
      | False -> goto BB17
      | _ -> goto BB11
      end
  }
  BB11 {
    _37 <- self_1;
    _36 <- _37;
    assume { Resolve0.resolve _37 };
    old_t2_35 <- Record0.record _36;
    goto BB12
  }
  BB12 {
    assume { Resolve1.resolve old_t2_35 };
    assert { Sorted0.sorted (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) };
    _38 <- ();
    assume { Resolve4.resolve _38 };
    assert { Seq.length (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) > 0 };
    _39 <- ();
    assume { Resolve4.resolve _39 };
    assert { let _ = LemmaPopMaintainsSorted0.lemma_pop_maintains_sorted (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) in true };
    _40 <- ();
    assume { Resolve4.resolve _40 };
    _43 <- borrow_mut (Type.lib_trail_trail_Trail_decisions ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail a b c d ( ^ _43)) };
    _42 <- Pop1.pop _43;
    goto BB13
  }
  BB13 {
    assume { Resolve6.resolve _42 };
    switch (_42)
      | Type.Core_Option_Option_None -> goto BB14
      | Type.Core_Option_Option_Some _ -> goto BB16
      end
  }
  BB14 {
    assume { Resolve7.resolve self_1 };
    assume { Resolve2.resolve level_2 };
    absurd
  }
  BB15 {
    assume { Resolve7.resolve self_1 };
    assume { Resolve2.resolve level_2 };
    absurd
  }
  BB16 {
    assert { Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1)) = Pop0.pop (Model3.model (Type.lib_trail_trail_Trail_decisions ( * Model0.model old_t2_35))) };
    _45 <- ();
    assume { Resolve4.resolve _45 };
    assert {  ^ Model0.model old_t2_35 =  ^ self_1 };
    _46 <- ();
    assume { Resolve4.resolve _46 };
    _41 <- ();
    assume { Resolve4.resolve _41 };
    assert { Sorted0.sorted (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) };
    _49 <- ();
    assume { Resolve4.resolve _49 };
    _20 <- ();
    assume { Resolve4.resolve _20 };
    goto BB9
  }
  BB17 {
    assume { Resolve2.resolve level_2 };
    _30 <- ();
    assume { Resolve4.resolve _30 };
    goto BB18
  }
  BB18 {
    invariant post_unit { LongArePostUnitInner0.long_are_post_unit_inner (Model1.model (Type.lib_trail_trail_Trail_trail ( * self_1))) f_3 (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) };
    invariant inv { InvariantNoDecision0.invariant_no_decision ( * self_1) f_3 };
    invariant proph {  ^ Model0.model old_t_4 =  ^ self_1 };
    _57 <- Type.lib_trail_trail_Trail_decisions ( * self_1);
    _56 <- Len1.len _57;
    goto BB22
  }
  BB19 {
    _54 <- false;
    goto BB21
  }
  BB20 {
    _61 <- Type.lib_trail_trail_Trail_decisions ( * self_1);
    _64 <- Type.lib_trail_trail_Trail_decisions ( * self_1);
    _63 <- Len1.len _64;
    goto BB23
  }
  BB21 {
    switch (_54)
      | False -> goto BB32
      | _ -> goto BB26
      end
  }
  BB22 {
    _55 <- _56 > (0 : usize);
    switch (_55)
      | False -> goto BB19
      | _ -> goto BB20
      end
  }
  BB23 {
    _62 <- _63 - (1 : usize);
    _60 <- Index0.index _61 _62;
    goto BB24
  }
  BB24 {
    assume { Resolve2.resolve _59 };
    _59 <- _60;
    assume { Resolve3.resolve _60 };
    _66 <- Type.lib_trail_trail_Trail_trail ( * self_1);
    _65 <- Len0.len _66;
    goto BB25
  }
  BB25 {
    _58 <- _59 > _65;
    assume { Resolve8.resolve _54 };
    _54 <- _58;
    goto BB21
  }
  BB26 {
    _69 <- self_1;
    _68 <- _69;
    assume { Resolve0.resolve _69 };
    old_t3_67 <- Record0.record _68;
    goto BB27
  }
  BB27 {
    assume { Resolve1.resolve old_t3_67 };
    assert { Sorted0.sorted (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) };
    _70 <- ();
    assume { Resolve4.resolve _70 };
    assert { Seq.length (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) > 0 };
    _71 <- ();
    assume { Resolve4.resolve _71 };
    assert { let _ = LemmaPopMaintainsSorted0.lemma_pop_maintains_sorted (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) in true };
    _72 <- ();
    assume { Resolve4.resolve _72 };
    _75 <- borrow_mut (Type.lib_trail_trail_Trail_decisions ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail a b c d ( ^ _75)) };
    _74 <- Pop1.pop _75;
    goto BB28
  }
  BB28 {
    assume { Resolve6.resolve _74 };
    switch (_74)
      | Type.Core_Option_Option_None -> goto BB29
      | Type.Core_Option_Option_Some _ -> goto BB31
      end
  }
  BB29 {
    assume { Resolve7.resolve self_1 };
    absurd
  }
  BB30 {
    assume { Resolve7.resolve self_1 };
    absurd
  }
  BB31 {
    assert { Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1)) = Pop0.pop (Model3.model (Type.lib_trail_trail_Trail_decisions ( * Model0.model old_t3_67))) };
    _77 <- ();
    assume { Resolve4.resolve _77 };
    assert {  ^ Model0.model old_t3_67 =  ^ self_1 };
    _78 <- ();
    assume { Resolve4.resolve _78 };
    _73 <- ();
    assume { Resolve4.resolve _73 };
    assert { let _ = LemmaPopMaintainsSorted0.lemma_pop_maintains_sorted (Model3.model (Type.lib_trail_trail_Trail_decisions ( * Model0.model old_t3_67))) in true };
    _81 <- ();
    assume { Resolve4.resolve _81 };
    assert { Sorted0.sorted (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) };
    _82 <- ();
    assume { Resolve4.resolve _82 };
    _20 <- ();
    assume { Resolve4.resolve _20 };
    goto BB18
  }
  BB32 {
    _53 <- ();
    assume { Resolve4.resolve _53 };
    assert { Seq.length (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) = 0 || UInt64.to_int (Seq.get (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) (Seq.length (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) - 1)) <= Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail ( * self_1))) };
    _86 <- ();
    assume { Resolve4.resolve _86 };
    assert { DecisionsInvariant0.decisions_invariant (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) (Model1.model (Type.lib_trail_trail_Trail_trail ( * self_1))) };
    _87 <- ();
    assume { Resolve4.resolve _87 };
    assert { Invariant0.invariant' (Type.lib_trail_trail_Trail_assignments ( * self_1)) f_3 };
    _88 <- ();
    assume { Resolve4.resolve _88 };
    assert { TrailInvariant0.trail_invariant (Model1.model (Type.lib_trail_trail_Trail_trail ( * self_1))) f_3 };
    _89 <- ();
    assume { Resolve4.resolve _89 };
    assert { LitToLevelInvariant0.lit_to_level_invariant (Model3.model (Type.lib_trail_trail_Trail_lit_to_level ( * self_1))) f_3 };
    _90 <- ();
    assume { Resolve4.resolve _90 };
    assert { LitNotInLess0.lit_not_in_less ( * self_1) f_3 };
    _91 <- ();
    assume { Resolve4.resolve _91 };
    assert { LitIsUnique0.lit_is_unique ( * self_1) };
    _92 <- ();
    assume { Resolve4.resolve _92 };
    assert { LongArePostUnitInner0.long_are_post_unit_inner (Model1.model (Type.lib_trail_trail_Trail_trail ( * self_1))) f_3 (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) };
    _93 <- ();
    assume { Resolve4.resolve _93 };
    assert { TrailEntriesAreAssigned0.trail_entries_are_assigned ( * self_1) };
    _94 <- ();
    assume { Resolve4.resolve _94 };
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail a b c (0 : usize) e) };
    assume { Resolve7.resolve self_1 };
    _0 <- ();
    return _0
  }
  
end
module Lib_Trail_Impl0_EnqAssignment_Interface
  use mach.int.UInt64
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToLit_Interface as ClausePostWithRegardsToLit0
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant3
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model3
  clone Lib_Logic_LogicLit_Impl1_LitIn_Interface as LitIn0
  clone Lib_Logic_LogicClause_Impl2_Unit_Interface as Unit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_IdxInTrail_Interface as IdxInTrail0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val enq_assignment [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (step : Type.lib_trail_step) (_f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step))))}
    requires {not (IdxInTrail0.idx_in_trail (Type.lib_trail_step_Step_lit step) (Type.lib_trail_trail_Trail_trail ( * self)))}
    requires {Invariant0.invariant' (Type.lib_trail_step_Step_lit step) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant1.invariant' step _f}
    requires {match (Type.lib_trail_step_Step_reason step) with
      | Type.Lib_Trail_Reason_Long cref -> UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses _f)) && Unit0.unit (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments ( * self)) && LitIn0.lit_in (Type.lib_trail_step_Step_lit step) (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int cref))
      | Type.Lib_Trail_Reason_Unit cref -> UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses _f)) && Type.lib_trail_step_Step_lit step = Seq.get (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int cref))) 0
      | _ -> true
      end}
    requires {Invariant0.invariant' (Type.lib_trail_step_Step_lit step) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant2.invariant' _f}
    requires {Invariant3.invariant' ( * self) _f}
    ensures { Type.lib_trail_trail_Trail_decisions ( ^ self) = Type.lib_trail_trail_Trail_decisions ( * self) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) = 1 + Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) }
    ensures { match (Type.lib_trail_step_Step_reason step) with
      | Type.Lib_Trail_Reason_Long k -> ClausePostWithRegardsToLit0.clause_post_with_regards_to_lit (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k)) (Type.lib_trail_trail_Trail_assignments ( ^ self)) (Type.lib_trail_step_Step_lit step)
      | _ -> true
      end }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Sat0.sat (Type.lib_trail_step_Step_lit step) (Type.lib_trail_trail_Trail_assignments ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)) -> Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) j = Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) j }
    ensures { Invariant3.invariant' ( ^ self) _f }
    
end
module Lib_Trail_Impl0_EnqAssignment
  use mach.int.UInt64
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model8.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model4.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_LitIn as LitIn0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant5 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model4.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_UnitInner as UnitInner0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, function Model0.model = Model4.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model7 with function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant5.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model7.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant4 with function Model0.model = Model3.model,
  function Model1.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant0 with predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model3.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model3.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model2.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicLit_Impl1_IdxInTrail as IdxInTrail0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model2.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model5.model
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model2.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant6 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl1_PostUnit as PostUnit0 with function Model0.model = Model1.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model3.model,
  function Model1.model = Model4.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant6.invariant',
  function Model0.model = Model2.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model8.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant3 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model8.model, function Model1.model = Model2.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicTrail_LemmaForallToUnsetPush as LemmaForallToUnsetPush0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model, function Model2.model = Model4.model,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model3.model = Model1.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant1.invariant' = Invariant3.invariant',
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner, axiom .
  clone Lib_Logic_LogicTrail_LemmaUnsetToForall as LemmaUnsetToForall0 with function Model0.model = Model1.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant3.invariant', function Model1.model = Model2.model,
  function Model2.model = Model3.model, function Model3.model = Model4.model, axiom .
  clone Lib_Logic_LogicTrail_LemmaPushMaintainsLitNotInLess as LemmaPushMaintainsLitNotInLess0 with function Model0.model = Model2.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model1.model = Model1.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant1.invariant' = Invariant3.invariant',
  predicate Invariant2.invariant' = Invariant2.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function LemmaUnsetToForall0.lemma_unset_to_forall = LemmaUnsetToForall0.lemma_unset_to_forall,
  function LemmaForallToUnsetPush0.lemma_forall_to_unset_push = LemmaForallToUnsetPush0.lemma_forall_to_unset_push,
  function Model2.model = Model3.model, function Model3.model = Model4.model, axiom .
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToLit as ClausePostWithRegardsToLit0 with predicate PostUnit0.post_unit = PostUnit0.post_unit,
  function Model0.model = Model4.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicClause_Impl2_Unit as Unit0 with function Model0.model = Model1.model,
  predicate UnitInner0.unit_inner = UnitInner0.unit_inner
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve9 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Logic_Model_Impl1_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model8.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = usize,
  function Model0.model = Model8.model, function Model1.model = Model9.model
  clone Lib_Trail_Impl0_DecisionLevel_Interface as DecisionLevel0 with function Model0.model = Model8.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model12 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = Type.lib_trail_step,
  function Model0.model = Model2.model, function Model1.model = Model12.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model11 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model1.model
  clone Lib_Assignments_Impl0_SetAssignment_Interface as SetAssignment0 with function Model0.model = Model10.model,
  function Model1.model = Model11.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Unset0.unset = Unset0.unset, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate Invariant0.invariant' = Invariant2.invariant', predicate Invariant1.invariant' = Invariant1.invariant',
  predicate Invariant2.invariant' = Invariant6.invariant', predicate Sat0.sat = Sat0.sat,
  function Model2.model = Model1.model, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_trail_trail),
  function Model0.model = Model0.model
  let rec cfg enq_assignment [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (step : Type.lib_trail_step) (_f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step))))}
    requires {not (IdxInTrail0.idx_in_trail (Type.lib_trail_step_Step_lit step) (Type.lib_trail_trail_Trail_trail ( * self)))}
    requires {Invariant1.invariant' (Type.lib_trail_step_Step_lit step) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant0.invariant' step _f}
    requires {match (Type.lib_trail_step_Step_reason step) with
      | Type.Lib_Trail_Reason_Long cref -> UInt64.to_int cref < Seq.length (Model3.model (Type.lib_formula_formula_Formula_clauses _f)) && Unit0.unit (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments ( * self)) && LitIn0.lit_in (Type.lib_trail_step_Step_lit step) (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int cref))
      | Type.Lib_Trail_Reason_Unit cref -> UInt64.to_int cref < Seq.length (Model3.model (Type.lib_formula_formula_Formula_clauses _f)) && Type.lib_trail_step_Step_lit step = Seq.get (Model4.model (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int cref))) 0
      | _ -> true
      end}
    requires {Invariant1.invariant' (Type.lib_trail_step_Step_lit step) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant2.invariant' _f}
    requires {Invariant3.invariant' ( * self) _f}
    ensures { Type.lib_trail_trail_Trail_decisions ( ^ self) = Type.lib_trail_trail_Trail_decisions ( * self) }
    ensures { Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( ^ self))) = 1 + Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) }
    ensures { match (Type.lib_trail_step_Step_reason step) with
      | Type.Lib_Trail_Reason_Long k -> ClausePostWithRegardsToLit0.clause_post_with_regards_to_lit (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k)) (Type.lib_trail_trail_Trail_assignments ( ^ self)) (Type.lib_trail_step_Step_lit step)
      | _ -> true
      end }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model2.model (Type.lib_trail_trail_Trail_trail ( ^ self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Sat0.sat (Type.lib_trail_step_Step_lit step) (Type.lib_trail_trail_Trail_assignments ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)) -> Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) j = Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) j }
    ensures { Invariant3.invariant' ( ^ self) _f }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_trail_trail);
  var step_2 : Type.lib_trail_step;
  var _f_3 : Type.lib_formula_formula;
  var _4 : usize;
  var _5 : Type.lib_trail_trail;
  var _6 : borrowed usize;
  var _7 : borrowed (Type.creusotcontracts_std1_vec_vec usize);
  var _8 : usize;
  var trail_9 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var old_self_10 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _11 : borrowed (Type.lib_trail_trail);
  var _12 : borrowed (Type.lib_trail_trail);
  var _13 : ();
  var _14 : ();
  var _15 : borrowed (Type.lib_assignments_assignments);
  var _16 : Type.lib_lit_lit;
  var _17 : Type.lib_formula_formula;
  var _18 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var _19 : ();
  var _20 : ();
  var _21 : ();
  var _22 : ();
  var _23 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step));
  var _24 : Type.lib_trail_step;
  var _25 : ();
  var _26 : ();
  var _27 : ();
  var _28 : ();
  var _29 : ();
  {
    self_1 <- self;
    step_2 <- step;
    _f_3 <- _f;
    goto BB0
  }
  BB0 {
    _5 <-  * self_1;
    _4 <- DecisionLevel0.decision_level _5;
    goto BB1
  }
  BB1 {
    _7 <- borrow_mut (Type.lib_trail_trail_Trail_lit_to_level ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail a ( ^ _7) c d e) };
    assume { Resolve0.resolve _8 };
    _8 <- Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step_2);
    _6 <- IndexMut0.index_mut _7 _8;
    goto BB2
  }
  BB2 {
    assume { Resolve0.resolve ( * _6) };
    _6 <- { _6 with current = _4 };
    assume { Resolve1.resolve _6 };
    trail_9 <- Type.lib_trail_trail_Trail_trail ( * self_1);
    _12 <- self_1;
    _11 <- _12;
    assume { Resolve2.resolve _12 };
    old_self_10 <- Record0.record _11;
    goto BB3
  }
  BB3 {
    assume { Resolve3.resolve old_self_10 };
    assert { Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * Model0.model old_self_10))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step_2)))) };
    _13 <- ();
    assume { Resolve4.resolve _13 };
    _15 <- borrow_mut (Type.lib_trail_trail_Trail_assignments ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail ( ^ _15) b c d e) };
    assume { Resolve5.resolve _16 };
    _16 <- Type.lib_trail_step_Step_lit step_2;
    _17 <- _f_3;
    assume { Resolve6.resolve _f_3 };
    _18 <- trail_9;
    assume { Resolve7.resolve trail_9 };
    _14 <- SetAssignment0.set_assignment _15 _16 _17 _18;
    goto BB4
  }
  BB4 {
    assert { LitNotInLessInner0.lit_not_in_less_inner (Model2.model (Type.lib_trail_trail_Trail_trail ( * self_1))) _f_3 };
    _19 <- ();
    assume { Resolve4.resolve _19 };
    assert { Invariant0.invariant' step_2 _f_3 };
    _20 <- ();
    assume { Resolve4.resolve _20 };
    assert { let _ = LemmaPushMaintainsLitNotInLess0.lemma_push_maintains_lit_not_in_less ( * self_1) _f_3 step_2 in true };
    _21 <- ();
    assume { Resolve4.resolve _21 };
    _23 <- borrow_mut (Type.lib_trail_trail_Trail_trail ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail a b ( ^ _23) d e) };
    assume { Resolve8.resolve _24 };
    _24 <- step_2;
    _22 <- Push0.push _23 _24;
    goto BB5
  }
  BB5 {
    assume { Resolve9.resolve self_1 };
    assert { Seq.snoc (Model2.model (Type.lib_trail_trail_Trail_trail ( * Model0.model old_self_10))) step_2 = Model2.model (Type.lib_trail_trail_Trail_trail ( * self_1)) };
    _25 <- ();
    assume { Resolve4.resolve _25 };
    assert {  ^ Model0.model old_self_10 =  ^ self_1 };
    _26 <- ();
    assume { Resolve4.resolve _26 };
    assert { LitNotInLessInner0.lit_not_in_less_inner (Model2.model (Type.lib_trail_trail_Trail_trail ( * self_1))) _f_3 };
    _27 <- ();
    assume { Resolve4.resolve _27 };
    assert { LitNotInLess0.lit_not_in_less ( * self_1) _f_3 };
    _28 <- ();
    assume { Resolve4.resolve _28 };
    assert { LongArePostUnitInner0.long_are_post_unit_inner (Model2.model (Type.lib_trail_trail_Trail_trail ( * self_1))) _f_3 (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) };
    _29 <- ();
    assume { Resolve4.resolve _29 };
    _0 <- ();
    return _0
  }
  
end
module Lib_Trail_Impl0_LearnUnit_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model3
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val learn_unit [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (cref : usize) (f : Type.lib_formula_formula) : Type.core_result_result () ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Invariant0.invariant' (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) = 1}
    requires {UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant1.invariant' f}
    requires {Invariant2.invariant' ( * self) f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { match (result) with
      | Type.Core_Result_Result_Err _ -> true
      | Type.Core_Result_Result_Ok _ -> Sat0.sat (Seq.get (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) 0) (Type.lib_trail_trail_Trail_assignments ( ^ self))
      end }
    ensures { Invariant2.invariant' ( ^ self) f }
    
end
module Lib_Trail_Impl0_LearnUnit
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant4
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model7.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model3.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant0 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model2.model,
  function Model1.model = Model3.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant4.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model2.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicFormula_Impl0_Model as Model6 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model1.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model6.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model4.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model1.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model, predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model7.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant2 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model7.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Logic_Logic_Unset as Unset1
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve6 with type t = Type.lib_trail_trail
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = ()
  clone Lib_Trail_Impl0_DecisionLevel_Interface as DecisionLevel0 with function Model0.model = Model7.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_lit_lit,
  function Model0.model = Model9.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model3.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_UnitInner as UnitInner0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, function Model0.model = Model3.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone Lib_Logic_LogicLit_Impl1_LitIn as LitIn0 with function Model0.model = Model3.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model8 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_clause_clause,
  function Model0.model = Model8.model
  clone Lib_Logic_LogicClause_Impl1_PostUnit as PostUnit0 with function Model0.model = Model1.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Logic_LogicClause_Impl2_Unit as Unit0 with function Model0.model = Model1.model,
  predicate UnitInner0.unit_inner = UnitInner0.unit_inner
  clone Lib_Logic_LogicLit_Impl1_Unset as Unset0 with function Model0.model = Model1.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model1.model
  clone Lib_Lit_Impl0_LitSet_Interface as LitSet0 with function Model0.model = Model10.model,
  predicate Invariant0.invariant' = Invariant4.invariant', predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToLit as ClausePostWithRegardsToLit0 with predicate PostUnit0.post_unit = PostUnit0.post_unit,
  function Model0.model = Model3.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicLit_Impl1_IdxInTrail as IdxInTrail0 with function Model0.model = Model0.model
  clone Lib_Trail_Impl0_EnqAssignment_Interface as EnqAssignment0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Unset0.unset = Unset1.unset, predicate IdxInTrail0.idx_in_trail = IdxInTrail0.idx_in_trail,
  predicate Invariant0.invariant' = Invariant4.invariant', predicate Invariant1.invariant' = Invariant5.invariant',
  function Model2.model = Model2.model, predicate Unit0.unit = Unit0.unit, predicate LitIn0.lit_in = LitIn0.lit_in,
  function Model3.model = Model3.model, predicate Invariant2.invariant' = Invariant1.invariant',
  predicate Invariant3.invariant' = Invariant2.invariant',
  predicate ClausePostWithRegardsToLit0.clause_post_with_regards_to_lit = ClausePostWithRegardsToLit0.clause_post_with_regards_to_lit,
  predicate Sat0.sat = Sat0.sat, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_Trail_Impl0_BacktrackTo_Interface as BacktrackTo0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Invariant0.invariant' = Invariant2.invariant', predicate Invariant1.invariant' = Invariant1.invariant',
  function Model2.model = Model7.model, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg learn_unit [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (cref : usize) (f : Type.lib_formula_formula) : Type.core_result_result () ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Invariant0.invariant' (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))}
    requires {Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) = 1}
    requires {UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant1.invariant' f}
    requires {Invariant2.invariant' ( * self) f}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { match (result) with
      | Type.Core_Result_Result_Err _ -> true
      | Type.Core_Result_Result_Ok _ -> Sat0.sat (Seq.get (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) 0) (Type.lib_trail_trail_Trail_assignments ( ^ self))
      end }
    ensures { Invariant2.invariant' ( ^ self) f }
    
   = 
  var _0 : Type.core_result_result () ();
  var self_1 : borrowed (Type.lib_trail_trail);
  var cref_2 : usize;
  var f_3 : Type.lib_formula_formula;
  var _4 : ();
  var _5 : bool;
  var _6 : usize;
  var _7 : Type.lib_trail_trail;
  var _8 : ();
  var _9 : borrowed (Type.lib_trail_trail);
  var _10 : Type.lib_formula_formula;
  var _11 : ();
  var _12 : bool;
  var _13 : Type.lib_lit_lit;
  var _14 : Type.lib_lit_lit;
  var _15 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _16 : Type.lib_clause_clause;
  var _17 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _18 : usize;
  var _19 : Type.lib_assignments_assignments;
  var _20 : Type.lib_assignments_assignments;
  var _21 : ();
  var _22 : ();
  var _23 : ();
  var _24 : borrowed (Type.lib_trail_trail);
  var _25 : Type.lib_trail_step;
  var _26 : Type.lib_lit_lit;
  var _27 : Type.lib_lit_lit;
  var _28 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _29 : Type.lib_clause_clause;
  var _30 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _31 : usize;
  var _32 : Type.lib_trail_reason;
  var _33 : usize;
  var _34 : Type.lib_formula_formula;
  var _35 : ();
  {
    self_1 <- self;
    cref_2 <- cref;
    f_3 <- f;
    goto BB0
  }
  BB0 {
    _7 <-  * self_1;
    _6 <- DecisionLevel0.decision_level _7;
    goto BB1
  }
  BB1 {
    _5 <- _6 > (0 : usize);
    switch (_5)
      | False -> goto BB4
      | _ -> goto BB2
      end
  }
  BB2 {
    _9 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _9) };
    _10 <- f_3;
    _8 <- BacktrackTo0.backtrack_to _9 (0 : usize) _10;
    goto BB3
  }
  BB3 {
    _4 <- ();
    assume { Resolve0.resolve _4 };
    goto BB5
  }
  BB4 {
    _4 <- ();
    assume { Resolve0.resolve _4 };
    goto BB5
  }
  BB5 {
    _17 <- Type.lib_formula_formula_Formula_clauses f_3;
    assume { Resolve1.resolve _18 };
    _18 <- cref_2;
    _16 <- Index0.index _17 _18;
    goto BB6
  }
  BB6 {
    _15 <- Type.lib_clause_clause_Clause_rest _16;
    assume { Resolve2.resolve _16 };
    _14 <- Index1.index _15 (0 : usize);
    goto BB7
  }
  BB7 {
    assume { Resolve3.resolve _13 };
    _13 <- _14;
    assume { Resolve4.resolve _14 };
    _20 <- Type.lib_trail_trail_Trail_assignments ( * self_1);
    _19 <- _20;
    assume { Resolve5.resolve _20 };
    _12 <- LitSet0.lit_set _13 _19;
    goto BB8
  }
  BB8 {
    switch (_12)
      | False -> goto BB10
      | _ -> goto BB9
      end
  }
  BB9 {
    assume { Resolve6.resolve self_1 };
    assume { Resolve1.resolve cref_2 };
    assume { Resolve7.resolve f_3 };
    _22 <- ();
    _0 <- Type.Core_Result_Result_Err _22;
    goto BB14
  }
  BB10 {
    _11 <- ();
    assume { Resolve0.resolve _11 };
    _24 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _24) };
    _30 <- Type.lib_formula_formula_Formula_clauses f_3;
    assume { Resolve1.resolve _31 };
    _31 <- cref_2;
    _29 <- Index0.index _30 _31;
    goto BB11
  }
  BB11 {
    _28 <- Type.lib_clause_clause_Clause_rest _29;
    assume { Resolve2.resolve _29 };
    _27 <- Index1.index _28 (0 : usize);
    goto BB12
  }
  BB12 {
    assume { Resolve3.resolve _26 };
    _26 <- _27;
    assume { Resolve4.resolve _27 };
    assume { Resolve1.resolve _33 };
    _33 <- cref_2;
    assume { Resolve1.resolve cref_2 };
    _32 <- Type.Lib_Trail_Reason_Unit _33;
    _25 <- Type.Lib_Trail_Step _26 (0 : usize) _32;
    _34 <- f_3;
    assume { Resolve7.resolve f_3 };
    _23 <- EnqAssignment0.enq_assignment _24 _25 _34;
    goto BB13
  }
  BB13 {
    assume { Resolve6.resolve self_1 };
    _35 <- ();
    _0 <- Type.Core_Result_Result_Ok _35;
    goto BB14
  }
  BB14 {
    return _0
  }
  
end
module Lib_Solver_HandleConflict_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable_Interface as NotSatisfiable0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val handle_conflict [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (t : borrowed (Type.lib_trail_trail)) (cref : usize) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments ( * t))}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * w) ( * f)}
    requires {Invariant1.invariant' ( * t) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { match (result) with
      | Type.Core_Option_Option_Some (False) -> NotSatisfiable0.not_satisfiable ( ^ f)
      | Type.Core_Option_Option_Some (True) -> true
      | Type.Core_Option_Option_None -> true
      end }
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant0.invariant' ( ^ w) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ t) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
end
module Lib_Solver_HandleConflict
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model6 with function Model0.model = Model9.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss1 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss1.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model6.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model6.model
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model6.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model7.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model4.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model4.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model3.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model0.model,
  function Model1.model = Model6.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model0.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model4.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model0.model,
  function Model1.model = Model6.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model0.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model4.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model3.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model3.model, function Model1.model = Model4.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicFormula_Impl0_Model as Model5 with function Model0.model = Model0.model
  clone Lib_Logic_LogicClause_Impl2_EquisatExtension as EquisatExtension0 with function Model0.model = Model5.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable as NotSatisfiable0 with function Model0.model = Model6.model,
  predicate EquisatExtension0.equisat_extension = EquisatExtension0.equisat_extension
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model6.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model5.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model8.model,
  function Model1.model = Model0.model, function Model2.model = Model6.model
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model2.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = Type.core_result_result () ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.lib_conflictanalysis_conflict
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve3 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve2 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve1 with type t = Type.lib_formula_formula
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model6.model
  clone Lib_Logic_LogicFormula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Logic_LogicFormula_Equisat as Equisat1 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss1.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat1.equisat
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model5.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone CreusotContracts_Logic_Model_Impl1_Model as Model11 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model5.model
  clone Lib_Trail_Impl0_LearnUnit_Interface as LearnUnit0 with function Model0.model = Model4.model,
  function Model1.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  function Model2.model = Model0.model, predicate Invariant0.invariant' = Invariant4.invariant',
  function Model3.model = Model6.model, predicate Invariant1.invariant' = Invariant2.invariant',
  predicate Invariant2.invariant' = Invariant1.invariant', predicate Sat0.sat = Sat0.sat,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_Formula_Impl1_AddUnit_Interface as AddUnit0 with function Model0.model = Model11.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  function Model1.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate Invariant0.invariant' = Invariant4.invariant', predicate Invariant1.invariant' = Invariant1.invariant',
  predicate Invariant2.invariant' = Invariant2.invariant', function Model2.model = Model0.model,
  predicate Equisat0.equisat = Equisat0.equisat,
  predicate EquisatCompatible0.equisat_compatible = EquisatCompatible0.equisat_compatible,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_Trail_Impl0_BacktrackTo_Interface as BacktrackTo0 with function Model0.model = Model4.model,
  function Model1.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate Invariant1.invariant' = Invariant2.invariant',
  function Model2.model = Model3.model, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_ConflictAnalysis_AnalyzeConflict_Interface as AnalyzeConflict0 with function Model0.model = Model0.model,
  predicate Unsat0.unsat = Unsat0.unsat, predicate Invariant0.invariant' = Invariant1.invariant',
  predicate Invariant1.invariant' = Invariant2.invariant', function Model1.model = Model3.model,
  predicate NotSatisfiable0.not_satisfiable = NotSatisfiable0.not_satisfiable,
  predicate Invariant2.invariant' = Invariant4.invariant', function Model2.model = Model6.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  function Model3.model = Model10.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_Formula_Impl1_AddClause_Interface as AddClause0 with function Model0.model = Model11.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner,
  function Model1.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate Invariant1.invariant' = Invariant1.invariant',
  predicate Invariant2.invariant' = Invariant2.invariant', function Model2.model = Model0.model,
  predicate Equisat0.equisat = Equisat0.equisat,
  predicate EquisatCompatible0.equisat_compatible = EquisatCompatible0.equisat_compatible,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg handle_conflict [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (t : borrowed (Type.lib_trail_trail)) (cref : usize) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments ( * t))}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * w) ( * f)}
    requires {Invariant1.invariant' ( * t) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { match (result) with
      | Type.Core_Option_Option_Some (False) -> NotSatisfiable0.not_satisfiable ( ^ f)
      | Type.Core_Option_Option_Some (True) -> true
      | Type.Core_Option_Option_None -> true
      end }
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant0.invariant' ( ^ w) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ t) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
   = 
  var _0 : Type.core_option_option bool;
  var f_1 : borrowed (Type.lib_formula_formula);
  var t_2 : borrowed (Type.lib_trail_trail);
  var cref_3 : usize;
  var w_4 : borrowed (Type.lib_watches_watches);
  var res_5 : Type.lib_conflictanalysis_conflict;
  var _6 : Type.lib_formula_formula;
  var _7 : Type.lib_trail_trail;
  var _8 : usize;
  var _9 : ();
  var _10 : isize;
  var _11 : ();
  var clause_12 : Type.lib_clause_clause;
  var cref_13 : usize;
  var _14 : borrowed (Type.lib_formula_formula);
  var _15 : Type.lib_clause_clause;
  var _16 : Type.lib_trail_trail;
  var _17 : Type.core_result_result () ();
  var _18 : borrowed (Type.lib_trail_trail);
  var _19 : usize;
  var _20 : Type.lib_formula_formula;
  var _21 : isize;
  var _22 : ();
  var level_23 : usize;
  var clause_24 : Type.lib_clause_clause;
  var cref_25 : usize;
  var _26 : borrowed (Type.lib_formula_formula);
  var _27 : Type.lib_clause_clause;
  var _28 : borrowed (Type.lib_watches_watches);
  var _29 : Type.lib_trail_trail;
  var _30 : ();
  var _31 : borrowed (Type.lib_trail_trail);
  var _32 : usize;
  var _33 : Type.lib_formula_formula;
  var _34 : ();
  {
    f_1 <- f;
    t_2 <- t;
    cref_3 <- cref;
    w_4 <- w;
    goto BB0
  }
  BB0 {
    _6 <-  * f_1;
    _7 <-  * t_2;
    assume { Resolve0.resolve _8 };
    _8 <- cref_3;
    assume { Resolve0.resolve cref_3 };
    res_5 <- AnalyzeConflict0.analyze_conflict _6 _7 _8;
    goto BB1
  }
  BB1 {
    switch (res_5)
      | Type.Lib_ConflictAnalysis_Conflict_Ground -> goto BB4
      | Type.Lib_ConflictAnalysis_Conflict_Unit _ -> goto BB5
      | Type.Lib_ConflictAnalysis_Conflict_Learned _ _ -> goto BB12
      | Type.Lib_ConflictAnalysis_Conflict_Panic -> goto BB2
      end
  }
  BB2 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve t_2 };
    assume { Resolve3.resolve w_4 };
    _0 <- Type.Core_Option_Option_Some true;
    goto BB19
  }
  BB3 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve t_2 };
    assume { Resolve3.resolve w_4 };
    assume { Resolve4.resolve res_5 };
    absurd
  }
  BB4 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve t_2 };
    assume { Resolve3.resolve w_4 };
    _0 <- Type.Core_Option_Option_Some false;
    goto BB19
  }
  BB5 {
    assume { Resolve3.resolve w_4 };
    assume { Resolve5.resolve clause_12 };
    clause_12 <- Type.lib_conflictanalysis_conflict_Unit_0 res_5;
    _14 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _14) };
    assume { Resolve5.resolve _15 };
    _15 <- clause_12;
    _16 <-  * t_2;
    cref_13 <- AddUnit0.add_unit _14 _15 _16;
    goto BB6
  }
  BB6 {
    _18 <- borrow_mut ( * t_2);
    t_2 <- { t_2 with current = ( ^ _18) };
    assume { Resolve0.resolve _19 };
    _19 <- cref_13;
    assume { Resolve0.resolve cref_13 };
    _20 <-  * f_1;
    assume { Resolve1.resolve f_1 };
    _17 <- LearnUnit0.learn_unit _18 _19 _20;
    goto BB7
  }
  BB7 {
    assume { Resolve2.resolve t_2 };
    assume { Resolve7.resolve _17 };
    switch (_17)
      | Type.Core_Result_Result_Ok _ -> goto BB8
      | Type.Core_Result_Result_Err _ -> goto BB10
      end
  }
  BB8 {
    _9 <- ();
    assume { Resolve6.resolve _9 };
    goto BB11
  }
  BB9 {
    assume { Resolve4.resolve res_5 };
    absurd
  }
  BB10 {
    _0 <- Type.Core_Option_Option_Some true;
    goto BB18
  }
  BB11 {
    goto BB16
  }
  BB12 {
    assume { Resolve0.resolve level_23 };
    level_23 <- Type.lib_conflictanalysis_conflict_Learned_0 res_5;
    assume { Resolve5.resolve clause_24 };
    clause_24 <- Type.lib_conflictanalysis_conflict_Learned_1 res_5;
    _26 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _26) };
    assume { Resolve5.resolve _27 };
    _27 <- clause_24;
    _28 <- borrow_mut ( * w_4);
    w_4 <- { w_4 with current = ( ^ _28) };
    _29 <-  * t_2;
    cref_25 <- AddClause0.add_clause _26 _27 _28 _29;
    goto BB13
  }
  BB13 {
    assume { Resolve3.resolve w_4 };
    assume { Resolve0.resolve cref_25 };
    _31 <- borrow_mut ( * t_2);
    t_2 <- { t_2 with current = ( ^ _31) };
    assume { Resolve0.resolve _32 };
    _32 <- level_23;
    assume { Resolve0.resolve level_23 };
    _33 <-  * f_1;
    assume { Resolve1.resolve f_1 };
    _30 <- BacktrackTo0.backtrack_to _31 _32 _33;
    goto BB14
  }
  BB14 {
    assume { Resolve2.resolve t_2 };
    _9 <- ();
    assume { Resolve6.resolve _9 };
    goto BB15
  }
  BB15 {
    goto BB16
  }
  BB16 {
    _0 <- Type.Core_Option_Option_None;
    goto BB17
  }
  BB17 {
    assume { Resolve4.resolve res_5 };
    goto BB21
  }
  BB18 {
    goto BB19
  }
  BB19 {
    goto BB20
  }
  BB20 {
    assume { Resolve4.resolve res_5 };
    goto BB21
  }
  BB21 {
    return _0
  }
  
end
module Lib_UnitProp_Swap_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val swap [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : Type.lib_trail_trail) (watches : Type.lib_watches_watches) (cref : usize) (j : usize) (k : usize) : ()
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > UInt64.to_int k}
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > UInt64.to_int j}
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) >= 2}
    requires {Invariant0.invariant' watches ( * f)}
    requires {Invariant1.invariant' ( * f)}
    requires {Invariant2.invariant' trail ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) = Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int cref))) }
    ensures { Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant0.invariant' watches ( ^ f) }
    ensures { Invariant1.invariant' ( ^ f) }
    ensures { Invariant2.invariant' trail ( ^ f) }
    
end
module Lib_UnitProp_Swap
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model10 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model9.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model4 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model3 with function Model0.model = Model6.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant5 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model2.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner2 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model1.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnit as PostUnit0 with function Model0.model = Model3.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model1.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_Logic_LemmaSwapClauseNoDups as LemmaSwapClauseNoDups0 with function Model0.model = Model1.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  axiom .
  clone Lib_Logic_Logic_LemmaSwapMaintainsPostUnit as LemmaSwapMaintainsPostUnit0 with predicate PostUnit0.post_unit = PostUnit0.post_unit,
  function Model0.model = Model1.model,
  function LemmaSwapClauseNoDups0.lemma_swap_clause_no_dups = LemmaSwapClauseNoDups0.lemma_swap_clause_no_dups,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model0.model,
  function Model1.model = Model1.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant6 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model0.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model2.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner1 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicFormula_Impl0_Model as Model8 with function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model8.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model10.model,
  function Model1.model = Model0.model, function Model2.model = Model1.model
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model7.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model0.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model2.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model9.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model3.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant2 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model9.model, function Model1.model = Model2.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve5 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_formula_formula),
  function Model0.model = Model4.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model12 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl1_Swap_Interface as Swap0 with type t = Type.lib_lit_lit,
  function Model0.model = Model12.model, function Model1.model = Model5.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = Type.lib_clause_clause,
  function Model0.model = Model0.model, function Model1.model = Model11.model
  let rec cfg swap [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : Type.lib_trail_trail) (watches : Type.lib_watches_watches) (cref : usize) (j : usize) (k : usize) : ()
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > UInt64.to_int k}
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > UInt64.to_int j}
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) >= 2}
    requires {Invariant0.invariant' watches ( * f)}
    requires {Invariant1.invariant' ( * f)}
    requires {Invariant2.invariant' trail ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) = Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int cref))) }
    ensures { Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant0.invariant' watches ( ^ f) }
    ensures { Invariant1.invariant' ( ^ f) }
    ensures { Invariant2.invariant' trail ( ^ f) }
    
   = 
  var _0 : ();
  var f_1 : borrowed (Type.lib_formula_formula);
  var trail_2 : Type.lib_trail_trail;
  var watches_3 : Type.lib_watches_watches;
  var cref_4 : usize;
  var j_5 : usize;
  var k_6 : usize;
  var old_f_7 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula));
  var _8 : borrowed (Type.lib_formula_formula);
  var _9 : borrowed (Type.lib_formula_formula);
  var _10 : ();
  var _11 : ();
  var _12 : ();
  var _13 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _14 : borrowed (Type.lib_clause_clause);
  var _15 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _16 : usize;
  var _17 : usize;
  var _18 : usize;
  var _19 : ();
  var _20 : ();
  var _21 : ();
  var _22 : ();
  var _23 : ();
  {
    f_1 <- f;
    trail_2 <- trail;
    watches_3 <- watches;
    cref_4 <- cref;
    j_5 <- j;
    k_6 <- k;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve trail_2 };
    assume { Resolve1.resolve watches_3 };
    _9 <- f_1;
    _8 <- _9;
    assume { Resolve2.resolve _9 };
    old_f_7 <- Record0.record _8;
    goto BB1
  }
  BB1 {
    assume { Resolve3.resolve old_f_7 };
    assert { NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4))) };
    _10 <- ();
    assume { Resolve4.resolve _10 };
    assert { LongArePostUnitInner0.long_are_post_unit_inner (Model2.model (Type.lib_trail_trail_Trail_trail trail_2)) ( * f_1) (Model3.model (Type.lib_trail_trail_Trail_assignments trail_2)) && true };
    _11 <- ();
    assume { Resolve4.resolve _11 };
    _15 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Type.Lib_Formula_Formula a b =  * f_1 in Type.Lib_Formula_Formula ( ^ _15) b) };
    assume { Resolve5.resolve f_1 };
    assume { Resolve6.resolve _16 };
    _16 <- cref_4;
    assume { Resolve6.resolve cref_4 };
    _14 <- IndexMut0.index_mut _15 _16;
    goto BB2
  }
  BB2 {
    _13 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * _14));
    _14 <- { _14 with current = (let Type.Lib_Clause_Clause a =  * _14 in Type.Lib_Clause_Clause ( ^ _13)) };
    assume { Resolve6.resolve _17 };
    _17 <- j_5;
    assume { Resolve6.resolve j_5 };
    assume { Resolve6.resolve _18 };
    _18 <- k_6;
    assume { Resolve6.resolve k_6 };
    _12 <- Swap0.swap _13 _17 _18;
    goto BB3
  }
  BB3 {
    assume { Resolve7.resolve _14 };
    assert { let _ = LemmaSwapMaintainsPostUnit0.lemma_swap_maintains_post_unit (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * Model4.model old_f_7))) (UInt64.to_int cref_4)) (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4)) (UInt64.to_int j_5) (UInt64.to_int k_6) (Type.lib_trail_trail_Trail_assignments trail_2) in true };
    _19 <- ();
    assume { Resolve4.resolve _19 };
    assert { VarsInRangeInner0.vars_in_range_inner (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4))) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f_1))) };
    _20 <- ();
    assume { Resolve4.resolve _20 };
    assert { NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4))) };
    _21 <- ();
    assume { Resolve4.resolve _21 };
    assert { LongArePostUnitInner0.long_are_post_unit_inner (Model2.model (Type.lib_trail_trail_Trail_trail trail_2)) ( * f_1) (Model3.model (Type.lib_trail_trail_Trail_assignments trail_2)) };
    _22 <- ();
    assume { Resolve4.resolve _22 };
    assert {  ^ Model4.model old_f_7 =  ^ f_1 };
    _23 <- ();
    assume { Resolve4.resolve _23 };
    _0 <- ();
    return _0
  }
  
end
module Lib_Watches_UpdateWatch_Interface
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model3
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  val update_watch [@cfg:stackify] (f : Type.lib_formula_formula) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (j : usize) (k : usize) (lit : Type.lib_lit_lit) : ()
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) > UInt64.to_int j}
    requires {Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) >= 2}
    requires {0 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)))}
    requires {UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' f}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) < div 18446744073709551615 2}
    requires {Invariant2.invariant' ( * watches) f}
    ensures { Invariant2.invariant' ( ^ watches) f }
    
end
module Lib_Watches_UpdateWatch
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model10 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model9 with function Model0.model = Model10.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model9.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model9.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model7.model,
  function Model1.model = Model9.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model7.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model6.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model4.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  clone Lib_Logic_LogicUtil_Pop as Pop0 with type t = Type.lib_watches_watcher, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model3.model,
  function Model1.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model3.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model7.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model3.model,
  function Model1.model = Model4.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model3.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model7.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model6.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model9.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model6.model, function Model1.model = Model7.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicFormula_Impl0_Model as Model8 with function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model8.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicWatches_LemmaPushMaintainsWatcherInvariant as LemmaPushMaintainsWatcherInvariant0 with function Model0.model = Model3.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range, axiom .
  clone Lib_Logic_LogicWatches_LemmaPopWatchMaintainsWatcherInvariant as LemmaPopWatchMaintainsWatcherInvariant0 with predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range,
  function Pop0.pop = Pop0.pop, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model, function Model2.model = Model4.model
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model1 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve13 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve12 with type t = Type.core_option_option (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve11 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve10 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy3 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Model_Impl0_Model as Model16 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index2 with type t = Type.lib_lit_lit,
  function Model0.model = Model16.model
  clone Lib_Lit_Impl0_ToWatchidx_Interface as ToWatchidx0 with function ToWatchidxLogic0.to_watchidx_logic = ToWatchidxLogic0.to_watchidx_logic
  clone Lib_Lit_Impl0_ToNegWatchidx_Interface as ToNegWatchidx0 with function ToNegWatchidxLogic0.to_neg_watchidx_logic = ToNegWatchidxLogic0.to_neg_watchidx_logic
  clone CreusotContracts_Logic_Model_Impl0_Model as Model15 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_clause_clause,
  function Model0.model = Model15.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model14 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model2.model, function Model1.model = Model14.model
  clone CreusotContracts_Std1_Vec_Impl1_Pop_Interface as Pop1 with type t = Type.lib_watches_watcher,
  function Model0.model = Model14.model, function Model1.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl1_Swap_Interface as Swap0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model14.model, function Model1.model = Model2.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model12 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model12.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_watches_watches),
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model13 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model0.model, function Model1.model = Model13.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model11.model
  let rec cfg update_watch [@cfg:stackify] (f : Type.lib_formula_formula) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (j : usize) (k : usize) (lit : Type.lib_lit_lit) : ()
    requires {Seq.length (Model2.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) > UInt64.to_int j}
    requires {Seq.length (Model4.model (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) >= 2}
    requires {0 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model4.model (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)))}
    requires {UInt64.to_int cref < Seq.length (Model3.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant1.invariant' trail f}
    requires {Invariant2.invariant' f}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * watches) f}
    ensures { Invariant0.invariant' ( ^ watches) f }
    
   = 
  var _0 : ();
  var f_1 : Type.lib_formula_formula;
  var trail_2 : Type.lib_trail_trail;
  var watches_3 : borrowed (Type.lib_watches_watches);
  var cref_4 : usize;
  var j_5 : usize;
  var k_6 : usize;
  var lit_7 : Type.lib_lit_lit;
  var watchidx_8 : usize;
  var _9 : Type.lib_lit_lit;
  var end'_10 : usize;
  var _11 : usize;
  var _12 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _13 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _14 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _15 : usize;
  var _16 : ();
  var _17 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _18 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _19 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)));
  var _20 : usize;
  var _21 : usize;
  var _22 : usize;
  var curr_lit_23 : Type.lib_lit_lit;
  var _24 : Type.lib_lit_lit;
  var _25 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _26 : Type.lib_clause_clause;
  var _27 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _28 : usize;
  var _29 : usize;
  var _30 : ();
  var old_w_31 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches));
  var _32 : borrowed (Type.lib_watches_watches);
  var _33 : borrowed (Type.lib_watches_watches);
  var _34 : ();
  var _35 : ();
  var _36 : Type.core_option_option (Type.lib_watches_watcher);
  var _37 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _38 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _39 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)));
  var _40 : usize;
  var _41 : isize;
  var w_42 : Type.lib_watches_watcher;
  var _43 : ();
  var _44 : ();
  var _45 : ();
  var _46 : ();
  var _47 : ();
  var _48 : ();
  var _49 : ();
  var _50 : ();
  var _51 : ();
  var _52 : ();
  var _53 : ();
  var _54 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _55 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _56 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)));
  var _57 : usize;
  var _58 : Type.lib_lit_lit;
  var _59 : Type.lib_watches_watcher;
  var _60 : ();
  var _61 : ();
  var _62 : ();
  var _63 : ();
  var _64 : ();
  {
    f_1 <- f;
    trail_2 <- trail;
    watches_3 <- watches;
    cref_4 <- cref;
    j_5 <- j;
    k_6 <- k;
    lit_7 <- lit;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve trail_2 };
    _9 <- lit_7;
    assume { Resolve1.resolve lit_7 };
    watchidx_8 <- ToWatchidx0.to_watchidx _9;
    goto BB1
  }
  BB1 {
    _14 <- Type.lib_watches_watches_Watches_watches ( * watches_3);
    assume { Resolve2.resolve _15 };
    _15 <- watchidx_8;
    _13 <- Index0.index _14 _15;
    goto BB2
  }
  BB2 {
    _12 <- _13;
    assume { Resolve3.resolve _13 };
    _11 <- Len0.len _12;
    goto BB3
  }
  BB3 {
    end'_10 <- _11 - (1 : usize);
    _19 <- borrow_mut (Type.lib_watches_watches_Watches_watches ( * watches_3));
    watches_3 <- { watches_3 with current = (let Type.Lib_Watches_Watches a =  * watches_3 in Type.Lib_Watches_Watches ( ^ _19)) };
    assume { Resolve2.resolve _20 };
    _20 <- watchidx_8;
    _18 <- IndexMut0.index_mut _19 _20;
    goto BB4
  }
  BB4 {
    _17 <- borrow_mut ( * _18);
    _18 <- { _18 with current = ( ^ _17) };
    assume { Resolve2.resolve _21 };
    _21 <- j_5;
    assume { Resolve2.resolve j_5 };
    assume { Resolve2.resolve _22 };
    _22 <- end'_10;
    assume { Resolve2.resolve end'_10 };
    _16 <- Swap0.swap _17 _21 _22;
    goto BB5
  }
  BB5 {
    assume { Resolve4.resolve _18 };
    _27 <- Type.lib_formula_formula_Formula_clauses f_1;
    assume { Resolve5.resolve f_1 };
    assume { Resolve2.resolve _28 };
    _28 <- cref_4;
    assume { Resolve2.resolve cref_4 };
    _26 <- Index1.index _27 _28;
    goto BB6
  }
  BB6 {
    _25 <- Type.lib_clause_clause_Clause_rest _26;
    assume { Resolve6.resolve _26 };
    assume { Resolve2.resolve _29 };
    _29 <- k_6;
    assume { Resolve2.resolve k_6 };
    _24 <- Index2.index _25 _29;
    goto BB7
  }
  BB7 {
    assume { Resolve1.resolve curr_lit_23 };
    curr_lit_23 <- _24;
    assume { Resolve7.resolve _24 };
    assert { UInt64.to_int watchidx_8 < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) };
    _30 <- ();
    assume { Resolve8.resolve _30 };
    _33 <- watches_3;
    _32 <- _33;
    assume { Resolve9.resolve _33 };
    old_w_31 <- Record0.record _32;
    goto BB8
  }
  BB8 {
    assume { Resolve10.resolve old_w_31 };
    assert { Type.lib_watches_watches_Watches_watches ( * Model1.model old_w_31) = Type.lib_watches_watches_Watches_watches ( * watches_3) };
    _34 <- ();
    assume { Resolve8.resolve _34 };
    assert { WatcherCrefsInRange0.watcher_crefs_in_range (Model2.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) (UInt64.to_int watchidx_8))) f_1 };
    _35 <- ();
    assume { Resolve8.resolve _35 };
    _39 <- borrow_mut (Type.lib_watches_watches_Watches_watches ( * watches_3));
    watches_3 <- { watches_3 with current = (let Type.Lib_Watches_Watches a =  * watches_3 in Type.Lib_Watches_Watches ( ^ _39)) };
    assume { Resolve2.resolve _40 };
    _40 <- watchidx_8;
    assume { Resolve2.resolve watchidx_8 };
    _38 <- IndexMut0.index_mut _39 _40;
    goto BB9
  }
  BB9 {
    _37 <- borrow_mut ( * _38);
    _38 <- { _38 with current = ( ^ _37) };
    _36 <- Pop1.pop _37;
    goto BB10
  }
  BB10 {
    assume { Resolve4.resolve _38 };
    switch (_36)
      | Type.Core_Option_Option_None -> goto BB11
      | Type.Core_Option_Option_Some _ -> goto BB13
      end
  }
  BB11 {
    assume { Resolve11.resolve watches_3 };
    assume { Resolve1.resolve curr_lit_23 };
    assume { Resolve12.resolve _36 };
    absurd
  }
  BB12 {
    assume { Resolve11.resolve watches_3 };
    assume { Resolve1.resolve curr_lit_23 };
    assume { Resolve12.resolve _36 };
    absurd
  }
  BB13 {
    assume { Resolve13.resolve w_42 };
    w_42 <- Type.core_option_option_Some_0 _36;
    assume { Resolve12.resolve _36 };
    assert {  ^ Model1.model old_w_31 =  ^ watches_3 };
    _43 <- ();
    assume { Resolve8.resolve _43 };
    assert { let _ = LemmaPopWatchMaintainsWatcherInvariant0.lemma_pop_watch_maintains_watcher_invariant (Model2.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * Model1.model old_w_31))) (UInt64.to_int watchidx_8))) f_1 in true };
    _44 <- ();
    assume { Resolve8.resolve _44 };
    assert { WatcherCrefsInRange0.watcher_crefs_in_range (Pop0.pop (Model2.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * Model1.model old_w_31))) (UInt64.to_int watchidx_8)))) f_1 };
    _45 <- ();
    assume { Resolve8.resolve _45 };
    assert { Model2.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) (UInt64.to_int watchidx_8)) = Pop0.pop (Model2.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * Model1.model old_w_31))) (UInt64.to_int watchidx_8))) };
    _46 <- ();
    assume { Resolve8.resolve _46 };
    assert { WatcherCrefsInRange0.watcher_crefs_in_range (Model2.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) (UInt64.to_int watchidx_8))) f_1 };
    _47 <- ();
    assume { Resolve8.resolve _47 };
    assert { Invariant0.invariant' ( * watches_3) f_1 };
    _48 <- ();
    assume { Resolve8.resolve _48 };
    assert { ToNegWatchidxLogic0.to_neg_watchidx_logic curr_lit_23 < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) };
    _49 <- ();
    assume { Resolve8.resolve _49 };
    assert { WatcherCrefsInRange0.watcher_crefs_in_range (Model2.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) (ToNegWatchidxLogic0.to_neg_watchidx_logic curr_lit_23))) f_1 };
    _50 <- ();
    assume { Resolve8.resolve _50 };
    assert { UInt64.to_int (Type.lib_watches_watcher_Watcher_cref w_42) < Seq.length (Model3.model (Type.lib_formula_formula_Formula_clauses f_1)) };
    _51 <- ();
    assume { Resolve8.resolve _51 };
    assert { let _ = LemmaPushMaintainsWatcherInvariant0.lemma_push_maintains_watcher_invariant (Model2.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) (ToNegWatchidxLogic0.to_neg_watchidx_logic curr_lit_23))) f_1 w_42 in true };
    _52 <- ();
    assume { Resolve8.resolve _52 };
    _56 <- borrow_mut (Type.lib_watches_watches_Watches_watches ( * watches_3));
    watches_3 <- { watches_3 with current = (let Type.Lib_Watches_Watches a =  * watches_3 in Type.Lib_Watches_Watches ( ^ _56)) };
    assume { Resolve11.resolve watches_3 };
    _58 <- curr_lit_23;
    assume { Resolve1.resolve curr_lit_23 };
    _57 <- ToNegWatchidx0.to_neg_watchidx _58;
    goto BB14
  }
  BB14 {
    _55 <- IndexMut0.index_mut _56 _57;
    goto BB15
  }
  BB15 {
    _54 <- borrow_mut ( * _55);
    _55 <- { _55 with current = ( ^ _54) };
    assume { Resolve13.resolve _59 };
    _59 <- w_42;
    _53 <- Push0.push _54 _59;
    goto BB16
  }
  BB16 {
    assume { Resolve4.resolve _55 };
    assert { WatcherCrefsInRange0.watcher_crefs_in_range (Model2.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) (ToNegWatchidxLogic0.to_neg_watchidx_logic curr_lit_23))) f_1 };
    _60 <- ();
    assume { Resolve8.resolve _60 };
    assert { Invariant0.invariant' ( * watches_3) f_1 };
    _61 <- ();
    assume { Resolve8.resolve _61 };
    _0 <- ();
    return _0
  }
  
end
module Lib_UnitProp_UnitPropCheckRest_Interface
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicLit_Impl1_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model3
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  val unit_prop_check_rest [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (j : usize) (k : usize) (lit : Type.lib_lit_lit) : Type.core_result_result () ()
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) > UInt64.to_int j}
    requires {Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > 2}
    requires {2 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref)))}
    requires {UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' trail ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int cref))) = Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok _ -> true
      | Type.Core_Result_Result_Err _ -> Unsat0.unsat (Seq.get (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int cref))) (UInt64.to_int k)) (Type.lib_trail_trail_Trail_assignments trail) &&  ^ f =  * f &&  * watches =  ^ watches
      end }
    ensures { Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) }
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' trail ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
end
module Lib_UnitProp_UnitPropCheckRest
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model8 with function Model0.model = Model9.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model8.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model8.model
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Unsat as Unsat0 with function Model0.model = Model8.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model6.model,
  function Model1.model = Model8.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model6.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model5.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model3.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model2.model,
  function Model1.model = Model3.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model2.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model6.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model6.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model5.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model8.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model5.model, function Model1.model = Model6.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicFormula_Impl0_Model as Model7 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model7.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model1.model,
  function Model1.model = Model2.model, function Model2.model = Model3.model
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve5 with type t = Type.lib_formula_formula
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone Lib_Logic_LogicLit_Impl1_Unset as Unset1 with function Model0.model = Model8.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone CreusotContracts_Logic_Model_Impl0_Model as Model12 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model8.model
  clone Lib_Lit_Impl0_LitUnset_Interface as LitUnset0 with function Model0.model = Model12.model,
  predicate Invariant0.invariant' = Invariant6.invariant', predicate Unset0.unset = Unset1.unset
  clone Lib_Lit_Impl0_LitSat_Interface as LitSat0 with function Model0.model = Model12.model,
  predicate Invariant0.invariant' = Invariant6.invariant', predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Logic_Model_Impl0_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_lit_lit,
  function Model0.model = Model11.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_clause_clause,
  function Model0.model = Model10.model
  clone Lib_Watches_UpdateWatch_Interface as UpdateWatch0 with function Model0.model = Model0.model,
  function ToWatchidxLogic0.to_watchidx_logic = ToWatchidxLogic0.to_watchidx_logic,
  function Model1.model = Model1.model, function Model2.model = Model2.model, function Model3.model = Model3.model,
  predicate Invariant0.invariant' = Invariant1.invariant', predicate Invariant1.invariant' = Invariant2.invariant',
  predicate Invariant2.invariant' = Invariant0.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_UnitProp_Swap_Interface as Swap0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant2.invariant', predicate Invariant2.invariant' = Invariant1.invariant',
  predicate Equisat0.equisat = Equisat0.equisat, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg unit_prop_check_rest [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (j : usize) (k : usize) (lit : Type.lib_lit_lit) : Type.core_result_result () ()
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) > UInt64.to_int j}
    requires {Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > 2}
    requires {2 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref)))}
    requires {UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' trail ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int cref))) = Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok _ -> true
      | Type.Core_Result_Result_Err _ -> Unsat0.unsat (Seq.get (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int cref))) (UInt64.to_int k)) (Type.lib_trail_trail_Trail_assignments trail) &&  ^ f =  * f &&  * watches =  ^ watches
      end }
    ensures { Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) }
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' trail ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
   = 
  var _0 : Type.core_result_result () ();
  var f_1 : borrowed (Type.lib_formula_formula);
  var trail_2 : Type.lib_trail_trail;
  var watches_3 : borrowed (Type.lib_watches_watches);
  var cref_4 : usize;
  var j_5 : usize;
  var k_6 : usize;
  var lit_7 : Type.lib_lit_lit;
  var _8 : ();
  var curr_lit_9 : Type.lib_lit_lit;
  var _10 : Type.lib_lit_lit;
  var _11 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _12 : Type.lib_clause_clause;
  var _13 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _14 : usize;
  var _15 : usize;
  var _16 : ();
  var _17 : bool;
  var _18 : bool;
  var _19 : Type.lib_lit_lit;
  var _20 : Type.lib_assignments_assignments;
  var _21 : Type.lib_assignments_assignments;
  var _22 : bool;
  var _23 : Type.lib_lit_lit;
  var _24 : Type.lib_assignments_assignments;
  var _25 : Type.lib_assignments_assignments;
  var _26 : ();
  var _27 : ();
  var _28 : bool;
  var _29 : usize;
  var _30 : Type.lib_lit_lit;
  var _31 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _32 : Type.lib_clause_clause;
  var _33 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _34 : usize;
  var _35 : usize;
  var _36 : ();
  var _37 : borrowed (Type.lib_formula_formula);
  var _38 : Type.lib_trail_trail;
  var _39 : Type.lib_watches_watches;
  var _40 : usize;
  var _41 : usize;
  var _42 : ();
  var _43 : Type.lib_formula_formula;
  var _44 : Type.lib_trail_trail;
  var _45 : borrowed (Type.lib_watches_watches);
  var _46 : usize;
  var _47 : usize;
  var _48 : Type.lib_lit_lit;
  var _49 : ();
  var _50 : borrowed (Type.lib_formula_formula);
  var _51 : Type.lib_trail_trail;
  var _52 : Type.lib_watches_watches;
  var _53 : usize;
  var _54 : usize;
  var _55 : ();
  var _56 : Type.lib_formula_formula;
  var _57 : Type.lib_trail_trail;
  var _58 : borrowed (Type.lib_watches_watches);
  var _59 : usize;
  var _60 : usize;
  var _61 : Type.lib_lit_lit;
  var _62 : ();
  var _63 : ();
  {
    f_1 <- f;
    trail_2 <- trail;
    watches_3 <- watches;
    cref_4 <- cref;
    j_5 <- j;
    k_6 <- k;
    lit_7 <- lit;
    goto BB0
  }
  BB0 {
    _13 <- Type.lib_formula_formula_Formula_clauses ( * f_1);
    assume { Resolve0.resolve _14 };
    _14 <- cref_4;
    _12 <- Index0.index _13 _14;
    goto BB1
  }
  BB1 {
    _11 <- Type.lib_clause_clause_Clause_rest _12;
    assume { Resolve1.resolve _12 };
    assume { Resolve0.resolve _15 };
    _15 <- k_6;
    _10 <- Index1.index _11 _15;
    goto BB2
  }
  BB2 {
    assume { Resolve2.resolve curr_lit_9 };
    curr_lit_9 <- _10;
    assume { Resolve3.resolve _10 };
    assume { Resolve2.resolve _19 };
    _19 <- curr_lit_9;
    _21 <- Type.lib_trail_trail_Trail_assignments trail_2;
    _20 <- _21;
    assume { Resolve4.resolve _21 };
    _18 <- LitUnset0.lit_unset _19 _20;
    goto BB6
  }
  BB3 {
    assume { Resolve2.resolve curr_lit_9 };
    _17 <- true;
    goto BB5
  }
  BB4 {
    assume { Resolve2.resolve _23 };
    _23 <- curr_lit_9;
    assume { Resolve2.resolve curr_lit_9 };
    _25 <- Type.lib_trail_trail_Trail_assignments trail_2;
    _24 <- _25;
    assume { Resolve4.resolve _25 };
    _22 <- LitSat0.lit_sat _23 _24;
    goto BB7
  }
  BB5 {
    switch (_17)
      | False -> goto BB18
      | _ -> goto BB8
      end
  }
  BB6 {
    switch (_18)
      | False -> goto BB4
      | _ -> goto BB3
      end
  }
  BB7 {
    assume { Resolve9.resolve _17 };
    _17 <- _22;
    goto BB5
  }
  BB8 {
    _33 <- Type.lib_formula_formula_Formula_clauses ( * f_1);
    assume { Resolve0.resolve _34 };
    _34 <- cref_4;
    _32 <- Index0.index _33 _34;
    goto BB9
  }
  BB9 {
    _31 <- Type.lib_clause_clause_Clause_rest _32;
    assume { Resolve1.resolve _32 };
    _30 <- Index1.index _31 (0 : usize);
    goto BB10
  }
  BB10 {
    assume { Resolve0.resolve _29 };
    _29 <- Type.lib_lit_lit_Lit_idx _30;
    assume { Resolve3.resolve _30 };
    assume { Resolve0.resolve _35 };
    _35 <- Type.lib_lit_lit_Lit_idx lit_7;
    _28 <- _29 = _35;
    switch (_28)
      | False -> goto BB14
      | _ -> goto BB11
      end
  }
  BB11 {
    _37 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _37) };
    _38 <- trail_2;
    _39 <-  * watches_3;
    assume { Resolve0.resolve _40 };
    _40 <- cref_4;
    assume { Resolve0.resolve _41 };
    _41 <- k_6;
    assume { Resolve0.resolve k_6 };
    _36 <- Swap0.swap _37 _38 _39 _40 _41 (0 : usize);
    goto BB12
  }
  BB12 {
    _43 <-  * f_1;
    assume { Resolve5.resolve f_1 };
    _44 <- trail_2;
    assume { Resolve6.resolve trail_2 };
    _45 <- borrow_mut ( * watches_3);
    watches_3 <- { watches_3 with current = ( ^ _45) };
    assume { Resolve0.resolve _46 };
    _46 <- cref_4;
    assume { Resolve0.resolve cref_4 };
    assume { Resolve0.resolve _47 };
    _47 <- j_5;
    assume { Resolve0.resolve j_5 };
    assume { Resolve2.resolve _48 };
    _48 <- lit_7;
    assume { Resolve2.resolve lit_7 };
    _42 <- UpdateWatch0.update_watch _43 _44 _45 _46 _47 (0 : usize) _48;
    goto BB13
  }
  BB13 {
    assume { Resolve7.resolve watches_3 };
    _27 <- ();
    assume { Resolve8.resolve _27 };
    goto BB17
  }
  BB14 {
    _50 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _50) };
    _51 <- trail_2;
    _52 <-  * watches_3;
    assume { Resolve0.resolve _53 };
    _53 <- cref_4;
    assume { Resolve0.resolve _54 };
    _54 <- k_6;
    assume { Resolve0.resolve k_6 };
    _49 <- Swap0.swap _50 _51 _52 _53 _54 (1 : usize);
    goto BB15
  }
  BB15 {
    _56 <-  * f_1;
    assume { Resolve5.resolve f_1 };
    _57 <- trail_2;
    assume { Resolve6.resolve trail_2 };
    _58 <- borrow_mut ( * watches_3);
    watches_3 <- { watches_3 with current = ( ^ _58) };
    assume { Resolve0.resolve _59 };
    _59 <- cref_4;
    assume { Resolve0.resolve cref_4 };
    assume { Resolve0.resolve _60 };
    _60 <- j_5;
    assume { Resolve0.resolve j_5 };
    assume { Resolve2.resolve _61 };
    _61 <- lit_7;
    assume { Resolve2.resolve lit_7 };
    _55 <- UpdateWatch0.update_watch _56 _57 _58 _59 _60 (1 : usize) _61;
    goto BB16
  }
  BB16 {
    assume { Resolve7.resolve watches_3 };
    _27 <- ();
    assume { Resolve8.resolve _27 };
    goto BB17
  }
  BB17 {
    _62 <- ();
    _0 <- Type.Core_Result_Result_Ok _62;
    goto BB19
  }
  BB18 {
    assume { Resolve5.resolve f_1 };
    assume { Resolve6.resolve trail_2 };
    assume { Resolve7.resolve watches_3 };
    assume { Resolve0.resolve cref_4 };
    assume { Resolve0.resolve j_5 };
    assume { Resolve0.resolve k_6 };
    assume { Resolve2.resolve lit_7 };
    _16 <- ();
    assume { Resolve8.resolve _16 };
    _63 <- ();
    _0 <- Type.Core_Result_Result_Err _63;
    goto BB19
  }
  BB19 {
    return _0
  }
  
end
module Lib_UnitProp_UnitPropDoOuter_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat1
  clone Lib_Logic_LogicFormula_Impl1_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model4 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model3 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val unit_prop_do_outer [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (lit : Type.lib_lit_lit) (j : usize) : Type.core_result_result bool usize
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) >= 2}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) > UInt64.to_int j}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' ( * trail) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok (True) -> true
      | Type.Core_Result_Result_Ok (False) -> Seq.length (Model4.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) = Seq.length (Model4.model (Type.lib_trail_trail_Trail_trail ( * trail)))
      | Type.Core_Result_Result_Err n -> UInt64.to_int n < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) && Unsat0.unsat ( ^ f) (Type.lib_trail_trail_Trail_assignments ( ^ trail)) && Unsat1.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int n)) (Type.lib_trail_trail_Trail_assignments ( ^ trail))
      end }
    ensures { Type.lib_trail_trail_Trail_decisions ( ^ trail) = Type.lib_trail_trail_Trail_decisions ( * trail) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ trail) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
end
module Lib_UnitProp_UnitPropDoOuter
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_Logic_Unset as Unset1
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset1.unset
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model12 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model11 with function Model0.model = Model12.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model11.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model11.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Logic_LogicLit_Impl1_Unset as Unset0 with function Model0.model = Model11.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Unsat as Unsat0 with function Model0.model = Model11.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model6 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model10 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model10.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model4.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_UnitInner as UnitInner0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, function Model0.model = Model4.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone Lib_Logic_LogicClause_Impl2_Unit as Unit0 with function Model0.model = Model11.model,
  predicate UnitInner0.unit_inner = UnitInner0.unit_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model4.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnit as PostUnit0 with function Model0.model = Model11.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToLit as ClausePostWithRegardsToLit0 with predicate PostUnit0.post_unit = PostUnit0.post_unit,
  function Model0.model = Model4.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model4.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat1 with function Model0.model = Model11.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model3.model,
  function Model1.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model3.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model3.model,
  function Model1.model = Model4.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model3.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner2 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicFormula_Impl1_Unsat as Unsat2 with function Model0.model = Model11.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model9 with function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model9.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model7.model,
  function Model1.model = Model3.model, function Model2.model = Model4.model
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model2 with type t = borrowed (Type.lib_formula_formula)
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model8.model,
  function Model1.model = Model11.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model8.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model8.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model5.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model8.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model5.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model11.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model5.model, function Model1.model = Model8.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model1 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve16 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve15 with type t = Type.core_result_result () ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve14 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve13 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve12 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve11 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve10 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve6 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve5 with type t = Type.lib_formula_formula
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Logic_Model_Impl0_Model as Model15 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model11.model
  clone Lib_Lit_Impl0_LitSat_Interface as LitSat0 with function Model0.model = Model15.model,
  predicate Invariant0.invariant' = Invariant6.invariant', predicate Sat0.sat = Sat0.sat
  clone Lib_Lit_Impl0_LitUnset_Interface as LitUnset0 with function Model0.model = Model15.model,
  predicate Invariant0.invariant' = Invariant6.invariant', predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record1 with type t = borrowed (Type.lib_trail_trail),
  function Model0.model = Model6.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model14 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model10.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_lit_lit,
  function Model0.model = Model14.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_lit_lit,
  function Model0.model = Model14.model
  clone Lib_Logic_LogicLit_Impl1_LitIn as LitIn0 with function Model0.model = Model4.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model13 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_clause_clause,
  function Model0.model = Model13.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_formula_formula),
  function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_IdxInTrail as IdxInTrail0 with function Model0.model = Model8.model
  clone Lib_Trail_Impl0_DecisionLevel_Interface as DecisionLevel0 with function Model0.model = Model5.model
  clone Lib_Trail_Impl0_EnqAssignment_Interface as EnqAssignment0 with function Model0.model = Model8.model,
  function Model1.model = Model11.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Unset0.unset = Unset1.unset, predicate IdxInTrail0.idx_in_trail = IdxInTrail0.idx_in_trail,
  predicate Invariant0.invariant' = Invariant6.invariant', predicate Invariant1.invariant' = Invariant5.invariant',
  function Model2.model = Model3.model, predicate Unit0.unit = Unit0.unit, predicate LitIn0.lit_in = LitIn0.lit_in,
  function Model3.model = Model4.model, predicate Invariant2.invariant' = Invariant2.invariant',
  predicate Invariant3.invariant' = Invariant1.invariant',
  predicate ClausePostWithRegardsToLit0.clause_post_with_regards_to_lit = ClausePostWithRegardsToLit0.clause_post_with_regards_to_lit,
  predicate Sat0.sat = Sat0.sat, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record2 with type t = borrowed (Type.lib_watches_watches),
  function Model0.model = Model1.model
  clone Lib_UnitProp_UnitPropCheckRest_Interface as UnitPropCheckRest0 with function Model0.model = Model0.model,
  function ToWatchidxLogic0.to_watchidx_logic = ToWatchidxLogic0.to_watchidx_logic,
  function Model1.model = Model7.model, function Model2.model = Model3.model, function Model3.model = Model4.model,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate Invariant1.invariant' = Invariant1.invariant',
  predicate Invariant2.invariant' = Invariant2.invariant', predicate Unsat0.unsat = Unsat0.unsat,
  predicate Equisat0.equisat = Equisat0.equisat, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_UnitProp_Swap_Interface as Swap0 with function Model0.model = Model3.model,
  function Model1.model = Model4.model, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant2.invariant', predicate Invariant2.invariant' = Invariant1.invariant',
  predicate Equisat0.equisat = Equisat0.equisat, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg unit_prop_do_outer [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (lit : Type.lib_lit_lit) (j : usize) : Type.core_result_result bool usize
    requires {Seq.length (Model4.model (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) >= 2}
    requires {UInt64.to_int cref < Seq.length (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Seq.length (Model7.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) > UInt64.to_int j}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' ( * trail) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok (True) -> true
      | Type.Core_Result_Result_Ok (False) -> Seq.length (Model8.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) = Seq.length (Model8.model (Type.lib_trail_trail_Trail_trail ( * trail)))
      | Type.Core_Result_Result_Err n -> UInt64.to_int n < Seq.length (Model3.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) && Unsat2.unsat ( ^ f) (Type.lib_trail_trail_Trail_assignments ( ^ trail)) && Unsat1.unsat (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int n)) (Type.lib_trail_trail_Trail_assignments ( ^ trail))
      end }
    ensures { Type.lib_trail_trail_Trail_decisions ( ^ trail) = Type.lib_trail_trail_Trail_decisions ( * trail) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ trail) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
   = 
  var _0 : Type.core_result_result bool usize;
  var f_1 : borrowed (Type.lib_formula_formula);
  var trail_2 : borrowed (Type.lib_trail_trail);
  var watches_3 : borrowed (Type.lib_watches_watches);
  var cref_4 : usize;
  var lit_5 : Type.lib_lit_lit;
  var j_6 : usize;
  var first_lit_7 : Type.lib_lit_lit;
  var _8 : Type.lib_lit_lit;
  var _9 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _10 : Type.lib_clause_clause;
  var _11 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _12 : usize;
  var _13 : ();
  var _14 : bool;
  var _15 : Type.lib_lit_lit;
  var _16 : Type.lib_assignments_assignments;
  var _17 : Type.lib_assignments_assignments;
  var _18 : ();
  var second_lit_19 : Type.lib_lit_lit;
  var _20 : Type.lib_lit_lit;
  var _21 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _22 : Type.lib_clause_clause;
  var _23 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _24 : usize;
  var old_f_25 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula));
  var _26 : borrowed (Type.lib_formula_formula);
  var _27 : borrowed (Type.lib_formula_formula);
  var _28 : ();
  var _29 : bool;
  var _30 : Type.lib_lit_lit;
  var _31 : Type.lib_assignments_assignments;
  var _32 : Type.lib_assignments_assignments;
  var _33 : ();
  var _34 : ();
  var _35 : borrowed (Type.lib_formula_formula);
  var _36 : Type.lib_trail_trail;
  var _37 : Type.lib_watches_watches;
  var _38 : usize;
  var k_39 : usize;
  var clause_len_40 : usize;
  var _41 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _42 : Type.lib_clause_clause;
  var _43 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _44 : usize;
  var old_trail_45 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _46 : borrowed (Type.lib_trail_trail);
  var _47 : borrowed (Type.lib_trail_trail);
  var old_w_48 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches));
  var _49 : borrowed (Type.lib_watches_watches);
  var _50 : borrowed (Type.lib_watches_watches);
  var _51 : ();
  var _52 : ();
  var _53 : bool;
  var _54 : usize;
  var _55 : usize;
  var _56 : ();
  var _57 : ();
  var _58 : Type.core_result_result () ();
  var _59 : borrowed (Type.lib_formula_formula);
  var _60 : Type.lib_trail_trail;
  var _61 : borrowed (Type.lib_watches_watches);
  var _62 : usize;
  var _63 : usize;
  var _64 : usize;
  var _65 : Type.lib_lit_lit;
  var _66 : isize;
  var _67 : ();
  var _68 : ();
  var _69 : ();
  var _70 : ();
  var _71 : ();
  var _72 : ();
  var _73 : ();
  var _74 : ();
  var _75 : ();
  var _76 : bool;
  var _77 : Type.lib_lit_lit;
  var _78 : Type.lib_assignments_assignments;
  var _79 : Type.lib_assignments_assignments;
  var _80 : ();
  var _81 : ();
  var _82 : bool;
  var _83 : Type.lib_lit_lit;
  var _84 : Type.lib_assignments_assignments;
  var _85 : Type.lib_assignments_assignments;
  var _86 : ();
  var _87 : ();
  var _88 : ();
  var _89 : ();
  var step_90 : Type.lib_trail_step;
  var _91 : Type.lib_lit_lit;
  var _92 : usize;
  var _93 : Type.lib_trail_trail;
  var _94 : Type.lib_trail_reason;
  var _95 : usize;
  var _96 : ();
  var _97 : borrowed (Type.lib_trail_trail);
  var _98 : Type.lib_trail_step;
  var _99 : Type.lib_formula_formula;
  var _100 : ();
  var _101 : ();
  var _102 : bool;
  var _103 : Type.lib_lit_lit;
  var _104 : Type.lib_assignments_assignments;
  var _105 : Type.lib_assignments_assignments;
  var _106 : ();
  var _107 : ();
  var _108 : ();
  var step_109 : Type.lib_trail_step;
  var _110 : Type.lib_lit_lit;
  var _111 : usize;
  var _112 : Type.lib_trail_trail;
  var _113 : Type.lib_trail_reason;
  var _114 : usize;
  var _115 : ();
  var _116 : borrowed (Type.lib_trail_trail);
  var _117 : Type.lib_trail_step;
  var _118 : Type.lib_formula_formula;
  var _119 : ();
  var _120 : ();
  var _121 : ();
  var _122 : usize;
  {
    f_1 <- f;
    trail_2 <- trail;
    watches_3 <- watches;
    cref_4 <- cref;
    lit_5 <- lit;
    j_6 <- j;
    goto BB0
  }
  BB0 {
    _11 <- Type.lib_formula_formula_Formula_clauses ( * f_1);
    assume { Resolve0.resolve _12 };
    _12 <- cref_4;
    _10 <- Index0.index _11 _12;
    goto BB1
  }
  BB1 {
    _9 <- Type.lib_clause_clause_Clause_rest _10;
    assume { Resolve1.resolve _10 };
    _8 <- Index1.index _9 (0 : usize);
    goto BB2
  }
  BB2 {
    assume { Resolve2.resolve first_lit_7 };
    first_lit_7 <- _8;
    assume { Resolve3.resolve _8 };
    assume { Resolve2.resolve _15 };
    _15 <- first_lit_7;
    _17 <- Type.lib_trail_trail_Trail_assignments ( * trail_2);
    _16 <- _17;
    assume { Resolve4.resolve _17 };
    _14 <- LitSat0.lit_sat _15 _16;
    goto BB3
  }
  BB3 {
    switch (_14)
      | False -> goto BB5
      | _ -> goto BB4
      end
  }
  BB4 {
    assume { Resolve5.resolve f_1 };
    assume { Resolve6.resolve trail_2 };
    assume { Resolve7.resolve watches_3 };
    assume { Resolve0.resolve cref_4 };
    assume { Resolve2.resolve lit_5 };
    assume { Resolve0.resolve j_6 };
    assume { Resolve2.resolve first_lit_7 };
    _0 <- Type.Core_Result_Result_Ok true;
    goto BB41
  }
  BB5 {
    _13 <- ();
    assume { Resolve8.resolve _13 };
    _23 <- Type.lib_formula_formula_Formula_clauses ( * f_1);
    assume { Resolve0.resolve _24 };
    _24 <- cref_4;
    _22 <- Index0.index _23 _24;
    goto BB6
  }
  BB6 {
    _21 <- Type.lib_clause_clause_Clause_rest _22;
    assume { Resolve1.resolve _22 };
    _20 <- Index1.index _21 (1 : usize);
    goto BB7
  }
  BB7 {
    assume { Resolve2.resolve second_lit_19 };
    second_lit_19 <- _20;
    assume { Resolve3.resolve _20 };
    _27 <- f_1;
    _26 <- _27;
    assume { Resolve9.resolve _27 };
    old_f_25 <- Record0.record _26;
    goto BB8
  }
  BB8 {
    assume { Resolve10.resolve old_f_25 };
    assume { Resolve2.resolve _30 };
    _30 <- second_lit_19;
    _32 <- Type.lib_trail_trail_Trail_assignments ( * trail_2);
    _31 <- _32;
    assume { Resolve4.resolve _32 };
    _29 <- LitSat0.lit_sat _30 _31;
    goto BB9
  }
  BB9 {
    switch (_29)
      | False -> goto BB12
      | _ -> goto BB10
      end
  }
  BB10 {
    assume { Resolve2.resolve lit_5 };
    assume { Resolve0.resolve j_6 };
    assume { Resolve2.resolve first_lit_7 };
    assume { Resolve2.resolve second_lit_19 };
    _35 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _35) };
    _36 <-  * trail_2;
    assume { Resolve6.resolve trail_2 };
    _37 <-  * watches_3;
    assume { Resolve7.resolve watches_3 };
    assume { Resolve0.resolve _38 };
    _38 <- cref_4;
    assume { Resolve0.resolve cref_4 };
    _34 <- Swap0.swap _35 _36 _37 _38 (0 : usize) (1 : usize);
    goto BB11
  }
  BB11 {
    assume { Resolve5.resolve f_1 };
    _0 <- Type.Core_Result_Result_Ok true;
    goto BB40
  }
  BB12 {
    _28 <- ();
    assume { Resolve8.resolve _28 };
    k_39 <- (2 : usize);
    _43 <- Type.lib_formula_formula_Formula_clauses ( * f_1);
    assume { Resolve0.resolve _44 };
    _44 <- cref_4;
    _42 <- Index0.index _43 _44;
    goto BB13
  }
  BB13 {
    _41 <- Type.lib_clause_clause_Clause_rest _42;
    assume { Resolve1.resolve _42 };
    clause_len_40 <- Len0.len _41;
    goto BB14
  }
  BB14 {
    _47 <- trail_2;
    _46 <- _47;
    assume { Resolve11.resolve _47 };
    old_trail_45 <- Record1.record _46;
    goto BB15
  }
  BB15 {
    assume { Resolve12.resolve old_trail_45 };
    _50 <- watches_3;
    _49 <- _50;
    assume { Resolve13.resolve _50 };
    old_w_48 <- Record2.record _49;
    goto BB16
  }
  BB16 {
    assume { Resolve14.resolve old_w_48 };
    goto BB17
  }
  BB17 {
    invariant k_bound { 2 <= UInt64.to_int k_39 && UInt64.to_int k_39 <= UInt64.to_int clause_len_40 };
    invariant watch_len { Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) = Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * Model1.model old_w_48))) };
    invariant watch_inv { Invariant0.invariant' ( * watches_3) ( * f_1) };
    invariant trail_inv { Invariant1.invariant' ( * trail_2) ( * f_1) };
    invariant f_equi { Equisat0.equisat ( * Model2.model old_f_25) ( * f_1) };
    invariant f_inv { Invariant2.invariant' ( * f_1) };
    invariant f_len { Seq.length (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) = Seq.length (Model3.model (Type.lib_formula_formula_Formula_clauses ( * Model2.model old_f_25))) };
    invariant len_same { Seq.length (Model4.model (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4))) = UInt64.to_int clause_len_40 };
    invariant nvars_unch { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f_1)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * Model2.model old_f_25)) };
    invariant f_unch { f_1 = Model2.model old_f_25 };
    invariant w_unch {  * watches_3 =  * Model1.model old_w_48 };
    invariant dec_unch { Model5.model (Type.lib_trail_trail_Trail_decisions ( * trail_2)) = Model5.model (Type.lib_trail_trail_Trail_decisions ( * Model6.model old_trail_45)) };
    invariant proph_t {  ^ trail_2 =  ^ Model6.model old_trail_45 };
    invariant proph_f {  ^ f_1 =  ^ Model2.model old_f_25 };
    invariant proph_w {  ^ watches_3 =  ^ Model1.model old_w_48 };
    invariant uns { forall m : (int) . 2 <= m && m < UInt64.to_int k_39 -> Unsat0.unsat (Seq.get (Model4.model (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4))) m) (Type.lib_trail_trail_Trail_assignments ( * trail_2)) };
    assume { Resolve0.resolve _54 };
    _54 <- k_39;
    assume { Resolve0.resolve _55 };
    _55 <- clause_len_40;
    _53 <- _54 < _55;
    switch (_53)
      | False -> goto BB23
      | _ -> goto BB18
      end
  }
  BB18 {
    assert { Seq.length (Model7.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) (ToWatchidxLogic0.to_watchidx_logic lit_5))) > UInt64.to_int j_6 };
    _56 <- ();
    assume { Resolve8.resolve _56 };
    _59 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _59) };
    _60 <-  * trail_2;
    _61 <- borrow_mut ( * watches_3);
    watches_3 <- { watches_3 with current = ( ^ _61) };
    assume { Resolve0.resolve _62 };
    _62 <- cref_4;
    assume { Resolve0.resolve _63 };
    _63 <- j_6;
    assume { Resolve0.resolve _64 };
    _64 <- k_39;
    assume { Resolve2.resolve _65 };
    _65 <- lit_5;
    _58 <- UnitPropCheckRest0.unit_prop_check_rest _59 _60 _61 _62 _63 _64 _65;
    goto BB19
  }
  BB19 {
    assume { Resolve15.resolve _58 };
    switch (_58)
      | Type.Core_Result_Result_Ok _ -> goto BB20
      | Type.Core_Result_Result_Err _ -> goto BB22
      end
  }
  BB20 {
    assume { Resolve5.resolve f_1 };
    assume { Resolve6.resolve trail_2 };
    assume { Resolve7.resolve watches_3 };
    assume { Resolve0.resolve cref_4 };
    assume { Resolve2.resolve lit_5 };
    assume { Resolve0.resolve j_6 };
    assume { Resolve2.resolve first_lit_7 };
    assume { Resolve2.resolve second_lit_19 };
    assume { Resolve0.resolve k_39 };
    assume { Resolve0.resolve clause_len_40 };
    _0 <- Type.Core_Result_Result_Ok false;
    goto BB39
  }
  BB21 {
    assume { Resolve5.resolve f_1 };
    assume { Resolve6.resolve trail_2 };
    assume { Resolve7.resolve watches_3 };
    assume { Resolve0.resolve cref_4 };
    assume { Resolve2.resolve lit_5 };
    assume { Resolve0.resolve j_6 };
    assume { Resolve2.resolve first_lit_7 };
    assume { Resolve2.resolve second_lit_19 };
    assume { Resolve0.resolve k_39 };
    assume { Resolve0.resolve clause_len_40 };
    absurd
  }
  BB22 {
    assert { Type.lib_trail_trail_Trail_decisions ( * Model6.model old_trail_45) = Type.lib_trail_trail_Trail_decisions ( * trail_2) };
    _67 <- ();
    assume { Resolve8.resolve _67 };
    assert {  * watches_3 =  * Model1.model old_w_48 };
    _68 <- ();
    assume { Resolve8.resolve _68 };
    assert {  * f_1 =  * Model2.model old_f_25 };
    _69 <- ();
    assume { Resolve8.resolve _69 };
    _57 <- ();
    assume { Resolve8.resolve _57 };
    k_39 <- k_39 + (1 : usize);
    _52 <- ();
    assume { Resolve8.resolve _52 };
    goto BB17
  }
  BB23 {
    assume { Resolve7.resolve watches_3 };
    assume { Resolve2.resolve lit_5 };
    assume { Resolve0.resolve j_6 };
    assume { Resolve0.resolve k_39 };
    assume { Resolve0.resolve clause_len_40 };
    _51 <- ();
    assume { Resolve8.resolve _51 };
    assert { Type.lib_trail_trail_Trail_decisions ( * Model6.model old_trail_45) = Type.lib_trail_trail_Trail_decisions ( * trail_2) };
    _74 <- ();
    assume { Resolve8.resolve _74 };
    assert { Unsat1.unsat (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4)) (Type.lib_trail_trail_Trail_assignments ( * trail_2)) || Unset0.unset (Seq.get (Model4.model (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4))) 0) (Type.lib_trail_trail_Trail_assignments ( * trail_2)) || Unset0.unset (Seq.get (Model4.model (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4))) 1) (Type.lib_trail_trail_Trail_assignments ( * trail_2)) };
    _75 <- ();
    assume { Resolve8.resolve _75 };
    assume { Resolve2.resolve _77 };
    _77 <- first_lit_7;
    _79 <- Type.lib_trail_trail_Trail_assignments ( * trail_2);
    _78 <- _79;
    assume { Resolve4.resolve _79 };
    _76 <- LitUnset0.lit_unset _77 _78;
    goto BB24
  }
  BB24 {
    switch (_76)
      | False -> goto BB31
      | _ -> goto BB25
      end
  }
  BB25 {
    assume { Resolve2.resolve _83 };
    _83 <- second_lit_19;
    assume { Resolve2.resolve second_lit_19 };
    _85 <- Type.lib_trail_trail_Trail_assignments ( * trail_2);
    _84 <- _85;
    assume { Resolve4.resolve _85 };
    _82 <- LitUnset0.lit_unset _83 _84;
    goto BB26
  }
  BB26 {
    switch (_82)
      | False -> goto BB28
      | _ -> goto BB27
      end
  }
  BB27 {
    assume { Resolve5.resolve f_1 };
    assume { Resolve6.resolve trail_2 };
    assume { Resolve0.resolve cref_4 };
    assume { Resolve2.resolve first_lit_7 };
    _0 <- Type.Core_Result_Result_Ok true;
    goto BB38
  }
  BB28 {
    _81 <- ();
    assume { Resolve8.resolve _81 };
    assert { Invariant1.invariant' ( * trail_2) ( * f_1) };
    _87 <- ();
    assume { Resolve8.resolve _87 };
    assert { not (Unsat1.unsat (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4)) (Type.lib_trail_trail_Trail_assignments ( * trail_2))) };
    _88 <- ();
    assume { Resolve8.resolve _88 };
    assert { Unit0.unit (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4)) (Type.lib_trail_trail_Trail_assignments ( * trail_2)) };
    _89 <- ();
    assume { Resolve8.resolve _89 };
    assume { Resolve2.resolve _91 };
    _91 <- first_lit_7;
    assume { Resolve2.resolve first_lit_7 };
    _93 <-  * trail_2;
    _92 <- DecisionLevel0.decision_level _93;
    goto BB29
  }
  BB29 {
    assume { Resolve0.resolve _95 };
    _95 <- cref_4;
    assume { Resolve0.resolve cref_4 };
    _94 <- Type.Lib_Trail_Reason_Long _95;
    step_90 <- Type.Lib_Trail_Step _91 _92 _94;
    _97 <- borrow_mut ( * trail_2);
    trail_2 <- { trail_2 with current = ( ^ _97) };
    assume { Resolve16.resolve _98 };
    _98 <- step_90;
    _99 <-  * f_1;
    assume { Resolve5.resolve f_1 };
    _96 <- EnqAssignment0.enq_assignment _97 _98 _99;
    goto BB30
  }
  BB30 {
    assume { Resolve6.resolve trail_2 };
    assert { PostUnit0.post_unit (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4)) (Type.lib_trail_trail_Trail_assignments ( * trail_2)) && true };
    _100 <- ();
    assume { Resolve8.resolve _100 };
    assert { ClausePostWithRegardsToLit0.clause_post_with_regards_to_lit (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4)) (Type.lib_trail_trail_Trail_assignments ( * trail_2)) first_lit_7 };
    _101 <- ();
    assume { Resolve8.resolve _101 };
    _0 <- Type.Core_Result_Result_Ok true;
    goto BB38
  }
  BB31 {
    assume { Resolve2.resolve first_lit_7 };
    assume { Resolve2.resolve _103 };
    _103 <- second_lit_19;
    _105 <- Type.lib_trail_trail_Trail_assignments ( * trail_2);
    _104 <- _105;
    assume { Resolve4.resolve _105 };
    _102 <- LitUnset0.lit_unset _103 _104;
    goto BB32
  }
  BB32 {
    switch (_102)
      | False -> goto BB36
      | _ -> goto BB33
      end
  }
  BB33 {
    assert { not (Unsat1.unsat (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4)) (Type.lib_trail_trail_Trail_assignments ( * trail_2))) && true && true };
    _107 <- ();
    assume { Resolve8.resolve _107 };
    assert { Unit0.unit (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4)) (Type.lib_trail_trail_Trail_assignments ( * trail_2)) };
    _108 <- ();
    assume { Resolve8.resolve _108 };
    assume { Resolve2.resolve _110 };
    _110 <- second_lit_19;
    assume { Resolve2.resolve second_lit_19 };
    _112 <-  * trail_2;
    _111 <- DecisionLevel0.decision_level _112;
    goto BB34
  }
  BB34 {
    assume { Resolve0.resolve _114 };
    _114 <- cref_4;
    assume { Resolve0.resolve cref_4 };
    _113 <- Type.Lib_Trail_Reason_Long _114;
    step_109 <- Type.Lib_Trail_Step _110 _111 _113;
    _116 <- borrow_mut ( * trail_2);
    trail_2 <- { trail_2 with current = ( ^ _116) };
    assume { Resolve16.resolve _117 };
    _117 <- step_109;
    _118 <-  * f_1;
    assume { Resolve5.resolve f_1 };
    _115 <- EnqAssignment0.enq_assignment _116 _117 _118;
    goto BB35
  }
  BB35 {
    assume { Resolve6.resolve trail_2 };
    assert { PostUnit0.post_unit (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4)) (Type.lib_trail_trail_Trail_assignments ( * trail_2)) };
    _119 <- ();
    assume { Resolve8.resolve _119 };
    assert { ClausePostWithRegardsToLit0.clause_post_with_regards_to_lit (Seq.get (Model3.model (Type.lib_formula_formula_Formula_clauses ( * f_1))) (UInt64.to_int cref_4)) (Type.lib_trail_trail_Trail_assignments ( * trail_2)) second_lit_19 };
    _120 <- ();
    assume { Resolve8.resolve _120 };
    _0 <- Type.Core_Result_Result_Ok true;
    goto BB37
  }
  BB36 {
    assume { Resolve5.resolve f_1 };
    assume { Resolve6.resolve trail_2 };
    assume { Resolve2.resolve second_lit_19 };
    assume { Resolve0.resolve _122 };
    _122 <- cref_4;
    assume { Resolve0.resolve cref_4 };
    _0 <- Type.Core_Result_Result_Err _122;
    goto BB37
  }
  BB37 {
    goto BB38
  }
  BB38 {
    goto BB39
  }
  BB39 {
    goto BB40
  }
  BB40 {
    goto BB41
  }
  BB41 {
    return _0
  }
  
end
module Lib_UnitProp_UnitPropCurrentLevel_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use seq.Seq
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat1
  clone Lib_Logic_LogicFormula_Impl1_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  val unit_prop_current_level [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (lit : Type.lib_lit_lit) : Type.core_result_result () usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' ( * trail) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok () -> true
      | Type.Core_Result_Result_Err n -> UInt64.to_int n < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) && Unsat0.unsat ( ^ f) (Type.lib_trail_trail_Trail_assignments ( ^ trail)) && Unsat1.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int n)) (Type.lib_trail_trail_Trail_assignments ( ^ trail))
      end }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ trail) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
end
module Lib_UnitProp_UnitPropCurrentLevel
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model12 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model10 with function Model0.model = Model12.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model10.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model10.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model10.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model10.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model10.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model10.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model10.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model11 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model8 with function Model0.model = Model11.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model8.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model8.model
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat1 with function Model0.model = Model8.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model5.model,
  function Model1.model = Model10.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model5.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model5.model,
  function Model1.model = Model10.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model5.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicFormula_Impl1_Unsat as Unsat0 with function Model0.model = Model8.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model7 with function Model0.model = Model5.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model10.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model7.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model9.model,
  function Model1.model = Model5.model, function Model2.model = Model10.model
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model4 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model2 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model1 with type t = borrowed (Type.lib_watches_watches)
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model6.model,
  function Model1.model = Model8.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model6.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model6.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model3.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model6.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model3.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model8.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model3.model, function Model1.model = Model6.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant1 with function Model0.model = Model0.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve14 with type t = Type.core_result_result bool usize
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve13 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve12 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve11 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve10 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = ()
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone Lib_Lit_Impl0_ToWatchidx_Interface as ToWatchidx0 with function ToWatchidxLogic0.to_watchidx_logic = ToWatchidxLogic0.to_watchidx_logic
  clone CreusotContracts_Logic_Model_Impl0_Model as Model14 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model9.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_watches_watcher,
  function Model0.model = Model14.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model14.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_trail_trail),
  function Model0.model = Model4.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record1 with type t = borrowed (Type.lib_formula_formula),
  function Model0.model = Model2.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record2 with type t = borrowed (Type.lib_watches_watches),
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model13 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model13.model
  clone Lib_UnitProp_UnitPropDoOuter_Interface as UnitPropDoOuter0 with function Model0.model = Model5.model,
  function Model1.model = Model10.model, predicate Invariant0.invariant' = Invariant1.invariant',
  function Model2.model = Model0.model,
  function ToWatchidxLogic0.to_watchidx_logic = ToWatchidxLogic0.to_watchidx_logic,
  function Model3.model = Model9.model, predicate Invariant1.invariant' = Invariant0.invariant',
  predicate Invariant2.invariant' = Invariant2.invariant', predicate Equisat0.equisat = Equisat0.equisat,
  function Model4.model = Model6.model, predicate Unsat0.unsat = Unsat0.unsat, predicate Unsat1.unsat = Unsat1.unsat,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg unit_prop_current_level [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (lit : Type.lib_lit_lit) : Type.core_result_result () usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant1.invariant' ( * watches) ( * f)}
    requires {Invariant0.invariant' ( * trail) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok () -> true
      | Type.Core_Result_Result_Err n -> UInt64.to_int n < Seq.length (Model5.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) && Unsat0.unsat ( ^ f) (Type.lib_trail_trail_Trail_assignments ( ^ trail)) && Unsat1.unsat (Seq.get (Model5.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int n)) (Type.lib_trail_trail_Trail_assignments ( ^ trail))
      end }
    ensures { Invariant1.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ trail) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
   = 
  var _0 : Type.core_result_result () usize;
  var f_1 : borrowed (Type.lib_formula_formula);
  var trail_2 : borrowed (Type.lib_trail_trail);
  var watches_3 : borrowed (Type.lib_watches_watches);
  var lit_4 : Type.lib_lit_lit;
  var j_5 : usize;
  var watchidx_6 : usize;
  var _7 : Type.lib_lit_lit;
  var _8 : ();
  var _9 : ();
  var old_trail_10 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _11 : borrowed (Type.lib_trail_trail);
  var _12 : borrowed (Type.lib_trail_trail);
  var old_f_13 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula));
  var _14 : borrowed (Type.lib_formula_formula);
  var _15 : borrowed (Type.lib_formula_formula);
  var old_w_16 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches));
  var _17 : borrowed (Type.lib_watches_watches);
  var _18 : borrowed (Type.lib_watches_watches);
  var _19 : ();
  var _20 : ();
  var _21 : bool;
  var _22 : usize;
  var _23 : usize;
  var _24 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _25 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _26 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _27 : usize;
  var cref_28 : usize;
  var _29 : Type.lib_watches_watcher;
  var _30 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _31 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _32 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _33 : usize;
  var _34 : usize;
  var _35 : Type.core_result_result bool usize;
  var _36 : borrowed (Type.lib_formula_formula);
  var _37 : borrowed (Type.lib_trail_trail);
  var _38 : borrowed (Type.lib_watches_watches);
  var _39 : usize;
  var _40 : Type.lib_lit_lit;
  var _41 : usize;
  var _42 : isize;
  var cref_43 : usize;
  var _44 : ();
  var _45 : usize;
  var _46 : ();
  var _47 : ();
  var _48 : ();
  var _49 : ();
  {
    f_1 <- f;
    trail_2 <- trail;
    watches_3 <- watches;
    lit_4 <- lit;
    goto BB0
  }
  BB0 {
    j_5 <- (0 : usize);
    _7 <- lit_4;
    watchidx_6 <- ToWatchidx0.to_watchidx _7;
    goto BB1
  }
  BB1 {
    assert { Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) = 2 * UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f_1)) };
    _8 <- ();
    assume { Resolve0.resolve _8 };
    assert { Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) > UInt64.to_int watchidx_6 };
    _9 <- ();
    assume { Resolve0.resolve _9 };
    _12 <- trail_2;
    _11 <- _12;
    assume { Resolve1.resolve _12 };
    old_trail_10 <- Record0.record _11;
    goto BB2
  }
  BB2 {
    assume { Resolve2.resolve old_trail_10 };
    _15 <- f_1;
    _14 <- _15;
    assume { Resolve3.resolve _15 };
    old_f_13 <- Record1.record _14;
    goto BB3
  }
  BB3 {
    assume { Resolve4.resolve old_f_13 };
    _18 <- watches_3;
    _17 <- _18;
    assume { Resolve5.resolve _18 };
    old_w_16 <- Record2.record _17;
    goto BB4
  }
  BB4 {
    assume { Resolve6.resolve old_w_16 };
    goto BB5
  }
  BB5 {
    invariant trail_inv { Invariant0.invariant' ( * trail_2) ( * f_1) };
    invariant watch_len { Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) = Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * Model1.model old_w_16))) };
    invariant watch_inv { Invariant1.invariant' ( * watches_3) ( * f_1) };
    invariant f_equi { Equisat0.equisat ( * Model2.model old_f_13) ( * f_1) };
    invariant f_inv { Invariant2.invariant' ( * f_1) };
    invariant dec_unch { Model3.model (Type.lib_trail_trail_Trail_decisions ( * trail_2)) = Model3.model (Type.lib_trail_trail_Trail_decisions ( * Model4.model old_trail_10)) };
    invariant nvars_unch { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f_1)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * Model2.model old_f_13)) };
    invariant proph_t {  ^ trail_2 =  ^ Model4.model old_trail_10 };
    invariant proph_f {  ^ f_1 =  ^ Model2.model old_f_13 };
    invariant proph_w {  ^ watches_3 =  ^ Model1.model old_w_16 };
    assume { Resolve7.resolve _22 };
    _22 <- j_5;
    _26 <- Type.lib_watches_watches_Watches_watches ( * watches_3);
    assume { Resolve7.resolve _27 };
    _27 <- watchidx_6;
    _25 <- Index0.index _26 _27;
    goto BB6
  }
  BB6 {
    _24 <- _25;
    assume { Resolve8.resolve _25 };
    _23 <- Len0.len _24;
    goto BB7
  }
  BB7 {
    _21 <- _22 < _23;
    switch (_21)
      | False -> goto BB18
      | _ -> goto BB8
      end
  }
  BB8 {
    _32 <- Type.lib_watches_watches_Watches_watches ( * watches_3);
    assume { Resolve7.resolve _33 };
    _33 <- watchidx_6;
    _31 <- Index0.index _32 _33;
    goto BB9
  }
  BB9 {
    _30 <- _31;
    assume { Resolve8.resolve _31 };
    assume { Resolve7.resolve _34 };
    _34 <- j_5;
    _29 <- Index1.index _30 _34;
    goto BB10
  }
  BB10 {
    assume { Resolve7.resolve cref_28 };
    cref_28 <- Type.lib_watches_watcher_Watcher_cref _29;
    assume { Resolve9.resolve _29 };
    _36 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _36) };
    _37 <- borrow_mut ( * trail_2);
    trail_2 <- { trail_2 with current = ( ^ _37) };
    _38 <- borrow_mut ( * watches_3);
    watches_3 <- { watches_3 with current = ( ^ _38) };
    assume { Resolve7.resolve _39 };
    _39 <- cref_28;
    assume { Resolve7.resolve cref_28 };
    assume { Resolve10.resolve _40 };
    _40 <- lit_4;
    assume { Resolve7.resolve _41 };
    _41 <- j_5;
    _35 <- UnitPropDoOuter0.unit_prop_do_outer _36 _37 _38 _39 _40 _41;
    goto BB11
  }
  BB11 {
    switch (_35)
      | Type.Core_Result_Result_Ok _ -> goto BB12
      | Type.Core_Result_Result_Err _ -> goto BB13
      end
  }
  BB12 {
    switch (Type.core_result_result_Ok_0 _35)
      | False -> goto BB16
      | _ -> goto BB15
      end
  }
  BB13 {
    assume { Resolve11.resolve f_1 };
    assume { Resolve12.resolve trail_2 };
    assume { Resolve13.resolve watches_3 };
    assume { Resolve10.resolve lit_4 };
    assume { Resolve7.resolve j_5 };
    assume { Resolve7.resolve watchidx_6 };
    assume { Resolve7.resolve cref_43 };
    cref_43 <- Type.core_result_result_Err_0 _35;
    assume { Resolve14.resolve _35 };
    assume { Resolve7.resolve _45 };
    _45 <- cref_43;
    assume { Resolve7.resolve cref_43 };
    _0 <- Type.Core_Result_Result_Err _45;
    goto BB19
  }
  BB14 {
    assume { Resolve11.resolve f_1 };
    assume { Resolve12.resolve trail_2 };
    assume { Resolve13.resolve watches_3 };
    assume { Resolve10.resolve lit_4 };
    assume { Resolve7.resolve j_5 };
    assume { Resolve7.resolve watchidx_6 };
    assume { Resolve14.resolve _35 };
    absurd
  }
  BB15 {
    assume { Resolve14.resolve _35 };
    j_5 <- j_5 + (1 : usize);
    _20 <- ();
    assume { Resolve0.resolve _20 };
    goto BB17
  }
  BB16 {
    assume { Resolve14.resolve _35 };
    _20 <- ();
    assume { Resolve0.resolve _20 };
    goto BB17
  }
  BB17 {
    goto BB5
  }
  BB18 {
    assume { Resolve11.resolve f_1 };
    assume { Resolve12.resolve trail_2 };
    assume { Resolve13.resolve watches_3 };
    assume { Resolve10.resolve lit_4 };
    assume { Resolve7.resolve j_5 };
    assume { Resolve7.resolve watchidx_6 };
    _19 <- ();
    assume { Resolve0.resolve _19 };
    _49 <- ();
    _0 <- Type.Core_Result_Result_Ok _49;
    goto BB19
  }
  BB19 {
    return _0
  }
  
end
module Lib_UnitProp_UnitPropagate_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use seq.Seq
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat1
  clone Lib_Logic_LogicFormula_Impl1_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  val unit_propagate [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) : Type.core_result_result () usize
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' ( * trail) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok () -> true
      | Type.Core_Result_Result_Err n -> UInt64.to_int n < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) && Unsat0.unsat ( ^ f) (Type.lib_trail_trail_Trail_assignments ( ^ trail)) && Unsat1.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int n)) (Type.lib_trail_trail_Trail_assignments ( ^ trail))
      end }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ trail) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
end
module Lib_UnitProp_UnitPropagate
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model12 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model9 with function Model0.model = Model12.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model9.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model9.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant3 with function Model0.model = Model9.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model9.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model9.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model9.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model9.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model11 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model8 with function Model0.model = Model11.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model8.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant4 with function Model0.model = Model8.model
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat1 with function Model0.model = Model8.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model10 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model4.model,
  function Model1.model = Model9.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model4.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model4.model,
  function Model1.model = Model9.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model4.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner0 with function Model0.model = Model4.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicFormula_Impl1_Unsat as Unsat0 with function Model0.model = Model8.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model10.model,
  function Model1.model = Model4.model, function Model2.model = Model9.model
  clone Lib_Logic_LogicFormula_Impl0_Model as Model5 with function Model0.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model4.model,
  predicate Invariant0.invariant' = Invariant3.invariant', function Model1.model = Model9.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model5.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model3 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model2 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model1 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant2 with function Model0.model = Model0.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model7.model,
  function Model1.model = Model8.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model7.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model7.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model6.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model7.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model6.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model8.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model6.model, function Model1.model = Model7.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve13 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve12 with type t = Type.core_result_result () usize
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve11 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve10 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve9 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_trail_trail),
  function Model0.model = Model3.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record1 with type t = borrowed (Type.lib_formula_formula),
  function Model0.model = Model2.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record2 with type t = borrowed (Type.lib_watches_watches),
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model13 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model7.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_trail_step,
  function Model0.model = Model13.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_trail_step,
  function Model0.model = Model13.model
  clone Lib_UnitProp_UnitPropCurrentLevel_Interface as UnitPropCurrentLevel0 with predicate Invariant0.invariant' = Invariant2.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant0.invariant',
  predicate Equisat0.equisat = Equisat0.equisat, function Model0.model = Model4.model,
  predicate Unsat0.unsat = Unsat0.unsat, predicate Unsat1.unsat = Unsat1.unsat,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg unit_propagate [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) : Type.core_result_result () usize
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant2.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' ( * trail) ( * f)}
    requires {Invariant0.invariant' ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok () -> true
      | Type.Core_Result_Result_Err n -> UInt64.to_int n < Seq.length (Model4.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) && Unsat0.unsat ( ^ f) (Type.lib_trail_trail_Trail_assignments ( ^ trail)) && Unsat1.unsat (Seq.get (Model4.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int n)) (Type.lib_trail_trail_Trail_assignments ( ^ trail))
      end }
    ensures { Invariant2.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ trail) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ f) }
    
   = 
  var _0 : Type.core_result_result () usize;
  var f_1 : borrowed (Type.lib_formula_formula);
  var trail_2 : borrowed (Type.lib_trail_trail);
  var watches_3 : borrowed (Type.lib_watches_watches);
  var i_4 : usize;
  var old_trail_5 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _6 : borrowed (Type.lib_trail_trail);
  var _7 : borrowed (Type.lib_trail_trail);
  var old_f_8 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula));
  var _9 : borrowed (Type.lib_formula_formula);
  var _10 : borrowed (Type.lib_formula_formula);
  var old_w_11 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches));
  var _12 : borrowed (Type.lib_watches_watches);
  var _13 : borrowed (Type.lib_watches_watches);
  var _14 : ();
  var _15 : ();
  var _16 : bool;
  var _17 : usize;
  var _18 : usize;
  var _19 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var lit_20 : Type.lib_lit_lit;
  var _21 : Type.lib_trail_step;
  var _22 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var _23 : usize;
  var _24 : ();
  var _25 : Type.core_result_result () usize;
  var _26 : borrowed (Type.lib_formula_formula);
  var _27 : borrowed (Type.lib_trail_trail);
  var _28 : borrowed (Type.lib_watches_watches);
  var _29 : Type.lib_lit_lit;
  var _30 : isize;
  var cref_31 : usize;
  var _32 : ();
  var _33 : usize;
  var _34 : ();
  var _35 : ();
  var _36 : ();
  var _37 : usize;
  var _38 : ();
  {
    f_1 <- f;
    trail_2 <- trail;
    watches_3 <- watches;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve i_4 };
    i_4 <- Type.lib_trail_trail_Trail_curr_i ( * trail_2);
    _7 <- trail_2;
    _6 <- _7;
    assume { Resolve1.resolve _7 };
    old_trail_5 <- Record0.record _6;
    goto BB1
  }
  BB1 {
    assume { Resolve2.resolve old_trail_5 };
    _10 <- f_1;
    _9 <- _10;
    assume { Resolve3.resolve _10 };
    old_f_8 <- Record1.record _9;
    goto BB2
  }
  BB2 {
    assume { Resolve4.resolve old_f_8 };
    _13 <- watches_3;
    _12 <- _13;
    assume { Resolve5.resolve _13 };
    old_w_11 <- Record2.record _12;
    goto BB3
  }
  BB3 {
    assume { Resolve6.resolve old_w_11 };
    goto BB4
  }
  BB4 {
    invariant f_inv { Invariant0.invariant' ( * f_1) };
    invariant trail_inv { Invariant1.invariant' ( * trail_2) ( * f_1) };
    invariant watch_len { Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches_3))) = Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * Model1.model old_w_11))) };
    invariant watch_inv { Invariant2.invariant' ( * watches_3) ( * f_1) };
    invariant f_equi { Equisat0.equisat ( * Model2.model old_f_8) ( * f_1) };
    invariant nvars_unch { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f_1)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * Model2.model old_f_8)) };
    invariant proph_t {  ^ trail_2 =  ^ Model3.model old_trail_5 };
    invariant proph_f {  ^ f_1 =  ^ Model2.model old_f_8 };
    invariant proph_w {  ^ watches_3 =  ^ Model1.model old_w_11 };
    assume { Resolve0.resolve _17 };
    _17 <- i_4;
    _19 <- Type.lib_trail_trail_Trail_trail ( * trail_2);
    _18 <- Len0.len _19;
    goto BB5
  }
  BB5 {
    _16 <- _17 < _18;
    switch (_16)
      | False -> goto BB12
      | _ -> goto BB6
      end
  }
  BB6 {
    _22 <- Type.lib_trail_trail_Trail_trail ( * trail_2);
    assume { Resolve0.resolve _23 };
    _23 <- i_4;
    _21 <- Index0.index _22 _23;
    goto BB7
  }
  BB7 {
    assume { Resolve7.resolve lit_20 };
    lit_20 <- Type.lib_trail_step_Step_lit _21;
    assume { Resolve8.resolve _21 };
    _26 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _26) };
    _27 <- borrow_mut ( * trail_2);
    trail_2 <- { trail_2 with current = ( ^ _27) };
    _28 <- borrow_mut ( * watches_3);
    watches_3 <- { watches_3 with current = ( ^ _28) };
    assume { Resolve7.resolve _29 };
    _29 <- lit_20;
    assume { Resolve7.resolve lit_20 };
    _25 <- UnitPropCurrentLevel0.unit_prop_current_level _26 _27 _28 _29;
    goto BB8
  }
  BB8 {
    switch (_25)
      | Type.Core_Result_Result_Ok _ -> goto BB11
      | Type.Core_Result_Result_Err _ -> goto BB9
      end
  }
  BB9 {
    assume { Resolve9.resolve f_1 };
    assume { Resolve10.resolve trail_2 };
    assume { Resolve11.resolve watches_3 };
    assume { Resolve0.resolve i_4 };
    assume { Resolve0.resolve cref_31 };
    cref_31 <- Type.core_result_result_Err_0 _25;
    assume { Resolve12.resolve _25 };
    assume { Resolve0.resolve _33 };
    _33 <- cref_31;
    assume { Resolve0.resolve cref_31 };
    _0 <- Type.Core_Result_Result_Err _33;
    goto BB13
  }
  BB10 {
    assume { Resolve9.resolve f_1 };
    assume { Resolve10.resolve trail_2 };
    assume { Resolve11.resolve watches_3 };
    assume { Resolve0.resolve i_4 };
    assume { Resolve12.resolve _25 };
    absurd
  }
  BB11 {
    assume { Resolve12.resolve _25 };
    _24 <- ();
    assume { Resolve13.resolve _24 };
    i_4 <- i_4 + (1 : usize);
    _15 <- ();
    assume { Resolve13.resolve _15 };
    goto BB4
  }
  BB12 {
    assume { Resolve9.resolve f_1 };
    assume { Resolve11.resolve watches_3 };
    _14 <- ();
    assume { Resolve13.resolve _14 };
    assume { Resolve0.resolve _37 };
    _37 <- i_4;
    assume { Resolve0.resolve i_4 };
    assume { Resolve0.resolve (Type.lib_trail_trail_Trail_curr_i ( * trail_2)) };
    trail_2 <- { trail_2 with current = (let Type.Lib_Trail_Trail a b c d e =  * trail_2 in Type.Lib_Trail_Trail a b c _37 e) };
    assume { Resolve10.resolve trail_2 };
    _38 <- ();
    _0 <- Type.Core_Result_Result_Ok _38;
    goto BB13
  }
  BB13 {
    return _0
  }
  
end
module Lib_Solver_UnitPropStep_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable_Interface as NotSatisfiable0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicDecision_Impl0_Invariant_Interface as Invariant0
  val unit_prop_step [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.lib_solver_conflictresult
    requires {Invariant0.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant1.invariant' ( * t) ( * f)}
    requires {Invariant2.invariant' ( * w) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { match (result) with
      | Type.Lib_Solver_ConflictResult_Ground -> NotSatisfiable0.not_satisfiable ( ^ f)
      | _ -> true
      end }
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant1.invariant' ( ^ t) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ w) ( ^ f) }
    ensures { Invariant3.invariant' ( ^ f) }
    
end
module Lib_Solver_UnitPropStep
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant7
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model5 with function Model0.model = Model9.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant4 with function Model0.model = Model5.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model8.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model4.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss1 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss1.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant5 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant8 with function Model0.model = Model7.model,
  function Model1.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant6 with predicate Invariant0.invariant' = Invariant7.invariant',
  predicate Invariant1.invariant' = Invariant8.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model7.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model7.model,
  function Model1.model = Model4.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model7.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model3 with function Model0.model = Model7.model
  clone Lib_Logic_LogicClause_Impl2_EquisatExtension as EquisatExtension0 with function Model0.model = Model3.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable as NotSatisfiable0 with function Model0.model = Model4.model,
  predicate EquisatExtension0.equisat_extension = EquisatExtension0.equisat_extension
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model7.model,
  predicate Invariant0.invariant' = Invariant5.invariant', function Model1.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model3.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model6.model,
  function Model1.model = Model7.model, function Model2.model = Model4.model
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant2 with function Model0.model = Model2.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model5.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model0.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model0.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model5.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model0.model, function Model1.model = Model1.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicDecision_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.core_option_option bool
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.core_result_result () usize
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve3 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve2 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve1 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_decision_decisions
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner2 with function Model0.model = Model4.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat1 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner1 with function Model0.model = Model7.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_LogicFormula_Impl1_Unsat as Unsat0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Solver_HandleConflict_Interface as HandleConflict0 with function Model0.model = Model7.model,
  predicate Unsat0.unsat = Unsat1.unsat, predicate Invariant0.invariant' = Invariant2.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant3.invariant',
  predicate NotSatisfiable0.not_satisfiable = NotSatisfiable0.not_satisfiable,
  predicate Equisat0.equisat = Equisat0.equisat, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_UnitProp_UnitPropagate_Interface as UnitPropagate0 with predicate Invariant0.invariant' = Invariant2.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant3.invariant',
  predicate Equisat0.equisat = Equisat0.equisat, function Model0.model = Model7.model,
  predicate Unsat0.unsat = Unsat0.unsat, predicate Unsat1.unsat = Unsat1.unsat,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg unit_prop_step [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.lib_solver_conflictresult
    requires {Invariant0.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant1.invariant' ( * t) ( * f)}
    requires {Invariant2.invariant' ( * w) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { match (result) with
      | Type.Lib_Solver_ConflictResult_Ground -> NotSatisfiable0.not_satisfiable ( ^ f)
      | _ -> true
      end }
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant1.invariant' ( ^ t) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ w) ( ^ f) }
    ensures { Invariant3.invariant' ( ^ f) }
    
   = 
  var _0 : Type.lib_solver_conflictresult;
  var f_1 : borrowed (Type.lib_formula_formula);
  var d_2 : Type.lib_decision_decisions;
  var t_3 : borrowed (Type.lib_trail_trail);
  var w_4 : borrowed (Type.lib_watches_watches);
  var _5 : ();
  var _6 : Type.core_result_result () usize;
  var _7 : borrowed (Type.lib_formula_formula);
  var _8 : borrowed (Type.lib_trail_trail);
  var _9 : borrowed (Type.lib_watches_watches);
  var _10 : isize;
  var cref_11 : usize;
  var _12 : Type.core_option_option bool;
  var _13 : borrowed (Type.lib_formula_formula);
  var _14 : borrowed (Type.lib_trail_trail);
  var _15 : usize;
  var _16 : borrowed (Type.lib_watches_watches);
  var _17 : isize;
  {
    f_1 <- f;
    d_2 <- d;
    t_3 <- t;
    w_4 <- w;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve d_2 };
    _7 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _7) };
    _8 <- borrow_mut ( * t_3);
    t_3 <- { t_3 with current = ( ^ _8) };
    _9 <- borrow_mut ( * w_4);
    w_4 <- { w_4 with current = ( ^ _9) };
    _6 <- UnitPropagate0.unit_propagate _7 _8 _9;
    goto BB1
  }
  BB1 {
    switch (_6)
      | Type.Core_Result_Result_Ok _ -> goto BB4
      | Type.Core_Result_Result_Err _ -> goto BB2
      end
  }
  BB2 {
    assume { Resolve5.resolve cref_11 };
    cref_11 <- Type.core_result_result_Err_0 _6;
    assume { Resolve4.resolve _6 };
    _13 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _13) };
    _14 <- borrow_mut ( * t_3);
    t_3 <- { t_3 with current = ( ^ _14) };
    assume { Resolve5.resolve _15 };
    _15 <- cref_11;
    assume { Resolve5.resolve cref_11 };
    _16 <- borrow_mut ( * w_4);
    w_4 <- { w_4 with current = ( ^ _16) };
    _12 <- HandleConflict0.handle_conflict _13 _14 _15 _16;
    goto BB5
  }
  BB3 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve t_3 };
    assume { Resolve3.resolve w_4 };
    assume { Resolve4.resolve _6 };
    absurd
  }
  BB4 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve t_3 };
    assume { Resolve3.resolve w_4 };
    assume { Resolve4.resolve _6 };
    _0 <- Type.Lib_Solver_ConflictResult_Ok;
    goto BB12
  }
  BB5 {
    assume { Resolve1.resolve f_1 };
    assume { Resolve2.resolve t_3 };
    assume { Resolve3.resolve w_4 };
    switch (_12)
      | Type.Core_Option_Option_None -> goto BB6
      | Type.Core_Option_Option_Some _ -> goto BB7
      end
  }
  BB6 {
    assume { Resolve6.resolve _12 };
    _0 <- Type.Lib_Solver_ConflictResult_Continue;
    goto BB11
  }
  BB7 {
    switch (Type.core_option_option_Some_0 _12)
      | False -> goto BB9
      | _ -> goto BB10
      end
  }
  BB8 {
    assume { Resolve6.resolve _12 };
    absurd
  }
  BB9 {
    assume { Resolve6.resolve _12 };
    _0 <- Type.Lib_Solver_ConflictResult_Ground;
    goto BB11
  }
  BB10 {
    assume { Resolve6.resolve _12 };
    _0 <- Type.Lib_Solver_ConflictResult_Err;
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    return _0
  }
  
end
module Lib_Solver_UnitPropLoop_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable_Interface as NotSatisfiable0
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicDecision_Impl0_Invariant_Interface as Invariant0
  val unit_prop_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant1.invariant' ( * w) ( * f)}
    requires {Invariant2.invariant' ( * t) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some (False) -> NotSatisfiable0.not_satisfiable ( ^ f)
      | Type.Core_Option_Option_Some (True) -> true
      | Type.Core_Option_Option_None -> true
      end }
    ensures { Invariant1.invariant' ( ^ w) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ t) ( ^ f) }
    ensures { Invariant3.invariant' ( ^ f) }
    
end
module Lib_Solver_UnitPropLoop
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant7
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model12 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model9 with function Model0.model = Model12.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model9.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant5 with function Model0.model = Model9.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model11 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model7 with function Model0.model = Model11.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model7.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model7.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss1 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss1.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model7.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model7.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model10 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant8 with function Model0.model = Model8.model,
  function Model1.model = Model7.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant6 with predicate Invariant0.invariant' = Invariant7.invariant',
  predicate Invariant1.invariant' = Invariant8.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model8.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model8.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model8.model,
  function Model1.model = Model7.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model8.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model10.model,
  function Model1.model = Model8.model, function Model2.model = Model7.model
  clone Lib_Logic_LogicFormula_Impl0_Model as Model3 with function Model0.model = Model8.model
  clone Lib_Logic_LogicClause_Impl2_EquisatExtension as EquisatExtension0 with function Model0.model = Model3.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable as NotSatisfiable0 with function Model0.model = Model7.model,
  predicate EquisatExtension0.equisat_extension = EquisatExtension0.equisat_extension
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model8.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model7.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model3.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model2 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model1 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant2 with function Model0.model = Model6.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model5.model,
  function Model1.model = Model9.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model5.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model5.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model4.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model5.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model4.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model9.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model4.model, function Model1.model = Model5.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicDecision_Impl0_Invariant as Invariant3 with function Model0.model = Model4.model
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve11 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve10 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve9 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_decision_decisions
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.lib_solver_conflictresult
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record2 with type t = borrowed (Type.lib_watches_watches),
  function Model0.model = Model2.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record1 with type t = borrowed (Type.lib_trail_trail),
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_formula_formula),
  function Model0.model = Model0.model
  clone Lib_Solver_UnitPropStep_Interface as UnitPropStep0 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  predicate Invariant3.invariant' = Invariant0.invariant',
  predicate NotSatisfiable0.not_satisfiable = NotSatisfiable0.not_satisfiable,
  predicate Equisat0.equisat = Equisat0.equisat, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg unit_prop_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant3.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant2.invariant' ( * w) ( * f)}
    requires {Invariant1.invariant' ( * t) ( * f)}
    requires {Invariant0.invariant' ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some (False) -> NotSatisfiable0.not_satisfiable ( ^ f)
      | Type.Core_Option_Option_Some (True) -> true
      | Type.Core_Option_Option_None -> true
      end }
    ensures { Invariant2.invariant' ( ^ w) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ t) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ f) }
    
   = 
  var _0 : Type.core_option_option bool;
  var f_1 : borrowed (Type.lib_formula_formula);
  var d_2 : Type.lib_decision_decisions;
  var t_3 : borrowed (Type.lib_trail_trail);
  var w_4 : borrowed (Type.lib_watches_watches);
  var old_f_5 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula));
  var _6 : borrowed (Type.lib_formula_formula);
  var _7 : borrowed (Type.lib_formula_formula);
  var old_t_8 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _9 : borrowed (Type.lib_trail_trail);
  var _10 : borrowed (Type.lib_trail_trail);
  var old_w_11 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches));
  var _12 : borrowed (Type.lib_watches_watches);
  var _13 : borrowed (Type.lib_watches_watches);
  var _14 : ();
  var _15 : ();
  var _16 : Type.lib_solver_conflictresult;
  var _17 : borrowed (Type.lib_formula_formula);
  var _18 : Type.lib_decision_decisions;
  var _19 : borrowed (Type.lib_trail_trail);
  var _20 : borrowed (Type.lib_watches_watches);
  var _21 : isize;
  var _22 : ();
  var _23 : ();
  var _24 : ();
  {
    f_1 <- f;
    d_2 <- d;
    t_3 <- t;
    w_4 <- w;
    goto BB0
  }
  BB0 {
    _7 <- f_1;
    _6 <- _7;
    assume { Resolve0.resolve _7 };
    old_f_5 <- Record0.record _6;
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve old_f_5 };
    _10 <- t_3;
    _9 <- _10;
    assume { Resolve2.resolve _10 };
    old_t_8 <- Record1.record _9;
    goto BB2
  }
  BB2 {
    assume { Resolve3.resolve old_t_8 };
    _13 <- w_4;
    _12 <- _13;
    assume { Resolve4.resolve _13 };
    old_w_11 <- Record2.record _12;
    goto BB3
  }
  BB3 {
    assume { Resolve5.resolve old_w_11 };
    goto BB4
  }
  BB4 {
    invariant maintains_f { Invariant0.invariant' ( * f_1) };
    invariant maintains_t { Invariant1.invariant' ( * t_3) ( * f_1) };
    invariant maintains_w { Invariant2.invariant' ( * w_4) ( * f_1) };
    invariant equi { Equisat0.equisat ( * Model0.model old_f_5) ( * f_1) };
    invariant num_vars { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f_1)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * Model0.model old_f_5)) };
    invariant prophf {  ^ f_1 =  ^ Model0.model old_f_5 };
    invariant propht {  ^ t_3 =  ^ Model1.model old_t_8 };
    invariant prophw {  ^ w_4 =  ^ Model2.model old_w_11 };
    _17 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _17) };
    _18 <- d_2;
    _19 <- borrow_mut ( * t_3);
    t_3 <- { t_3 with current = ( ^ _19) };
    _20 <- borrow_mut ( * w_4);
    w_4 <- { w_4 with current = ( ^ _20) };
    _16 <- UnitPropStep0.unit_prop_step _17 _18 _19 _20;
    goto BB5
  }
  BB5 {
    assume { Resolve6.resolve _16 };
    switch (_16)
      | Type.Lib_Solver_ConflictResult_Ok -> goto BB8
      | Type.Lib_Solver_ConflictResult_Err -> goto BB10
      | Type.Lib_Solver_ConflictResult_Ground -> goto BB9
      | Type.Lib_Solver_ConflictResult_Continue -> goto BB6
      end
  }
  BB6 {
    _15 <- ();
    assume { Resolve11.resolve _15 };
    goto BB4
  }
  BB7 {
    assume { Resolve7.resolve f_1 };
    assume { Resolve8.resolve d_2 };
    assume { Resolve9.resolve t_3 };
    assume { Resolve10.resolve w_4 };
    absurd
  }
  BB8 {
    assume { Resolve7.resolve f_1 };
    assume { Resolve8.resolve d_2 };
    assume { Resolve9.resolve t_3 };
    assume { Resolve10.resolve w_4 };
    _0 <- Type.Core_Option_Option_Some true;
    goto BB11
  }
  BB9 {
    assume { Resolve7.resolve f_1 };
    assume { Resolve8.resolve d_2 };
    assume { Resolve9.resolve t_3 };
    assume { Resolve10.resolve w_4 };
    _0 <- Type.Core_Option_Option_Some false;
    goto BB11
  }
  BB10 {
    assume { Resolve7.resolve f_1 };
    assume { Resolve8.resolve d_2 };
    assume { Resolve9.resolve t_3 };
    assume { Resolve10.resolve w_4 };
    _0 <- Type.Core_Option_Option_None;
    goto BB11
  }
  BB11 {
    return _0
  }
  
end
module Lib_Trail_Impl0_EnqDecision_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.UInt8
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val enq_decision [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (idx : usize) (_f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) (UInt64.to_int idx))}
    requires {UInt64.to_int idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {Invariant0.invariant' ( * self) _f}
    requires {Invariant1.invariant' _f}
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) = 1 + Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { UInt8.to_int (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) (UInt64.to_int idx)) = 1 || UInt8.to_int (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) (UInt64.to_int idx)) = 0 }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) && j <> UInt64.to_int idx -> Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) j = Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) j }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Trail_Impl0_EnqDecision
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model6 with function Model0.model = Model8.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model6.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model6.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model3.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant4
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant6 with function Model0.model = Model6.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant6.invariant',
  function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model7 with function Model0.model = Model5.model
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant5 with function Model0.model = Model5.model,
  function Model1.model = Model6.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  predicate Invariant1.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant6.invariant', function Model1.model = Model6.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model7.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model5.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model5.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model2 with function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model5.model,
  function Model1.model = Model6.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant1 with function Model0.model = Model2.model
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model1 with type t = borrowed (Type.lib_trail_trail)
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicTrail_LemmaAssignMaintainsLongArePostUnit2 as LemmaAssignMaintainsLongArePostUnit20 with function Model0.model = Model2.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Unset0.unset = Unset0.unset, predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range,
  predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate Invariant0.invariant' = Invariant3.invariant', predicate Invariant1.invariant' = Invariant1.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model3.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model2.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant2 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model3.model, function Model1.model = Model0.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicTrail_LemmaForallToUnsetPush as LemmaForallToUnsetPush0 with function Model0.model = Model0.model,
  function Model1.model = Model5.model, function Model2.model = Model6.model,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model3.model = Model2.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant1.invariant' = Invariant2.invariant',
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner, axiom .
  clone Lib_Logic_LogicTrail_LemmaUnsetToForall as LemmaUnsetToForall0 with function Model0.model = Model2.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant2.invariant', function Model1.model = Model0.model,
  function Model2.model = Model5.model, function Model3.model = Model6.model, axiom .
  clone Lib_Logic_LogicTrail_LemmaPushMaintainsLitNotInLess as LemmaPushMaintainsLitNotInLess0 with function Model0.model = Model0.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner,
  predicate Invariant0.invariant' = Invariant0.invariant', function Model1.model = Model2.model,
  predicate Unset0.unset = Unset0.unset, predicate Invariant1.invariant' = Invariant2.invariant',
  predicate Invariant2.invariant' = Invariant3.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function LemmaUnsetToForall0.lemma_unset_to_forall = LemmaUnsetToForall0.lemma_unset_to_forall,
  function LemmaForallToUnsetPush0.lemma_forall_to_unset_push = LemmaForallToUnsetPush0.lemma_forall_to_unset_push,
  function Model2.model = Model5.model, function Model3.model = Model6.model, axiom .
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve11 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve10 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve6 with type t = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_trail_step
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = borrowed (Type.lib_trail_trail)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Model_Impl0_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len1 with type t = usize, function Model0.model = Model11.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec usize,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = usize,
  function Model0.model = Model3.model, function Model1.model = Model10.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = usize,
  function Model0.model = Model3.model, function Model1.model = Model10.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model13 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = uint8,
  function Model0.model = Model13.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model12 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut1 with type t = uint8,
  function Model0.model = Model4.model, function Model1.model = Model12.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_trail_trail),
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model14 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push1 with type t = Type.lib_trail_step,
  function Model0.model = Model0.model, function Model1.model = Model14.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_trail_step,
  function Model0.model = Model9.model
  let rec cfg enq_decision [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (idx : usize) (_f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) _f (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Unset0.unset (Seq.get (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self))) (UInt64.to_int idx))}
    requires {UInt64.to_int idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {Invariant2.invariant' ( * self) _f}
    requires {Invariant3.invariant' _f}
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) = 1 + Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) _f (Model2.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { UInt8.to_int (Seq.get (Model2.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) (UInt64.to_int idx)) = 1 || UInt8.to_int (Seq.get (Model2.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) (UInt64.to_int idx)) = 0 }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self))) && j <> UInt64.to_int idx -> Seq.get (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self))) j = Seq.get (Model2.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) j }
    ensures { Invariant2.invariant' ( ^ self) _f }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_trail_trail);
  var idx_2 : usize;
  var _f_3 : Type.lib_formula_formula;
  var old_self_4 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _5 : borrowed (Type.lib_trail_trail);
  var _6 : borrowed (Type.lib_trail_trail);
  var trail_len_7 : usize;
  var _8 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var _9 : ();
  var _10 : borrowed (Type.creusotcontracts_std1_vec_vec usize);
  var _11 : usize;
  var dlevel_12 : usize;
  var _13 : Type.creusotcontracts_std1_vec_vec usize;
  var _14 : usize;
  var _15 : borrowed usize;
  var _16 : borrowed (Type.creusotcontracts_std1_vec_vec usize);
  var _17 : usize;
  var _18 : ();
  var old_self_19 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _20 : borrowed (Type.lib_trail_trail);
  var _21 : borrowed (Type.lib_trail_trail);
  var _22 : ();
  var _23 : borrowed uint8;
  var _24 : borrowed (Type.creusotcontracts_std1_vec_vec uint8);
  var _25 : usize;
  var _26 : ();
  var _27 : ();
  var _28 : ();
  var _29 : ();
  var lit_30 : Type.lib_lit_lit;
  var _31 : usize;
  var _32 : bool;
  var _33 : bool;
  var _34 : uint8;
  var _35 : uint8;
  var _36 : Type.creusotcontracts_std1_vec_vec uint8;
  var _37 : usize;
  var step_38 : Type.lib_trail_step;
  var _39 : Type.lib_lit_lit;
  var _40 : usize;
  var _41 : Type.lib_trail_reason;
  var _42 : ();
  var _43 : ();
  var _44 : ();
  var _45 : ();
  var _46 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step));
  var _47 : Type.lib_trail_step;
  var _48 : ();
  var _49 : ();
  var _50 : ();
  var _51 : ();
  var _52 : ();
  var _53 : ();
  var _54 : ();
  var _55 : ();
  var _56 : ();
  var _57 : ();
  var _58 : ();
  {
    self_1 <- self;
    idx_2 <- idx;
    _f_3 <- _f;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _f_3 };
    _6 <- self_1;
    _5 <- _6;
    assume { Resolve1.resolve _6 };
    old_self_4 <- Record0.record _5;
    goto BB1
  }
  BB1 {
    assume { Resolve2.resolve old_self_4 };
    _8 <- Type.lib_trail_trail_Trail_trail ( * self_1);
    trail_len_7 <- Len0.len _8;
    goto BB2
  }
  BB2 {
    _10 <- borrow_mut (Type.lib_trail_trail_Trail_decisions ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail a b c d ( ^ _10)) };
    assume { Resolve3.resolve _11 };
    _11 <- trail_len_7;
    assume { Resolve3.resolve trail_len_7 };
    _9 <- Push0.push _10 _11;
    goto BB3
  }
  BB3 {
    _13 <- Type.lib_trail_trail_Trail_decisions ( * self_1);
    dlevel_12 <- Len1.len _13;
    goto BB4
  }
  BB4 {
    assume { Resolve3.resolve _14 };
    _14 <- dlevel_12;
    _16 <- borrow_mut (Type.lib_trail_trail_Trail_lit_to_level ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail a ( ^ _16) c d e) };
    assume { Resolve3.resolve _17 };
    _17 <- idx_2;
    _15 <- IndexMut0.index_mut _16 _17;
    goto BB5
  }
  BB5 {
    assume { Resolve3.resolve ( * _15) };
    _15 <- { _15 with current = _14 };
    assume { Resolve4.resolve _15 };
    assert { let _ = LemmaAssignMaintainsLongArePostUnit20.lemma_assign_maintains_long_are_post_unit2 (Model0.model (Type.lib_trail_trail_Trail_trail ( * self_1))) _f_3 (Type.lib_trail_trail_Trail_assignments ( * self_1)) idx_2 in true };
    _18 <- ();
    assume { Resolve5.resolve _18 };
    _21 <- self_1;
    _20 <- _21;
    assume { Resolve1.resolve _21 };
    old_self_19 <- Record0.record _20;
    goto BB6
  }
  BB6 {
    assume { Resolve2.resolve old_self_19 };
    assert { Unset0.unset (Seq.get (Model2.model (Type.lib_trail_trail_Trail_assignments ( * Model1.model old_self_19))) (UInt64.to_int idx_2)) };
    _22 <- ();
    assume { Resolve5.resolve _22 };
    _24 <- borrow_mut (Type.lib_assignments_assignments_Assignments_0 (Type.lib_trail_trail_Trail_assignments ( * self_1)));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail (let Type.Lib_Assignments_Assignments a b = Type.lib_trail_trail_Trail_assignments ( * self_1) in Type.Lib_Assignments_Assignments ( ^ _24) b) b c d e) };
    assume { Resolve3.resolve _25 };
    _25 <- idx_2;
    _23 <- IndexMut1.index_mut _24 _25;
    goto BB7
  }
  BB7 {
    _23 <- { _23 with current = ( * _23 - (2 : uint8)) };
    assume { Resolve6.resolve _23 };
    assert { Seq.(==) (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments ( * Model1.model old_self_19))) (UInt64.to_int idx_2) (0 : uint8)) || Seq.(==) (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments ( * Model1.model old_self_19))) (UInt64.to_int idx_2) (1 : uint8)) };
    _26 <- ();
    assume { Resolve5.resolve _26 };
    assert { let _ = LemmaAssignMaintainsLongArePostUnit20.lemma_assign_maintains_long_are_post_unit2 (Model0.model (Type.lib_trail_trail_Trail_trail ( * self_1))) _f_3 (Type.lib_trail_trail_Trail_assignments ( * self_1)) idx_2 in true };
    _27 <- ();
    assume { Resolve5.resolve _27 };
    assert {  ^ Model1.model old_self_19 =  ^ self_1 };
    _28 <- ();
    assume { Resolve5.resolve _28 };
    assert { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self_1))) _f_3 (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) };
    _29 <- ();
    assume { Resolve5.resolve _29 };
    assume { Resolve3.resolve _31 };
    _31 <- idx_2;
    _36 <- Type.lib_assignments_assignments_Assignments_0 (Type.lib_trail_trail_Trail_assignments ( * self_1));
    assume { Resolve3.resolve _37 };
    _37 <- idx_2;
    assume { Resolve3.resolve idx_2 };
    _35 <- Index0.index _36 _37;
    goto BB8
  }
  BB8 {
    assume { Resolve7.resolve _34 };
    _34 <- _35;
    assume { Resolve8.resolve _35 };
    _33 <- _34 = (0 : uint8);
    switch (_33)
      | False -> goto BB10
      | _ -> goto BB9
      end
  }
  BB9 {
    _32 <- false;
    goto BB11
  }
  BB10 {
    _32 <- true;
    goto BB11
  }
  BB11 {
    lit_30 <- Type.Lib_Lit_Lit _31 _32;
    assume { Resolve9.resolve _39 };
    _39 <- lit_30;
    assume { Resolve9.resolve lit_30 };
    assume { Resolve3.resolve _40 };
    _40 <- dlevel_12;
    assume { Resolve3.resolve dlevel_12 };
    _41 <- Type.Lib_Trail_Reason_Decision;
    step_38 <- Type.Lib_Trail_Step _39 _40 _41;
    assert { LitNotInLessInner0.lit_not_in_less_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self_1))) _f_3 };
    _42 <- ();
    assume { Resolve5.resolve _42 };
    assert { Invariant0.invariant' step_38 _f_3 };
    _43 <- ();
    assume { Resolve5.resolve _43 };
    assert { let _ = LemmaPushMaintainsLitNotInLess0.lemma_push_maintains_lit_not_in_less ( * self_1) _f_3 step_38 in true };
    _44 <- ();
    assume { Resolve5.resolve _44 };
    _46 <- borrow_mut (Type.lib_trail_trail_Trail_trail ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Trail_Trail a b c d e =  * self_1 in Type.Lib_Trail_Trail a b ( ^ _46) d e) };
    assume { Resolve10.resolve _47 };
    _47 <- step_38;
    _45 <- Push1.push _46 _47;
    goto BB12
  }
  BB12 {
    assume { Resolve11.resolve self_1 };
    assert { Seq.snoc (Model0.model (Type.lib_trail_trail_Trail_trail ( * Model1.model old_self_19))) step_38 = Model0.model (Type.lib_trail_trail_Trail_trail ( * self_1)) };
    _48 <- ();
    assume { Resolve5.resolve _48 };
    assert {  ^ Model1.model old_self_19 =  ^ self_1 };
    _49 <- ();
    assume { Resolve5.resolve _49 };
    assert { LitNotInLessInner0.lit_not_in_less_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self_1))) _f_3 };
    _50 <- ();
    assume { Resolve5.resolve _50 };
    assert { LitNotInLess0.lit_not_in_less ( * self_1) _f_3 };
    _51 <- ();
    assume { Resolve5.resolve _51 };
    assert { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self_1))) _f_3 (Model2.model (Type.lib_trail_trail_Trail_assignments ( * self_1))) };
    _52 <- ();
    assume { Resolve5.resolve _52 };
    assert { Invariant1.invariant' (Type.lib_trail_trail_Trail_assignments ( * self_1)) _f_3 };
    _53 <- ();
    assume { Resolve5.resolve _53 };
    assert { TrailInvariant0.trail_invariant (Model0.model (Type.lib_trail_trail_Trail_trail ( * self_1))) _f_3 };
    _54 <- ();
    assume { Resolve5.resolve _54 };
    assert { LitToLevelInvariant0.lit_to_level_invariant (Model3.model (Type.lib_trail_trail_Trail_lit_to_level ( * self_1))) _f_3 };
    _55 <- ();
    assume { Resolve5.resolve _55 };
    assert { DecisionsInvariant0.decisions_invariant (Model3.model (Type.lib_trail_trail_Trail_decisions ( * self_1))) (Model0.model (Type.lib_trail_trail_Trail_trail ( * self_1))) };
    _56 <- ();
    assume { Resolve5.resolve _56 };
    assert { LitIsUnique0.lit_is_unique ( * self_1) };
    _57 <- ();
    assume { Resolve5.resolve _57 };
    assert { TrailEntriesAreAssigned0.trail_entries_are_assigned ( * self_1) };
    _58 <- ();
    assume { Resolve5.resolve _58 };
    _0 <- ();
    return _0
  }
  
end
module Lib_Solver_OuterLoop_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable_Interface as NotSatisfiable0
  clone Lib_Logic_LogicAssignments_Impl1_Complete_Interface as Complete0
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicFormula_Impl1_Sat_Interface as Sat0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicDecision_Impl0_Invariant_Interface as Invariant0
  val outer_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (trail : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.lib_solver_satresult
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant1.invariant' ( * w) ( * f)}
    requires {Invariant2.invariant' ( * trail) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { match (result) with
      | Type.Lib_Solver_SatResult_Sat _ -> Sat0.sat ( ^ f) (Type.lib_trail_trail_Trail_assignments ( ^ trail)) && Complete0.complete (Type.lib_trail_trail_Trail_assignments ( ^ trail))
      | Type.Lib_Solver_SatResult_Unsat -> NotSatisfiable0.not_satisfiable ( ^ f)
      | Type.Lib_Solver_SatResult_Unknown -> true
      | Type.Lib_Solver_SatResult_Err -> true
      end }
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant1.invariant' ( ^ w) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ trail) ( ^ f) }
    ensures { Invariant3.invariant' ( ^ f) }
    
end
module Lib_Solver_OuterLoop
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant7
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model9.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model5.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model5.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant5 with function Model0.model = Model5.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model4 with function Model0.model = Model8.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat1 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant4 with function Model0.model = Model4.model
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant8 with function Model0.model = Model7.model,
  function Model1.model = Model5.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant6 with predicate Invariant0.invariant' = Invariant7.invariant',
  predicate Invariant1.invariant' = Invariant8.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model7.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model7.model,
  function Model1.model = Model5.model, predicate Sat0.sat = Sat1.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model7.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model3 with function Model0.model = Model7.model
  clone Lib_Logic_LogicFormula_Impl1_Sat as Sat0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, function Model1.model = Model3.model,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model7.model,
  predicate Invariant0.invariant' = Invariant5.invariant', function Model1.model = Model5.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model3.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model6.model,
  function Model1.model = Model7.model, function Model2.model = Model5.model
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss1 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss1.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_EquisatExtension as EquisatExtension0 with function Model0.model = Model3.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable as NotSatisfiable0 with function Model0.model = Model5.model,
  predicate EquisatExtension0.equisat_extension = EquisatExtension0.equisat_extension
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicAssignments_Impl1_Complete as Complete0 with function Model0.model = Model4.model,
  predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model2.model,
  function Model1.model = Model4.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model2.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model2.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant1 with function Model0.model = Model1.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model0.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model2.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model0.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model4.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant2 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model0.model, function Model1.model = Model2.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicDecision_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.core_option_option usize
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve5 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = Type.lib_formula_formula
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.lib_decision_decisions
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.core_option_option bool
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = Type.lib_watches_watches
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New0 with type t = uint8, function Model0.model = Model8.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model10 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model4.model
  clone Lib_Formula_Impl1_IsSat_Interface as IsSat0 with predicate Invariant0.invariant' = Invariant4.invariant',
  predicate Invariant1.invariant' = Invariant3.invariant', predicate Sat0.sat = Sat0.sat,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old, function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Trail_Impl0_EnqDecision_Interface as EnqDecision0 with function Model0.model = Model2.model,
  function Model1.model = Model4.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate Unset0.unset = Unset0.unset, predicate Invariant0.invariant' = Invariant2.invariant',
  predicate Invariant1.invariant' = Invariant3.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_Assignments_Impl0_FindUnassigned_Interface as FindUnassigned0 with function Model0.model = Model10.model,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate Invariant1.invariant' = Invariant4.invariant',
  function Model1.model = Model4.model, predicate Unset0.unset = Unset0.unset,
  predicate Complete0.complete = Complete0.complete
  clone Lib_Solver_UnitPropLoop_Interface as UnitPropLoop0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant1.invariant', predicate Invariant2.invariant' = Invariant2.invariant',
  predicate Invariant3.invariant' = Invariant3.invariant', predicate Equisat0.equisat = Equisat0.equisat,
  predicate NotSatisfiable0.not_satisfiable = NotSatisfiable0.not_satisfiable,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg outer_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (trail : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.lib_solver_satresult
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant1.invariant' ( * w) ( * f)}
    requires {Invariant2.invariant' ( * trail) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { match (result) with
      | Type.Lib_Solver_SatResult_Sat _ -> Sat0.sat ( ^ f) (Type.lib_trail_trail_Trail_assignments ( ^ trail)) && Complete0.complete (Type.lib_trail_trail_Trail_assignments ( ^ trail))
      | Type.Lib_Solver_SatResult_Unsat -> NotSatisfiable0.not_satisfiable ( ^ f)
      | Type.Lib_Solver_SatResult_Unknown -> true
      | Type.Lib_Solver_SatResult_Err -> true
      end }
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant1.invariant' ( ^ w) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ trail) ( ^ f) }
    ensures { Invariant3.invariant' ( ^ f) }
    
   = 
  var _0 : Type.lib_solver_satresult;
  var f_1 : borrowed (Type.lib_formula_formula);
  var d_2 : Type.lib_decision_decisions;
  var trail_3 : borrowed (Type.lib_trail_trail);
  var w_4 : borrowed (Type.lib_watches_watches);
  var _5 : ();
  var _6 : Type.core_option_option bool;
  var _7 : borrowed (Type.lib_formula_formula);
  var _8 : Type.lib_decision_decisions;
  var _9 : borrowed (Type.lib_trail_trail);
  var _10 : borrowed (Type.lib_watches_watches);
  var _11 : isize;
  var _12 : ();
  var _13 : ();
  var _14 : ();
  var _15 : Type.core_option_option usize;
  var _16 : borrowed (Type.lib_assignments_assignments);
  var _17 : Type.lib_decision_decisions;
  var _18 : Type.lib_formula_formula;
  var _19 : isize;
  var next_20 : usize;
  var _21 : ();
  var _22 : borrowed (Type.lib_trail_trail);
  var _23 : usize;
  var _24 : Type.lib_formula_formula;
  var _25 : bool;
  var _26 : Type.lib_formula_formula;
  var _27 : Type.lib_assignments_assignments;
  var _28 : Type.lib_assignments_assignments;
  var _29 : ();
  var _30 : Type.creusotcontracts_std1_vec_vec uint8;
  var _31 : ();
  {
    f_1 <- f;
    d_2 <- d;
    trail_3 <- trail;
    w_4 <- w;
    goto BB0
  }
  BB0 {
    _7 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _7) };
    _8 <- d_2;
    _9 <- borrow_mut ( * trail_3);
    trail_3 <- { trail_3 with current = ( ^ _9) };
    _10 <- borrow_mut ( * w_4);
    w_4 <- { w_4 with current = ( ^ _10) };
    _6 <- UnitPropLoop0.unit_prop_loop _7 _8 _9 _10;
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve w_4 };
    switch (_6)
      | Type.Core_Option_Option_None -> goto BB5
      | Type.Core_Option_Option_Some _ -> goto BB2
      end
  }
  BB2 {
    switch (Type.core_option_option_Some_0 _6)
      | False -> goto BB4
      | _ -> goto BB3
      end
  }
  BB3 {
    assume { Resolve1.resolve _6 };
    _5 <- ();
    assume { Resolve2.resolve _5 };
    _16 <- borrow_mut (Type.lib_trail_trail_Trail_assignments ( * trail_3));
    trail_3 <- { trail_3 with current = (let Type.Lib_Trail_Trail a b c d e =  * trail_3 in Type.Lib_Trail_Trail ( ^ _16) b c d e) };
    _17 <- d_2;
    assume { Resolve3.resolve d_2 };
    _18 <-  * f_1;
    _15 <- FindUnassigned0.find_unassigned _16 _17 _18;
    goto BB6
  }
  BB4 {
    assume { Resolve4.resolve f_1 };
    assume { Resolve3.resolve d_2 };
    assume { Resolve5.resolve trail_3 };
    assume { Resolve1.resolve _6 };
    _0 <- Type.Lib_Solver_SatResult_Unsat;
    goto BB17
  }
  BB5 {
    assume { Resolve4.resolve f_1 };
    assume { Resolve3.resolve d_2 };
    assume { Resolve5.resolve trail_3 };
    assume { Resolve1.resolve _6 };
    _0 <- Type.Lib_Solver_SatResult_Err;
    goto BB17
  }
  BB6 {
    switch (_15)
      | Type.Core_Option_Option_None -> goto BB7
      | Type.Core_Option_Option_Some _ -> goto BB9
      end
  }
  BB7 {
    assume { Resolve6.resolve _15 };
    _26 <-  * f_1;
    assume { Resolve4.resolve f_1 };
    _28 <- Type.lib_trail_trail_Trail_assignments ( * trail_3);
    assume { Resolve5.resolve trail_3 };
    _27 <- _28;
    assume { Resolve8.resolve _28 };
    _25 <- IsSat0.is_sat _26 _27;
    goto BB11
  }
  BB8 {
    assume { Resolve4.resolve f_1 };
    assume { Resolve5.resolve trail_3 };
    assume { Resolve6.resolve _15 };
    absurd
  }
  BB9 {
    assume { Resolve7.resolve next_20 };
    next_20 <- Type.core_option_option_Some_0 _15;
    assume { Resolve6.resolve _15 };
    _22 <- borrow_mut ( * trail_3);
    trail_3 <- { trail_3 with current = ( ^ _22) };
    assume { Resolve7.resolve _23 };
    _23 <- next_20;
    assume { Resolve7.resolve next_20 };
    _24 <-  * f_1;
    assume { Resolve4.resolve f_1 };
    _21 <- EnqDecision0.enq_decision _22 _23 _24;
    goto BB10
  }
  BB10 {
    assume { Resolve5.resolve trail_3 };
    _14 <- ();
    assume { Resolve2.resolve _14 };
    _0 <- Type.Lib_Solver_SatResult_Unknown;
    goto BB18
  }
  BB11 {
    switch (_25)
      | False -> goto BB15
      | _ -> goto BB12
      end
  }
  BB12 {
    _30 <- New0.new ();
    goto BB13
  }
  BB13 {
    _0 <- Type.Lib_Solver_SatResult_Sat _30;
    goto BB14
  }
  BB14 {
    goto BB16
  }
  BB15 {
    _0 <- Type.Lib_Solver_SatResult_Err;
    goto BB16
  }
  BB16 {
    goto BB18
  }
  BB17 {
    goto BB18
  }
  BB18 {
    return _0
  }
  
end
module Lib_Solver_Inner_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable_Interface as NotSatisfiable0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = uint8
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicDecision_Impl0_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  val inner [@cfg:stackify] (formula : borrowed (Type.lib_formula_formula)) (decisions : Type.lib_decision_decisions) (trail : Type.lib_trail_trail) (watches : Type.lib_watches_watches) : Type.lib_solver_satresult
    requires {Invariant0.invariant' watches ( * formula)}
    requires {Invariant1.invariant' trail ( * formula)}
    requires {Invariant2.invariant' decisions (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * formula)))}
    requires {Invariant3.invariant' ( * formula)}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * formula)) < div 18446744073709551615 2}
    ensures { Equisat0.equisat ( * formula) ( ^ formula) }
    ensures { match (result) with
      | Type.Lib_Solver_SatResult_Sat v -> SatInner0.sat_inner ( ^ formula) (Model0.model v) && Equisat0.equisat ( * formula) ( ^ formula) && EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass ( * formula)
      | Type.Lib_Solver_SatResult_Unsat -> NotSatisfiable0.not_satisfiable ( ^ formula) && Equisat0.equisat ( * formula) ( ^ formula)
      | _ -> true
      end }
    
end
module Lib_Solver_Inner
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant7
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model10 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model7 with function Model0.model = Model10.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model7.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model7.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model7.model
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model7.model, predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss1 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss1.eventually_sat_complete_no_ass
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant8 with function Model0.model = Model6.model,
  function Model1.model = Model7.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant6 with predicate Invariant0.invariant' = Invariant7.invariant',
  predicate Invariant1.invariant' = Invariant8.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model6.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model6.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model9.model,
  function Model1.model = Model6.model, function Model2.model = Model7.model
  clone Lib_Logic_LogicFormula_Impl0_Model as Model2 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl2_EquisatExtension as EquisatExtension0 with function Model0.model = Model2.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable as NotSatisfiable0 with function Model0.model = Model7.model,
  predicate EquisatExtension0.equisat_extension = EquisatExtension0.equisat_extension
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model6.model,
  predicate Invariant0.invariant' = Invariant4.invariant', function Model1.model = Model7.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model2.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model8 with function Model0.model = Model1.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model8.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model6.model,
  function Model1.model = Model7.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant5 with function Model0.model = Model8.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant2 with function Model0.model = Model5.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model4.model,
  function Model1.model = Model8.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model4.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model4.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model3.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model4.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model3.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model8.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model3.model, function Model1.model = Model4.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicDecision_Impl0_Invariant as Invariant3 with function Model0.model = Model3.model
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = borrowed (Type.lib_formula_formula)
  use mach.int.Int64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve12 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve10 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = Type.lib_decision_decisions
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.lib_solver_satresult
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve5 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve3 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_decision_decisions
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = borrowed (Type.lib_formula_formula)
  clone CreusotContracts_Std1_Vec_Impl5_Resolve as Resolve11 with type t = uint8, function Model0.model = Model1.model,
  predicate Resolve0.resolve = Resolve12.resolve
  clone Lib_Logic_LogicAssignments_Impl1_Complete as Complete0 with function Model0.model = Model8.model,
  predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicFormula_Impl1_Sat as Sat1 with function Model0.model = Model8.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, function Model1.model = Model2.model,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner, axiom .
  clone Lib_Solver_OuterLoop_Interface as OuterLoop0 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant2.invariant', predicate Invariant2.invariant' = Invariant1.invariant',
  predicate Invariant3.invariant' = Invariant0.invariant', predicate Sat0.sat = Sat1.sat,
  predicate Complete0.complete = Complete0.complete,
  predicate NotSatisfiable0.not_satisfiable = NotSatisfiable0.not_satisfiable,
  predicate Equisat0.equisat = Equisat0.equisat, predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model8.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_formula_formula),
  function Model0.model = Model0.model
  let rec cfg inner [@cfg:stackify] (formula : borrowed (Type.lib_formula_formula)) (decisions : Type.lib_decision_decisions) (trail : Type.lib_trail_trail) (watches : Type.lib_watches_watches) : Type.lib_solver_satresult
    requires {Invariant2.invariant' watches ( * formula)}
    requires {Invariant1.invariant' trail ( * formula)}
    requires {Invariant3.invariant' decisions (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * formula)))}
    requires {Invariant0.invariant' ( * formula)}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * formula)) < div 18446744073709551615 2}
    ensures { Equisat0.equisat ( * formula) ( ^ formula) }
    ensures { match (result) with
      | Type.Lib_Solver_SatResult_Sat v -> SatInner0.sat_inner ( ^ formula) (Model1.model v) && Equisat0.equisat ( * formula) ( ^ formula) && EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass ( * formula)
      | Type.Lib_Solver_SatResult_Unsat -> NotSatisfiable0.not_satisfiable ( ^ formula) && Equisat0.equisat ( * formula) ( ^ formula)
      | _ -> true
      end }
    
   = 
  var _0 : Type.lib_solver_satresult;
  var formula_1 : borrowed (Type.lib_formula_formula);
  var decisions_2 : Type.lib_decision_decisions;
  var trail_3 : Type.lib_trail_trail;
  var watches_4 : Type.lib_watches_watches;
  var old_f_5 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_formula_formula));
  var _6 : borrowed (Type.lib_formula_formula);
  var _7 : borrowed (Type.lib_formula_formula);
  var _8 : ();
  var _9 : ();
  var _10 : Type.lib_solver_satresult;
  var _11 : borrowed (Type.lib_formula_formula);
  var _12 : Type.lib_decision_decisions;
  var _13 : Type.lib_decision_decisions;
  var _14 : borrowed (Type.lib_trail_trail);
  var _15 : borrowed (Type.lib_trail_trail);
  var _16 : borrowed (Type.lib_watches_watches);
  var _17 : borrowed (Type.lib_watches_watches);
  var _18 : isize;
  var _19 : ();
  var _20 : Type.creusotcontracts_std1_vec_vec uint8;
  var o_21 : Type.lib_solver_satresult;
  var _22 : ();
  {
    formula_1 <- formula;
    decisions_2 <- decisions;
    trail_3 <- trail;
    watches_4 <- watches;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    _7 <- formula_1;
    _6 <- _7;
    assume { Resolve0.resolve _7 };
    old_f_5 <- Record0.record _6;
    goto BB4
  }
  BB4 {
    assume { Resolve1.resolve old_f_5 };
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    invariant equi { Equisat0.equisat ( * Model0.model old_f_5) ( * formula_1) };
    invariant num_vars { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * formula_1)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * Model0.model old_f_5)) };
    invariant maintains_f { Invariant0.invariant' ( * formula_1) };
    invariant maintains_t { Invariant1.invariant' trail_3 ( * formula_1) };
    invariant maintains_w { Invariant2.invariant' watches_4 ( * formula_1) };
    invariant prophf {  ^ formula_1 =  ^ Model0.model old_f_5 };
    _11 <- borrow_mut ( * formula_1);
    formula_1 <- { formula_1 with current = ( ^ _11) };
    _13 <- decisions_2;
    _12 <- _13;
    assume { Resolve2.resolve _13 };
    _15 <- borrow_mut trail_3;
    trail_3 <-  ^ _15;
    _14 <- borrow_mut ( * _15);
    _15 <- { _15 with current = ( ^ _14) };
    _17 <- borrow_mut watches_4;
    watches_4 <-  ^ _17;
    _16 <- borrow_mut ( * _17);
    _17 <- { _17 with current = ( ^ _16) };
    _10 <- OuterLoop0.outer_loop _11 _12 _14 _16;
    goto BB8
  }
  BB8 {
    assume { Resolve3.resolve _15 };
    assume { Resolve4.resolve _17 };
    switch (_10)
      | Type.Lib_Solver_SatResult_Sat _ -> goto BB11
      | Type.Lib_Solver_SatResult_Unknown -> goto BB10
      | _ -> goto BB9
      end
  }
  BB9 {
    assume { Resolve5.resolve formula_1 };
    assume { Resolve6.resolve o_21 };
    o_21 <- _10;
    assume { Resolve6.resolve _0 };
    _0 <- o_21;
    goto BB14
  }
  BB10 {
    _9 <- ();
    assume { Resolve10.resolve _9 };
    goto BB13
  }
  BB11 {
    assume { Resolve5.resolve formula_1 };
    assume { Resolve11.resolve _20 };
    _20 <- Type.lib_assignments_assignments_Assignments_0 (Type.lib_trail_trail_Trail_assignments trail_3);
    _0 <- Type.Lib_Solver_SatResult_Sat _20;
    goto BB12
  }
  BB12 {
    goto BB15
  }
  BB13 {
    assume { Resolve6.resolve _10 };
    goto BB7
  }
  BB14 {
    goto BB15
  }
  BB15 {
    goto BB16
  }
  BB16 {
    goto BB17
  }
  BB17 {
    assume { Resolve7.resolve watches_4 };
    goto BB18
  }
  BB18 {
    assume { Resolve8.resolve trail_3 };
    goto BB19
  }
  BB19 {
    assume { Resolve9.resolve decisions_2 };
    return _0
  }
  
end
module Lib_Trail_Impl0_New_Interface
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant0
  val new [@cfg:stackify] (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : Type.lib_trail_trail
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    ensures { Invariant2.invariant' result f }
    
end
module Lib_Trail_Impl0_New
  use prelude.Prelude
  use Type
  use mach.int.Int
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant5
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model6 with function Model0.model = Model7.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model6.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant3 with function Model0.model = Model6.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model6.model
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model5.model,
  function Model1.model = Model6.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant4 with predicate Invariant0.invariant' = Invariant5.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model5.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model5.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model1 with function Model0.model = Model5.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant3.invariant', function Model1.model = Model6.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model1.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model5.model,
  function Model1.model = Model6.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model3.model,
  function Model1.model = Model0.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model3.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model3.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model2.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model3.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model2.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model0.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant2 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model2.model, function Model1.model = Model3.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New0 with type t = Type.lib_trail_step,
  function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New1 with type t = usize, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_FromElem_Interface as FromElem0 with type t = usize,
  function Model0.model = Model2.model
  let rec cfg new [@cfg:stackify] (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : Type.lib_trail_trail
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    ensures { Invariant2.invariant' result f }
    
   = 
  var _0 : Type.lib_trail_trail;
  var f_1 : Type.lib_formula_formula;
  var a_2 : Type.lib_assignments_assignments;
  var _3 : Type.lib_assignments_assignments;
  var _4 : Type.creusotcontracts_std1_vec_vec usize;
  var _5 : usize;
  var _6 : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step);
  var _7 : Type.creusotcontracts_std1_vec_vec usize;
  {
    f_1 <- f;
    a_2 <- a;
    goto BB0
  }
  BB0 {
    goto BB1
  }
  BB1 {
    assume { Resolve0.resolve _3 };
    _3 <- a_2;
    assume { Resolve1.resolve _5 };
    _5 <- Type.lib_formula_formula_Formula_num_vars f_1;
    assume { Resolve2.resolve f_1 };
    _4 <- FromElem0.from_elem (18446744073709551615 : usize) _5;
    goto BB2
  }
  BB2 {
    _6 <- New0.new ();
    goto BB3
  }
  BB3 {
    _7 <- New1.new ();
    goto BB4
  }
  BB4 {
    _0 <- Type.Lib_Trail_Trail _3 _4 _6 (0 : usize) _7;
    goto BB5
  }
  BB5 {
    goto BB6
  }
  BB6 {
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    return _0
  }
  
end
module Lib_Watches_Impl0_New_Interface
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_watches_watches
    ensures { Invariant0.invariant' result f }
    
end
module Lib_Watches_Impl0_New
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model1.model,
  function Model1.model = Model2.model, function Model2.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = ()
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl5_Resolve as Resolve4 with type t = Type.lib_watches_watcher,
  function Model0.model = Model1.model, predicate Resolve0.resolve = Resolve5.resolve
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New1 with type t = Type.lib_watches_watcher,
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model5 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model0.model, function Model1.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl5_Resolve as Resolve3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model0.model, predicate Resolve0.resolve = Resolve4.resolve
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model0.model
  let rec cfg new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_watches_watches
    ensures { Invariant0.invariant' result f }
    
   = 
  var _0 : Type.lib_watches_watches;
  var f_1 : Type.lib_formula_formula;
  var i_2 : usize;
  var watches_3 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _4 : ();
  var _5 : ();
  var _6 : bool;
  var _7 : usize;
  var _8 : usize;
  var _9 : ();
  var _10 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)));
  var _11 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _12 : ();
  var _13 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)));
  var _14 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _15 : ();
  var _16 : ();
  var _17 : ();
  var _18 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  {
    f_1 <- f;
    goto BB0
  }
  BB0 {
    i_2 <- (0 : usize);
    watches_3 <- New0.new ();
    goto BB1
  }
  BB1 {
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    invariant i_less { UInt64.to_int i_2 <= UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    invariant maintains_inv { WatchesInvariantInternal0.watches_invariant_internal (Model0.model watches_3) (UInt64.to_int i_2) f_1 };
    assume { Resolve0.resolve _7 };
    _7 <- i_2;
    assume { Resolve0.resolve _8 };
    _8 <- Type.lib_formula_formula_Formula_num_vars f_1;
    _6 <- _7 < _8;
    switch (_6)
      | False -> goto BB9
      | _ -> goto BB4
      end
  }
  BB4 {
    _10 <- borrow_mut watches_3;
    watches_3 <-  ^ _10;
    _11 <- New1.new ();
    goto BB5
  }
  BB5 {
    _9 <- Push0.push _10 _11;
    goto BB6
  }
  BB6 {
    _13 <- borrow_mut watches_3;
    watches_3 <-  ^ _13;
    _14 <- New1.new ();
    goto BB7
  }
  BB7 {
    _12 <- Push0.push _13 _14;
    goto BB8
  }
  BB8 {
    i_2 <- i_2 + (1 : usize);
    _5 <- ();
    assume { Resolve1.resolve _5 };
    goto BB3
  }
  BB9 {
    assume { Resolve2.resolve f_1 };
    assume { Resolve0.resolve i_2 };
    _4 <- ();
    assume { Resolve1.resolve _4 };
    assume { Resolve3.resolve _18 };
    _18 <- watches_3;
    _0 <- Type.Lib_Watches_Watches _18;
    goto BB10
  }
  BB10 {
    goto BB11
  }
  BB11 {
    return _0
  }
  
end
module Lib_Watches_Impl0_InitWatches_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val init_watches [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (f : Type.lib_formula_formula) : ()
    requires {Invariant0.invariant' f}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) < div 18446744073709551615 2}
    requires {Invariant1.invariant' ( * self) f}
    ensures { Invariant1.invariant' ( ^ self) f }
    
end
module Lib_Watches_Impl0_InitWatches
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model5.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model2 with function Model0.model = Model4.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model4.model,
  predicate Invariant0.invariant' = Invariant2.invariant', function Model1.model = Model5.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model2.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model3.model,
  function Model1.model = Model4.model, function Model2.model = Model5.model
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model1 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = ()
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = borrowed (Type.lib_watches_watches)
  clone CreusotContracts_Logic_Model_Impl0_Model as Model8 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_lit_lit,
  function Model0.model = Model8.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len1 with type t = Type.lib_lit_lit,
  function Model0.model = Model8.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model7 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_clause_clause,
  function Model0.model = Model7.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_clause_clause,
  function Model0.model = Model7.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_watches_watches),
  function Model0.model = Model1.model
  clone Lib_Watches_Impl0_AddWatcher_Interface as AddWatcher0 with function Model0.model = Model4.model,
  function Model1.model = Model5.model,
  function ToNegWatchidxLogic0.to_neg_watchidx_logic = ToNegWatchidxLogic0.to_neg_watchidx_logic,
  function Model2.model = Model0.model, predicate Invariant0.invariant' = Invariant0.invariant'
  let rec cfg init_watches [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (f : Type.lib_formula_formula) : ()
    requires {Invariant1.invariant' f}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) f}
    ensures { Invariant0.invariant' ( ^ self) f }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_watches_watches);
  var f_2 : Type.lib_formula_formula;
  var old_w_3 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_watches_watches));
  var _4 : borrowed (Type.lib_watches_watches);
  var _5 : borrowed (Type.lib_watches_watches);
  var i_6 : usize;
  var _7 : ();
  var _8 : bool;
  var _9 : usize;
  var _10 : usize;
  var _11 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var clause_12 : Type.lib_clause_clause;
  var _13 : Type.lib_clause_clause;
  var _14 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _15 : usize;
  var _16 : ();
  var _17 : bool;
  var _18 : usize;
  var _19 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _20 : ();
  var _21 : borrowed (Type.lib_watches_watches);
  var _22 : Type.lib_lit_lit;
  var _23 : Type.lib_lit_lit;
  var _24 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _25 : usize;
  var _26 : Type.lib_formula_formula;
  var _27 : ();
  var _28 : borrowed (Type.lib_watches_watches);
  var _29 : Type.lib_lit_lit;
  var _30 : Type.lib_lit_lit;
  var _31 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _32 : usize;
  var _33 : Type.lib_formula_formula;
  var _34 : ();
  var _35 : ();
  var _36 : ();
  {
    self_1 <- self;
    f_2 <- f;
    goto BB0
  }
  BB0 {
    _5 <- self_1;
    _4 <- _5;
    assume { Resolve0.resolve _5 };
    old_w_3 <- Record0.record _4;
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve old_w_3 };
    i_6 <- (0 : usize);
    goto BB2
  }
  BB2 {
    invariant watch_inv { Invariant0.invariant' ( * self_1) f_2 };
    invariant same_len { Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self_1))) = 2 * UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_2) };
    invariant proph {  ^ self_1 =  ^ Model1.model old_w_3 };
    assume { Resolve2.resolve _9 };
    _9 <- i_6;
    _11 <- Type.lib_formula_formula_Formula_clauses f_2;
    _10 <- Len0.len _11;
    goto BB3
  }
  BB3 {
    _8 <- _9 < _10;
    switch (_8)
      | False -> goto BB14
      | _ -> goto BB4
      end
  }
  BB4 {
    _14 <- Type.lib_formula_formula_Formula_clauses f_2;
    assume { Resolve2.resolve _15 };
    _15 <- i_6;
    _13 <- Index0.index _14 _15;
    goto BB5
  }
  BB5 {
    clause_12 <- _13;
    assume { Resolve3.resolve _13 };
    _19 <- Type.lib_clause_clause_Clause_rest clause_12;
    _18 <- Len1.len _19;
    goto BB6
  }
  BB6 {
    _17 <- _18 > (1 : usize);
    switch (_17)
      | False -> goto BB12
      | _ -> goto BB7
      end
  }
  BB7 {
    _21 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _21) };
    _24 <- Type.lib_clause_clause_Clause_rest clause_12;
    _23 <- Index1.index _24 (0 : usize);
    goto BB8
  }
  BB8 {
    assume { Resolve4.resolve _22 };
    _22 <- _23;
    assume { Resolve5.resolve _23 };
    assume { Resolve2.resolve _25 };
    _25 <- i_6;
    _26 <- f_2;
    _20 <- AddWatcher0.add_watcher _21 _22 _25 _26;
    goto BB9
  }
  BB9 {
    _28 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _28) };
    _31 <- Type.lib_clause_clause_Clause_rest clause_12;
    assume { Resolve3.resolve clause_12 };
    _30 <- Index1.index _31 (1 : usize);
    goto BB10
  }
  BB10 {
    assume { Resolve4.resolve _29 };
    _29 <- _30;
    assume { Resolve5.resolve _30 };
    assume { Resolve2.resolve _32 };
    _32 <- i_6;
    _33 <- f_2;
    _27 <- AddWatcher0.add_watcher _28 _29 _32 _33;
    goto BB11
  }
  BB11 {
    _16 <- ();
    assume { Resolve6.resolve _16 };
    goto BB13
  }
  BB12 {
    assume { Resolve3.resolve clause_12 };
    _16 <- ();
    assume { Resolve6.resolve _16 };
    goto BB13
  }
  BB13 {
    i_6 <- i_6 + (1 : usize);
    _7 <- ();
    assume { Resolve6.resolve _7 };
    goto BB2
  }
  BB14 {
    assume { Resolve7.resolve self_1 };
    assume { Resolve8.resolve f_2 };
    assume { Resolve2.resolve i_6 };
    _0 <- ();
    return _0
  }
  
end
module Lib_Trail_Impl0_LearnUnits_Interface
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_Unsat_Interface as Unsat1
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val learn_units [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Invariant0.invariant' f}
    requires {Invariant1.invariant' ( * self) f}
    ensures { match (result) with
      | Type.Core_Option_Option_Some cref -> UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) && Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) = 1 && Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments ( ^ self)) && Unsat1.unsat (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) 0) (Type.lib_trail_trail_Trail_assignments ( ^ self))
      | _ -> true
      end }
    ensures { Invariant1.invariant' ( ^ self) f }
    
end
module Lib_Trail_Impl0_LearnUnits
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int32
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant5
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model7 with function Model0.model = Model8.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant2 with function Model0.model = Model7.model
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Logic_LogicLit_Impl1_Unsat as Unsat1 with function Model0.model = Model7.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model2.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant3 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model7.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model1.model,
  function Model1.model = Model2.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant4 with predicate Invariant0.invariant' = Invariant5.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model1.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model1.model,
  function Model1.model = Model2.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model1.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicFormula_Impl0_Model as Model5 with function Model0.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant3.invariant', function Model1.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model5.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = borrowed (Type.lib_trail_trail)
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model4.model,
  function Model1.model = Model7.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model4.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model4.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model3.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model4.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model3.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model7.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model3.model, function Model1.model = Model4.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_trail_trail
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve4 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail))
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = borrowed (Type.lib_trail_trail)
  clone Lib_Logic_LogicLit_Impl1_Unset as Unset0 with function Model0.model = Model7.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone CreusotContracts_Logic_Model_Impl0_Model as Model11 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model7.model
  clone Lib_Lit_Impl0_LitSet_Interface as LitSet0 with function Model0.model = Model11.model,
  predicate Invariant0.invariant' = Invariant5.invariant', predicate Unset0.unset = Unset0.unset
  clone Lib_Lit_Impl0_LitUnsat_Interface as LitUnsat0 with function Model0.model = Model11.model,
  predicate Invariant0.invariant' = Invariant5.invariant', predicate Unsat0.unsat = Unsat1.unsat
  clone CreusotContracts_Logic_Model_Impl0_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_lit_lit,
  function Model0.model = Model10.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len1 with type t = Type.lib_lit_lit,
  function Model0.model = Model10.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_clause_clause,
  function Model0.model = Model9.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_clause_clause,
  function Model0.model = Model9.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.lib_trail_trail),
  function Model0.model = Model0.model
  clone Lib_Trail_Impl0_LearnUnit_Interface as LearnUnit0 with function Model0.model = Model4.model,
  function Model1.model = Model7.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  function Model2.model = Model1.model, predicate Invariant0.invariant' = Invariant3.invariant',
  function Model3.model = Model2.model, predicate Invariant1.invariant' = Invariant1.invariant',
  predicate Invariant2.invariant' = Invariant0.invariant', predicate Sat0.sat = Sat0.sat,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg learn_units [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Invariant1.invariant' f}
    requires {Invariant0.invariant' ( * self) f}
    ensures { match (result) with
      | Type.Core_Option_Option_Some cref -> UInt64.to_int cref < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses f)) && Seq.length (Model2.model (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) = 1 && Unsat0.unsat (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments ( ^ self)) && Unsat1.unsat (Seq.get (Model2.model (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) 0) (Type.lib_trail_trail_Trail_assignments ( ^ self))
      | _ -> true
      end }
    ensures { Invariant0.invariant' ( ^ self) f }
    
   = 
  var _0 : Type.core_option_option usize;
  var self_1 : borrowed (Type.lib_trail_trail);
  var f_2 : Type.lib_formula_formula;
  var _3 : ();
  var i_4 : usize;
  var old_self_5 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_trail_trail));
  var _6 : borrowed (Type.lib_trail_trail);
  var _7 : borrowed (Type.lib_trail_trail);
  var _8 : ();
  var _9 : ();
  var _10 : bool;
  var _11 : usize;
  var _12 : usize;
  var _13 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var clause_14 : Type.lib_clause_clause;
  var _15 : Type.lib_clause_clause;
  var _16 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _17 : usize;
  var _18 : ();
  var _19 : bool;
  var _20 : usize;
  var _21 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var lit_22 : Type.lib_lit_lit;
  var _23 : Type.lib_lit_lit;
  var _24 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _25 : bool;
  var _26 : Type.lib_lit_lit;
  var _27 : Type.lib_assignments_assignments;
  var _28 : Type.lib_assignments_assignments;
  var _29 : bool;
  var _30 : Type.lib_lit_lit;
  var _31 : Type.lib_assignments_assignments;
  var _32 : Type.lib_assignments_assignments;
  var _33 : ();
  var _34 : usize;
  var _35 : Type.core_result_result () ();
  var _36 : borrowed (Type.lib_trail_trail);
  var _37 : usize;
  var _38 : Type.lib_formula_formula;
  var _39 : ();
  var _40 : ();
  var _41 : ();
  {
    self_1 <- self;
    f_2 <- f;
    goto BB0
  }
  BB0 {
    i_4 <- (0 : usize);
    _7 <- self_1;
    _6 <- _7;
    assume { Resolve0.resolve _7 };
    old_self_5 <- Record0.record _6;
    goto BB1
  }
  BB1 {
    assume { Resolve1.resolve old_self_5 };
    goto BB2
  }
  BB2 {
    invariant self_inv { Invariant0.invariant' ( * self_1) f_2 };
    invariant proph {  ^ Model0.model old_self_5 =  ^ self_1 };
    assume { Resolve2.resolve _11 };
    _11 <- i_4;
    _13 <- Type.lib_formula_formula_Formula_clauses f_2;
    _12 <- Len0.len _13;
    goto BB3
  }
  BB3 {
    _10 <- _11 < _12;
    switch (_10)
      | False -> goto BB19
      | _ -> goto BB4
      end
  }
  BB4 {
    _16 <- Type.lib_formula_formula_Formula_clauses f_2;
    assume { Resolve2.resolve _17 };
    _17 <- i_4;
    _15 <- Index0.index _16 _17;
    goto BB5
  }
  BB5 {
    clause_14 <- _15;
    assume { Resolve3.resolve _15 };
    _21 <- Type.lib_clause_clause_Clause_rest clause_14;
    _20 <- Len1.len _21;
    goto BB6
  }
  BB6 {
    _19 <- _20 = (1 : usize);
    switch (_19)
      | False -> goto BB17
      | _ -> goto BB7
      end
  }
  BB7 {
    _24 <- Type.lib_clause_clause_Clause_rest clause_14;
    assume { Resolve3.resolve clause_14 };
    _23 <- Index1.index _24 (0 : usize);
    goto BB8
  }
  BB8 {
    assume { Resolve4.resolve lit_22 };
    lit_22 <- _23;
    assume { Resolve5.resolve _23 };
    assume { Resolve4.resolve _26 };
    _26 <- lit_22;
    _28 <- Type.lib_trail_trail_Trail_assignments ( * self_1);
    _27 <- _28;
    assume { Resolve6.resolve _28 };
    _25 <- LitSet0.lit_set _26 _27;
    goto BB9
  }
  BB9 {
    switch (_25)
      | False -> goto BB14
      | _ -> goto BB10
      end
  }
  BB10 {
    assume { Resolve4.resolve _30 };
    _30 <- lit_22;
    assume { Resolve4.resolve lit_22 };
    _32 <- Type.lib_trail_trail_Trail_assignments ( * self_1);
    _31 <- _32;
    assume { Resolve6.resolve _32 };
    _29 <- LitUnsat0.lit_unsat _30 _31;
    goto BB11
  }
  BB11 {
    switch (_29)
      | False -> goto BB13
      | _ -> goto BB12
      end
  }
  BB12 {
    assume { Resolve7.resolve self_1 };
    assume { Resolve8.resolve f_2 };
    assume { Resolve2.resolve _34 };
    _34 <- i_4;
    assume { Resolve2.resolve i_4 };
    _0 <- Type.Core_Option_Option_Some _34;
    goto BB20
  }
  BB13 {
    _18 <- ();
    assume { Resolve9.resolve _18 };
    goto BB16
  }
  BB14 {
    assume { Resolve4.resolve lit_22 };
    _36 <- borrow_mut ( * self_1);
    self_1 <- { self_1 with current = ( ^ _36) };
    assume { Resolve2.resolve _37 };
    _37 <- i_4;
    _38 <- f_2;
    _35 <- LearnUnit0.learn_unit _36 _37 _38;
    goto BB15
  }
  BB15 {
    _18 <- ();
    assume { Resolve9.resolve _18 };
    goto BB16
  }
  BB16 {
    goto BB18
  }
  BB17 {
    assume { Resolve3.resolve clause_14 };
    _18 <- ();
    assume { Resolve9.resolve _18 };
    goto BB18
  }
  BB18 {
    i_4 <- i_4 + (1 : usize);
    _9 <- ();
    assume { Resolve9.resolve _9 };
    goto BB2
  }
  BB19 {
    assume { Resolve7.resolve self_1 };
    assume { Resolve8.resolve f_2 };
    assume { Resolve2.resolve i_4 };
    _8 <- ();
    assume { Resolve9.resolve _8 };
    _0 <- Type.Core_Option_Option_None;
    goto BB20
  }
  BB20 {
    return _0
  }
  
end
module Lib_Solver_Solver_Interface
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable_Interface as NotSatisfiable0
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_FormulaSatInner_Interface as FormulaSatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = uint8
  clone Lib_Logic_LogicFormula_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val solver [@cfg:stackify] (formula : borrowed (Type.lib_formula_formula)) : Type.lib_solver_satresult
    requires {Invariant0.invariant' ( * formula)}
    ensures { match (result) with
      | Type.Lib_Solver_SatResult_Sat assn -> FormulaSatInner0.formula_sat_inner (Model0.model ( ^ formula)) (Model1.model assn) && Equisat0.equisat ( * formula) ( ^ formula)
      | Type.Lib_Solver_SatResult_Unsat -> NotSatisfiable0.not_satisfiable ( ^ formula) && Equisat0.equisat ( * formula) ( ^ formula)
      | _ -> true
      end }
    
end
module Lib_Solver_Solver
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant1 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_FormulaInvariant as FormulaInvariant0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model3.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss1 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss1.eventually_sat_complete_no_ass
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = uint8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner2 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant1.invariant', function Model1.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_EquisatExtension as EquisatExtension0 with function Model0.model = Model0.model,
  predicate EquisatExtensionInner0.equisat_extension_inner = EquisatExtensionInner0.equisat_extension_inner
  clone Lib_Logic_LogicFormula_Impl1_NotSatisfiable as NotSatisfiable0 with function Model0.model = Model3.model,
  predicate EquisatExtension0.equisat_extension = EquisatExtension0.equisat_extension
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  function Model0.model = Model0.model,
  predicate FormulaInvariant0.formula_invariant = FormulaInvariant0.formula_invariant, axiom .
  use mach.int.UInt64
  use mach.int.Int64
  clone Lib_Logic_LogicUtil_SortedRange as SortedRange0
  clone Lib_Logic_LogicUtil_Sorted as Sorted0 with predicate SortedRange0.sorted_range = SortedRange0.sorted_range
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model10 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model8.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = usize
  clone Lib_Logic_LogicTrail_Impl2_DecisionsAreSorted as DecisionsAreSorted0 with function Model0.model = Model7.model,
  predicate Sorted0.sorted = Sorted0.sorted
  clone Lib_Logic_LogicDecision_Impl0_Invariant as Invariant5 with function Model0.model = Model7.model
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve8 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve7 with type t = Type.core_option_option usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve6 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve5 with type t = Type.lib_decision_decisions
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve9 with type t = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = ()
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve1 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = usize
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model3.model, predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model6 with function Model0.model = Model1.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model8.model,
  function Model1.model = Model6.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicLit_Impl1_Unsat as Unsat1 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl5_Resolve as Resolve4 with type t = uint8, function Model0.model = Model1.model,
  predicate Resolve0.resolve = Resolve9.resolve
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New2 with type t = uint8, function Model0.model = Model1.model
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant8 with function Model0.model = Model2.model,
  function Model1.model = Model3.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant7 with predicate Invariant0.invariant' = Invariant2.invariant',
  predicate Invariant1.invariant' = Invariant8.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LitNotInLessInner as LitNotInLessInner0 with function Model0.model = Model2.model,
  predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model8.model,
  predicate LitNotInLessInner0.lit_not_in_less_inner = LitNotInLessInner0.lit_not_in_less_inner
  clone Lib_Logic_LogicTrail_UnitAreSat as UnitAreSat0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model, predicate Sat0.sat = Sat0.sat
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_InvariantNoDecision as InvariantNoDecision0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model8.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model7.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model6.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned,
  predicate DecisionsAreSorted0.decisions_are_sorted = DecisionsAreSorted0.decisions_are_sorted,
  predicate UnitAreSat0.unit_are_sat = UnitAreSat0.unit_are_sat
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant4 with predicate InvariantNoDecision0.invariant_no_decision = InvariantNoDecision0.invariant_no_decision,
  function Model0.model = Model7.model, function Model1.model = Model8.model,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model10.model,
  function Model1.model = Model2.model, function Model2.model = Model3.model
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant6 with function Model0.model = Model9.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone Lib_Watches_Impl0_New_Interface as New4 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone CreusotContracts_Logic_Model_Impl0_Model as Model5 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_clause_clause,
  function Model0.model = Model5.model
  clone Lib_Solver_Inner_Interface as Inner0 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant', predicate Invariant2.invariant' = Invariant5.invariant',
  predicate Invariant3.invariant' = Invariant0.invariant', predicate Equisat0.equisat = Equisat0.equisat,
  function Model0.model = Model1.model, predicate SatInner0.sat_inner = SatInner2.sat_inner,
  predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass,
  predicate NotSatisfiable0.not_satisfiable = NotSatisfiable0.not_satisfiable,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_ConflictAnalysis_DeriveEmptyFormula_Interface as DeriveEmptyFormula0 with function Model0.model = Model2.model,
  predicate Unsat0.unsat = Unsat0.unsat, predicate Invariant0.invariant' = Invariant4.invariant',
  predicate Invariant1.invariant' = Invariant0.invariant',
  predicate NotSatisfiable0.not_satisfiable = NotSatisfiable0.not_satisfiable,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_Trail_Impl0_LearnUnits_Interface as LearnUnits0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant', function Model0.model = Model2.model,
  function Model1.model = Model3.model, predicate Unsat0.unsat = Unsat0.unsat, predicate Unsat1.unsat = Unsat1.unsat,
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_Watches_Impl0_InitWatches_Interface as InitWatches0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_Decision_Impl0_New_Interface as New3 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant5.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_Trail_Impl0_New_Interface as New1 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant0.invariant', predicate Invariant2.invariant' = Invariant4.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  clone Lib_Assignments_Impl0_New_Interface as New0 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant3.invariant',
  predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old
  let rec cfg solver [@cfg:stackify] (formula : borrowed (Type.lib_formula_formula)) : Type.lib_solver_satresult
    requires {Invariant0.invariant' ( * formula)}
    ensures { match (result) with
      | Type.Lib_Solver_SatResult_Sat assn -> FormulaSatInner0.formula_sat_inner (Model0.model ( ^ formula)) (Model1.model assn) && Equisat0.equisat ( * formula) ( ^ formula)
      | Type.Lib_Solver_SatResult_Unsat -> NotSatisfiable0.not_satisfiable ( ^ formula) && Equisat0.equisat ( * formula) ( ^ formula)
      | _ -> true
      end }
    
   = 
  var _0 : Type.lib_solver_satresult;
  var formula_1 : borrowed (Type.lib_formula_formula);
  var trail_2 : Type.lib_trail_trail;
  var _3 : Type.lib_formula_formula;
  var _4 : Type.lib_assignments_assignments;
  var _5 : Type.lib_formula_formula;
  var _6 : ();
  var _7 : bool;
  var _8 : usize;
  var _9 : usize;
  var _10 : bool;
  var _11 : ();
  var _12 : ();
  var _13 : bool;
  var _14 : usize;
  var _15 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _16 : ();
  var a_17 : Type.creusotcontracts_std1_vec_vec uint8;
  var _18 : Type.creusotcontracts_std1_vec_vec uint8;
  var decisions_19 : Type.lib_decision_decisions;
  var _20 : Type.lib_formula_formula;
  var watches_21 : Type.lib_watches_watches;
  var _22 : Type.lib_formula_formula;
  var _23 : ();
  var _24 : borrowed (Type.lib_watches_watches);
  var _25 : Type.lib_formula_formula;
  var _26 : ();
  var _27 : Type.core_option_option usize;
  var _28 : borrowed (Type.lib_trail_trail);
  var _29 : Type.lib_formula_formula;
  var _30 : isize;
  var cref_31 : usize;
  var _32 : bool;
  var _33 : Type.lib_formula_formula;
  var _34 : Type.lib_trail_trail;
  var _35 : Type.lib_trail_trail;
  var _36 : usize;
  var _37 : ();
  var _38 : ();
  var _39 : borrowed (Type.lib_formula_formula);
  var _40 : Type.lib_decision_decisions;
  var _41 : Type.lib_trail_trail;
  var _42 : Type.lib_watches_watches;
  {
    formula_1 <- formula;
    goto BB0
  }
  BB0 {
    _3 <-  * formula_1;
    _5 <-  * formula_1;
    _4 <- New0.new _5;
    goto BB1
  }
  BB1 {
    trail_2 <- New1.new _3 _4;
    goto BB2
  }
  BB2 {
    assume { Resolve0.resolve _8 };
    _8 <- Type.lib_formula_formula_Formula_num_vars ( * formula_1);
    _10 <- (2 : usize) = (0 : usize);
    assert { not _10 };
    goto BB3
  }
  BB3 {
    _9 <- (18446744073709551615 : usize) / (2 : usize);
    _7 <- _8 >= _9;
    switch (_7)
      | False -> goto BB5
      | _ -> goto BB4
      end
  }
  BB4 {
    assume { Resolve1.resolve formula_1 };
    _0 <- Type.Lib_Solver_SatResult_Err;
    goto BB29
  }
  BB5 {
    _6 <- ();
    assume { Resolve3.resolve _6 };
    _15 <- Type.lib_formula_formula_Formula_clauses ( * formula_1);
    _14 <- Len0.len _15;
    goto BB6
  }
  BB6 {
    _13 <- _14 = (0 : usize);
    switch (_13)
      | False -> goto BB10
      | _ -> goto BB7
      end
  }
  BB7 {
    assume { Resolve1.resolve formula_1 };
    a_17 <- New2.new ();
    goto BB8
  }
  BB8 {
    assume { Resolve4.resolve _18 };
    _18 <- a_17;
    _0 <- Type.Lib_Solver_SatResult_Sat _18;
    goto BB9
  }
  BB9 {
    goto BB28
  }
  BB10 {
    _12 <- ();
    assume { Resolve3.resolve _12 };
    _20 <-  * formula_1;
    decisions_19 <- New3.new _20;
    goto BB11
  }
  BB11 {
    _22 <-  * formula_1;
    watches_21 <- New4.new _22;
    goto BB12
  }
  BB12 {
    _24 <- borrow_mut watches_21;
    watches_21 <-  ^ _24;
    _25 <-  * formula_1;
    _23 <- InitWatches0.init_watches _24 _25;
    goto BB13
  }
  BB13 {
    _28 <- borrow_mut trail_2;
    trail_2 <-  ^ _28;
    _29 <-  * formula_1;
    _27 <- LearnUnits0.learn_units _28 _29;
    goto BB14
  }
  BB14 {
    switch (_27)
      | Type.Core_Option_Option_None -> goto BB15
      | Type.Core_Option_Option_Some _ -> goto BB17
      end
  }
  BB15 {
    assume { Resolve7.resolve _27 };
    _26 <- ();
    assume { Resolve3.resolve _26 };
    _39 <- borrow_mut ( * formula_1);
    formula_1 <- { formula_1 with current = ( ^ _39) };
    assume { Resolve5.resolve _40 };
    _40 <- decisions_19;
    assume { Resolve2.resolve _41 };
    _41 <- trail_2;
    assume { Resolve6.resolve _42 };
    _42 <- watches_21;
    _0 <- Inner0.inner _39 _40 _41 _42;
    goto BB21
  }
  BB16 {
    assume { Resolve1.resolve formula_1 };
    assume { Resolve2.resolve trail_2 };
    assume { Resolve5.resolve decisions_19 };
    assume { Resolve6.resolve watches_21 };
    assume { Resolve7.resolve _27 };
    absurd
  }
  BB17 {
    assume { Resolve0.resolve cref_31 };
    cref_31 <- Type.core_option_option_Some_0 _27;
    assume { Resolve7.resolve _27 };
    _33 <-  * formula_1;
    assume { Resolve1.resolve formula_1 };
    _35 <- trail_2;
    _34 <- _35;
    assume { Resolve8.resolve _35 };
    assume { Resolve0.resolve _36 };
    _36 <- cref_31;
    assume { Resolve0.resolve cref_31 };
    _32 <- DeriveEmptyFormula0.derive_empty_formula _33 _34 _36;
    goto BB18
  }
  BB18 {
    switch (_32)
      | False -> goto BB20
      | _ -> goto BB19
      end
  }
  BB19 {
    _0 <- Type.Lib_Solver_SatResult_Unsat;
    goto BB25
  }
  BB20 {
    _0 <- Type.Lib_Solver_SatResult_Err;
    goto BB25
  }
  BB21 {
    assume { Resolve1.resolve formula_1 };
    goto BB22
  }
  BB22 {
    goto BB23
  }
  BB23 {
    goto BB24
  }
  BB24 {
    goto BB31
  }
  BB25 {
    goto BB26
  }
  BB26 {
    assume { Resolve6.resolve watches_21 };
    goto BB27
  }
  BB27 {
    assume { Resolve5.resolve decisions_19 };
    goto BB29
  }
  BB28 {
    goto BB29
  }
  BB29 {
    goto BB30
  }
  BB30 {
    assume { Resolve2.resolve trail_2 };
    goto BB31
  }
  BB31 {
    return _0
  }
  
end
module Lib_Watches_Impl0_MoveToEnd_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic_Interface as ToNegWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  val move_to_end [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (old_idx : usize) (old_pos : usize) (new_lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {UInt64.to_int old_pos < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx)))}
    requires {UInt64.to_int old_idx < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic new_lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx new_lit) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( ^ self))) (UInt64.to_int old_idx))) = Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl0_MoveToEnd
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicWatches_WatchesInvariantInternal as WatchesInvariantInternal0 with function Model0.model = Model1.model,
  function Model1.model = Model2.model, function Model2.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  predicate WatchesInvariantInternal0.watches_invariant_internal = WatchesInvariantInternal0.watches_invariant_internal
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve5 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = Type.lib_watches_watches
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve2 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl1_Model as Model8 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl1_Swap_Interface as Swap0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model8.model, function Model1.model = Model1.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model6 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model6.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model7 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model0.model, function Model1.model = Model7.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model5 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model5.model
  let rec cfg move_to_end [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (old_idx : usize) (old_pos : usize) (new_lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {UInt64.to_int old_pos < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx)))}
    requires {UInt64.to_int old_idx < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic new_lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx new_lit) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( ^ self))) (UInt64.to_int old_idx))) = Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_watches_watches);
  var old_idx_2 : usize;
  var old_pos_3 : usize;
  var new_lit_4 : Type.lib_lit_lit;
  var _f_5 : Type.lib_formula_formula;
  var end'_6 : usize;
  var _7 : usize;
  var _8 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _9 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _10 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _11 : usize;
  var _12 : ();
  var _13 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _14 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _15 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)));
  var _16 : usize;
  var _17 : usize;
  var _18 : usize;
  {
    self_1 <- self;
    old_idx_2 <- old_idx;
    old_pos_3 <- old_pos;
    new_lit_4 <- new_lit;
    _f_5 <- _f;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve new_lit_4 };
    assume { Resolve1.resolve _f_5 };
    _10 <- Type.lib_watches_watches_Watches_watches ( * self_1);
    assume { Resolve2.resolve _11 };
    _11 <- old_idx_2;
    _9 <- Index0.index _10 _11;
    goto BB1
  }
  BB1 {
    _8 <- _9;
    assume { Resolve3.resolve _9 };
    _7 <- Len0.len _8;
    goto BB2
  }
  BB2 {
    end'_6 <- _7 - (1 : usize);
    _15 <- borrow_mut (Type.lib_watches_watches_Watches_watches ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Watches_Watches a =  * self_1 in Type.Lib_Watches_Watches ( ^ _15)) };
    assume { Resolve4.resolve self_1 };
    assume { Resolve2.resolve _16 };
    _16 <- old_idx_2;
    assume { Resolve2.resolve old_idx_2 };
    _14 <- IndexMut0.index_mut _15 _16;
    goto BB3
  }
  BB3 {
    _13 <- borrow_mut ( * _14);
    _14 <- { _14 with current = ( ^ _13) };
    assume { Resolve2.resolve _17 };
    _17 <- old_pos_3;
    assume { Resolve2.resolve old_pos_3 };
    assume { Resolve2.resolve _18 };
    _18 <- end'_6;
    assume { Resolve2.resolve end'_6 };
    _12 <- Swap0.swap _13 _17 _18;
    goto BB4
  }
  BB4 {
    assume { Resolve5.resolve _14 };
    _0 <- ();
    return _0
  }
  
end
module Core_Cmp_PartialEq_Eq_Interface
  type self   
  type rhs   
  use prelude.Prelude
  val eq [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Core_Cmp_PartialEq_Eq
  type self   
  type rhs   
  use prelude.Prelude
  val eq [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Core_Cmp_PartialEq_Ne_Interface
  type self   
  type rhs   
  use prelude.Prelude
  val ne [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Core_Cmp_PartialEq_Ne
  type self   
  type rhs   
  use prelude.Prelude
  val ne [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Lib_Formula_Impl0
  use Type
  clone Lib_Formula_Impl0_Eq_Interface as Eq0
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.lib_formula_satstate,
  type rhs = Type.lib_formula_satstate, val eq = Eq0.eq
end
module Lib_Lit_Impl1
  use Type
  clone Lib_Lit_Impl1_Eq_Interface as Eq0
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.lib_lit_lit, type rhs = Type.lib_lit_lit,
  val eq = Eq0.eq
end
module Core_Clone_Clone_Clone_Interface
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    requires {false}
    
end
module Core_Clone_Clone_Clone
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    requires {false}
    
end
module Core_Clone_Clone_CloneFrom_Interface
  type self   
  use prelude.Prelude
  val clone_from [@cfg:stackify] (self : borrowed self) (source : self) : ()
    requires {false}
    
end
module Core_Clone_Clone_CloneFrom
  type self   
  use prelude.Prelude
  val clone_from [@cfg:stackify] (self : borrowed self) (source : self) : ()
    requires {false}
    
end
module Lib_Lit_Impl3
  use Type
  clone Lib_Lit_Impl3_Clone_Interface as Clone0
  clone Core_Clone_Clone_Clone_Interface as Clone1 with type self = Type.lib_lit_lit, val clone' = Clone0.clone'
end
module Lib_Lit_Impl4
  
end
module Core_Ops_Bit_Not_Output
  type self   
  type output   
end
module Core_Ops_Bit_Not_Not_Interface
  type self   
  clone Core_Ops_Bit_Not_Output as Output0 with type self = self
  val not' [@cfg:stackify] (self : self) : Output0.output
    requires {false}
    
end
module Core_Ops_Bit_Not_Not
  type self   
  clone Core_Ops_Bit_Not_Output as Output0 with type self = self
  val not' [@cfg:stackify] (self : self) : Output0.output
    requires {false}
    
end
module Lib_Lit_Impl2_Output
  use Type
  type output  = 
    Type.lib_lit_lit
end
module Lib_Lit_Impl2
  use Type
  clone Lib_Lit_Impl2_Not_Interface as Not0
  clone Lib_Lit_Impl2_Output as Output0
  clone Core_Ops_Bit_Not_Not_Interface as Not1 with type self = Type.lib_lit_lit, val not' = Not0.not',
  type Output0.output = Output0.output
  clone Core_Ops_Bit_Not_Output as Output1 with type self = Type.lib_lit_lit, type output = Output0.output
end
