module Type
  use Ref
  use mach.int.Int
  use prelude.Int8
  use prelude.Int16
  use mach.int.Int32
  use mach.int.Int64
  use prelude.UInt8
  use prelude.UInt16
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  type creusotcontracts_std1_vec_vec 't  
  type lib_decision_decisions  = 
    | Lib_Decision_Decisions (creusotcontracts_std1_vec_vec usize)
    
  function lib_decision_decisions_Decisions_lit_order (self : lib_decision_decisions) : creusotcontracts_std1_vec_vec usize
    
  val lib_decision_decisions_Decisions_lit_order (self : lib_decision_decisions) : creusotcontracts_std1_vec_vec usize
    ensures { result = lib_decision_decisions_Decisions_lit_order self }
    
  axiom lib_decision_decisions_Decisions_lit_order_acc : forall a : creusotcontracts_std1_vec_vec usize . lib_decision_decisions_Decisions_lit_order (Lib_Decision_Decisions a : lib_decision_decisions) = a
  type lib_assignments_assignments  = 
    | Lib_Assignments_Assignments (creusotcontracts_std1_vec_vec uint8) usize
    
  function lib_assignments_assignments_Assignments_0 (self : lib_assignments_assignments) : creusotcontracts_std1_vec_vec uint8
    
  val lib_assignments_assignments_Assignments_0 (self : lib_assignments_assignments) : creusotcontracts_std1_vec_vec uint8
    ensures { result = lib_assignments_assignments_Assignments_0 self }
    
  axiom lib_assignments_assignments_Assignments_0_acc : forall a : creusotcontracts_std1_vec_vec uint8, b : usize . lib_assignments_assignments_Assignments_0 (Lib_Assignments_Assignments a b : lib_assignments_assignments) = a
  function lib_assignments_assignments_Assignments_1 (self : lib_assignments_assignments) : usize
  val lib_assignments_assignments_Assignments_1 (self : lib_assignments_assignments) : usize
    ensures { result = lib_assignments_assignments_Assignments_1 self }
    
  axiom lib_assignments_assignments_Assignments_1_acc : forall a : creusotcontracts_std1_vec_vec uint8, b : usize . lib_assignments_assignments_Assignments_1 (Lib_Assignments_Assignments a b : lib_assignments_assignments) = b
  type lib_lit_lit  = 
    | Lib_Lit_Lit usize bool
    
  function lib_lit_lit_Lit_idx (self : lib_lit_lit) : usize
  val lib_lit_lit_Lit_idx (self : lib_lit_lit) : usize
    ensures { result = lib_lit_lit_Lit_idx self }
    
  axiom lib_lit_lit_Lit_idx_acc : forall a : usize, b : bool . lib_lit_lit_Lit_idx (Lib_Lit_Lit a b : lib_lit_lit) = a
  function lib_lit_lit_Lit_polarity (self : lib_lit_lit) : bool
  val lib_lit_lit_Lit_polarity (self : lib_lit_lit) : bool
    ensures { result = lib_lit_lit_Lit_polarity self }
    
  axiom lib_lit_lit_Lit_polarity_acc : forall a : usize, b : bool . lib_lit_lit_Lit_polarity (Lib_Lit_Lit a b : lib_lit_lit) = b
  type lib_clause_clause  = 
    | Lib_Clause_Clause (creusotcontracts_std1_vec_vec (lib_lit_lit))
    
  function lib_clause_clause_Clause_rest (self : lib_clause_clause) : creusotcontracts_std1_vec_vec (lib_lit_lit)
  val lib_clause_clause_Clause_rest (self : lib_clause_clause) : creusotcontracts_std1_vec_vec (lib_lit_lit)
    ensures { result = lib_clause_clause_Clause_rest self }
    
  axiom lib_clause_clause_Clause_rest_acc : forall a : creusotcontracts_std1_vec_vec (lib_lit_lit) . lib_clause_clause_Clause_rest (Lib_Clause_Clause a : lib_clause_clause) = a
  type lib_formula_formula  = 
    | Lib_Formula_Formula (creusotcontracts_std1_vec_vec (lib_clause_clause)) usize
    
  function lib_formula_formula_Formula_clauses (self : lib_formula_formula) : creusotcontracts_std1_vec_vec (lib_clause_clause)
    
  val lib_formula_formula_Formula_clauses (self : lib_formula_formula) : creusotcontracts_std1_vec_vec (lib_clause_clause)
    ensures { result = lib_formula_formula_Formula_clauses self }
    
  axiom lib_formula_formula_Formula_clauses_acc : forall a : creusotcontracts_std1_vec_vec (lib_clause_clause), b : usize . lib_formula_formula_Formula_clauses (Lib_Formula_Formula a b : lib_formula_formula) = a
  function lib_formula_formula_Formula_num_vars (self : lib_formula_formula) : usize
  val lib_formula_formula_Formula_num_vars (self : lib_formula_formula) : usize
    ensures { result = lib_formula_formula_Formula_num_vars self }
    
  axiom lib_formula_formula_Formula_num_vars_acc : forall a : creusotcontracts_std1_vec_vec (lib_clause_clause), b : usize . lib_formula_formula_Formula_num_vars (Lib_Formula_Formula a b : lib_formula_formula) = b
  type lib_trail_reason  = 
    | Lib_Trail_Reason_Decision
    | Lib_Trail_Reason_Unit
    | Lib_Trail_Reason_Long usize
    
  type lib_trail_step  = 
    | Lib_Trail_Step (lib_lit_lit) usize (lib_trail_reason)
    
  function lib_trail_step_Step_lit (self : lib_trail_step) : lib_lit_lit
  val lib_trail_step_Step_lit (self : lib_trail_step) : lib_lit_lit
    ensures { result = lib_trail_step_Step_lit self }
    
  axiom lib_trail_step_Step_lit_acc : forall a : lib_lit_lit, b : usize, c : lib_trail_reason . lib_trail_step_Step_lit (Lib_Trail_Step a b c : lib_trail_step) = a
  function lib_trail_step_Step_reason (self : lib_trail_step) : lib_trail_reason
  val lib_trail_step_Step_reason (self : lib_trail_step) : lib_trail_reason
    ensures { result = lib_trail_step_Step_reason self }
    
  axiom lib_trail_step_Step_reason_acc : forall a : lib_lit_lit, b : usize, c : lib_trail_reason . lib_trail_step_Step_reason (Lib_Trail_Step a b c : lib_trail_step) = c
  type core_option_option 't = 
    | Core_Option_Option_None
    | Core_Option_Option_Some 't
    
  type lib_trail_trail  = 
    | Lib_Trail_Trail (lib_assignments_assignments) (creusotcontracts_std1_vec_vec usize) (creusotcontracts_std1_vec_vec (lib_trail_step)) usize (creusotcontracts_std1_vec_vec usize)
    
  function lib_trail_trail_Trail_trail (self : lib_trail_trail) : creusotcontracts_std1_vec_vec (lib_trail_step)
  val lib_trail_trail_Trail_trail (self : lib_trail_trail) : creusotcontracts_std1_vec_vec (lib_trail_step)
    ensures { result = lib_trail_trail_Trail_trail self }
    
  axiom lib_trail_trail_Trail_trail_acc : forall a : lib_assignments_assignments, b : creusotcontracts_std1_vec_vec usize, c : creusotcontracts_std1_vec_vec (lib_trail_step), d : usize, e : creusotcontracts_std1_vec_vec usize . lib_trail_trail_Trail_trail (Lib_Trail_Trail a b c d e : lib_trail_trail) = c
  function lib_trail_trail_Trail_assignments (self : lib_trail_trail) : lib_assignments_assignments
  val lib_trail_trail_Trail_assignments (self : lib_trail_trail) : lib_assignments_assignments
    ensures { result = lib_trail_trail_Trail_assignments self }
    
  axiom lib_trail_trail_Trail_assignments_acc : forall a : lib_assignments_assignments, b : creusotcontracts_std1_vec_vec usize, c : creusotcontracts_std1_vec_vec (lib_trail_step), d : usize, e : creusotcontracts_std1_vec_vec usize . lib_trail_trail_Trail_assignments (Lib_Trail_Trail a b c d e : lib_trail_trail) = a
  function lib_trail_trail_Trail_lit_to_level (self : lib_trail_trail) : creusotcontracts_std1_vec_vec usize
  val lib_trail_trail_Trail_lit_to_level (self : lib_trail_trail) : creusotcontracts_std1_vec_vec usize
    ensures { result = lib_trail_trail_Trail_lit_to_level self }
    
  axiom lib_trail_trail_Trail_lit_to_level_acc : forall a : lib_assignments_assignments, b : creusotcontracts_std1_vec_vec usize, c : creusotcontracts_std1_vec_vec (lib_trail_step), d : usize, e : creusotcontracts_std1_vec_vec usize . lib_trail_trail_Trail_lit_to_level (Lib_Trail_Trail a b c d e : lib_trail_trail) = b
  function lib_trail_trail_Trail_decisions (self : lib_trail_trail) : creusotcontracts_std1_vec_vec usize
  val lib_trail_trail_Trail_decisions (self : lib_trail_trail) : creusotcontracts_std1_vec_vec usize
    ensures { result = lib_trail_trail_Trail_decisions self }
    
  axiom lib_trail_trail_Trail_decisions_acc : forall a : lib_assignments_assignments, b : creusotcontracts_std1_vec_vec usize, c : creusotcontracts_std1_vec_vec (lib_trail_step), d : usize, e : creusotcontracts_std1_vec_vec usize . lib_trail_trail_Trail_decisions (Lib_Trail_Trail a b c d e : lib_trail_trail) = e
  type lib_conflictanalysis_conflict  = 
    | Lib_ConflictAnalysis_Conflict_Ground
    | Lib_ConflictAnalysis_Conflict_Unit (lib_lit_lit)
    | Lib_ConflictAnalysis_Conflict_Learned usize (lib_lit_lit) (lib_clause_clause)
    | Lib_ConflictAnalysis_Conflict_Panic
    
  type lib_formula_satstate  = 
    | Lib_Formula_SatState_Unknown
    | Lib_Formula_SatState_Sat
    | Lib_Formula_SatState_Unsat
    
  type lib_watches_watcher  = 
    | Lib_Watches_Watcher usize
    
  function lib_watches_watcher_Watcher_cref (self : lib_watches_watcher) : usize
  val lib_watches_watcher_Watcher_cref (self : lib_watches_watcher) : usize
    ensures { result = lib_watches_watcher_Watcher_cref self }
    
  axiom lib_watches_watcher_Watcher_cref_acc : forall a : usize . lib_watches_watcher_Watcher_cref (Lib_Watches_Watcher a : lib_watches_watcher) = a
  type lib_watches_watches  = 
    | Lib_Watches_Watches (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher)))
    
  function lib_watches_watches_Watches_watches (self : lib_watches_watches) : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher))
    
  val lib_watches_watches_Watches_watches (self : lib_watches_watches) : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher))
    ensures { result = lib_watches_watches_Watches_watches self }
    
  axiom lib_watches_watches_Watches_watches_acc : forall a : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher)) . lib_watches_watches_Watches_watches (Lib_Watches_Watches a : lib_watches_watches) = a
  type lib_solver_conflictresult  = 
    | Lib_Solver_ConflictResult_Ok
    | Lib_Solver_ConflictResult_Err
    | Lib_Solver_ConflictResult_Ground
    | Lib_Solver_ConflictResult_Continue
    
  type lib_solver_satresult  = 
    | Lib_Solver_SatResult_Sat (creusotcontracts_std1_vec_vec (lib_lit_lit))
    | Lib_Solver_SatResult_Unsat
    | Lib_Solver_SatResult_Unknown
    | Lib_Solver_SatResult_Err
    
  type core_result_result 't 'e = 
    | Core_Result_Result_Ok 't
    | Core_Result_Result_Err 'e
    
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve_Interface
  type t   
  use prelude.Prelude
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve
  type t   
  use prelude.Prelude
  predicate resolve (self : borrowed t) = 
     ^ self =  * self
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve_Interface
  type t   
  predicate resolve (self : t)
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve
  type t   
  predicate resolve (self : t) = 
    true
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface
  type self   
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve
  type self   
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Impl1
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = t
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = borrowed t,
  predicate resolve = Resolve0.resolve
end
module CreusotContracts_Logic_Resolve_Impl2
  type t   
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = t
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = t,
  predicate resolve = Resolve0.resolve
end
module Lib_Decision_Impl0_MoveToFront_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val move_to_front [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (tomove : usize) : ()
end
module Lib_Decision_Impl0_MoveToFront
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = usize
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = Type.lib_decision_decisions
  let rec cfg move_to_front [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (tomove : usize) : () = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_decision_decisions);
  var tomove_2 : usize;
  {
    self_1 <- self;
    tomove_2 <- tomove;
    goto BB0
  }
  BB0 {
    _0 <- ();
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve tomove_2 };
    return _0
  }
  
end
module Lib_Assignments_Impl0_Len_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val len [@cfg:stackify] (self : Type.lib_assignments_assignments) : usize
end
module Lib_Assignments_Impl0_Len
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val len [@cfg:stackify] (self : Type.lib_assignments_assignments) : usize
end
module Lib_Assignments_Impl0_SetAssignmentNew_Interface
  use prelude.Prelude
  use Type
  val set_assignment_new [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) (_t : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step)) : ()
    
end
module Lib_Assignments_Impl0_SetAssignmentNew
  use prelude.Prelude
  use Type
  val set_assignment_new [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) (_t : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step)) : ()
    
end
module CreusotContracts_Std1_Vec_Impl0_Model_Interface
  type t   
  use Type
  use seq.Seq
  function model (self : Type.creusotcontracts_std1_vec_vec t) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_Model
  type t   
  use Type
  use seq.Seq
  function model (self : Type.creusotcontracts_std1_vec_vec t) : Seq.seq t
end
module Lib_Logic_LogicClause_Impl0_Model_Interface
  use Type
  use seq.Seq
  function model (self : Type.lib_clause_clause) : Seq.seq (Type.lib_lit_lit)
end
module Lib_Logic_LogicClause_Impl0_Model
  use Type
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_lit_lit
  function model (self : Type.lib_clause_clause) : Seq.seq (Type.lib_lit_lit) = 
    Model0.model (Type.lib_clause_clause_Clause_rest self)
end
module Lib_Logic_LogicLit_Impl1_Invariant_Interface
  use Type
  use mach.int.Int
  predicate invariant' (self : Type.lib_lit_lit) (n : int)
end
module Lib_Logic_LogicLit_Impl1_Invariant
  use Type
  use mach.int.Int
  use mach.int.UInt64
  predicate invariant' (self : Type.lib_lit_lit) (n : int) = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < n
end
module Lib_Logic_LogicClause_VarsInRangeInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate vars_in_range_inner (s : Seq.seq (Type.lib_lit_lit)) (n : int)
end
module Lib_Logic_LogicClause_VarsInRangeInner
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  predicate vars_in_range_inner (s : Seq.seq (Type.lib_lit_lit)) (n : int) = 
    forall i : (int) . 0 <= i && i < Seq.length s -> Invariant0.invariant' (Seq.get s i) n
end
module Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface
  use seq.Seq
  use Type
  predicate no_duplicate_indexes_inner (s : Seq.seq (Type.lib_lit_lit))
end
module Lib_Logic_LogicClause_NoDuplicateIndexesInner
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  predicate no_duplicate_indexes_inner (s : Seq.seq (Type.lib_lit_lit)) = 
    forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length s && 0 <= k && k < j -> not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get s k)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get s j)))
end
module Lib_Logic_LogicClause_AtLeastBinary_Interface
  use seq.Seq
  use Type
  predicate at_least_binary (s : Seq.seq (Type.lib_lit_lit))
end
module Lib_Logic_LogicClause_AtLeastBinary
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  predicate at_least_binary (s : Seq.seq (Type.lib_lit_lit)) = 
    Seq.length s >= 2
end
module Lib_Logic_LogicClause_InvariantInternal_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate invariant_internal (s : Seq.seq (Type.lib_lit_lit)) (n : int)
end
module Lib_Logic_LogicClause_InvariantInternal
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_AtLeastBinary_Interface as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  predicate invariant_internal (s : Seq.seq (Type.lib_lit_lit)) (n : int) = 
    VarsInRangeInner0.vars_in_range_inner s n && NoDuplicateIndexesInner0.no_duplicate_indexes_inner s && AtLeastBinary0.at_least_binary s
end
module Lib_Logic_LogicClause_Impl2_Invariant_Interface
  use Type
  use mach.int.Int
  predicate invariant' (self : Type.lib_clause_clause) (n : int)
end
module Lib_Logic_LogicClause_Impl2_Invariant
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate invariant' (self : Type.lib_clause_clause) (n : int) = 
    InvariantInternal0.invariant_internal (Model0.model self) n
end
module Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface
  use Type
  predicate invariant_old (self : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_InvariantOld
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate invariant_old (self : Type.lib_formula_formula) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) -> Invariant0.invariant' (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self))
end
module Lib_Logic_LogicFormula_Impl1_Invariant_Interface
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  predicate invariant' (self : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_Invariant
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  predicate invariant' (self : Type.lib_formula_formula)
  axiom invariant'_spec : forall self : Type.lib_formula_formula . invariant' self = InvariantOld0.invariant_old self
end
module Lib_Logic_LogicAssignments_Impl0_Model_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function model (self : Type.lib_assignments_assignments) : Seq.seq uint8
end
module Lib_Logic_LogicAssignments_Impl0_Model
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = uint8
  function model (self : Type.lib_assignments_assignments) : Seq.seq uint8 = 
    Model0.model (Type.lib_assignments_assignments_Assignments_0 self)
end
module Lib_Logic_LogicAssignments_Impl1_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_assignments_assignments) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicAssignments_Impl1_Invariant
  use Type
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate invariant' (self : Type.lib_assignments_assignments) (f : Type.lib_formula_formula) = 
    UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length (Model0.model self) && UInt64.to_int (Type.lib_assignments_assignments_Assignments_1 self) <= UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)
end
module Lib_Assignments_Impl0_New_Interface
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_assignments_assignments
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result f }
    
end
module Lib_Assignments_Impl0_New
  use prelude.Prelude
  use Type
  use mach.int.Int
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant1 with function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_assignments_assignments
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result f }
    
end
module CreusotContracts_Logic_Model_Model_ModelTy
  type self   
  type modelTy   
end
module CreusotContracts_Logic_Model_Model_Model_Interface
  type self   
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Model_Model
  type self   
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl1_Model_Interface
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  function model (self : borrowed t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl1_Model
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : borrowed t) : ModelTy0.modelTy = 
    Model0.model ( * self)
end
module Lib_Logic_LogicDecision_Impl0_Invariant_Interface
  use Type
  use mach.int.Int
  predicate invariant' (self : Type.lib_decision_decisions) (n : int)
end
module Lib_Logic_LogicDecision_Impl0_Invariant
  use Type
  use mach.int.Int
  use seq.Seq
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = usize
  predicate invariant' (self : Type.lib_decision_decisions) (n : int) = 
    Seq.length (Model0.model (Type.lib_decision_decisions_Decisions_lit_order self)) = n && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_decision_decisions_Decisions_lit_order self)) -> UInt64.to_int (Seq.get (Model0.model (Type.lib_decision_decisions_Decisions_lit_order self)) i) < n)
end
module Lib_Logic_Logic_Unset_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unset (v : uint8)
end
module Lib_Logic_Logic_Unset
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  predicate unset (v : uint8) = 
    if UInt8.to_int v >= 2 then true else false
end
module Lib_Logic_LogicAssignments_Impl1_Complete_Interface
  use Type
  predicate complete (self : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicAssignments_Impl1_Complete
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate complete (self : Type.lib_assignments_assignments) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> not (Unset0.unset (Seq.get (Model0.model self) i))
end
module Lib_Logic_LogicAssignments_Impl0_ModelTy
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  type modelTy  = 
    Seq.seq uint8
end
module Lib_Assignments_Impl0_FindUnassigned_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Logic_LogicAssignments_Impl1_Complete_Interface as Complete0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicDecision_Impl0_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val find_unassigned [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (_f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Invariant0.invariant' d (Seq.length (Model0.model self))}
    requires {Invariant1.invariant' ( * self) _f}
    ensures { Invariant1.invariant' ( ^ self) _f }
    ensures { Model0.model self = Model1.model ( ^ self) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some res -> UInt64.to_int res < Seq.length (Model0.model self) && Unset0.unset (Seq.get (Model0.model self) (UInt64.to_int res))
      | Type.Core_Option_Option_None -> Complete0.complete ( * self)
      end }
    
end
module Lib_Assignments_Impl0_FindUnassigned
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use prelude.UInt8
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicAssignments_Impl1_Complete as Complete0 with function Model0.model = Model1.model,
  predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant1 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone Lib_Logic_LogicDecision_Impl0_Invariant as Invariant0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val find_unassigned [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (_f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Invariant0.invariant' d (Seq.length (Model0.model self))}
    requires {Invariant1.invariant' ( * self) _f}
    ensures { Invariant1.invariant' ( ^ self) _f }
    ensures { Model0.model self = Model1.model ( ^ self) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some res -> UInt64.to_int res < Seq.length (Model0.model self) && Unset0.unset (Seq.get (Model0.model self) (UInt64.to_int res))
      | Type.Core_Option_Option_None -> Complete0.complete ( * self)
      end }
    
end
module Lib_Clause_Impl0_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.lib_clause_clause) : Type.lib_clause_clause
    ensures { result = self }
    
end
module Lib_Clause_Impl0_Clone
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.lib_clause_clause) : Type.lib_clause_clause
    ensures { result = self }
    
end
module Lib_Clause_Impl1_ClauseFromVec_Interface
  use prelude.Prelude
  use Type
  val clause_from_vec [@cfg:stackify] (vec : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : Type.lib_clause_clause
    
end
module Lib_Clause_Impl1_ClauseFromVec
  use prelude.Prelude
  use Type
  val clause_from_vec [@cfg:stackify] (vec : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : Type.lib_clause_clause
    
end
module CreusotContracts_Logic_Model_Impl0_Model_Interface
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  function model (self : t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0_Model
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : t) : ModelTy0.modelTy = 
    Model0.model self
end
module CreusotContracts_Std1_Vec_Impl0_ModelTy
  type t   
  use seq.Seq
  type modelTy  = 
    Seq.seq t
end
module Lib_ConflictAnalysis_IdxIn_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy0.modelTy
  val idx_in [@cfg:stackify] (v : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) (idx : usize) : bool
    ensures { result = (exists i : (int) . 0 <= i && i < Seq.length (Model0.model v) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model v) i)) = UInt64.to_int idx) }
    
end
module Lib_ConflictAnalysis_IdxIn
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val idx_in [@cfg:stackify] (v : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) (idx : usize) : bool
    ensures { result = (exists i : (int) . 0 <= i && i < Seq.length (Model0.model v) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model v) i)) = UInt64.to_int idx) }
    
end
module Lib_Logic_LogicLit_Impl1_UnsatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unsat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8)
end
module Lib_Logic_LogicLit_Impl1_UnsatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  use mach.int.Int32
  predicate unsat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8) = 
    if Type.lib_lit_lit_Lit_polarity self then
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 0
    else
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 1
    
end
module Lib_Logic_LogicClause_Impl2_UnsatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unsat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl2_UnsatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate unsat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> UnsatInner0.unsat_inner (Seq.get (Model0.model self) i) a
end
module Lib_Logic_LogicClause_Impl2_VarsInRange_Interface
  use Type
  use mach.int.Int
  predicate vars_in_range (self : Type.lib_clause_clause) (n : int)
end
module Lib_Logic_LogicClause_Impl2_VarsInRange
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate vars_in_range (self : Type.lib_clause_clause) (n : int) = 
    VarsInRangeInner0.vars_in_range_inner (Model0.model self) n
end
module Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes_Interface
  use Type
  predicate no_duplicate_indexes (self : Type.lib_clause_clause)
end
module Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate no_duplicate_indexes (self : Type.lib_clause_clause) = 
    NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model0.model self)
end
module Lib_Logic_LogicClause_Impl2_InvariantUnaryOk_Interface
  use Type
  use mach.int.Int
  predicate invariant_unary_ok (self : Type.lib_clause_clause) (n : int)
end
module Lib_Logic_LogicClause_Impl2_InvariantUnaryOk
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes_Interface as NoDuplicateIndexes0
  clone Lib_Logic_LogicClause_Impl2_VarsInRange_Interface as VarsInRange0
  predicate invariant_unary_ok (self : Type.lib_clause_clause) (n : int) = 
    VarsInRange0.vars_in_range self n && NoDuplicateIndexes0.no_duplicate_indexes self
end
module Lib_Logic_LogicLit_Impl1_SatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate sat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8)
end
module Lib_Logic_LogicLit_Impl1_SatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  use mach.int.Int32
  predicate sat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8) = 
    if Type.lib_lit_lit_Lit_polarity self then
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 1
    else
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 0
    
end
module Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate post_unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl1_PostUnitInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate post_unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && SatInner0.sat_inner (Seq.get (Model0.model self) i) a && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> i -> UnsatInner0.unsat_inner (Seq.get (Model0.model self) j) a)
end
module Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept_Interface
  use Type
  use mach.int.Int
  predicate same_idx_same_polarity_except (self : Type.lib_clause_clause) (other : Type.lib_clause_clause) (exception' : int)
    
end
module Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate same_idx_same_polarity_except (self : Type.lib_clause_clause) (other : Type.lib_clause_clause) (exception' : int)
    
   = 
    forall j : (int) . forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) && 0 <= j && j < Seq.length (Model0.model other) -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model self) i)) <> exception' && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model self) i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model other) j)) -> Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model self) i) = Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model other) j)
end
module Lib_Logic_LogicLit_Impl1_IsOpp_Interface
  use Type
  predicate is_opp (self : Type.lib_lit_lit) (o : Type.lib_lit_lit)
end
module Lib_Logic_LogicLit_Impl1_IsOpp
  use Type
  use mach.int.UInt64
  predicate is_opp (self : Type.lib_lit_lit) (o : Type.lib_lit_lit) = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) = UInt64.to_int (Type.lib_lit_lit_Lit_idx o) && Type.lib_lit_lit_Lit_polarity self <> Type.lib_lit_lit_Lit_polarity o
end
module Lib_Logic_LogicClause_Impl2_InFormula_Interface
  use Type
  predicate in_formula (self : Type.lib_clause_clause) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicClause_Impl2_InFormula
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate in_formula (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) && Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i = self
end
module Lib_Logic_LogicAssignments_CompleteInner_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate complete_inner (a : Seq.seq uint8)
end
module Lib_Logic_LogicAssignments_CompleteInner
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  predicate complete_inner (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length a -> not (Unset0.unset (Seq.get a i))
end
module Lib_Logic_LogicClause_Impl2_SatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate sat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl2_SatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate sat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && SatInner0.sat_inner (Seq.get (Model0.model self) i) a
end
module Lib_Logic_LogicFormula_FormulaSatInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate formula_sat_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (a : Seq.seq uint8)
end
module Lib_Logic_LogicFormula_FormulaSatInner
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  predicate formula_sat_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> SatInner0.sat_inner (Seq.get (let (a, _) = f in a) i) a
end
module Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate eventually_sat_complete_no_ass (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicFormula_EventuallySatCompleteNoAss
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_FormulaSatInner_Interface as FormulaSatInner0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  predicate eventually_sat_complete_no_ass (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = (let (_, a) = f in a) && CompleteInner0.complete_inner a2 && FormulaSatInner0.formula_sat_inner f a2
end
module Lib_Logic_LogicClause_EquisatExtensionInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  predicate equisat_extension_inner (c : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicClause_EquisatExtensionInner
  use Type
  use seq.Seq
  use mach.int.Int
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  predicate equisat_extension_inner (c : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c, let (_, a) = f in a)
end
module Lib_Logic_LogicClause_Impl0_ModelTy
  use seq.Seq
  use Type
  type modelTy  = 
    Seq.seq (Type.lib_lit_lit)
end
module Lib_Logic_LogicFormula_Impl0_ModelTy
  use seq.Seq
  use Type
  use mach.int.Int
  type modelTy  = 
    (Seq.seq (Type.lib_clause_clause), int)
end
module Lib_Logic_LogicFormula_Impl0_Model_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  function model (self : Type.lib_formula_formula) : (Seq.seq (Type.lib_clause_clause), int)
end
module Lib_Logic_LogicFormula_Impl0_Model
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function model (self : Type.lib_formula_formula) : (Seq.seq (Type.lib_clause_clause), int) = 
    (Model0.model (Type.lib_formula_formula_Formula_clauses self), UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self))
end
module Lib_ConflictAnalysis_Resolve_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicClause_Impl2_VarsInRange_Interface as VarsInRange0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model3
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model2 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy2.modelTy
  clone Lib_Logic_LogicClause_Impl2_InFormula_Interface as InFormula0
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept_Interface as SameIdxSamePolarityExcept0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicClause_Impl2_InvariantUnaryOk_Interface as InvariantUnaryOk0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val resolve [@cfg:stackify] (_f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (o : Type.lib_clause_clause) (idx : usize) (c_idx : usize) (_a : Type.lib_assignments_assignments) : Type.lib_clause_clause
    requires {UnsatInner0.unsat_inner c (Model0.model _a)}
    requires {InvariantUnaryOk0.invariant_unary_ok o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {InvariantUnaryOk0.invariant_unary_ok c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {PostUnitInner0.post_unit_inner o (Model0.model _a)}
    requires {UInt64.to_int idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {SameIdxSamePolarityExcept0.same_idx_same_polarity_except c o (UInt64.to_int idx)}
    requires {forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length (Model1.model o) && 0 <= k && k < Seq.length (Model1.model c) && k <> UInt64.to_int c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o) j)) <> UInt64.to_int idx -> not (IsOpp0.is_opp (Seq.get (Model1.model c) k) (Seq.get (Model1.model o) j))}
    requires {UInt64.to_int c_idx < Seq.length (Model1.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c) (UInt64.to_int c_idx))) = UInt64.to_int idx && (exists k : (int) . 0 <= k && k < Seq.length (Model1.model o) && IsOpp0.is_opp (Seq.get (Model1.model o) k) (Seq.get (Model1.model c) (UInt64.to_int c_idx)))}
    requires {InFormula0.in_formula o _f}
    requires {EquisatExtensionInner0.equisat_extension_inner c (Model2.model _f)}
    requires {Invariant0.invariant' _f}
    ensures { Seq.length (Model3.model result) > 0 }
    ensures { UnsatInner0.unsat_inner result (Model0.model _a) }
    ensures { VarsInRange0.vars_in_range result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    ensures { InvariantUnaryOk0.invariant_unary_ok result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    ensures { EquisatExtensionInner0.equisat_extension_inner result (Model2.model _f) }
    
end
module Lib_ConflictAnalysis_Resolve
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model4 with function Model0.model = Model8.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model7.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant1 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicClause_Impl2_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model3.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Logic_LogicClause_Impl2_VarsInRange as VarsInRange0 with function Model0.model = Model3.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Logic_LogicClause_Impl2_InvariantUnaryOk as InvariantUnaryOk0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept as SameIdxSamePolarityExcept0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicFormula_Impl0_Model as Model6 with function Model0.model = Model5.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model2 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl2_InFormula as InFormula0 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model3.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model4.model
  val resolve [@cfg:stackify] (_f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (o : Type.lib_clause_clause) (idx : usize) (c_idx : usize) (_a : Type.lib_assignments_assignments) : Type.lib_clause_clause
    requires {UnsatInner0.unsat_inner c (Model0.model _a)}
    requires {InvariantUnaryOk0.invariant_unary_ok o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {InvariantUnaryOk0.invariant_unary_ok c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {PostUnitInner0.post_unit_inner o (Model0.model _a)}
    requires {UInt64.to_int idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {SameIdxSamePolarityExcept0.same_idx_same_polarity_except c o (UInt64.to_int idx)}
    requires {forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length (Model1.model o) && 0 <= k && k < Seq.length (Model1.model c) && k <> UInt64.to_int c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o) j)) <> UInt64.to_int idx -> not (IsOpp0.is_opp (Seq.get (Model1.model c) k) (Seq.get (Model1.model o) j))}
    requires {UInt64.to_int c_idx < Seq.length (Model1.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c) (UInt64.to_int c_idx))) = UInt64.to_int idx && (exists k : (int) . 0 <= k && k < Seq.length (Model1.model o) && IsOpp0.is_opp (Seq.get (Model1.model o) k) (Seq.get (Model1.model c) (UInt64.to_int c_idx)))}
    requires {InFormula0.in_formula o _f}
    requires {EquisatExtensionInner0.equisat_extension_inner c (Model2.model _f)}
    requires {Invariant0.invariant' _f}
    ensures { Seq.length (Model3.model result) > 0 }
    ensures { UnsatInner0.unsat_inner result (Model0.model _a) }
    ensures { VarsInRange0.vars_in_range result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    ensures { InvariantUnaryOk0.invariant_unary_ok result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    ensures { EquisatExtensionInner0.equisat_extension_inner result (Model2.model _f) }
    
end
module Lib_Logic_LogicClause_Impl2_Unsat_Interface
  use Type
  predicate unsat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl2_Unsat
  use Type
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unsat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    UnsatInner0.unsat_inner self (Model0.model a)
end
module Lib_Logic_LogicTrail_Impl0_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_trail_reason) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_Impl0_Invariant
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate invariant' (self : Type.lib_trail_reason) (f : Type.lib_formula_formula) = 
    match (self) with
      | Type.Lib_Trail_Reason_Long i -> 0 <= UInt64.to_int i && UInt64.to_int i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))
      | _ -> true
      end
end
module Lib_Logic_LogicTrail_Impl1_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_trail_step) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_Impl1_Invariant
  use Type
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_Impl0_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  predicate invariant' (self : Type.lib_trail_step) (f : Type.lib_formula_formula) = 
    Invariant0.invariant' (Type.lib_trail_step_Step_lit self) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && Invariant1.invariant' (Type.lib_trail_step_Step_reason self) f
end
module Lib_Logic_LogicTrail_CrefsInRange_Interface
  use seq.Seq
  use Type
  predicate crefs_in_range (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_CrefsInRange
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicTrail_Impl1_Invariant_Interface as Invariant0
  predicate crefs_in_range (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) = 
    forall i : (int) . 0 <= i && i < Seq.length trail -> Invariant0.invariant' (Seq.get trail i) f
end
module Lib_Logic_LogicTrail_TrailInvariant_Interface
  use seq.Seq
  use Type
  predicate trail_invariant (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_TrailInvariant
  use seq.Seq
  use Type
  use mach.int.UInt64
  use mach.int.Int
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  predicate trail_invariant (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) = 
    Seq.length trail <= UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) && CrefsInRange0.crefs_in_range trail f
end
module Lib_Logic_LogicTrail_LitToLevelInvariant_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  predicate lit_to_level_invariant (lit_to_level : Seq.seq usize) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_LitToLevelInvariant
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  predicate lit_to_level_invariant (lit_to_level : Seq.seq usize) (f : Type.lib_formula_formula) = 
    Seq.length lit_to_level = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)
end
module Lib_Logic_LogicTrail_DecisionsInvariant_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  predicate decisions_invariant (decisions : Seq.seq usize) (trail : Seq.seq (Type.lib_trail_step))
end
module Lib_Logic_LogicTrail_DecisionsInvariant
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  use mach.int.Int32
  predicate decisions_invariant (decisions : Seq.seq usize) (trail : Seq.seq (Type.lib_trail_step)) = 
    forall i : (int) . 0 <= i && i < Seq.length decisions -> UInt64.to_int (Seq.get decisions i) <= Seq.length trail
end
module Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface
  use Type
  predicate lit_idx_in (self : Type.lib_lit_lit) (c : Type.lib_clause_clause)
end
module Lib_Logic_LogicLit_Impl1_LitIdxIn
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate lit_idx_in (self : Type.lib_lit_lit) (c : Type.lib_clause_clause) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i) = Type.lib_lit_lit_Lit_idx self
end
module Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface
  use Type
  predicate lit_not_in_less (self : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_Impl2_LitNotInLess
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  predicate lit_not_in_less (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail self)) -> (forall j : (int) . 0 <= j && j < i -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail self)) j)) with
      | Type.Lib_Trail_Reason_Long cref -> not (LitIdxIn0.lit_idx_in (Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail self)) i)) (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)))
      | _ -> true
      end)
end
module Lib_Logic_LogicTrail_LitIsUniqueInner_Interface
  use seq.Seq
  use Type
  predicate lit_is_unique_inner (trail : Seq.seq (Type.lib_trail_step))
end
module Lib_Logic_LogicTrail_LitIsUniqueInner
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use mach.int.UInt64
  predicate lit_is_unique_inner (trail : Seq.seq (Type.lib_trail_step)) = 
    forall i : (int) . 0 <= i && i < Seq.length trail -> (forall j : (int) . 0 <= j && j < i -> Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get trail j)) <> Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get trail i)))
end
module Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface
  use Type
  predicate lit_is_unique (self : Type.lib_trail_trail)
end
module Lib_Logic_LogicTrail_Impl2_LitIsUnique
  use Type
  clone Lib_Logic_LogicTrail_LitIsUniqueInner_Interface as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  predicate lit_is_unique (self : Type.lib_trail_trail) = 
    LitIsUniqueInner0.lit_is_unique_inner (Model0.model (Type.lib_trail_trail_Trail_trail self))
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsToInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate clause_post_with_regards_to_inner (c : Type.lib_clause_clause) (a : Seq.seq uint8) (j : int)
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsToInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  predicate clause_post_with_regards_to_inner (c : Type.lib_clause_clause) (a : Seq.seq uint8) (j : int) = 
    PostUnitInner0.post_unit_inner c a && (exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) = j && SatInner0.sat_inner (Seq.get (Model0.model c) i) a)
end
module Lib_Logic_LogicTrail_LongArePostUnitInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate long_are_post_unit_inner (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Seq.seq uint8)
    
end
module Lib_Logic_LogicTrail_LongArePostUnitInner
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner_Interface as ClausePostWithRegardsToInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate long_are_post_unit_inner (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Seq.seq uint8)
    
   = 
    forall j : (int) . 0 <= j && j < Seq.length trail -> match (Type.lib_trail_step_Step_reason (Seq.get trail j)) with
      | Type.Lib_Trail_Reason_Long k -> ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) a (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get trail j))))
      | _ -> true
      end
end
module Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate trail_entries_are_assigned_inner (t : Seq.seq (Type.lib_trail_step)) (a : Seq.seq uint8)
end
module Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  predicate trail_entries_are_assigned_inner (t : Seq.seq (Type.lib_trail_step)) (a : Seq.seq uint8) = 
    forall j : (int) . 0 <= j && j < Seq.length t -> SatInner0.sat_inner (Type.lib_trail_step_Step_lit (Seq.get t j)) a
end
module Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned_Interface
  use Type
  predicate trail_entries_are_assigned (self : Type.lib_trail_trail)
end
module Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned
  use Type
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner_Interface as TrailEntriesAreAssignedInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  predicate trail_entries_are_assigned (self : Type.lib_trail_trail) = 
    TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner (Model0.model (Type.lib_trail_trail_Trail_trail self)) (Model1.model (Type.lib_trail_trail_Trail_assignments self))
end
module Lib_Logic_LogicTrail_Impl2_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_Impl2_Invariant
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned_Interface as TrailEntriesAreAssigned0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_DecisionsInvariant_Interface as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant_Interface as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = usize
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant0
  predicate invariant' (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    Invariant0.invariant' (Type.lib_trail_trail_Trail_assignments self) f && TrailInvariant0.trail_invariant (Model0.model (Type.lib_trail_trail_Trail_trail self)) f && LitToLevelInvariant0.lit_to_level_invariant (Model1.model (Type.lib_trail_trail_Trail_lit_to_level self)) f && DecisionsInvariant0.decisions_invariant (Model1.model (Type.lib_trail_trail_Trail_decisions self)) (Model0.model (Type.lib_trail_trail_Trail_trail self)) && LitNotInLess0.lit_not_in_less self f && LitIsUnique0.lit_is_unique self && LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail self)) f (Model2.model (Type.lib_trail_trail_Trail_assignments self)) && TrailEntriesAreAssigned0.trail_entries_are_assigned self
end
module CreusotContracts_Logic_Int_Impl11_ModelTy
  use mach.int.Int
  type modelTy  = 
    int
end
module CreusotContracts_Logic_Int_Impl11_Model_Interface
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  function model (self : usize) : int
end
module CreusotContracts_Logic_Int_Impl11_Model
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  function model (self : usize) : int = 
    UInt64.to_int self
end
module Lib_ConflictAnalysis_ChooseLiteral_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone CreusotContracts_Logic_Int_Impl11_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = usize,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val choose_literal [@cfg:stackify] (c : Type.lib_clause_clause) (trail : Type.lib_trail_trail) (i : borrowed usize) (_f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {Model1.model i <= Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail))}
    requires {Unsat0.unsat c (Type.lib_trail_trail_Trail_assignments trail)}
    requires {Invariant0.invariant' trail _f}
    ensures { UInt64.to_int ( ^ i) < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail)) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some r -> UInt64.to_int r < Seq.length (Model2.model c) && IsOpp0.is_opp (Seq.get (Model2.model c) (UInt64.to_int r)) (Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail trail)) (UInt64.to_int ( ^ i)))) && Type.lib_lit_lit_Lit_idx (Seq.get (Model2.model c) (UInt64.to_int r)) = Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail trail)) (UInt64.to_int ( ^ i))))
      | Type.Core_Option_Option_None -> true
      end }
    
end
module Lib_ConflictAnalysis_ChooseLiteral
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model6 with function Model0.model = Model9.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model6.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant4 with function Model0.model = Model8.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant2 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model6.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model8.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model4 with function Model0.model = Model7.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant1 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model4.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicLit_Impl1_IsOpp as IsOpp0
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model as Model2 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model6.model
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = usize
  clone CreusotContracts_Logic_Int_Impl11_Model as Model3
  clone CreusotContracts_Logic_Int_Impl11_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = usize,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model4.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  function Model1.model = Model8.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate Invariant0.invariant' = Invariant1.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model5.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model4.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  val choose_literal [@cfg:stackify] (c : Type.lib_clause_clause) (trail : Type.lib_trail_trail) (i : borrowed usize) (_f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {Model1.model i <= Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail))}
    requires {Unsat0.unsat c (Type.lib_trail_trail_Trail_assignments trail)}
    requires {Invariant0.invariant' trail _f}
    ensures { UInt64.to_int ( ^ i) < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail)) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some r -> UInt64.to_int r < Seq.length (Model2.model c) && IsOpp0.is_opp (Seq.get (Model2.model c) (UInt64.to_int r)) (Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail trail)) (UInt64.to_int ( ^ i)))) && Type.lib_lit_lit_Lit_idx (Seq.get (Model2.model c) (UInt64.to_int r)) = Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail trail)) (UInt64.to_int ( ^ i))))
      | Type.Core_Option_Option_None -> true
      end }
    
end
module Lib_ConflictAnalysis_AnalyzeConflict_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model5 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model4
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model3
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val analyze_conflict [@cfg:stackify] (f : Type.lib_formula_formula) (trail : Type.lib_trail_trail) (cref : usize) : Type.lib_conflictanalysis_conflict
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments trail)}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_decisions trail)) > 0}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' f}
    ensures { match (result) with
      | Type.Lib_ConflictAnalysis_Conflict_Unit lit -> 0 <= UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) && UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < Seq.length (Model3.model (Type.lib_trail_trail_Trail_assignments trail))
      | Type.Lib_ConflictAnalysis_Conflict_Learned level lit clause -> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < Seq.length (Model3.model (Type.lib_trail_trail_Trail_assignments trail)) && Seq.length (Model4.model clause) > 1 && VarsInRangeInner0.vars_in_range_inner (Model4.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model4.model clause) && EquisatExtensionInner0.equisat_extension_inner clause (Model5.model f)
      | _ -> true
      end }
    
end
module Lib_ConflictAnalysis_AnalyzeConflict
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model7.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model4.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model4.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model3 with function Model0.model = Model6.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model3.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model0.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl0_Model as Model8 with function Model0.model = Model0.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model5 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model8.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model0.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  function Model1.model = Model0.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model2.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model3.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  val analyze_conflict [@cfg:stackify] (f : Type.lib_formula_formula) (trail : Type.lib_trail_trail) (cref : usize) : Type.lib_conflictanalysis_conflict
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments trail)}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_decisions trail)) > 0}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' f}
    ensures { match (result) with
      | Type.Lib_ConflictAnalysis_Conflict_Unit lit -> 0 <= UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) && UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < Seq.length (Model3.model (Type.lib_trail_trail_Trail_assignments trail))
      | Type.Lib_ConflictAnalysis_Conflict_Learned level lit clause -> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < Seq.length (Model3.model (Type.lib_trail_trail_Trail_assignments trail)) && Seq.length (Model4.model clause) > 1 && VarsInRangeInner0.vars_in_range_inner (Model4.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model4.model clause) && EquisatExtensionInner0.equisat_extension_inner clause (Model5.model f)
      | _ -> true
      end }
    
end
module Lib_Decision_Impl0_New_Interface
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicDecision_Impl0_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_decision_decisions
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) }
    
end
module Lib_Decision_Impl0_New
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = usize
  clone Lib_Logic_LogicDecision_Impl0_Invariant as Invariant1 with function Model0.model = Model0.model
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_decision_decisions
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) }
    
end
module Lib_Decision_Impl0_GetNext_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val get_next [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (a : Type.lib_assignments_assignments) : Type.core_option_option usize
    
end
module Lib_Decision_Impl0_GetNext
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val get_next [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (a : Type.lib_assignments_assignments) : Type.core_option_option usize
    
end
module Lib_Formula_Impl0_Eq_Interface
  use prelude.Prelude
  use Type
  val eq [@cfg:stackify] (self : Type.lib_formula_satstate) (other : Type.lib_formula_satstate) : bool
end
module Lib_Formula_Impl0_Eq
  use prelude.Prelude
  use Type
  val eq [@cfg:stackify] (self : Type.lib_formula_satstate) (other : Type.lib_formula_satstate) : bool
end
module Lib_Logic_LogicClause_Impl2_Sat_Interface
  use Type
  predicate sat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl2_Sat
  use Type
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    SatInner0.sat_inner self (Model0.model a)
end
module Lib_Formula_IsClauseSat_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicClause_Impl2_Sat_Interface as Sat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val is_clause_sat [@cfg:stackify] (f : Type.lib_formula_formula) (idx : usize) (a : Type.lib_assignments_assignments) : bool
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    ensures { result = Sat0.sat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int idx)) a }
    
end
module Lib_Formula_IsClauseSat
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant0 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val is_clause_sat [@cfg:stackify] (f : Type.lib_formula_formula) (idx : usize) (a : Type.lib_assignments_assignments) : bool
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    ensures { result = Sat0.sat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int idx)) a }
    
end
module Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface
  use seq.Seq
  use Type
  predicate watcher_crefs_in_range (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicWatches_WatcherCrefsInRange
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate watcher_crefs_in_range (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) = 
    forall j : (int) . 0 <= j && j < Seq.length w -> UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get w j)) < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))
end
module Lib_Logic_LogicWatches_Impl0_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_watches_watches) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicWatches_Impl0_Invariant
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  predicate invariant' (self : Type.lib_watches_watches) (f : Type.lib_formula_formula) = 
    2 * UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches self)) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches self)) -> WatcherCrefsInRange0.watcher_crefs_in_range (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches self)) i)) f)
end
module Lib_Logic_LogicClause_Impl2_Equals_Interface
  use Type
  predicate equals (self : Type.lib_clause_clause) (o : Type.lib_clause_clause)
end
module Lib_Logic_LogicClause_Impl2_Equals
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate equals (self : Type.lib_clause_clause) (o : Type.lib_clause_clause) = 
    Seq.length (Model0.model self) = Seq.length (Model0.model o) && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) -> Seq.get (Model0.model self) j = Seq.get (Model0.model o) j)
end
module Lib_Logic_LogicFormula_Compatible_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicFormula_Compatible
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  predicate compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int)) = 
    (let (_, a) = f in a) = (let (_, a) = o in a) && Seq.length (let (a, _) = o in a) >= Seq.length (let (a, _) = f in a) && (forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Equals0.equals (Seq.get (let (a, _) = f in a) i) (Seq.get (let (a, _) = o in a) i))
end
module Lib_Logic_LogicFormula_Equisat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicFormula_Equisat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  predicate equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int)) = 
    EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass o
end
module Lib_Logic_LogicFormula_EquisatCompatibleInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate equisat_compatible_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
    
end
module Lib_Logic_LogicFormula_EquisatCompatibleInner
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicFormula_Compatible_Interface as Compatible0
  predicate equisat_compatible_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
    
   = 
    Compatible0.compatible f o && Equisat0.equisat f o
end
module Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface
  use Type
  predicate equisat_compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_EquisatCompatible
  use Type
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner_Interface as EquisatCompatibleInner0
  clone Lib_Logic_LogicFormula_Impl0_Model_Interface as Model0
  predicate equisat_compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula) = 
    EquisatCompatibleInner0.equisat_compatible_inner (Model0.model self) (Model0.model o)
end
module Lib_Formula_Impl1_AddClause_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface as EquisatCompatible0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  val add_clause [@cfg:stackify] (self : borrowed (Type.lib_formula_formula)) (clause : Type.lib_clause_clause) (watches : borrowed (Type.lib_watches_watches)) (_t : Type.lib_trail_trail) : usize
    requires {Invariant0.invariant' ( * watches) ( * self)}
    requires {EquisatExtensionInner0.equisat_extension_inner clause (Model0.model self)}
    requires {NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model1.model clause)}
    requires {VarsInRangeInner0.vars_in_range_inner (Model1.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)))}
    requires {Seq.length (Model1.model clause) >= 2}
    requires {Invariant1.invariant' _t ( * self)}
    requires {Invariant2.invariant' ( * self)}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) < div 18446744073709551615 2}
    ensures { Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) + 1 = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ self))) }
    ensures { UInt64.to_int result = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) }
    ensures { EquisatCompatible0.equisat_compatible ( * self) ( ^ self) }
    ensures { Invariant1.invariant' _t ( * self) }
    ensures { Invariant2.invariant' ( ^ self) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ self)) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ self) }
    
end
module Lib_Formula_Impl1_AddClause
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model10 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model9 with function Model0.model = Model10.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant4 with function Model0.model = Model9.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl0_Model as Model5 with function Model0.model = Model2.model
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model7.model,
  function Model1.model = Model9.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model7.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant6 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model1 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicFormula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model1.model, predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicFormula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model5.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Logic_LogicClause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant5 with function Model0.model = Model1.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model7.model,
  function Model1.model = Model2.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate Invariant0.invariant' = Invariant4.invariant',
  function Model0.model = Model7.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model8.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model9.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model0 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model3.model,
  function Model1.model = Model4.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range
  val add_clause [@cfg:stackify] (self : borrowed (Type.lib_formula_formula)) (clause : Type.lib_clause_clause) (watches : borrowed (Type.lib_watches_watches)) (_t : Type.lib_trail_trail) : usize
    requires {Invariant0.invariant' ( * watches) ( * self)}
    requires {EquisatExtensionInner0.equisat_extension_inner clause (Model0.model self)}
    requires {NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model1.model clause)}
    requires {VarsInRangeInner0.vars_in_range_inner (Model1.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)))}
    requires {Seq.length (Model1.model clause) >= 2}
    requires {Invariant1.invariant' _t ( * self)}
    requires {Invariant2.invariant' ( * self)}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) < div 18446744073709551615 2}
    ensures { Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) + 1 = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ self))) }
    ensures { UInt64.to_int result = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) }
    ensures { EquisatCompatible0.equisat_compatible ( * self) ( ^ self) }
    ensures { Invariant1.invariant' _t ( * self) }
    ensures { Invariant2.invariant' ( ^ self) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ self)) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ self) }
    
end
module Lib_Logic_LogicFormula_Impl1_SatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Logic_LogicFormula_Impl1_SatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) -> SatInner0.sat_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) a
end
module Lib_Logic_LogicFormula_Impl1_Sat_Interface
  use Type
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicFormula_Impl1_Sat
  use Type
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
  axiom sat_spec : forall self : Type.lib_formula_formula, a : Type.lib_assignments_assignments . sat self a = SatInner0.sat_inner self (Model0.model a)
end
module Lib_Formula_Impl1_IsSat_Interface
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicFormula_Impl1_Sat_Interface as Sat0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant0
  val is_sat [@cfg:stackify] (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' a self}
    requires {Invariant1.invariant' self}
    ensures { result = Sat0.sat self a }
    
end
module Lib_Formula_Impl1_IsSat
  use prelude.Prelude
  use Type
  use mach.int.Int
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner2
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model1.model
  clone Lib_Logic_LogicFormula_Impl1_Sat as Sat0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant0 with function Model0.model = Model0.model
  val is_sat [@cfg:stackify] (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' a self}
    requires {Invariant1.invariant' self}
    ensures { result = Sat0.sat self a }
    
end
module Lib_Lit_Impl3_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit
end
module Lib_Lit_Impl3_Clone
  use prelude.Prelude
  use Type
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve0 with type t = Type.lib_lit_lit
  let rec cfg clone' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit = 
  var _0 : Type.lib_lit_lit;
  var self_1 : Type.lib_lit_lit;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _0 };
    _0 <- self_1;
    assume { Resolve1.resolve self_1 };
    return _0
  }
  
end
module Lib_Logic_LogicLit_Impl1_Sat_Interface
  use Type
  predicate sat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicLit_Impl1_Sat
  use Type
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) = 
    SatInner0.sat_inner self (Model0.model a)
end
module Lib_Lit_Impl0_LitSat_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val lit_sat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Sat0.sat self a }
    
end
module Lib_Lit_Impl0_LitSat
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val lit_sat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Sat0.sat self a }
    
end
module Lib_Logic_LogicLit_Impl1_Unsat_Interface
  use Type
  predicate unsat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicLit_Impl1_Unsat
  use Type
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unsat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) = 
    UnsatInner0.unsat_inner self (Model0.model a)
end
module Lib_Lit_Impl0_LitUnsat_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val lit_unsat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unsat0.unsat self a }
    
end
module Lib_Lit_Impl0_LitUnsat
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Unsat as Unsat0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val lit_unsat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unsat0.unsat self a }
    
end
module Lib_Logic_LogicLit_Impl1_UnsetInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unset_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8)
end
module Lib_Logic_LogicLit_Impl1_UnsetInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  use mach.int.Int32
  predicate unset_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8) = 
    UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) >= 2
end
module Lib_Logic_LogicLit_Impl1_Unset_Interface
  use Type
  predicate unset (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicLit_Impl1_Unset
  use Type
  clone Lib_Logic_LogicLit_Impl1_UnsetInner_Interface as UnsetInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unset (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) = 
    UnsetInner0.unset_inner self (Model0.model a)
end
module Lib_Lit_Impl0_LitUnset_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_Unset_Interface as Unset0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val lit_unset [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unset0.unset self a }
    
end
module Lib_Lit_Impl0_LitUnset
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Logic_LogicLit_Impl1_Unset as Unset0 with function Model0.model = Model1.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val lit_unset [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unset0.unset self a }
    
end
module Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  function to_watchidx_logic (self : Type.lib_lit_lit) : int
end
module Lib_Logic_LogicLit_Impl0_ToWatchidxLogic
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  use mach.int.Int32
  function to_watchidx_logic (self : Type.lib_lit_lit) : int = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then 0 else 1)
end
module Lib_Lit_Impl0_ToWatchidx_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  val to_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      0
    else
      1
    ) }
    ensures { UInt64.to_int result = ToWatchidxLogic0.to_watchidx_logic self }
    
end
module Lib_Lit_Impl0_ToWatchidx
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  val to_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      0
    else
      1
    ) }
    ensures { UInt64.to_int result = ToWatchidxLogic0.to_watchidx_logic self }
    
end
module Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  function to_neg_watchidx_logic (self : Type.lib_lit_lit) : int
end
module Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  use mach.int.Int32
  function to_neg_watchidx_logic (self : Type.lib_lit_lit) : int = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then 1 else 0)
end
module Lib_Lit_Impl0_ToNegWatchidx_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic_Interface as ToNegWatchidxLogic0
  val to_neg_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      1
    else
      0
    ) }
    ensures { UInt64.to_int result = ToNegWatchidxLogic0.to_neg_watchidx_logic self }
    
end
module Lib_Lit_Impl0_ToNegWatchidx
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  val to_neg_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      1
    else
      0
    ) }
    ensures { UInt64.to_int result = ToNegWatchidxLogic0.to_neg_watchidx_logic self }
    
end
module Lib_Lit_Impl1_Eq_Interface
  use prelude.Prelude
  use Type
  val eq [@cfg:stackify] (self : Type.lib_lit_lit) (other : Type.lib_lit_lit) : bool
    ensures { result = (self = other) }
    
end
module Lib_Lit_Impl1_Eq
  use prelude.Prelude
  use Type
  val eq [@cfg:stackify] (self : Type.lib_lit_lit) (other : Type.lib_lit_lit) : bool
    ensures { result = (self = other) }
    
end
module Lib_Lit_Impl2_Not_Interface
  use mach.int.UInt64
  use Type
  val not' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit
    ensures { Type.lib_lit_lit_Lit_polarity result = not (Type.lib_lit_lit_Lit_polarity self) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx result) = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) }
    
end
module Lib_Lit_Impl2_Not
  use mach.int.UInt64
  use Type
  val not' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit
    ensures { Type.lib_lit_lit_Lit_polarity result = not (Type.lib_lit_lit_Lit_polarity self) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx result) = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) }
    
end
module Lib_Solver_IsClauseUnsat_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val is_clause_unsat [@cfg:stackify] (f : Type.lib_formula_formula) (idx : usize) (a : Type.lib_assignments_assignments) : bool
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    ensures { result = Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int idx)) a }
    
end
module Lib_Solver_IsClauseUnsat
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant0 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val is_clause_unsat [@cfg:stackify] (f : Type.lib_formula_formula) (idx : usize) (a : Type.lib_assignments_assignments) : bool
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    ensures { result = Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int idx)) a }
    
end
module Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unsat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Logic_LogicFormula_Impl1_UnsatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate unsat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) && UnsatInner0.unsat_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) a
end
module Lib_Logic_LogicFormula_Impl1_Unsat_Interface
  use Type
  predicate unsat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicFormula_Impl1_Unsat
  use Type
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unsat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) = 
    UnsatInner0.unsat_inner self (Model0.model a)
end
module Lib_Solver_HandleConflict_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Logic_LogicFormula_Impl1_Unsat_Interface as Unsat1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val handle_conflict [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (t : borrowed (Type.lib_trail_trail)) (cref : usize) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments ( * t))}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * w) ( * f)}
    requires {Invariant1.invariant' ( * t) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { match (result) with
      | Type.Core_Option_Option_Some (False) -> Unsat1.unsat ( ^ f) (Type.lib_trail_trail_Trail_assignments ( ^ t))
      | Type.Core_Option_Option_Some (True) -> true
      | Type.Core_Option_Option_None -> true
      end }
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail ( ^ t))) > 0 }
    ensures { Invariant0.invariant' ( ^ w) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ t) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
end
module Lib_Solver_HandleConflict
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  use prelude.UInt8
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model8 with function Model0.model = Model9.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner1 with function Model0.model = Model8.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Logic_LogicFormula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicClause_Impl2_Equals as Equals0 with function Model0.model = Model8.model
  clone Lib_Logic_LogicFormula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model8.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model8.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model8.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model8.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model8.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model2 with function Model0.model = Model7.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_Unsat as Unsat0 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model2.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model0.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl0_Model as Model6 with function Model0.model = Model0.model
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model6.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner as UnsatInner1 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicFormula_Impl1_Unsat as Unsat1 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model0.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  function Model1.model = Model0.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model5.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model2.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model3.model,
  function Model1.model = Model4.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range
  val handle_conflict [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (t : borrowed (Type.lib_trail_trail)) (cref : usize) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref)) (Type.lib_trail_trail_Trail_assignments ( * t))}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * w) ( * f)}
    requires {Invariant1.invariant' ( * t) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { match (result) with
      | Type.Core_Option_Option_Some (False) -> Unsat1.unsat ( ^ f) (Type.lib_trail_trail_Trail_assignments ( ^ t))
      | Type.Core_Option_Option_Some (True) -> true
      | Type.Core_Option_Option_None -> true
      end }
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail ( ^ t))) > 0 }
    ensures { Invariant0.invariant' ( ^ w) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ t) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
end
module Lib_Solver_UnitPropStep_Interface
  use prelude.Prelude
  use Type
  val unit_prop_step [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.lib_solver_conflictresult
    
end
module Lib_Solver_UnitPropStep
  use prelude.Prelude
  use Type
  val unit_prop_step [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.lib_solver_conflictresult
    
end
module Lib_Solver_UnitPropLoop_Interface
  use prelude.Prelude
  use Type
  val unit_prop_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    
end
module Lib_Solver_UnitPropLoop
  use prelude.Prelude
  use Type
  val unit_prop_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    
end
module Lib_Solver_OuterLoop_Interface
  use prelude.Prelude
  use Type
  val outer_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.lib_solver_satresult
    
end
module Lib_Solver_OuterLoop
  use prelude.Prelude
  use Type
  val outer_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.lib_solver_satresult
    
end
module Lib_Solver_Inner_Interface
  use prelude.Prelude
  use Type
  val inner [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.lib_solver_satresult
    
end
module Lib_Solver_Inner
  use prelude.Prelude
  use Type
  val inner [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.lib_solver_satresult
    
end
module Lib_Solver_Solver_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val solver [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (units : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : Type.lib_solver_satresult
    requires {Invariant0.invariant' ( * f)}
    requires {forall i : (int) . 0 <= i && i < Seq.length (Model0.model units) -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model units) i)) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    
end
module Lib_Solver_Solver
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant2
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant1 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val solver [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (units : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : Type.lib_solver_satresult
    requires {Invariant0.invariant' ( * f)}
    requires {forall i : (int) . 0 <= i && i < Seq.length (Model0.model units) -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model units) i)) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    
end
module Lib_Trail_Impl0_DecisionLevel_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = usize
  val decision_level [@cfg:stackify] (self : Type.lib_trail_trail) : usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_decisions self)) > 0}
    ensures { UInt64.to_int result = Seq.length (Model0.model (Type.lib_trail_trail_Trail_decisions self)) - 1 }
    
end
module Lib_Trail_Impl0_DecisionLevel
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = usize
  val decision_level [@cfg:stackify] (self : Type.lib_trail_trail) : usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_decisions self)) > 0}
    ensures { UInt64.to_int result = Seq.length (Model0.model (Type.lib_trail_trail_Trail_decisions self)) - 1 }
    
end
module Lib_Trail_Impl0_New_Interface
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant0
  val new [@cfg:stackify] (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : Type.lib_trail_trail
    requires {Invariant0.invariant' a f}
    ensures { Invariant1.invariant' result f }
    
end
module Lib_Trail_Impl0_New
  use prelude.Prelude
  use Type
  use mach.int.Int
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model6.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model5.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant4 with function Model0.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant2 with predicate Invariant0.invariant' = Invariant3.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model4.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model3.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model0.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  function Model1.model = Model4.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate Invariant0.invariant' = Invariant0.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model2.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model0.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  val new [@cfg:stackify] (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : Type.lib_trail_trail
    requires {Invariant0.invariant' a f}
    ensures { Invariant1.invariant' result f }
    
end
module Lib_Trail_Impl0_Backstep_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val backstep [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) > 0}
    requires {Invariant0.invariant' ( * self) f}
    requires {Invariant1.invariant' f}
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) + 1 }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) f }
    
end
module Lib_Trail_Impl0_Backstep
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use mach.int.UInt64
  use prelude.UInt8
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant5
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant3 with function Model0.model = Model5.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model5.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model3.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant4 with predicate Invariant0.invariant' = Invariant5.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model3.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant2 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  function Model1.model = Model3.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model4.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  val backstep [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) > 0}
    requires {Invariant0.invariant' ( * self) f}
    requires {Invariant1.invariant' f}
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) + 1 }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) f }
    
end
module Lib_Trail_Impl0_BacktrackTo_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = usize
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val backtrack_to [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (level : usize) (f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) > 0}
    requires {Invariant0.invariant' ( * self) f}
    requires {Invariant1.invariant' f}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_decisions ( * self))) > UInt64.to_int level}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) f }
    
end
module Lib_Trail_Impl0_BacktrackTo
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant5
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model6.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant3 with function Model0.model = Model5.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model5.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant4 with predicate Invariant0.invariant' = Invariant5.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model4.model,
  predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model4.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant2 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  function Model1.model = Model4.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate Invariant0.invariant' = Invariant2.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model2.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  val backtrack_to [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (level : usize) (f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) > 0}
    requires {Invariant0.invariant' ( * self) f}
    requires {Invariant1.invariant' f}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_decisions ( * self))) > UInt64.to_int level}
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) f }
    
end
module Lib_Logic_LogicLit_Impl1_IdxInTrail_Interface
  use Type
  predicate idx_in_trail (self : Type.lib_lit_lit) (t : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step))
end
module Lib_Logic_LogicLit_Impl1_IdxInTrail
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  predicate idx_in_trail (self : Type.lib_lit_lit) (t : Type.creusotcontracts_std1_vec_vec (Type.lib_trail_step)) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model t) && Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get (Model0.model t) i)) = Type.lib_lit_lit_Lit_idx self
end
module Lib_Logic_LogicClause_Impl1_PostUnit_Interface
  use Type
  predicate post_unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl1_PostUnit
  use Type
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate post_unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    PostUnitInner0.post_unit_inner self (Model0.model a)
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsToLit_Interface
  use Type
  predicate clause_post_with_regards_to_lit (c : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit)
    
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsToLit
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  predicate clause_post_with_regards_to_lit (c : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit)
    
   = 
    PostUnit0.post_unit c a && (exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model c) i) = Type.lib_lit_lit_Lit_polarity lit && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) && Sat0.sat (Seq.get (Model0.model c) i) a)
end
module Lib_Trail_Impl0_EnqAssignment_Interface
  use mach.int.UInt64
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToLit_Interface as ClausePostWithRegardsToLit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_IdxInTrail_Interface as IdxInTrail0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val enq_assignment [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (step : Type.lib_trail_step) (_f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step))))}
    requires {not (IdxInTrail0.idx_in_trail (Type.lib_trail_step_Step_lit step) (Type.lib_trail_trail_Trail_trail ( * self)))}
    requires {Invariant0.invariant' (Type.lib_trail_step_Step_lit step) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant1.invariant' step _f}
    requires {match (Type.lib_trail_step_Step_reason step) with
      | Type.Lib_Trail_Reason_Long k -> 0 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses _f)) && ClausePostWithRegardsToLit0.clause_post_with_regards_to_lit (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k)) (Type.lib_trail_trail_Trail_assignments ( * self)) (Type.lib_trail_step_Step_lit step)
      | _ -> true
      end}
    requires {Invariant2.invariant' ( * self) _f}
    requires {Invariant0.invariant' (Type.lib_trail_step_Step_lit step) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {Invariant3.invariant' _f}
    ensures { Invariant2.invariant' ( ^ self) _f }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Sat0.sat (Type.lib_trail_step_Step_lit step) (Type.lib_trail_trail_Trail_assignments ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)) -> Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) j = Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) j }
    
end
module Lib_Trail_Impl0_EnqAssignment
  use mach.int.UInt64
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model4 with function Model0.model = Model6.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model4.model
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model4.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = usize
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant6 with function Model0.model = Model4.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant4 with function Model0.model = Model2.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant1 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant5 with function Model0.model = Model1.model
  clone Lib_Logic_LogicClause_Impl1_PostUnit as PostUnit0 with function Model0.model = Model1.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToLit as ClausePostWithRegardsToLit0 with predicate PostUnit0.post_unit = PostUnit0.post_unit,
  function Model0.model = Model4.model, predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant2 with predicate Invariant0.invariant' = Invariant5.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model5.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  clone Lib_Logic_LogicLit_Impl1_IdxInTrail as IdxInTrail0 with function Model0.model = Model0.model
  val enq_assignment [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (step : Type.lib_trail_step) (_f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step))))}
    requires {not (IdxInTrail0.idx_in_trail (Type.lib_trail_step_Step_lit step) (Type.lib_trail_trail_Trail_trail ( * self)))}
    requires {Invariant0.invariant' (Type.lib_trail_step_Step_lit step) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant1.invariant' step _f}
    requires {match (Type.lib_trail_step_Step_reason step) with
      | Type.Lib_Trail_Reason_Long k -> 0 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses _f)) && ClausePostWithRegardsToLit0.clause_post_with_regards_to_lit (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k)) (Type.lib_trail_trail_Trail_assignments ( * self)) (Type.lib_trail_step_Step_lit step)
      | _ -> true
      end}
    requires {Invariant2.invariant' ( * self) _f}
    requires {Invariant0.invariant' (Type.lib_trail_step_Step_lit step) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {Invariant3.invariant' _f}
    ensures { Invariant2.invariant' ( ^ self) _f }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Sat0.sat (Type.lib_trail_step_Step_lit step) (Type.lib_trail_trail_Trail_assignments ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit step)) -> Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) j = Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) j }
    
end
module Lib_Trail_Impl0_EnqAssignment2_Interface
  use prelude.Prelude
  use Type
  val enq_assignment2 [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (step : Type.lib_trail_step) (_f : Type.lib_formula_formula) : ()
    
end
module Lib_Trail_Impl0_EnqAssignment2
  use prelude.Prelude
  use Type
  val enq_assignment2 [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (step : Type.lib_trail_step) (_f : Type.lib_formula_formula) : ()
    
end
module Lib_Trail_Impl0_EnqDecision_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = usize
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_IdxInTrail_Interface as IdxInTrail0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val enq_decision [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)))}
    requires {not (IdxInTrail0.idx_in_trail lit (Type.lib_trail_trail_Trail_trail ( * self)))}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant1.invariant' ( * self) _f}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {Invariant2.invariant' _f}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_decisions ( * self))) > 0}
    ensures { Invariant1.invariant' ( ^ self) _f }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Sat0.sat lit (Type.lib_trail_trail_Trail_assignments ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) j = Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) j }
    
end
module Lib_Trail_Impl0_EnqDecision
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model6.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model5.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model5.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model4.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model4.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model1.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  function Model1.model = Model4.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model2.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  clone Lib_Logic_LogicLit_Impl1_IdxInTrail as IdxInTrail0 with function Model0.model = Model0.model
  val enq_decision [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)))}
    requires {not (IdxInTrail0.idx_in_trail lit (Type.lib_trail_trail_Trail_trail ( * self)))}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant1.invariant' ( * self) _f}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {Invariant2.invariant' _f}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_decisions ( * self))) > 0}
    ensures { Invariant1.invariant' ( ^ self) _f }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Sat0.sat lit (Type.lib_trail_trail_Trail_assignments ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) j = Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) j }
    
end
module Lib_Trail_Impl0_LearnUnit_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = usize
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_IdxInTrail_Interface as IdxInTrail0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  val learn_unit [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)))}
    requires {not (IdxInTrail0.idx_in_trail lit (Type.lib_trail_trail_Trail_trail ( * self)))}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant1.invariant' ( * self) _f}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {Invariant2.invariant' _f}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_decisions ( * self))) = 1}
    ensures { Invariant1.invariant' ( ^ self) _f }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Sat0.sat lit (Type.lib_trail_trail_Trail_assignments ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) j = Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) j }
    
end
module Lib_Trail_Impl0_LearnUnit
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model5 with function Model0.model = Model6.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model5.model
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model5.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant0
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model5.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant6 with function Model0.model = Model4.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant0.invariant',
  predicate Invariant1.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model4.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model4.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model1.model
  clone Lib_Logic_LogicLit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model0.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model0.model,
  function Model1.model = Model4.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model0.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model2.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model1.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  clone Lib_Logic_LogicLit_Impl1_IdxInTrail as IdxInTrail0 with function Model0.model = Model0.model
  val learn_unit [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self)))}
    requires {Unset0.unset (Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)))}
    requires {not (IdxInTrail0.idx_in_trail lit (Type.lib_trail_trail_Trail_trail ( * self)))}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant1.invariant' ( * self) _f}
    requires {Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {Invariant2.invariant' _f}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_decisions ( * self))) = 1}
    ensures { Invariant1.invariant' ( ^ self) _f }
    ensures { LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) _f (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) }
    ensures { Sat0.sat lit (Type.lib_trail_trail_Trail_assignments ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( * self))) j = Seq.get (Model1.model (Type.lib_trail_trail_Trail_assignments ( ^ self))) j }
    
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface
  use Type
  predicate eventually_sat_complete_no_ass (self : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  predicate eventually_sat_complete_no_ass (self : Type.lib_formula_formula) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) && CompleteInner0.complete_inner a2 && SatInner0.sat_inner self a2
end
module Lib_Logic_LogicFormula_Impl1_Equisat_Interface
  use Type
  predicate equisat (self : Type.lib_formula_formula) (o : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_Equisat
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  predicate equisat (self : Type.lib_formula_formula) (o : Type.lib_formula_formula) = 
    EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass self = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass o
end
module Lib_UnitProp_UnitPropCheckRest_Interface
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicLit_Impl1_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model4 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model3
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  val unit_prop_check_rest [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (j : usize) (k : usize) (lit : Type.lib_lit_lit) : Type.core_result_result () ()
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) > UInt64.to_int j}
    requires {Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > 2}
    requires {2 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref)))}
    requires {UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Seq.length (Model4.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' trail ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { match (result) with
      | Type.Core_Result_Result_Ok _ -> true
      | Type.Core_Result_Result_Err _ -> Unsat0.unsat (Seq.get (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int cref))) (UInt64.to_int k)) (Type.lib_trail_trail_Trail_assignments trail) &&  ^ f =  * f &&  * watches =  ^ watches
      end }
    ensures { Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) }
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' trail ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
end
module Lib_UnitProp_UnitPropCheckRest
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model7 with function Model0.model = Model8.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model7.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Unsat as Unsat0 with function Model0.model = Model7.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model4.model,
  function Model1.model = Model7.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model4.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model5.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner2 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model3.model, predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model2.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model4.model,
  function Model1.model = Model2.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant1 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model4.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model6.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model7.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range
  val unit_prop_check_rest [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (j : usize) (k : usize) (lit : Type.lib_lit_lit) : Type.core_result_result () ()
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) > UInt64.to_int j}
    requires {Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > 2}
    requires {2 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref)))}
    requires {UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Seq.length (Model4.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' trail ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { match (result) with
      | Type.Core_Result_Result_Ok _ -> true
      | Type.Core_Result_Result_Err _ -> Unsat0.unsat (Seq.get (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int cref))) (UInt64.to_int k)) (Type.lib_trail_trail_Trail_assignments trail) &&  ^ f =  * f &&  * watches =  ^ watches
      end }
    ensures { Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * f))) = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) }
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' trail ( ^ f) }
    ensures { Invariant2.invariant' ( ^ f) }
    
end
module Lib_UnitProp_Swap_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model4 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_trail_step
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val swap [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (lit : Type.lib_lit_lit) (j : usize) (k : usize) (n : usize) : ()
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Seq.length (Model2.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > UInt64.to_int n}
    requires {Seq.length (Model2.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > UInt64.to_int k}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' ( * f)}
    requires {Invariant2.invariant' trail ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Seq.length (Model4.model (Seq.get (Model3.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) = Seq.length (Model4.model (Seq.get (Model3.model (Type.lib_watches_watches_Watches_watches ( ^ watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ f) }
    ensures { Invariant2.invariant' trail ( ^ f) }
    
end
module Lib_UnitProp_Swap
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model7 with function Model0.model = Model8.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model7.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model2 with function Model0.model = Model5.model
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner2 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model2.model, predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model2.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model7.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model0.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model0.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  function Model1.model = Model0.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant2 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model6.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model7.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model3.model,
  function Model1.model = Model4.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range
  val swap [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (lit : Type.lib_lit_lit) (j : usize) (k : usize) (n : usize) : ()
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Seq.length (Model2.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > UInt64.to_int n}
    requires {Seq.length (Model2.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref))) > UInt64.to_int k}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' ( * f)}
    requires {Invariant2.invariant' trail ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Seq.length (Model4.model (Seq.get (Model3.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) = Seq.length (Model4.model (Seq.get (Model3.model (Type.lib_watches_watches_Watches_watches ( ^ watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ f) }
    ensures { Invariant2.invariant' trail ( ^ f) }
    
end
module Lib_UnitProp_SwapZeroOne_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model3 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicFormula_Impl1_Equisat_Interface as Equisat0
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_trail_step
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val swap_zero_one [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (lit : Type.lib_lit_lit) (j : usize) : ()
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' ( * f)}
    requires {Invariant2.invariant' trail ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) = Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_watches_watches_Watches_watches ( ^ watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ f) }
    ensures { Invariant2.invariant' trail ( ^ f) }
    
end
module Lib_UnitProp_SwapZeroOne
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model7 with function Model0.model = Model8.model
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model7.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model7.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_Logic_Unset as Unset0
  clone Lib_Logic_LogicAssignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner1
  clone Lib_Logic_LogicClause_Impl2_SatInner as SatInner2 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model7.model, predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model5 with function Model0.model = Model6.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model5.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model1.model,
  function Model1.model = Model5.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model1.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model0.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicFormula_Impl1_SatInner as SatInner0 with function Model0.model = Model0.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicFormula_Impl1_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model0.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model1.model,
  function Model1.model = Model0.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant2 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model1.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model4.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model5.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model0.model
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range
  val swap_zero_one [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (lit : Type.lib_lit_lit) (j : usize) : ()
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f))}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * watches) ( * f)}
    requires {Invariant1.invariant' ( * f)}
    requires {Invariant2.invariant' trail ( * f)}
    ensures { Equisat0.equisat ( * f) ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) = Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_watches_watches_Watches_watches ( ^ watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) }
    ensures { Invariant0.invariant' ( ^ watches) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ f) }
    ensures { Invariant2.invariant' trail ( ^ f) }
    
end
module Lib_UnitProp_UnitPropDoOuter_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val unit_prop_do_outer [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (lit : Type.lib_lit_lit) (j : usize) : Type.core_result_result bool usize
    
end
module Lib_UnitProp_UnitPropDoOuter
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val unit_prop_do_outer [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (lit : Type.lib_lit_lit) (j : usize) : Type.core_result_result bool usize
    
end
module Lib_UnitProp_UnitPropCurrentLevel_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val unit_prop_current_level [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (lit : Type.lib_lit_lit) : Type.core_result_result () usize
    
end
module Lib_UnitProp_UnitPropCurrentLevel
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val unit_prop_current_level [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (lit : Type.lib_lit_lit) : Type.core_result_result () usize
    
end
module Lib_UnitProp_UnitPropagate_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val unit_propagate [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) : Type.core_result_result () usize
    
end
module Lib_UnitProp_UnitPropagate
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val unit_propagate [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) : Type.core_result_result () usize
    
end
module CreusotContracts_Logic_Seq_Impl1_PermutationOf_Interface
  type t   
  use seq.Seq
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t)
end
module CreusotContracts_Logic_Seq_Impl1_PermutationOf
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t) = 
    Permut.permut self o 0 (Seq.length self)
end
module Lib_Logic_LogicUtil_SortedRangeRev_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_range_rev (s : Seq.seq (usize, usize)) (l : int) (u : int)
end
module Lib_Logic_LogicUtil_SortedRangeRev
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_range_rev (s : Seq.seq (usize, usize)) (l : int) (u : int) = 
    forall j : (int) . forall i : (int) . l <= i && i < j && j < u -> (let (a, _) = Seq.get s i in a) >= (let (a, _) = Seq.get s j in a)
end
module Lib_Logic_LogicUtil_SortedRev_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_rev (s : Seq.seq (usize, usize))
end
module Lib_Logic_LogicUtil_SortedRev
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use mach.int.Int32
  clone Lib_Logic_LogicUtil_SortedRangeRev_Interface as SortedRangeRev0
  predicate sorted_rev (s : Seq.seq (usize, usize)) = 
    SortedRangeRev0.sorted_range_rev s 0 (Seq.length s)
end
module Lib_Util_SortReverse_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone Lib_Logic_LogicUtil_SortedRev_Interface as SortedRev0
  clone CreusotContracts_Logic_Seq_Impl1_PermutationOf_Interface as PermutationOf0 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = (usize, usize)
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize),
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = (usize, usize)
  val sort_reverse [@cfg:stackify] (v : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize))) : ()
    ensures { PermutationOf0.permutation_of (Model0.model ( ^ v)) (Model1.model v) }
    ensures { SortedRev0.sorted_rev (Model0.model ( ^ v)) }
    
end
module Lib_Util_SortReverse
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone Lib_Logic_LogicUtil_SortedRangeRev as SortedRangeRev0
  clone Lib_Logic_LogicUtil_SortedRev as SortedRev0 with predicate SortedRangeRev0.sorted_range_rev = SortedRangeRev0.sorted_range_rev
  clone CreusotContracts_Logic_Seq_Impl1_PermutationOf as PermutationOf0 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = (usize, usize)
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  val sort_reverse [@cfg:stackify] (v : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize))) : ()
    ensures { PermutationOf0.permutation_of (Model0.model ( ^ v)) (Model1.model v) }
    ensures { SortedRev0.sorted_rev (Model0.model ( ^ v)) }
    
end
module Lib_Watches_UpdateWatch_Interface
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model4 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model3
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  val update_watch [@cfg:stackify] (f : Type.lib_formula_formula) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (j : usize) (k : usize) (lit : Type.lib_lit_lit) : ()
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) > UInt64.to_int j}
    requires {Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) >= 2}
    requires {0 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)))}
    requires {UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Seq.length (Model4.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' f}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) < div 18446744073709551615 2}
    requires {Invariant2.invariant' ( * watches) f}
    ensures { Invariant2.invariant' ( ^ watches) f }
    
end
module Lib_Watches_UpdateWatch
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant6
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant6.invariant'
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone Lib_Logic_LogicLit_Impl1_SatInner as SatInner0
  clone Lib_Logic_LogicTrail_TrailEntriesAreAssignedInner as TrailEntriesAreAssignedInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model7 with function Model0.model = Model8.model
  clone Lib_Logic_LogicAssignments_Impl1_Invariant as Invariant3 with function Model0.model = Model7.model
  clone Lib_Logic_LogicTrail_LitIsUniqueInner as LitIsUniqueInner0
  clone Lib_Logic_LogicTrail_DecisionsInvariant as DecisionsInvariant0
  clone Lib_Logic_LogicTrail_LitToLevelInvariant as LitToLevelInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = usize
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicTrail_Impl2_TrailEntriesAreAssigned as TrailEntriesAreAssigned0 with function Model0.model = Model4.model,
  function Model1.model = Model7.model,
  predicate TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner = TrailEntriesAreAssignedInner0.trail_entries_are_assigned_inner
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique as LitIsUnique0 with function Model0.model = Model4.model,
  predicate LitIsUniqueInner0.lit_is_unique_inner = LitIsUniqueInner0.lit_is_unique_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model5.model
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner as ClausePostWithRegardsToInner0 with predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner,
  function Model0.model = Model3.model, predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant4 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn as LitIdxIn0 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl0_Invariant as Invariant7 with function Model0.model = Model2.model
  clone Lib_Logic_LogicTrail_Impl1_Invariant as Invariant5 with predicate Invariant0.invariant' = Invariant6.invariant',
  predicate Invariant1.invariant' = Invariant7.invariant'
  clone Lib_Logic_LogicTrail_CrefsInRange as CrefsInRange0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Logic_LogicTrail_TrailInvariant as TrailInvariant0 with predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_LongArePostUnitInner as LongArePostUnitInner0 with function Model0.model = Model2.model,
  predicate ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner = ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess as LitNotInLess0 with function Model0.model = Model4.model,
  function Model1.model = Model2.model, predicate LitIdxIn0.lit_idx_in = LitIdxIn0.lit_idx_in
  clone Lib_Logic_LogicTrail_Impl2_Invariant as Invariant0 with predicate Invariant0.invariant' = Invariant3.invariant',
  function Model0.model = Model4.model, predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  function Model1.model = Model6.model,
  predicate LitToLevelInvariant0.lit_to_level_invariant = LitToLevelInvariant0.lit_to_level_invariant,
  predicate DecisionsInvariant0.decisions_invariant = DecisionsInvariant0.decisions_invariant,
  predicate LitNotInLess0.lit_not_in_less = LitNotInLess0.lit_not_in_less,
  predicate LitIsUnique0.lit_is_unique = LitIsUnique0.lit_is_unique, function Model2.model = Model7.model,
  predicate LongArePostUnitInner0.long_are_post_unit_inner = LongArePostUnitInner0.long_are_post_unit_inner,
  predicate TrailEntriesAreAssigned0.trail_entries_are_assigned = TrailEntriesAreAssigned0.trail_entries_are_assigned
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Logic_LogicLit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant2 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range
  val update_watch [@cfg:stackify] (f : Type.lib_formula_formula) (trail : Type.lib_trail_trail) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (j : usize) (k : usize) (lit : Type.lib_lit_lit) : ()
    requires {Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * watches))) (ToWatchidxLogic0.to_watchidx_logic lit))) > UInt64.to_int j}
    requires {Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref))) >= 2}
    requires {0 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model3.model (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)))}
    requires {UInt64.to_int cref < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Seq.length (Model4.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' f}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) < div 18446744073709551615 2}
    requires {Invariant2.invariant' ( * watches) f}
    ensures { Invariant2.invariant' ( ^ watches) f }
    
end
module Lib_Watches_Impl0_New_Interface
  use prelude.Prelude
  use Type
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_watches_watches
    ensures { Invariant0.invariant' result f }
    
end
module Lib_Watches_Impl0_New
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_watches_watches
    ensures { Invariant0.invariant' result f }
    
end
module Lib_Watches_Impl0_AddWatcher_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic_Interface as ToNegWatchidxLogic0
  val add_watcher [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (lit : Type.lib_lit_lit) (cref : usize) (_f : Type.lib_formula_formula) : ()
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < div 18446744073709551615 2}
    requires {UInt64.to_int cref < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses _f))}
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) = Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl0_AddWatcher
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  val add_watcher [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (lit : Type.lib_lit_lit) (cref : usize) (_f : Type.lib_formula_formula) : ()
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < div 18446744073709551615 2}
    requires {UInt64.to_int cref < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses _f))}
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) = Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl0_MoveToEnd_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic_Interface as ToNegWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  val move_to_end [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (old_idx : usize) (old_pos : usize) (new_lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {UInt64.to_int old_pos < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx)))}
    requires {UInt64.to_int old_idx < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic new_lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx new_lit) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( ^ self))) (UInt64.to_int old_idx))) = Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl0_MoveToEnd
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicLit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range
  val move_to_end [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (old_idx : usize) (old_pos : usize) (new_lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {UInt64.to_int old_pos < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx)))}
    requires {UInt64.to_int old_idx < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic new_lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx new_lit) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( ^ self))) (UInt64.to_int old_idx))) = Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl0_InitWatches_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicWatches_Impl0_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val init_watches [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (f : Type.lib_formula_formula) : ()
    requires {Invariant0.invariant' f}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) < div 18446744073709551615 2}
    requires {Invariant1.invariant' ( * self) f}
    ensures { Invariant1.invariant' ( ^ self) f }
    
end
module Lib_Watches_Impl0_InitWatches
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicLit_Impl1_Invariant as Invariant3
  clone Lib_Logic_LogicClause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Logic_LogicClause_AtLeastBinary as AtLeastBinary0
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_InvariantInternal as InvariantInternal0 with predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner,
  predicate AtLeastBinary0.at_least_binary = AtLeastBinary0.at_least_binary
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Logic_LogicClause_Impl2_Invariant as Invariant2 with function Model0.model = Model3.model,
  predicate InvariantInternal0.invariant_internal = InvariantInternal0.invariant_internal
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange as WatcherCrefsInRange0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Logic_LogicFormula_Impl1_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Logic_LogicWatches_Impl0_Invariant as Invariant1 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate WatcherCrefsInRange0.watcher_crefs_in_range = WatcherCrefsInRange0.watcher_crefs_in_range
  val init_watches [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (f : Type.lib_formula_formula) : ()
    requires {Invariant0.invariant' f}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) < div 18446744073709551615 2}
    requires {Invariant1.invariant' ( * self) f}
    ensures { Invariant1.invariant' ( ^ self) f }
    
end
module Lib_Logic_LogicAssignments_AssignmentsEquality_Interface
  use Type
  predicate assignments_equality (a : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicAssignments_AssignmentsEquality
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate assignments_equality (a : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments) = 
    Seq.length (Model0.model a) = Seq.length (Model0.model a2) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model a) -> Seq.get (Model0.model a) i = Seq.get (Model0.model a2) i)
end
module Lib_Logic_LogicAssignments_CompatibleInner_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate compatible_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Lib_Logic_LogicAssignments_CompatibleInner
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  predicate compatible_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8) = 
    Seq.length a = Seq.length a2 && (forall i : (int) . 0 <= i && i < Seq.length a -> Unset0.unset (Seq.get a i) || Seq.get a i = Seq.get a2 i)
end
module Lib_Logic_LogicAssignments_CompatibleCompleteInner_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate compatible_complete_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Lib_Logic_LogicAssignments_CompatibleCompleteInner
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Logic_LogicAssignments_CompatibleInner_Interface as CompatibleInner0
  predicate compatible_complete_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8) = 
    CompatibleInner0.compatible_inner a a2 && CompleteInner0.complete_inner a2
end
module Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  predicate assignments_invariant (a : Seq.seq uint8) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicAssignments_AssignmentsInvariant
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  use mach.int.UInt64
  predicate assignments_invariant (a : Seq.seq uint8) (f : Type.lib_formula_formula) = 
    UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a
end
module Lib_Logic_LogicAssignments_Impl1_Compatible_Interface
  use Type
  predicate compatible (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicAssignments_Impl1_Compatible
  use Type
  clone Lib_Logic_LogicAssignments_CompatibleInner_Interface as CompatibleInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate compatible (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments) = 
    CompatibleInner0.compatible_inner (Model0.model self) (Model0.model a2)
end
module Lib_Logic_LogicAssignments_Impl1_CompatibleComplete_Interface
  use Type
  predicate compatible_complete (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicAssignments_Impl1_CompatibleComplete
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Complete_Interface as Complete0
  clone Lib_Logic_LogicAssignments_Impl1_Compatible_Interface as Compatible0
  predicate compatible_complete (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments) = 
    Compatible0.compatible self a2 && Complete0.complete a2
end
module Lib_Logic_LogicClause_InvariantUnaryOkInternal_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate invariant_unary_ok_internal (s : Seq.seq (Type.lib_lit_lit)) (n : int)
end
module Lib_Logic_LogicClause_InvariantUnaryOkInternal
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_VarsInRangeInner_Interface as VarsInRangeInner0
  predicate invariant_unary_ok_internal (s : Seq.seq (Type.lib_lit_lit)) (n : int) = 
    VarsInRangeInner0.vars_in_range_inner s n && NoDuplicateIndexesInner0.no_duplicate_indexes_inner s
end
module Lib_Logic_LogicClause_Impl1_UnitInner2_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unit_inner2 (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl1_UnitInner2
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicLit_Impl1_UnsetInner_Interface as UnsetInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate unit_inner2 (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && UnsetInner0.unset_inner (Seq.get (Model0.model self) i) a && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> i -> UnsatInner0.unsat_inner (Seq.get (Model0.model self) j) a)
end
module Lib_Logic_LogicClause_Impl1_Unit2_Interface
  use Type
  predicate unit2 (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl1_Unit2
  use Type
  clone Lib_Logic_LogicClause_Impl1_UnitInner2_Interface as UnitInner20
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unit2 (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    UnitInner20.unit_inner2 self (Model0.model a)
end
module Lib_Logic_LogicClause_Impl1_NoUnsetInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate no_unset_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl1_NoUnsetInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_UnsetInner_Interface as UnsetInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate no_unset_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) -> not (UnsetInner0.unset_inner (Seq.get (Model0.model self) j) a)
end
module Lib_Logic_LogicClause_Impl1_EqAssnInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate eq_assn_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl1_EqAssnInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate eq_assn_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) (a2 : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model self) i))) = Seq.get a2 (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model self) i)))
end
module Lib_Logic_LogicClause_Impl2_EquisatExtension_Interface
  use Type
  predicate equisat_extension (self : Type.lib_clause_clause) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicClause_Impl2_EquisatExtension
  use Type
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_Impl0_Model_Interface as Model0
  predicate equisat_extension (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) = 
    EquisatExtensionInner0.equisat_extension_inner self (Model0.model f)
end
module Lib_Logic_LogicClause_Impl2_EquisatExtensionDouble_Interface
  use Type
  predicate equisat_extension_double (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula)
    
end
module Lib_Logic_LogicClause_Impl2_EquisatExtensionDouble
  use Type
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  predicate equisat_extension_double (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula)
    
   = 
    Invariant0.invariant' f && Invariant0.invariant' f2 && UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) && Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) + 1 = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> Equals0.equals (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) i)) && Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) - 1)) = Model1.model self && EquisatCompatible0.equisat_compatible f f2
end
module Lib_Logic_LogicLit_Impl1_LitIn_Interface
  use Type
  predicate lit_in (self : Type.lib_lit_lit) (c : Type.lib_clause_clause)
end
module Lib_Logic_LogicLit_Impl1_LitIn
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate lit_in (self : Type.lib_lit_lit) (c : Type.lib_clause_clause) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && Seq.get (Model0.model c) i = self
end
module Lib_Logic_LogicClause_Impl2_ResolventOf_Interface
  use Type
  use mach.int.Int
  predicate resolvent_of (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (k : int) (m : int)
    
end
module Lib_Logic_LogicClause_Impl2_ResolventOf
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicLit_Impl1_LitIn_Interface as LitIn0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate resolvent_of (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (k : int) (m : int)
    
   = 
    (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) && i <> m -> LitIn0.lit_in (Seq.get (Model0.model c) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c2) && i <> k -> LitIn0.lit_in (Seq.get (Model0.model c2) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> LitIn0.lit_in (Seq.get (Model0.model self) i) c || LitIn0.lit_in (Seq.get (Model0.model self) i) c2) && not (LitIn0.lit_in (Seq.get (Model0.model c) m) self) && not (LitIn0.lit_in (Seq.get (Model0.model c2) k) self) && IsOpp0.is_opp (Seq.get (Model0.model c2) k) (Seq.get (Model0.model c) m)
end
module Lib_Logic_LogicClause_Impl2_ResolventOfIdx_Interface
  use Type
  use mach.int.Int
  predicate resolvent_of_idx (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int)
    
end
module Lib_Logic_LogicClause_Impl2_ResolventOfIdx
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicLit_Impl1_LitIn_Interface as LitIn0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate resolvent_of_idx (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int)
    
   = 
    (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c2) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c2) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c2) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> LitIn0.lit_in (Seq.get (Model0.model self) i) c || LitIn0.lit_in (Seq.get (Model0.model self) i) c2) && (exists m : (int) . exists k : (int) . 0 <= k && k < Seq.length (Model0.model c2) && 0 <= m && m < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) m)) = idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c2) k)) = idx && IsOpp0.is_opp (Seq.get (Model0.model c2) k) (Seq.get (Model0.model c) m))
end
module Lib_Logic_LogicClause_Impl2_ResolventOfIdx2_Interface
  use Type
  use mach.int.Int
  predicate resolvent_of_idx2 (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int) (c_idx : int)
    
end
module Lib_Logic_LogicClause_Impl2_ResolventOfIdx2
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicLit_Impl1_LitIn_Interface as LitIn0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  predicate resolvent_of_idx2 (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int) (c_idx : int)
    
   = 
    (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c2) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c2) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c2) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> LitIn0.lit_in (Seq.get (Model0.model self) i) c || LitIn0.lit_in (Seq.get (Model0.model self) i) c2) && 0 <= c_idx && c_idx < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length (Model0.model c2) && IsOpp0.is_opp (Seq.get (Model0.model c2) k) (Seq.get (Model0.model c) c_idx))
end
module Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  predicate in_formula_inner (self : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicClause_Impl2_InFormulaInner
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  predicate in_formula_inner (self : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    exists i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) && Seq.get (let (a, _) = f in a) i = self
end
module Lib_Logic_LogicClause_Impl2_UnitInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Logic_LogicClause_Impl2_UnitInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_LogicLit_Impl1_UnsetInner_Interface as UnsetInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl2_VarsInRange_Interface as VarsInRange0
  predicate unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    VarsInRange0.vars_in_range self (Seq.length a) && not (SatInner0.sat_inner self a) && (exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && UnsetInner0.unset_inner (Seq.get (Model0.model self) i) a && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> i -> not (UnsetInner0.unset_inner (Seq.get (Model0.model self) j) a)))
end
module Lib_Logic_LogicClause_Impl2_Unit_Interface
  use Type
  predicate unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl2_Unit
  use Type
  clone Lib_Logic_LogicClause_Impl2_UnitInner_Interface as UnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    UnitInner0.unit_inner self (Model0.model a)
end
module Lib_Logic_LogicClause_Impl2_Unknown_Interface
  use Type
  predicate unknown (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicClause_Impl2_Unknown
  use Type
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicClause_Impl2_Sat_Interface as Sat0
  predicate unknown (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    not (Sat0.sat self a) && not (Unsat0.unsat self a)
end
module Lib_Logic_LogicLit_Impl1_LitInInternal_Interface
  use Type
  use seq.Seq
  predicate lit_in_internal (self : Type.lib_lit_lit) (c : Seq.seq (Type.lib_lit_lit))
end
module Lib_Logic_LogicLit_Impl1_LitInInternal
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  predicate lit_in_internal (self : Type.lib_lit_lit) (c : Seq.seq (Type.lib_lit_lit)) = 
    exists i : (int) . 0 <= i && i < Seq.length c && Seq.get c i = self
end
module Lib_Logic_LogicConflictAnalysis_LemmaIdx_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Logic_LogicLit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_LogicConflictAnalysis_LemmaIdx
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Logic_LogicLit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
  axiom lemma_idx_spec : forall c : Seq.seq (Type.lib_lit_lit), o : Seq.seq (Type.lib_lit_lit), new : Seq.seq (Type.lib_lit_lit), i : int, idx : int, c_idx : int, _f : Type.lib_formula_formula . (exists k : (int) . 0 <= k && k < Seq.length new && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get new k))) -> (forall j : (int) . 0 <= j && j < Seq.length new -> LitInInternal0.lit_in_internal (Seq.get new j) c || LitInInternal0.lit_in_internal (Seq.get new j) o) -> (forall j : (int) . 0 <= j && j < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c j)) <> idx -> LitInInternal0.lit_in_internal (Seq.get c j) new) -> InvariantInternal0.invariant_internal c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> InvariantInternal0.invariant_internal o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> 0 <= i && i < Seq.length o && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) <> idx -> (forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length o && 0 <= k && k < Seq.length c && k <> c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o j)) <> idx -> not (IsOpp0.is_opp (Seq.get c k) (Seq.get o j))) -> 0 <= c_idx && c_idx < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length o && k <> i && IsOpp0.is_opp (Seq.get o k) (Seq.get c c_idx)) -> (exists k : (int) . 0 <= k && k < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c k)) || LitInInternal0.lit_in_internal (Seq.get o i) new) && (exists k : (int) . 0 <= k && k < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c k)) && Type.lib_lit_lit_Lit_polarity (Seq.get o i) = Type.lib_lit_lit_Lit_polarity (Seq.get c k) || LitInInternal0.lit_in_internal (Seq.get o i) new)
end
module Lib_Logic_LogicConflictAnalysis_LemmaIdx2_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Logic_LogicLit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx2 (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_LogicConflictAnalysis_LemmaIdx2
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Logic_LogicClause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Logic_LogicLit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx2 (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
  axiom lemma_idx2_spec : forall c : Seq.seq (Type.lib_lit_lit), o : Seq.seq (Type.lib_lit_lit), new : Seq.seq (Type.lib_lit_lit), i : int, idx : int, c_idx : int, _f : Type.lib_formula_formula . (exists k : (int) . 0 <= k && k < Seq.length new && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get new k))) -> (forall j : (int) . 0 <= j && j < Seq.length new -> LitInInternal0.lit_in_internal (Seq.get new j) c || LitInInternal0.lit_in_internal (Seq.get new j) o) -> (forall j : (int) . 0 <= j && j < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c j)) <> idx -> LitInInternal0.lit_in_internal (Seq.get c j) new) -> InvariantInternal0.invariant_internal c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> InvariantInternal0.invariant_internal o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> 0 <= i && i < Seq.length o && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) <> idx -> (forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length o && 0 <= k && k < Seq.length c && k <> c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o j)) <> idx -> not (IsOpp0.is_opp (Seq.get c k) (Seq.get o j))) -> 0 <= c_idx && c_idx < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length o && k <> i && IsOpp0.is_opp (Seq.get o k) (Seq.get c c_idx)) -> LitInInternal0.lit_in_internal (Seq.get o i) new
end
module Lib_Logic_LogicFormula_FormulaInvariant_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate formula_invariant (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Logic_LogicFormula_FormulaInvariant
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  predicate formula_invariant (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Invariant0.invariant' (Seq.get (let (a, _) = f in a) i) (let (_, a) = f in a)
end
module Lib_Logic_LogicFormula_Impl1_Compatible_Interface
  use Type
  predicate compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula)
end
module Lib_Logic_LogicFormula_Impl1_Compatible
  use Type
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula) = 
    UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars o) && Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses o)) >= Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) -> Equals0.equals (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses o)) i))
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate eventually_sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_CompatibleInner_Interface as CompatibleInner0
  predicate eventually_sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) && CompatibleInner0.compatible_inner a a2 && SatInner0.sat_inner self a2
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate eventually_sat_complete_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_CompatibleCompleteInner_Interface as CompatibleCompleteInner0
  predicate eventually_sat_complete_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) && CompatibleCompleteInner0.compatible_complete_inner a a2 && SatInner0.sat_inner self a2
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatComplete_Interface
  use Type
  predicate eventually_sat_complete (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySatComplete
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate eventually_sat_complete (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) = 
    EventuallySatCompleteInner0.eventually_sat_complete_inner self (Model0.model a)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySat_Interface
  use Type
  predicate eventually_sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Logic_LogicFormula_Impl1_EventuallySat
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatInner_Interface as EventuallySatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  predicate eventually_sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) = 
    EventuallySatInner0.eventually_sat_inner self (Model0.model a)
end
module Lib_Logic_LogicUtil_PartitionRev_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate partition_rev (v : Seq.seq (usize, usize)) (i : int)
end
module Lib_Logic_LogicUtil_PartitionRev
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use mach.int.Int32
  predicate partition_rev (v : Seq.seq (usize, usize)) (i : int) = 
    forall k2 : (int) . forall k1 : (int) . 0 <= k1 && k1 < i && i <= k2 && k2 < Seq.length v -> (let (a, _) = Seq.get v k1 in a) >= (let (a, _) = Seq.get v k2 in a)
end
module Lib_Logic_LogicUtil_Pop_Interface
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq_ext.SeqExt
  function pop (s : Seq.seq t) : Seq.seq t
end
module Lib_Logic_LogicUtil_Pop
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq_ext.SeqExt
  function pop (s : Seq.seq t) : Seq.seq t
  axiom pop_spec : forall s : Seq.seq t . Seq.length s > 0 -> pop s = SeqExt.subsequence s 0 (Seq.length s - 1) && Seq.length (pop s) = Seq.length s - 1 && (forall i : (int) . 0 <= i && i < Seq.length (pop s) -> Seq.get (pop s) i = Seq.get s i)
end
module Lib_Logic_LogicUtil_LastIdx_Interface
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  function last_idx (s : Seq.seq t) : int
end
module Lib_Logic_LogicUtil_LastIdx
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  function last_idx (s : Seq.seq t) : int
  axiom last_idx_spec : forall s : Seq.seq t . Seq.length s > 0 -> true
end
module Lib_Logic_LogicUtil_LastElem_Interface
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  function last_elem (s : Seq.seq t) : t
end
module Lib_Logic_LogicUtil_LastElem
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  function last_elem (s : Seq.seq t) : t
  axiom last_elem_spec : forall s : Seq.seq t . Seq.length s > 0 -> true
end
module Lib_Logic_LogicWatches_WatchesInvariantInternal_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate watches_invariant_internal (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (n : int) (f : Type.lib_formula_formula)
    
end
module Lib_Logic_LogicWatches_WatchesInvariantInternal
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_watches_watcher
  predicate watches_invariant_internal (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (n : int) (f : Type.lib_formula_formula)
    
   = 
    2 * n = Seq.length w && (forall i : (int) . 0 <= i && i < Seq.length w -> (forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Seq.get w i)) -> UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get (Model0.model (Seq.get w i)) j)) < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses f)) && Seq.length (Model2.model (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get (Model0.model (Seq.get w i)) j))))) > 1))
end
module Lib_Logic_LogicWatches_WatchesCrefsInRange_Interface
  use seq.Seq
  use Type
  predicate watches_crefs_in_range (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (f : Type.lib_formula_formula)
    
end
module Lib_Logic_LogicWatches_WatchesCrefsInRange
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_watches_watcher
  predicate watches_crefs_in_range (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (f : Type.lib_formula_formula)
    
   = 
    forall i : (int) . 0 <= i && i < Seq.length w -> WatcherCrefsInRange0.watcher_crefs_in_range (Model0.model (Seq.get w i)) f
end
module Lib_Logic_LogicWatches_LemmaPopWatchMaintainsWatcherInvariant_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_watches_watcher, axiom .
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  function lemma_pop_watch_maintains_watcher_invariant (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_LogicWatches_LemmaPopWatchMaintainsWatcherInvariant
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_watches_watcher, axiom .
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  function lemma_pop_watch_maintains_watcher_invariant (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) : ()
    
  axiom lemma_pop_watch_maintains_watcher_invariant_spec : forall w : Seq.seq (Type.lib_watches_watcher), f : Type.lib_formula_formula . WatcherCrefsInRange0.watcher_crefs_in_range w f -> Seq.length w > 0 -> WatcherCrefsInRange0.watcher_crefs_in_range (Pop0.pop w) f
end
module Lib_Logic_LogicWatches_LemmaPushMaintainsWatcherInvariant_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use Type
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_push_maintains_watcher_invariant (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) (o : Type.lib_watches_watcher) : ()
    
end
module Lib_Logic_LogicWatches_LemmaPushMaintainsWatcherInvariant
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use Type
  clone Lib_Logic_LogicWatches_WatcherCrefsInRange_Interface as WatcherCrefsInRange0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_push_maintains_watcher_invariant (w : Seq.seq (Type.lib_watches_watcher)) (f : Type.lib_formula_formula) (o : Type.lib_watches_watcher) : ()
    
  axiom lemma_push_maintains_watcher_invariant_spec : forall w : Seq.seq (Type.lib_watches_watcher), f : Type.lib_formula_formula, o : Type.lib_watches_watcher . UInt64.to_int (Type.lib_watches_watcher_Watcher_cref o) < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> WatcherCrefsInRange0.watcher_crefs_in_range w f -> WatcherCrefsInRange0.watcher_crefs_in_range (Seq.snoc w o) f
end
module Lib_Logic_Logic_BoolToAssignedstate_Interface
  use prelude.UInt8
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  function bool_to_assignedstate (b : bool) : uint8
end
module Lib_Logic_Logic_BoolToAssignedstate
  use prelude.UInt8
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  function bool_to_assignedstate (b : bool) : uint8
  axiom bool_to_assignedstate_spec : forall b : bool . (b -> UInt8.to_int (bool_to_assignedstate b) = 1) && (not b -> UInt8.to_int (bool_to_assignedstate b) = 0)
end
module Lib_Logic_LogicTrail_AssignmentsAreInTrail_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate assignments_are_in_trail (t : Seq.seq (Type.lib_trail_step)) (a : Seq.seq uint8)
end
module Lib_Logic_LogicTrail_AssignmentsAreInTrail
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  predicate assignments_are_in_trail (t : Seq.seq (Type.lib_trail_step)) (a : Seq.seq uint8) = 
    forall j : (int) . 0 <= j && j < Seq.length a -> (exists i : (int) . 0 <= i && i < Seq.length t && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get t i))) = j && BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Type.lib_trail_step_Step_lit (Seq.get t i))) = Seq.get a j)
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsTo_Interface
  use Type
  use mach.int.Int
  predicate clause_post_with_regards_to (c : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (j : int)
end
module Lib_Logic_LogicTrail_ClausePostWithRegardsTo
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicLit_Impl1_Sat_Interface as Sat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  predicate clause_post_with_regards_to (c : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (j : int) = 
    PostUnit0.post_unit c a && (exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) = j && Sat0.sat (Seq.get (Model0.model c) i) a)
end
module Lib_Logic_LogicTrail_LongArePostUnit_Interface
  use Type
  predicate long_are_post_unit (trail : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Logic_LogicTrail_LongArePostUnit
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsTo_Interface as ClausePostWithRegardsTo0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  predicate long_are_post_unit (trail : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail trail)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail trail)) j)) with
      | Type.Lib_Trail_Reason_Long k -> ClausePostWithRegardsTo0.clause_post_with_regards_to (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Type.lib_trail_trail_Trail_assignments trail) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail trail)) j))))
      | _ -> true
      end
end
module Lib_Logic_LogicTrail_LongArePostUnitInnerNew_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate long_are_post_unit_inner_new (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Seq.seq uint8)
    
end
module Lib_Logic_LogicTrail_LongArePostUnitInnerNew
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner_Interface as ClausePostWithRegardsToInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate long_are_post_unit_inner_new (trail : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Seq.seq uint8)
    
   = 
    forall j : (int) . 0 <= j && j < Seq.length trail -> match (Type.lib_trail_step_Step_reason (Seq.get trail j)) with
      | Type.Lib_Trail_Reason_Long k -> ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) a (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Type.lib_trail_step_Step_lit (Seq.get trail j))))
      | _ -> true
      end
end
module Lib_Logic_LogicTrail_LemmaTrailPost_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  function lemma_trail_post (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) (t : Type.lib_trail_trail) : ()
end
module Lib_Logic_LogicTrail_LemmaTrailPost
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  function lemma_trail_post (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) (t : Type.lib_trail_trail) : ()
  axiom lemma_trail_post_spec : forall f : Type.lib_formula_formula, lit : Type.lib_lit_lit, t : Type.lib_trail_trail . Invariant0.invariant' t f -> Invariant1.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> Invariant2.invariant' f -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) && not (LitIdxIn0.lit_idx_in lit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
    | _ -> true
    end) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) && not (LitIdxIn0.lit_idx_in lit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
    | _ -> true
    end)
end
module Lib_Logic_LogicTrail_LemmaTrailOnlyLast_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_only_last (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) (t : Type.lib_trail_trail) : ()
end
module Lib_Logic_LogicTrail_LemmaTrailOnlyLast
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  clone Lib_Logic_LogicLit_Impl1_LitIdxIn_Interface as LitIdxIn0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_only_last (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) (t : Type.lib_trail_trail) : ()
  axiom lemma_trail_only_last_spec : forall f : Type.lib_formula_formula, lit : Type.lib_lit_lit, t : Type.lib_trail_trail . lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant1.invariant' f -> Invariant2.invariant' t f -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> not (LitIdxIn0.lit_idx_in lit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)))
    | _ -> true
    end)
end
module Lib_Logic_LogicTrail_LemmaTrailFin_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_fin (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
end
module Lib_Logic_LogicTrail_LemmaTrailFin
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_fin (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
  axiom lemma_trail_fin_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, lit : Type.lib_lit_lit . lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Invariant0.invariant' t f -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> Invariant1.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant2.invariant' f -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
    | _ -> true
    end) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model2.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model2.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
    | _ -> true
    end)
end
module Lib_Logic_LogicTrail_LemmaTrailFin2_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_fin2 (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
end
module Lib_Logic_LogicTrail_LemmaTrailFin2
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_fin2 (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
  axiom lemma_trail_fin2_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, lit : Type.lib_lit_lit . LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
    | _ -> true
    end) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1 -> match (Type.lib_trail_step_Step_reason (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) i)) with
    | Type.Lib_Trail_Reason_Long k -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> PostUnitInner0.post_unit_inner (Seq.get (Model2.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
    | _ -> true
    end) -> lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant1.invariant' t f -> Invariant2.invariant' f -> LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8))
end
module Lib_Logic_LogicTrail_LemmaTrailFin3_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_fin3 (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
end
module Lib_Logic_LogicTrail_LemmaTrailFin3
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_trail_fin3 (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (lit : Type.lib_lit_lit) : ()
  axiom lemma_trail_fin3_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, lit : Type.lib_lit_lit . LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> lit = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant1.invariant' t f -> Invariant2.invariant' f -> LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (3 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (2 : uint8))
end
module Lib_Logic_LogicTrail_LemmaPopNoUnassIsOk_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_pop_no_unass_is_ok (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (l : Type.lib_lit_lit) : ()
    
end
module Lib_Logic_LogicTrail_LemmaPopNoUnassIsOk
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_pop_no_unass_is_ok (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (l : Type.lib_lit_lit) : ()
    
  axiom lemma_pop_no_unass_is_ok_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, l : Type.lib_lit_lit . LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> l = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant0.invariant' t f -> LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Model1.model (Type.lib_trail_trail_Trail_assignments t))
end
module Lib_Logic_LogicTrail_LemmaBacktrackOk_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_backtrack_ok (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (l : Type.lib_lit_lit) : ()
end
module Lib_Logic_LogicTrail_LemmaBacktrackOk
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicUtil_Pop_Interface as Pop0 with type t = Type.lib_trail_step, axiom .
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Logic_LogicTrail_Impl2_LitNotInLess_Interface as LitNotInLess0
  clone Lib_Logic_LogicTrail_Impl2_LitIsUnique_Interface as LitIsUnique0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_trail_step
  function lemma_backtrack_ok (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) (l : Type.lib_lit_lit) : ()
  axiom lemma_backtrack_ok_spec : forall t : Type.lib_trail_trail, f : Type.lib_formula_formula, l : Type.lib_lit_lit . LongArePostUnitInner0.long_are_post_unit_inner (Model0.model (Type.lib_trail_trail_Trail_trail t)) f (Model1.model (Type.lib_trail_trail_Trail_assignments t)) -> l = Type.lib_trail_step_Step_lit (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail t)) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) - 1)) -> Invariant0.invariant' l (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail t)) > 0 -> LitIsUnique0.lit_is_unique t -> LitNotInLess0.lit_not_in_less t f -> Invariant1.invariant' t f -> Invariant2.invariant' f -> LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx l)) (3 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner (Pop0.pop (Model0.model (Type.lib_trail_trail_Trail_trail t))) f (Seq.set (Model1.model (Type.lib_trail_trail_Trail_assignments t)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx l)) (2 : uint8))
end
module Lib_Logic_LogicTrail_LemmaPostUnitNoUnset_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  clone Lib_Logic_LogicLit_Impl1_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  function lemma_post_unit_no_unset (c : Type.lib_clause_clause) (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_LogicTrail_LemmaPostUnitNoUnset
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  clone Lib_Logic_LogicLit_Impl1_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  function lemma_post_unit_no_unset (c : Type.lib_clause_clause) (t : Type.lib_trail_trail) (f : Type.lib_formula_formula) : ()
    
  axiom lemma_post_unit_no_unset_spec : forall c : Type.lib_clause_clause, t : Type.lib_trail_trail, f : Type.lib_formula_formula . PostUnit0.post_unit c (Type.lib_trail_trail_Trail_assignments t) -> Invariant0.invariant' c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) -> not (Unset0.unset (Seq.get (Model0.model c) i) (Type.lib_trail_trail_Trail_assignments t)))
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsPostForEach_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_assign_maintains_post_for_each (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsPostForEach
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_assign_maintains_post_for_each (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
  axiom lemma_assign_maintains_post_for_each_spec : forall f : Type.lib_formula_formula, a : Type.lib_assignments_assignments, lit : Type.lib_lit_lit . Unset0.unset (Seq.get (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> Invariant1.invariant' f -> Invariant2.invariant' a f -> (forall i : (int) . 0 <= i && i < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model0.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8))) && (forall i : (int) . 0 <= i && i < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model0.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8)))
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsForEachToPost_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_assign_maintains_for_each_to_post (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsForEachToPost
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_assign_maintains_for_each_to_post (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
  axiom lemma_assign_maintains_for_each_to_post_spec : forall v : Seq.seq (Type.lib_trail_step), f : Type.lib_formula_formula, a : Type.lib_assignments_assignments, lit : Type.lib_lit_lit . (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model1.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8))) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Model1.model a) -> PostUnitInner0.post_unit_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8))) -> LongArePostUnitInner0.long_are_post_unit_inner v f (Model1.model a) -> Unset0.unset (Seq.get (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> CrefsInRange0.crefs_in_range v f -> TrailInvariant0.trail_invariant v f -> Invariant1.invariant' f -> Invariant2.invariant' a f -> LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model1.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8))
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsLongArePostUnit_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_assign_maintains_long_are_post_unit (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
end
module Lib_Logic_LogicTrail_LemmaAssignMaintainsLongArePostUnit
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_LogicAssignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicTrail_TrailInvariant_Interface as TrailInvariant0
  clone Lib_Logic_LogicTrail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Logic_LogicLit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicTrail_LongArePostUnitInner_Interface as LongArePostUnitInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model0
  function lemma_assign_maintains_long_are_post_unit (v : Seq.seq (Type.lib_trail_step)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (lit : Type.lib_lit_lit) : ()
    
  axiom lemma_assign_maintains_long_are_post_unit_spec : forall v : Seq.seq (Type.lib_trail_step), f : Type.lib_formula_formula, a : Type.lib_assignments_assignments, lit : Type.lib_lit_lit . LongArePostUnitInner0.long_are_post_unit_inner v f (Model0.model a) -> Unset0.unset (Seq.get (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) -> Invariant0.invariant' lit (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) -> CrefsInRange0.crefs_in_range v f -> TrailInvariant0.trail_invariant v f -> Invariant1.invariant' f -> Invariant2.invariant' a f -> LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (1 : uint8)) && LongArePostUnitInner0.long_are_post_unit_inner v f (Seq.set (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) (0 : uint8))
end
module Lib_Logic_Logic_LemmaPermutClauseOk_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicClause_Impl2_Sat_Interface as Sat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_permut_clause_ok (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) : ()
    
end
module Lib_Logic_Logic_LemmaPermutClauseOk
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicClause_Impl2_Sat_Interface as Sat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_permut_clause_ok (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) : ()
    
  axiom lemma_permut_clause_ok_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : Type.lib_assignments_assignments . Permut.permut (Model0.model c2) (Model0.model c) 0 (Seq.length (Model0.model c)) -> Sat0.sat c a -> Sat0.sat c2 a
end
module Lib_Logic_Logic_LemmaPermutClauseOk2_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_permut_clause_ok2 (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) : ()
    
end
module Lib_Logic_Logic_LemmaPermutClauseOk2
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicClause_Impl2_Unsat_Interface as Unsat0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_permut_clause_ok2 (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) : ()
    
  axiom lemma_permut_clause_ok2_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : Type.lib_assignments_assignments . Permut.permut (Model0.model c2) (Model0.model c) 0 (Seq.length (Model0.model c)) -> Unsat0.unsat c a -> Unsat0.unsat c2 a
end
module Lib_Logic_Logic_LemmaSwapClauseNoDups_Interface
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_swap_clause_no_dups (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) : ()
end
module Lib_Logic_Logic_LemmaSwapClauseNoDups
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_swap_clause_no_dups (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) : ()
  axiom lemma_swap_clause_no_dups_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : int, b : int . NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model0.model c) -> Permut.exchange (Model0.model c2) (Model0.model c) a b -> Seq.length (Model0.model c2) = Seq.length (Model0.model c) -> Seq.length (Model0.model c) >= 2 -> NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model0.model c2)
end
module Lib_Logic_Logic_LemmaSwapMaintainsPostUnit_Interface
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  function lemma_swap_maintains_post_unit (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) (ass : Type.lib_assignments_assignments) : ()
    
end
module Lib_Logic_Logic_LemmaSwapMaintainsPostUnit
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl1_PostUnit_Interface as PostUnit0
  function lemma_swap_maintains_post_unit (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) (ass : Type.lib_assignments_assignments) : ()
    
  axiom lemma_swap_maintains_post_unit_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : int, b : int, ass : Type.lib_assignments_assignments . PostUnit0.post_unit c ass -> Permut.exchange (Model0.model c2) (Model0.model c) a b -> Seq.length (Model0.model c2) = Seq.length (Model0.model c) -> Seq.length (Model0.model c) >= 2 -> PostUnit0.post_unit c2 ass
end
module Lib_Logic_Logic_LemmaSwapMaintainsPostWithRegardsTo_Interface
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner_Interface as ClausePostWithRegardsToInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsTo_Interface as ClausePostWithRegardsTo0
  function lemma_swap_maintains_post_with_regards_to (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) (ass : Type.lib_assignments_assignments) (j : int) : ()
    
end
module Lib_Logic_Logic_LemmaSwapMaintainsPostWithRegardsTo
  use seq.Permut
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsToInner_Interface as ClausePostWithRegardsToInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicTrail_ClausePostWithRegardsTo_Interface as ClausePostWithRegardsTo0
  function lemma_swap_maintains_post_with_regards_to (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : int) (b : int) (ass : Type.lib_assignments_assignments) (j : int) : ()
    
  axiom lemma_swap_maintains_post_with_regards_to_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : int, b : int, ass : Type.lib_assignments_assignments, j : int . ClausePostWithRegardsTo0.clause_post_with_regards_to c ass j -> Permut.exchange (Model0.model c2) (Model0.model c) a b -> Seq.length (Model0.model c2) = Seq.length (Model0.model c) -> Seq.length (Model0.model c) >= 2 -> ClausePostWithRegardsTo0.clause_post_with_regards_to c2 ass j && ClausePostWithRegardsToInner0.clause_post_with_regards_to_inner c2 (Model1.model ass) j
end
module Lib_Logic_Logic_LemmaPermutFormulaOk_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicFormula_Impl1_Sat_Interface as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : ()
    
end
module Lib_Logic_Logic_LemmaPermutFormulaOk
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicAssignments_Impl0_Model_Interface as Model1
  clone Lib_Logic_LogicFormula_Impl1_Sat_Interface as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : ()
    
  axiom lemma_permut_formula_ok_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, a : Type.lib_assignments_assignments . UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> Permut.permut (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Model0.model (Type.lib_formula_formula_Formula_clauses f)) 0 (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))) -> Sat0.sat f a -> Sat0.sat f2 a
end
module Lib_Logic_Logic_LemmaPermutFormulaOk2_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok2 (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : ()
    
end
module Lib_Logic_Logic_LemmaPermutFormulaOk2
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok2 (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : ()
    
  axiom lemma_permut_formula_ok2_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, a : Type.lib_assignments_assignments . UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> Permut.permut (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Model0.model (Type.lib_formula_formula_Formula_clauses f)) 0 (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))) -> Unsat0.unsat f a -> Unsat0.unsat f2 a
end
module Lib_Logic_Logic_LemmaPermutFormulaOkNoAss_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok_no_ass (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) : ()
end
module Lib_Logic_Logic_LemmaPermutFormulaOkNoAss
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_formula_ok_no_ass (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) : ()
  axiom lemma_permut_formula_ok_no_ass_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula . UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> Permut.permut (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Model0.model (Type.lib_formula_formula_Formula_clauses f)) 0 (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))) -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f2
end
module Lib_Logic_Logic_LemmaPermutClauseInFormulaMaintainsSat_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_clause_in_formula_maintains_sat (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (cref : int) : ()
    
end
module Lib_Logic_Logic_LemmaPermutClauseInFormulaMaintainsSat
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_clause_in_formula_maintains_sat (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (cref : int) : ()
    
  axiom lemma_permut_clause_in_formula_maintains_sat_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, cref : int . UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> Permut.permut (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) cref)) (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref)) 0 (Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref))) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) && i <> cref -> Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) i) = Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i)) -> Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f2
end
module Lib_Logic_Logic_LemmaPermutClauseInFormulaMaintainsUnsat_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_clause_in_formula_maintains_unsat (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (cref : int) : ()
    
end
module Lib_Logic_Logic_LemmaPermutClauseInFormulaMaintainsUnsat
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  use Type
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function lemma_permut_clause_in_formula_maintains_unsat (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (cref : int) : ()
    
  axiom lemma_permut_clause_in_formula_maintains_unsat_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, cref : int . UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) -> Permut.permut (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) cref)) (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref)) 0 (Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) cref))) -> (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) && i <> cref -> Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) i) = Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i)) -> Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f) -> not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f2)
end
module Lib_Logic_Logic_LemmaSamePol_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept_Interface as SameIdxSamePolarityExcept0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  function lemma_same_pol (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Seq.seq uint8) (idx : int) : ()
    
end
module Lib_Logic_Logic_LemmaSamePol
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_SameIdxSamePolarityExcept_Interface as SameIdxSamePolarityExcept0
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  function lemma_same_pol (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Seq.seq uint8) (idx : int) : ()
    
  axiom lemma_same_pol_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : Seq.seq uint8, idx : int . UnsatInner0.unsat_inner c2 a -> (exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) = idx && SatInner0.sat_inner (Seq.get (Model0.model c) i) a) -> Invariant0.invariant' c2 (Seq.length a) -> Invariant0.invariant' c (Seq.length a) -> PostUnitInner0.post_unit_inner c a -> SameIdxSamePolarityExcept0.same_idx_same_polarity_except c2 c idx
end
module Lib_Logic_Logic_LemmaResolvedPostAndUnsatIsUnsat_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  function lemma_resolved_post_and_unsat_is_unsat (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (a : Seq.seq uint8) (c_idx : int) (c2_idx : int) : ()
    
end
module Lib_Logic_Logic_LemmaResolvedPostAndUnsatIsUnsat
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl1_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  function lemma_resolved_post_and_unsat_is_unsat (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (a : Seq.seq uint8) (c_idx : int) (c2_idx : int) : ()
    
  axiom lemma_resolved_post_and_unsat_is_unsat_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, a : Seq.seq uint8, c_idx : int, c2_idx : int . ResolventOf0.resolvent_of c3 c c2 c2_idx c_idx -> 0 <= c2_idx && c2_idx < Seq.length (Model0.model c2) -> 0 <= c_idx && c_idx < Seq.length (Model0.model c) -> UnsatInner0.unsat_inner c2 a -> SatInner0.sat_inner (Seq.get (Model0.model c) c_idx) a -> Invariant0.invariant' c2 (Seq.length a) -> Invariant0.invariant' c (Seq.length a) -> PostUnitInner0.post_unit_inner c a -> UnsatInner0.unsat_inner c3 a
end
module Lib_Logic_Logic_LemmaEqFormulas_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  function lemma_eq_formulas (f : (Seq.seq (Type.lib_clause_clause), int)) (f2 : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
end
module Lib_Logic_Logic_LemmaEqFormulas
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Logic_LogicClause_Impl2_Equals_Interface as Equals0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  function lemma_eq_formulas (f : (Seq.seq (Type.lib_clause_clause), int)) (f2 : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
  axiom lemma_eq_formulas_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), f2 : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause . FormulaInvariant0.formula_invariant f -> (let (a, _) = f2 in a) = Seq.snoc (let (a, _) = f in a) c -> Seq.length (let (a, _) = f in a) + 1 = Seq.length (let (a, _) = f2 in a) && (forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Equals0.equals (Seq.get (let (a, _) = f in a) i) (Seq.get (let (a, _) = f2 in a) i)) && Model0.model (Seq.get (let (a, _) = f2 in a) (Seq.length (let (a, _) = f2 in a) - 1)) = Model0.model c
end
module Lib_Logic_Logic_LemmaSatGivesSat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  function lemma_sat_gives_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
end
module Lib_Logic_Logic_LemmaSatGivesSat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  function lemma_sat_gives_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
  axiom lemma_sat_gives_sat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, k : int, m : int . EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f -> ResolventOf0.resolvent_of c3 c c2 k m -> EquisatExtensionInner0.equisat_extension_inner c2 f -> InFormulaInner0.in_formula_inner c f -> FormulaInvariant0.formula_invariant f -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a)
end
module Lib_Logic_Logic_LemmaNotSatGivesNotSat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  function lemma_not_sat_gives_not_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) : ()
    
end
module Lib_Logic_Logic_LemmaNotSatGivesNotSat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicFormula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  function lemma_not_sat_gives_not_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) : ()
    
  axiom lemma_not_sat_gives_not_sat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause . not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f) -> FormulaInvariant0.formula_invariant f -> not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a))
end
module Lib_Logic_Logic_LemmaExtendedFormulaIsEquisatCompatible_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  function lemma_extended_formula_is_equisat_compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
end
module Lib_Logic_Logic_LemmaExtendedFormulaIsEquisatCompatible
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  function lemma_extended_formula_is_equisat_compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
  axiom lemma_extended_formula_is_equisat_compatible_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, k : int, m : int . ResolventOf0.resolvent_of c3 c c2 k m -> InFormulaInner0.in_formula_inner c2 f -> InFormulaInner0.in_formula_inner c f -> FormulaInvariant0.formula_invariant f -> EquisatExtensionInner0.equisat_extension_inner c3 f
end
module Lib_Logic_Logic_LemmaResolventOfEquisatExtensionIsEquisat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  function lemma_resolvent_of_equisat_extension_is_equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
end
module Lib_Logic_Logic_LemmaResolventOfEquisatExtensionIsEquisat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Logic_LogicClause_Impl2_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Logic_LogicClause_Impl2_ResolventOf_Interface as ResolventOf0
  function lemma_resolvent_of_equisat_extension_is_equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
  axiom lemma_resolvent_of_equisat_extension_is_equisat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, k : int, m : int . ResolventOf0.resolvent_of c3 c c2 k m -> InFormulaInner0.in_formula_inner c2 f -> EquisatExtensionInner0.equisat_extension_inner c f -> FormulaInvariant0.formula_invariant f -> EquisatExtensionInner0.equisat_extension_inner c3 f
end
module Lib_Logic_Logic_LemmaExtendingWithEquiExtIsEquiCompat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner_Interface as EquisatCompatibleInner0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  function lemma_extending_with_equi_ext_is_equi_compat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
end
module Lib_Logic_Logic_LemmaExtendingWithEquiExtIsEquiCompat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Logic_LogicFormula_EquisatCompatibleInner_Interface as EquisatCompatibleInner0
  clone Lib_Logic_LogicFormula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Logic_LogicClause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  function lemma_extending_with_equi_ext_is_equi_compat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
  axiom lemma_extending_with_equi_ext_is_equi_compat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause . EquisatExtensionInner0.equisat_extension_inner c f -> FormulaInvariant0.formula_invariant f -> EquisatCompatibleInner0.equisat_compatible_inner f (Seq.snoc (let (a, _) = f in a) c, let (_, a) = f in a)
end
module Lib_Logic_Logic_LemmaEquisatIsTrans_Interface
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface as EquisatCompatible0
  function lemma_equisat_is_trans (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (f3 : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_Logic_LemmaEquisatIsTrans
  use Type
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicFormula_Impl1_EquisatCompatible_Interface as EquisatCompatible0
  function lemma_equisat_is_trans (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (f3 : Type.lib_formula_formula) : ()
    
  axiom lemma_equisat_is_trans_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, f3 : Type.lib_formula_formula . EquisatCompatible0.equisat_compatible f2 f3 -> EquisatCompatible0.equisat_compatible f f2 -> Invariant0.invariant' f3 -> Invariant0.invariant' f2 -> Invariant0.invariant' f -> EquisatCompatible0.equisat_compatible f f3
end
module Lib_Logic_Logic_FlipV_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function flip_v (v : uint8) : uint8
end
module Lib_Logic_Logic_FlipV
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  function flip_v (v : uint8) : uint8 = 
    if UInt8.to_int v = 0 then (1 : uint8) else if UInt8.to_int v = 1 then (0 : uint8) else v
end
module Lib_Logic_Logic_Pos_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function pos () : uint8
end
module Lib_Logic_Logic_Pos
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function pos () : uint8 = 
    (1 : uint8)
end
module Lib_Logic_Logic_Neg_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function neg () : uint8
end
module Lib_Logic_Logic_Neg
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function neg () : uint8 = 
    (0 : uint8)
end
module Lib_Logic_Logic_LemmaCompleteImpliesSatOrUnsat_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  function lemma_complete_implies_sat_or_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_Logic_LemmaCompleteImpliesSatOrUnsat
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  function lemma_complete_implies_sat_or_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
  axiom lemma_complete_implies_sat_or_unsat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . CompleteInner0.complete_inner a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> UnsatInner0.unsat_inner f a || SatInner0.sat_inner f a
end
module Lib_Logic_Logic_LemmaCompleteAndNotSatImpliesUnsat_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  function lemma_complete_and_not_sat_implies_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_Logic_LemmaCompleteAndNotSatImpliesUnsat
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  function lemma_complete_and_not_sat_implies_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
  axiom lemma_complete_and_not_sat_implies_unsat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . not (SatInner0.sat_inner f a) -> CompleteInner0.complete_inner a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> UnsatInner0.unsat_inner f a
end
module Lib_Logic_Logic_LemmaCompleteAndNotUnsatImpliesSat_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  function lemma_complete_and_not_unsat_implies_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_Logic_LemmaCompleteAndNotUnsatImpliesSat
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicAssignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  function lemma_complete_and_not_unsat_implies_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
  axiom lemma_complete_and_not_unsat_implies_sat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . not (UnsatInner0.unsat_inner f a) -> CompleteInner0.complete_inner a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> SatInner0.sat_inner f a
end
module Lib_Logic_Logic_LemmaNotSatFormulaImpliesUnsatFormula_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  function lemma_not_sat_formula_implies_unsat_formula (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_Logic_LemmaNotSatFormulaImpliesUnsatFormula
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_LogicAssignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner0
  function lemma_not_sat_formula_implies_unsat_formula (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
  axiom lemma_not_sat_formula_implies_unsat_formula_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . UnsatInner0.unsat_inner f a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f a)
end
module Lib_Logic_Logic_LemmaNotSatClauseImpliesUnsatFormula_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl2_InFormula_Interface as InFormula0
  function lemma_not_sat_clause_implies_unsat_formula (f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
    
end
module Lib_Logic_Logic_LemmaNotSatClauseImpliesUnsatFormula
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl2_InFormula_Interface as InFormula0
  function lemma_not_sat_clause_implies_unsat_formula (f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
    
  axiom lemma_not_sat_clause_implies_unsat_formula_spec : forall f : Type.lib_formula_formula, c : Type.lib_clause_clause, a : Seq.seq uint8 . InFormula0.in_formula c f -> UnsatInner0.unsat_inner c a -> UnsatInner1.unsat_inner f a
end
module Lib_Logic_Logic_LemmaUnitForces_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  function lemma_unit_forces (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_Logic_LemmaUnitForces
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  function lemma_unit_forces (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
  axiom lemma_unit_forces_spec : forall c : Type.lib_clause_clause, f : Type.lib_formula_formula, a : Seq.seq uint8, ix : int, v : uint8 . not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (FlipV0.flip_v v))) -> EventuallySatCompleteInner0.eventually_sat_complete_inner f a -> not (Unset0.unset v) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a -> Invariant0.invariant' f -> EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix v)
end
module Lib_Logic_Logic_LemmaUnitWrongPolarityUnsatFormula_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl2_UnitInner_Interface as UnitInner0
  clone Lib_Logic_LogicClause_Impl2_InFormula_Interface as InFormula0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_unit_wrong_polarity_unsat_formula (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_Logic_LemmaUnitWrongPolarityUnsatFormula
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_LogicFormula_Impl1_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_LogicFormula_Impl1_InvariantOld_Interface as InvariantOld0
  clone Lib_Logic_LogicFormula_Impl1_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl2_UnitInner_Interface as UnitInner0
  clone Lib_Logic_LogicClause_Impl2_InFormula_Interface as InFormula0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_unit_wrong_polarity_unsat_formula (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
  axiom lemma_unit_wrong_polarity_unsat_formula_spec : forall c : Type.lib_clause_clause, f : Type.lib_formula_formula, a : Seq.seq uint8, ix : int, v : uint8 . (forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) && not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix) -> UnsatInner0.unsat_inner (Seq.get (Model0.model c) j) a) -> (exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model c) j)) = v) -> Invariant0.invariant' c (Seq.length a) -> InFormula0.in_formula c f -> UnitInner0.unit_inner c a -> not (Unset0.unset v) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a -> Invariant1.invariant' f -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (FlipV0.flip_v v))) && UnsatInner1.unsat_inner f (Seq.set a ix (FlipV0.flip_v v))
end
module Lib_Logic_Logic_LemmaCorrectPolarityMakesClauseSat_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone Lib_Logic_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_correct_polarity_makes_clause_sat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_Logic_LemmaCorrectPolarityMakesClauseSat
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner0
  clone Lib_Logic_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_correct_polarity_makes_clause_sat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
  axiom lemma_correct_polarity_makes_clause_sat_spec : forall c : Type.lib_clause_clause, a : Seq.seq uint8, ix : int, v : uint8 . (exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model c) j)) = v) -> 0 <= ix && ix < Seq.length a -> SatInner0.sat_inner c (Seq.set a ix v)
end
module Lib_Logic_Logic_LemmaIncorrectPolarityMakesClauseUnsat_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl2_UnitInner_Interface as UnitInner0
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner1
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_incorrect_polarity_makes_clause_unsat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_Logic_LemmaIncorrectPolarityMakesClauseUnsat
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_LogicClause_Impl2_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicClause_Impl2_UnitInner_Interface as UnitInner0
  clone Lib_Logic_LogicClause_Impl2_SatInner_Interface as SatInner1
  clone Lib_Logic_LogicLit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Logic_LogicClause_Impl2_Invariant_Interface as Invariant0
  clone Lib_Logic_LogicLit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Logic_LogicClause_Impl0_Model_Interface as Model0
  function lemma_incorrect_polarity_makes_clause_unsat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
  axiom lemma_incorrect_polarity_makes_clause_unsat_spec : forall c : Type.lib_clause_clause, a : Seq.seq uint8, ix : int, v : uint8 . (forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) && not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix) -> UnsatInner0.unsat_inner (Seq.get (Model0.model c) j) a) -> Invariant0.invariant' c (Seq.length a) -> (exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && SatInner0.sat_inner (Seq.get (Model0.model c) j) a) -> not (SatInner1.sat_inner c a) -> UnitInner0.unit_inner c a -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> not (Unset0.unset v) -> (forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) -> not (Unset0.unset (Seq.get (Seq.set a ix v) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)))))) && not (Unset0.unset (Seq.get (Seq.set a ix (FlipV0.flip_v v)) ix)) && UnsatInner1.unsat_inner c (Seq.set a ix (FlipV0.flip_v v)) && not (SatInner1.sat_inner c (Seq.set a ix (FlipV0.flip_v v)))
end
module Lib_Logic_Logic_LemmaExtensionSatBaseSat_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  function lemma_extension_sat_base_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
end
module Lib_Logic_Logic_LemmaExtensionSatBaseSat
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  function lemma_extension_sat_base_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
  axiom lemma_extension_sat_base_sat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8, ix : int, v : uint8 . EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix v) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> EventuallySatCompleteInner0.eventually_sat_complete_inner f a
end
module Lib_Logic_Logic_LemmaExtensionsUnsatBaseUnsat_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_Logic_Neg_Interface as Neg0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_Logic_Pos_Interface as Pos0
  function lemma_extensions_unsat_base_unsat (a : Seq.seq uint8) (ix : int) (f : Type.lib_formula_formula) : ()
end
module Lib_Logic_Logic_LemmaExtensionsUnsatBaseUnsat
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_Logic_Unset_Interface as Unset0
  clone Lib_Logic_Logic_Neg_Interface as Neg0
  clone Lib_Logic_LogicFormula_Impl1_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_Logic_Pos_Interface as Pos0
  function lemma_extensions_unsat_base_unsat (a : Seq.seq uint8) (ix : int) (f : Type.lib_formula_formula) : ()
  axiom lemma_extensions_unsat_base_unsat_spec : forall a : Seq.seq uint8, ix : int, f : Type.lib_formula_formula . not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (Pos0.pos ()))) -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (Neg0.neg ()))) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f a)
end
module CreusotContracts_Std1_Clone_Clone_Clone_Interface
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    ensures { result = self }
    
end
module CreusotContracts_Std1_Clone_Clone_Clone
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    ensures { result = self }
    
end
module Lib_Clause_Impl0
  use Type
  clone Lib_Clause_Impl0_Clone_Interface as Clone0
  clone CreusotContracts_Std1_Clone_Clone_Clone_Interface as Clone1 with type self = Type.lib_clause_clause,
  val clone' = Clone0.clone'
end
module Core_Cmp_PartialEq_Eq_Interface
  type self   
  type rhs   
  use prelude.Prelude
  val eq [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Core_Cmp_PartialEq_Eq
  type self   
  type rhs   
  use prelude.Prelude
  val eq [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Core_Cmp_PartialEq_Ne_Interface
  type self   
  type rhs   
  use prelude.Prelude
  val ne [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Core_Cmp_PartialEq_Ne
  type self   
  type rhs   
  use prelude.Prelude
  val ne [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Lib_Formula_Impl0
  use Type
  clone Lib_Formula_Impl0_Eq_Interface as Eq0
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.lib_formula_satstate,
  type rhs = Type.lib_formula_satstate, val eq = Eq0.eq
end
module Lib_Lit_Impl1
  use Type
  clone Lib_Lit_Impl1_Eq_Interface as Eq0
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.lib_lit_lit, type rhs = Type.lib_lit_lit,
  val eq = Eq0.eq
end
module Core_Clone_Clone_Clone_Interface
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    requires {false}
    
end
module Core_Clone_Clone_Clone
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    requires {false}
    
end
module Core_Clone_Clone_CloneFrom_Interface
  type self   
  use prelude.Prelude
  val clone_from [@cfg:stackify] (self : borrowed self) (source : self) : ()
    requires {false}
    
end
module Core_Clone_Clone_CloneFrom
  type self   
  use prelude.Prelude
  val clone_from [@cfg:stackify] (self : borrowed self) (source : self) : ()
    requires {false}
    
end
module Lib_Lit_Impl3
  use Type
  clone Lib_Lit_Impl3_Clone_Interface as Clone0
  clone Core_Clone_Clone_Clone_Interface as Clone1 with type self = Type.lib_lit_lit, val clone' = Clone0.clone'
end
module Lib_Lit_Impl4
  
end
module Core_Ops_Bit_Not_Output
  type self   
  type output   
end
module Core_Ops_Bit_Not_Not_Interface
  type self   
  clone Core_Ops_Bit_Not_Output as Output0 with type self = self
  val not' [@cfg:stackify] (self : self) : Output0.output
    requires {false}
    
end
module Core_Ops_Bit_Not_Not
  type self   
  clone Core_Ops_Bit_Not_Output as Output0 with type self = self
  val not' [@cfg:stackify] (self : self) : Output0.output
    requires {false}
    
end
module Lib_Lit_Impl2_Output
  use Type
  type output  = 
    Type.lib_lit_lit
end
module Lib_Lit_Impl2
  use Type
  clone Lib_Lit_Impl2_Not_Interface as Not0
  clone Lib_Lit_Impl2_Output as Output0
  clone Core_Ops_Bit_Not_Not_Interface as Not1 with type self = Type.lib_lit_lit, val not' = Not0.not',
  type Output0.output = Output0.output
  clone Core_Ops_Bit_Not_Output as Output1 with type self = Type.lib_lit_lit, type output = Output0.output
end
module Lib_Logic_LogicAssignments_Impl0
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Logic_LogicAssignments_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicAssignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.lib_assignments_assignments,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.lib_assignments_assignments,
  type modelTy = ModelTy0.modelTy
end
module Lib_Logic_LogicClause_Impl0
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Logic_LogicClause_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicClause_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.lib_clause_clause,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.lib_clause_clause,
  type modelTy = ModelTy0.modelTy
end
module Lib_Logic_LogicFormula_Impl0
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Logic_LogicFormula_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Logic_LogicFormula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.lib_formula_formula,
  function model = Model0.model, type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.lib_formula_formula,
  type modelTy = ModelTy0.modelTy
end
