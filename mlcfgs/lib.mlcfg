module Type
  use Ref
  use mach.int.Int
  use prelude.Int8
  use prelude.Int16
  use mach.int.Int32
  use mach.int.Int64
  use prelude.UInt8
  use prelude.UInt16
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  type creusotcontracts_std1_vec_vec 't  
  type lib_decision_decisions  = 
    | Lib_Decision_Decisions (creusotcontracts_std1_vec_vec usize)
    
  function lib_decision_decisions_Decisions_lit_order (self : lib_decision_decisions) : creusotcontracts_std1_vec_vec usize
    
  val lib_decision_decisions_Decisions_lit_order (self : lib_decision_decisions) : creusotcontracts_std1_vec_vec usize
    ensures { result = lib_decision_decisions_Decisions_lit_order self }
    
  axiom lib_decision_decisions_Decisions_lit_order_acc : forall a : creusotcontracts_std1_vec_vec usize . lib_decision_decisions_Decisions_lit_order (Lib_Decision_Decisions a : lib_decision_decisions) = a
  type lib_lit_lit  = 
    | Lib_Lit_Lit usize bool
    
  function lib_lit_lit_Lit_idx (self : lib_lit_lit) : usize
  val lib_lit_lit_Lit_idx (self : lib_lit_lit) : usize
    ensures { result = lib_lit_lit_Lit_idx self }
    
  axiom lib_lit_lit_Lit_idx_acc : forall a : usize, b : bool . lib_lit_lit_Lit_idx (Lib_Lit_Lit a b : lib_lit_lit) = a
  function lib_lit_lit_Lit_polarity (self : lib_lit_lit) : bool
  val lib_lit_lit_Lit_polarity (self : lib_lit_lit) : bool
    ensures { result = lib_lit_lit_Lit_polarity self }
    
  axiom lib_lit_lit_Lit_polarity_acc : forall a : usize, b : bool . lib_lit_lit_Lit_polarity (Lib_Lit_Lit a b : lib_lit_lit) = b
  type lib_clause_clause  = 
    | Lib_Clause_Clause (creusotcontracts_std1_vec_vec (lib_lit_lit))
    
  function lib_clause_clause_Clause_rest (self : lib_clause_clause) : creusotcontracts_std1_vec_vec (lib_lit_lit)
  val lib_clause_clause_Clause_rest (self : lib_clause_clause) : creusotcontracts_std1_vec_vec (lib_lit_lit)
    ensures { result = lib_clause_clause_Clause_rest self }
    
  axiom lib_clause_clause_Clause_rest_acc : forall a : creusotcontracts_std1_vec_vec (lib_lit_lit) . lib_clause_clause_Clause_rest (Lib_Clause_Clause a : lib_clause_clause) = a
  type lib_formula_formula  = 
    | Lib_Formula_Formula (creusotcontracts_std1_vec_vec (lib_clause_clause)) usize
    
  function lib_formula_formula_Formula_clauses (self : lib_formula_formula) : creusotcontracts_std1_vec_vec (lib_clause_clause)
    
  val lib_formula_formula_Formula_clauses (self : lib_formula_formula) : creusotcontracts_std1_vec_vec (lib_clause_clause)
    ensures { result = lib_formula_formula_Formula_clauses self }
    
  axiom lib_formula_formula_Formula_clauses_acc : forall a : creusotcontracts_std1_vec_vec (lib_clause_clause), b : usize . lib_formula_formula_Formula_clauses (Lib_Formula_Formula a b : lib_formula_formula) = a
  function lib_formula_formula_Formula_num_vars (self : lib_formula_formula) : usize
  val lib_formula_formula_Formula_num_vars (self : lib_formula_formula) : usize
    ensures { result = lib_formula_formula_Formula_num_vars self }
    
  axiom lib_formula_formula_Formula_num_vars_acc : forall a : creusotcontracts_std1_vec_vec (lib_clause_clause), b : usize . lib_formula_formula_Formula_num_vars (Lib_Formula_Formula a b : lib_formula_formula) = b
  type lib_trail_reason  = 
    | Lib_Trail_Reason_Undefined
    | Lib_Trail_Reason_Decision
    | Lib_Trail_Reason_Unit
    | Lib_Trail_Reason_Long usize
    
  type lib_assignments_assignments  = 
    | Lib_Assignments_Assignments (creusotcontracts_std1_vec_vec uint8) usize
    
  function lib_assignments_assignments_Assignments_0 (self : lib_assignments_assignments) : creusotcontracts_std1_vec_vec uint8
    
  val lib_assignments_assignments_Assignments_0 (self : lib_assignments_assignments) : creusotcontracts_std1_vec_vec uint8
    ensures { result = lib_assignments_assignments_Assignments_0 self }
    
  axiom lib_assignments_assignments_Assignments_0_acc : forall a : creusotcontracts_std1_vec_vec uint8, b : usize . lib_assignments_assignments_Assignments_0 (Lib_Assignments_Assignments a b : lib_assignments_assignments) = a
  function lib_assignments_assignments_Assignments_1 (self : lib_assignments_assignments) : usize
  val lib_assignments_assignments_Assignments_1 (self : lib_assignments_assignments) : usize
    ensures { result = lib_assignments_assignments_Assignments_1 self }
    
  axiom lib_assignments_assignments_Assignments_1_acc : forall a : creusotcontracts_std1_vec_vec uint8, b : usize . lib_assignments_assignments_Assignments_1 (Lib_Assignments_Assignments a b : lib_assignments_assignments) = b
  type lib_trail_trail  = 
    | Lib_Trail_Trail (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_lit_lit))) (creusotcontracts_std1_vec_vec (usize, lib_trail_reason))
    
  function lib_trail_trail_Trail_trail (self : lib_trail_trail) : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_lit_lit))
    
  val lib_trail_trail_Trail_trail (self : lib_trail_trail) : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_lit_lit))
    ensures { result = lib_trail_trail_Trail_trail self }
    
  axiom lib_trail_trail_Trail_trail_acc : forall a : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_lit_lit)), b : creusotcontracts_std1_vec_vec (usize, lib_trail_reason) . lib_trail_trail_Trail_trail (Lib_Trail_Trail a b : lib_trail_trail) = a
  function lib_trail_trail_Trail_vardata (self : lib_trail_trail) : creusotcontracts_std1_vec_vec (usize, lib_trail_reason)
    
  val lib_trail_trail_Trail_vardata (self : lib_trail_trail) : creusotcontracts_std1_vec_vec (usize, lib_trail_reason)
    ensures { result = lib_trail_trail_Trail_vardata self }
    
  axiom lib_trail_trail_Trail_vardata_acc : forall a : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_lit_lit)), b : creusotcontracts_std1_vec_vec (usize, lib_trail_reason) . lib_trail_trail_Trail_vardata (Lib_Trail_Trail a b : lib_trail_trail) = b
  type lib_watches_watcher  = 
    | Lib_Watches_Watcher usize
    
  function lib_watches_watcher_Watcher_cref (self : lib_watches_watcher) : usize
  val lib_watches_watcher_Watcher_cref (self : lib_watches_watcher) : usize
    ensures { result = lib_watches_watcher_Watcher_cref self }
    
  axiom lib_watches_watcher_Watcher_cref_acc : forall a : usize . lib_watches_watcher_Watcher_cref (Lib_Watches_Watcher a : lib_watches_watcher) = a
  type lib_watches_watches  = 
    | Lib_Watches_Watches (creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher)))
    
  function lib_watches_watches_Watches_watches (self : lib_watches_watches) : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher))
    
  val lib_watches_watches_Watches_watches (self : lib_watches_watches) : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher))
    ensures { result = lib_watches_watches_Watches_watches self }
    
  axiom lib_watches_watches_Watches_watches_acc : forall a : creusotcontracts_std1_vec_vec (creusotcontracts_std1_vec_vec (lib_watches_watcher)) . lib_watches_watches_Watches_watches (Lib_Watches_Watches a : lib_watches_watches) = a
  type core_result_result 't 'e = 
    | Core_Result_Result_Ok 't
    | Core_Result_Result_Err 'e
    
  type core_option_option 't = 
    | Core_Option_Option_None
    | Core_Option_Option_Some 't
    
  function core_option_option_Some_0 (self : core_option_option 't) : 't
  val core_option_option_Some_0 (self : core_option_option 't) : 't
    ensures { result = core_option_option_Some_0 self }
    
  axiom core_option_option_Some_0_acc : forall a : 't . core_option_option_Some_0 (Core_Option_Option_Some a : core_option_option 't) = a
  type core_ops_controlflow_controlflow 'b 'c = 
    | Core_Ops_ControlFlow_ControlFlow_Continue 'c
    | Core_Ops_ControlFlow_ControlFlow_Break 'b
    
  function core_ops_controlflow_controlflow_Break_0 (self : core_ops_controlflow_controlflow 'b 'c) : 'b
  val core_ops_controlflow_controlflow_Break_0 (self : core_ops_controlflow_controlflow 'b 'c) : 'b
    ensures { result = core_ops_controlflow_controlflow_Break_0 self }
    
  axiom core_ops_controlflow_controlflow_Break_0_acc : forall a : 'b . core_ops_controlflow_controlflow_Break_0 (Core_Ops_ControlFlow_ControlFlow_Break a : core_ops_controlflow_controlflow 'b 'c) = a
  function core_ops_controlflow_controlflow_Continue_0 (self : core_ops_controlflow_controlflow 'b 'c) : 'c
  val core_ops_controlflow_controlflow_Continue_0 (self : core_ops_controlflow_controlflow 'b 'c) : 'c
    ensures { result = core_ops_controlflow_controlflow_Continue_0 self }
    
  axiom core_ops_controlflow_controlflow_Continue_0_acc : forall a : 'c . core_ops_controlflow_controlflow_Continue_0 (Core_Ops_ControlFlow_ControlFlow_Continue a : core_ops_controlflow_controlflow 'b 'c) = a
  type core_convert_infallible  = 
    
  type lib_clause_clausestate  = 
    | Lib_Clause_ClauseState_Sat
    | Lib_Clause_ClauseState_Unsat
    | Lib_Clause_ClauseState_Unit
    | Lib_Clause_ClauseState_Unknown
    | Lib_Clause_ClauseState_Err usize
    
  type creusotcontracts_logic_ghost_ghost 't = 
    | CreusotContracts_Logic_Ghost_Ghost opaque_ptr
    
  type lib_formula_satstate  = 
    | Lib_Formula_SatState_Unknown
    | Lib_Formula_SatState_Sat
    | Lib_Formula_SatState_Unsat
    
  type lib_conflictanalysis_conflict  = 
    | Lib_ConflictAnalysis_Conflict_Ground
    | Lib_ConflictAnalysis_Conflict_Unit (lib_lit_lit)
    | Lib_ConflictAnalysis_Conflict_Learned usize (lib_lit_lit) (lib_clause_clause)
    | Lib_ConflictAnalysis_Conflict_Panic
    
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface
  type self   
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve
  type self   
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve_Interface
  type t   
  use prelude.Prelude
  predicate resolve (self : borrowed t)
end
module CreusotContracts_Logic_Resolve_Impl1_Resolve
  type t   
  use prelude.Prelude
  predicate resolve (self : borrowed t) = 
     ^ self =  * self
end
module CreusotContracts_Logic_Resolve_Impl1
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = t
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = borrowed t,
  predicate resolve = Resolve0.resolve
end
module Lib_Decision_Impl1_MoveToFront_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val move_to_front [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (tomove : usize) : ()
end
module Lib_Decision_Impl1_MoveToFront
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = usize
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = Type.lib_decision_decisions
  let rec cfg move_to_front [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (tomove : usize) : () = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_decision_decisions);
  var tomove_2 : usize;
  {
    self_1 <- self;
    tomove_2 <- tomove;
    goto BB0
  }
  BB0 {
    _0 <- ();
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve tomove_2 };
    return _0
  }
  
end
module Lib_Decision_Impl1_IncrementAndMove_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val increment_and_move [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (f : Type.lib_formula_formula) (cref : usize) : ()
    
end
module Lib_Decision_Impl1_IncrementAndMove
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve2 with type self = usize
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = Type.lib_decision_decisions
  let rec cfg increment_and_move [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (f : Type.lib_formula_formula) (cref : usize) : ()
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_decision_decisions);
  var f_2 : Type.lib_formula_formula;
  var cref_3 : usize;
  {
    self_1 <- self;
    f_2 <- f;
    cref_3 <- cref;
    goto BB0
  }
  BB0 {
    _0 <- ();
    assume { Resolve0.resolve self_1 };
    assume { Resolve1.resolve f_2 };
    assume { Resolve2.resolve cref_3 };
    return _0
  }
  
end
module Core_Default_Default_Default_Interface
  type self   
  val default [@cfg:stackify] () : self
    requires {false}
    
end
module Core_Default_Default_Default
  type self   
  val default [@cfg:stackify] () : self
    requires {false}
    
end
module Lib_Trail_Impl0_Default_Interface
  use Type
  val default [@cfg:stackify] () : Type.lib_trail_reason
end
module Lib_Trail_Impl0_Default
  use Type
  let rec cfg default [@cfg:stackify] () : Type.lib_trail_reason = 
  var _0 : Type.lib_trail_reason;
  {
    goto BB0
  }
  BB0 {
    _0 <- Type.Lib_Trail_Reason_Undefined;
    return _0
  }
  
end
module Lib_Trail_Impl0
  use Type
  clone Lib_Trail_Impl0_Default_Interface as Default0
  clone Core_Default_Default_Default_Interface as Default1 with type self = Type.lib_trail_reason,
  val default = Default0.default
end
module Core_Ops_Index_Index_Output
  type self   
  type idx   
  type output   
end
module Core_Ops_Index_Index_Index_Interface
  type self   
  type idx   
  use prelude.Prelude
  clone Core_Ops_Index_Index_Output as Output0 with type self = self, type idx = idx
  val index [@cfg:stackify] (self : self) (index : idx) : Output0.output
    requires {false}
    
end
module Core_Ops_Index_Index_Index
  type self   
  type idx   
  use prelude.Prelude
  clone Core_Ops_Index_Index_Output as Output0 with type self = self, type idx = idx
  val index [@cfg:stackify] (self : self) (index : idx) : Output0.output
    requires {false}
    
end
module CreusotContracts_Std1_Vec_Impl3_Output
  type t   
  type output  = 
    t
end
module CreusotContracts_Logic_Model_Model_ModelTy
  type self   
  type modelTy   
end
module CreusotContracts_Logic_Model_Model_Model_Interface
  type self   
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Model_Model
  type self   
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = self
  function model (self : self) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0_ModelTy
  type t   
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  type modelTy  = 
    ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0_Model_Interface
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  function model (self : t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl0_Model
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : t) : ModelTy0.modelTy = 
    Model0.model self
end
module CreusotContracts_Logic_Model_Impl0
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy2 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model as Model2 with type self = t, type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = t, type ModelTy0.modelTy = ModelTy2.modelTy,
  function Model0.model = Model2.model
  clone CreusotContracts_Logic_Model_Impl0_ModelTy as ModelTy0 with type t = t, type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = t, type ModelTy0.modelTy = ModelTy0.modelTy,
  function model = Model0.model
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = t, type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Std1_Vec_Impl0_ModelTy
  type t   
  use seq.Seq
  type modelTy  = 
    Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_Model_Interface
  type t   
  use Type
  use seq.Seq
  function model (self : Type.creusotcontracts_std1_vec_vec t) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0_Model
  type t   
  use Type
  use seq.Seq
  function model (self : Type.creusotcontracts_std1_vec_vec t) : Seq.seq t
end
module CreusotContracts_Std1_Vec_Impl0
  type t   
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function model = Model0.model
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.creusotcontracts_std1_vec_vec t,
  type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Std1_Vec_Impl3_Index_Interface
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val index [@cfg:stackify] (self : Type.creusotcontracts_std1_vec_vec t) (ix : usize) : t
    requires {UInt64.to_int ix < Seq.length (Model0.model self)}
    ensures { result = Seq.get (Model0.model self) (UInt64.to_int ix) }
    
end
module CreusotContracts_Std1_Vec_Impl3_Index
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val index [@cfg:stackify] (self : Type.creusotcontracts_std1_vec_vec t) (ix : usize) : t
    requires {UInt64.to_int ix < Seq.length (Model0.model self)}
    ensures { result = Seq.get (Model0.model self) (UInt64.to_int ix) }
    
end
module CreusotContracts_Std1_Vec_Impl3
  type t   
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = t, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl3_Output as Output0 with type t = t
  clone Core_Ops_Index_Index_Index_Interface as Index1 with type self = Type.creusotcontracts_std1_vec_vec t,
  type idx = usize, type Output0.output = Output0.output, val index = Index0.index
  clone Core_Ops_Index_Index_Output as Output1 with type self = Type.creusotcontracts_std1_vec_vec t, type idx = usize,
  type output = Output0.output
end
module Lib_Lit_Impl1_Invariant_Interface
  use Type
  use mach.int.Int
  predicate invariant' (self : Type.lib_lit_lit) (n : int)
end
module Lib_Lit_Impl1_Invariant
  use Type
  use mach.int.Int
  use mach.int.UInt64
  predicate invariant' (self : Type.lib_lit_lit) (n : int) = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < n
end
module Lib_Assignments_Impl0_ModelTy
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  type modelTy  = 
    Seq.seq uint8
end
module Lib_Assignments_Impl0_Model_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function model (self : Type.lib_assignments_assignments) : Seq.seq uint8
end
module Lib_Assignments_Impl0_Model
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = uint8
  function model (self : Type.lib_assignments_assignments) : Seq.seq uint8 = 
    Model0.model (Type.lib_assignments_assignments_Assignments_0 self)
end
module Lib_Assignments_Impl0
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function model = Model0.model
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.lib_assignments_assignments,
  type modelTy = ModelTy0.modelTy
end
module Lib_Lit_Impl1_UnsetInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unset_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8)
end
module Lib_Lit_Impl1_UnsetInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  use mach.int.Int32
  predicate unset_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8) = 
    UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) >= 2
end
module Lib_Lit_Impl1_Unset_Interface
  use Type
  predicate unset (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments)
end
module Lib_Lit_Impl1_Unset
  use Type
  clone Lib_Lit_Impl1_UnsetInner_Interface as UnsetInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate unset (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) = 
    UnsetInner0.unset_inner self (Model0.model a)
end
module Lib_Lit_Impl2_LitUnset_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Lit_Impl1_Unset_Interface as Unset0
  clone Lib_Lit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val lit_unset [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unset0.unset self a }
    
end
module Lib_Lit_Impl2_LitUnset
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Lit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Lit_Impl1_Unset as Unset0 with function Model0.model = Model1.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone Lib_Lit_Impl1_Invariant as Invariant0
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val lit_unset [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unset0.unset self a }
    
end
module Core_Ops_Index_IndexMut_IndexMut_Interface
  type self   
  type idx   
  use prelude.Prelude
  clone Core_Ops_Index_Index_Output as Output0 with type self = self, type idx = idx
  val index_mut [@cfg:stackify] (self : borrowed self) (index : idx) : borrowed Output0.output
    requires {false}
    
end
module Core_Ops_Index_IndexMut_IndexMut
  type self   
  type idx   
  use prelude.Prelude
  clone Core_Ops_Index_Index_Output as Output0 with type self = self, type idx = idx
  val index_mut [@cfg:stackify] (self : borrowed self) (index : idx) : borrowed Output0.output
    requires {false}
    
end
module CreusotContracts_Logic_Model_Impl1_ModelTy
  type t   
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  type modelTy  = 
    ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl1_Model_Interface
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  function model (self : borrowed t) : ModelTy0.modelTy
end
module CreusotContracts_Logic_Model_Impl1_Model
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy0 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model_Interface as Model0 with type self = t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  function model (self : borrowed t) : ModelTy0.modelTy = 
    Model0.model ( * self)
end
module CreusotContracts_Logic_Model_Impl1
  type t   
  use prelude.Prelude
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy2 with type self = t
  clone CreusotContracts_Logic_Model_Model_Model as Model2 with type self = t, type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Impl1_Model as Model0 with type t = t, type ModelTy0.modelTy = ModelTy2.modelTy,
  function Model0.model = Model2.model
  clone CreusotContracts_Logic_Model_Impl1_ModelTy as ModelTy0 with type t = t, type ModelTy0.modelTy = ModelTy2.modelTy
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = borrowed t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function model = Model0.model
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = borrowed t,
  type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val index_mut [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (ix : usize) : borrowed t
    requires {UInt64.to_int ix < Seq.length (Model0.model ( * self))}
    ensures { Seq.length (Model0.model ( * self)) = Seq.length (Model0.model ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model0.model ( ^ self)) -> not (j = UInt64.to_int ix) -> Seq.get (Model0.model ( ^ self)) j = Seq.get (Model0.model ( * self)) j }
    ensures {  ^ result = Seq.get (Model0.model ( ^ self)) (UInt64.to_int ix) }
    ensures {  * result = Seq.get (Model1.model self) (UInt64.to_int ix) }
    
end
module CreusotContracts_Std1_Vec_Impl2_IndexMut
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  val index_mut [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (ix : usize) : borrowed t
    requires {UInt64.to_int ix < Seq.length (Model0.model ( * self))}
    ensures { Seq.length (Model0.model ( * self)) = Seq.length (Model0.model ( ^ self)) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model0.model ( ^ self)) -> not (j = UInt64.to_int ix) -> Seq.get (Model0.model ( ^ self)) j = Seq.get (Model0.model ( * self)) j }
    ensures {  ^ result = Seq.get (Model0.model ( ^ self)) (UInt64.to_int ix) }
    ensures {  * result = Seq.get (Model1.model self) (UInt64.to_int ix) }
    
end
module CreusotContracts_Std1_Vec_Impl2
  type t   
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl3_Output as Output0 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = t,
  function Model0.model = Model0.model, function Model1.model = Model1.model
  clone Core_Ops_Index_IndexMut_IndexMut_Interface as IndexMut1 with type self = Type.creusotcontracts_std1_vec_vec t,
  type idx = usize, type Output0.output = Output0.output, val index_mut = IndexMut0.index_mut
end
module CreusotContracts_Std1_Vec_Impl1_Len_Interface
  type t   
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val len [@cfg:stackify] (self : Type.creusotcontracts_std1_vec_vec t) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model self) }
    
end
module CreusotContracts_Std1_Vec_Impl1_Len
  type t   
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val len [@cfg:stackify] (self : Type.creusotcontracts_std1_vec_vec t) : usize
    ensures { UInt64.to_int result = Seq.length (Model0.model self) }
    
end
module CreusotContracts_Std1_Vec_Impl1_Swap_Interface
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use seq.Permut
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val swap [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (i : usize) (j : usize) : ()
    requires {UInt64.to_int j < Seq.length (Model0.model self)}
    requires {UInt64.to_int i < Seq.length (Model0.model self)}
    ensures { Permut.exchange (Model1.model ( ^ self)) (Model1.model ( * self)) (UInt64.to_int i) (UInt64.to_int j) }
    
end
module CreusotContracts_Std1_Vec_Impl1_Swap
  type t   
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use seq.Permut
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val swap [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (i : usize) (j : usize) : ()
    requires {UInt64.to_int j < Seq.length (Model0.model self)}
    requires {UInt64.to_int i < Seq.length (Model0.model self)}
    ensures { Permut.exchange (Model1.model ( ^ self)) (Model1.model ( * self)) (UInt64.to_int i) (UInt64.to_int j) }
    
end
module CreusotContracts_Std1_Vec_Impl1_Pop_Interface
  type t   
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val pop [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) : Type.core_option_option t
    ensures { match (result) with
      | Type.Core_Option_Option_Some t -> t = Seq.get (Model0.model ( * self)) (Seq.length (Model0.model ( * self)) - 1)
      | Type.Core_Option_Option_None -> Seq.length (Model0.model ( * self)) = 0
      end }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model ( ^ self)) -> Seq.get (Model0.model ( ^ self)) i = Seq.get (Model1.model self) i }
    ensures { match (result) with
      | Type.Core_Option_Option_Some _ -> Seq.length (Model0.model ( * self)) = Seq.length (Model0.model ( ^ self)) + 1
      | Type.Core_Option_Option_None -> Seq.length (Model0.model ( * self)) = Seq.length (Model0.model ( ^ self))
      end }
    ensures { match (result) with
      | Type.Core_Option_Option_Some t -> Model1.model self = Seq.snoc (Model0.model ( ^ self)) t
      | Type.Core_Option_Option_None -> Seq.length (Model1.model self) = Seq.length (Model0.model ( ^ self)) && Seq.length (Model1.model self) = 0
      end }
    
end
module CreusotContracts_Std1_Vec_Impl1_Pop
  type t   
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  val pop [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) : Type.core_option_option t
    ensures { match (result) with
      | Type.Core_Option_Option_Some t -> t = Seq.get (Model0.model ( * self)) (Seq.length (Model0.model ( * self)) - 1)
      | Type.Core_Option_Option_None -> Seq.length (Model0.model ( * self)) = 0
      end }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model ( ^ self)) -> Seq.get (Model0.model ( ^ self)) i = Seq.get (Model1.model self) i }
    ensures { match (result) with
      | Type.Core_Option_Option_Some _ -> Seq.length (Model0.model ( * self)) = Seq.length (Model0.model ( ^ self)) + 1
      | Type.Core_Option_Option_None -> Seq.length (Model0.model ( * self)) = Seq.length (Model0.model ( ^ self))
      end }
    ensures { match (result) with
      | Type.Core_Option_Option_Some t -> Model1.model self = Seq.snoc (Model0.model ( ^ self)) t
      | Type.Core_Option_Option_None -> Seq.length (Model1.model self) = Seq.length (Model0.model ( ^ self)) && Seq.length (Model1.model self) = 0
      end }
    
end
module Lib_Lit_Impl0_ToNegWatchidxLogic_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  function to_neg_watchidx_logic (self : Type.lib_lit_lit) : int
end
module Lib_Lit_Impl0_ToNegWatchidxLogic
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  use mach.int.Int32
  function to_neg_watchidx_logic (self : Type.lib_lit_lit) : int = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then 1 else 0)
end
module Lib_Lit_Impl2_ToNegWatchidx_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Lit_Impl0_ToNegWatchidxLogic_Interface as ToNegWatchidxLogic0
  val to_neg_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      1
    else
      0
    ) }
    ensures { UInt64.to_int result = ToNegWatchidxLogic0.to_neg_watchidx_logic self }
    
end
module Lib_Lit_Impl2_ToNegWatchidx
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Lit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  val to_neg_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      1
    else
      0
    ) }
    ensures { UInt64.to_int result = ToNegWatchidxLogic0.to_neg_watchidx_logic self }
    
end
module CreusotContracts_Std1_Vec_Impl1_Push_Interface
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val push [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (v : t) : ()
    ensures { Seq.get (Model0.model ( ^ self)) (Seq.length (Model0.model ( ^ self)) - 1) = v }
    ensures { Seq.length (Model1.model self) + 1 = Seq.length (Model0.model ( ^ self)) }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model1.model self) -> Seq.get (Model1.model self) i = Seq.get (Model0.model ( ^ self)) i }
    ensures { Model0.model ( ^ self) = Seq.snoc (Model1.model self) v }
    
end
module CreusotContracts_Std1_Vec_Impl1_Push
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  val push [@cfg:stackify] (self : borrowed (Type.creusotcontracts_std1_vec_vec t)) (v : t) : ()
    ensures { Seq.get (Model0.model ( ^ self)) (Seq.length (Model0.model ( ^ self)) - 1) = v }
    ensures { Seq.length (Model1.model self) + 1 = Seq.length (Model0.model ( ^ self)) }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model1.model self) -> Seq.get (Model1.model self) i = Seq.get (Model0.model ( ^ self)) i }
    ensures { Model0.model ( ^ self) = Seq.snoc (Model1.model self) v }
    
end
module Lib_Lit_Impl1_SatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate sat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8)
end
module Lib_Lit_Impl1_SatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  use mach.int.Int32
  predicate sat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8) = 
    if Type.lib_lit_lit_Lit_polarity self then
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 1
    else
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 0
    
end
module Lib_Lit_Impl1_Sat_Interface
  use Type
  predicate sat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments)
end
module Lib_Lit_Impl1_Sat
  use Type
  clone Lib_Lit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) = 
    SatInner0.sat_inner self (Model0.model a)
end
module Lib_Lit_Impl2_LitSat_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Lit_Impl1_Sat_Interface as Sat0
  clone Lib_Lit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val lit_sat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Sat0.sat self a }
    
end
module Lib_Lit_Impl2_LitSat
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Lit_Impl1_Invariant as Invariant0
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val lit_sat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Sat0.sat self a }
    
end
module Lib_UnitProp_UnitPropCheckRest_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val unit_prop_check_rest [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (j : usize) (k : usize) (watchidx : usize) (first_lit : Type.lib_lit_lit) (second_lit : Type.lib_lit_lit) (lit : Type.lib_lit_lit) : Type.core_result_result () ()
    
end
module Lib_UnitProp_UnitPropCheckRest
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  use mach.int.Int64
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model14 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model13 with function Model0.model = Model14.model
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model13.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Lit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Lit_Impl1_Unset as Unset0 with function Model0.model = Model13.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve15 with type self = bool
  clone Lib_Lit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  clone Lib_Lit_Impl2_ToNegWatchidx_Interface as ToNegWatchidx0 with function ToNegWatchidxLogic0.to_neg_watchidx_logic = ToNegWatchidxLogic0.to_neg_watchidx_logic
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve14 with type self = Type.lib_watches_watcher
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve13 with type self = Type.core_option_option (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve12 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve11 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model12 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy4 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Logic_Model_Impl1_Model as Model11 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  type ModelTy0.modelTy = ModelTy4.modelTy, function Model0.model = Model12.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model12.model, function Model1.model = Model11.model
  clone CreusotContracts_Std1_Vec_Impl1_Pop_Interface as Pop0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model12.model, function Model1.model = Model11.model
  clone CreusotContracts_Std1_Vec_Impl1_Swap_Interface as Swap0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model11.model, function Model1.model = Model12.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model8 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  type ModelTy0.modelTy = ModelTy4.modelTy, function Model0.model = Model12.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model8.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve10 with type self = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Model_Impl1_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model9.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model9.model, function Model1.model = Model10.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model7 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model9.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model7.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve9 with type self = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve8 with type t = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve6 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve5 with type t = Type.lib_assignments_assignments
  clone Lib_Assignments_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Logic_Model_Impl0_Model as Model2 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model13.model
  clone Lib_Lit_Impl1_Invariant as Invariant0
  clone Lib_Lit_Impl2_LitSat_Interface as LitSat0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate Sat0.sat = Sat0.sat
  clone Lib_Lit_Impl2_LitUnset_Interface as LitUnset0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve4 with type self = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve3 with type self = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl1_Model as Model6 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut1 with type t = Type.lib_lit_lit,
  function Model0.model = Model5.model, function Model1.model = Model6.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_lit_lit,
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve2 with type self = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Model_Impl1_Model as Model4 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = Type.lib_clause_clause,
  function Model0.model = Model3.model, function Model1.model = Model4.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_clause_clause,
  function Model0.model = Model0.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = usize
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve0 with type t = Type.lib_trail_trail
  let rec cfg unit_prop_check_rest [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (cref : usize) (j : usize) (k : usize) (watchidx : usize) (first_lit : Type.lib_lit_lit) (second_lit : Type.lib_lit_lit) (lit : Type.lib_lit_lit) : Type.core_result_result () ()
    
   = 
  var _0 : Type.core_result_result () ();
  var f_1 : borrowed (Type.lib_formula_formula);
  var a_2 : borrowed (Type.lib_assignments_assignments);
  var trail_3 : borrowed (Type.lib_trail_trail);
  var watches_4 : borrowed (Type.lib_watches_watches);
  var cref_5 : usize;
  var j_6 : usize;
  var k_7 : usize;
  var watchidx_8 : usize;
  var first_lit_9 : Type.lib_lit_lit;
  var second_lit_10 : Type.lib_lit_lit;
  var lit_11 : Type.lib_lit_lit;
  var _12 : ();
  var curr_lit_13 : Type.lib_lit_lit;
  var _14 : Type.lib_lit_lit;
  var _15 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _16 : Type.lib_clause_clause;
  var _17 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _18 : usize;
  var _19 : usize;
  var _20 : ();
  var _21 : bool;
  var _22 : bool;
  var _23 : Type.lib_lit_lit;
  var _24 : Type.lib_assignments_assignments;
  var _25 : bool;
  var _26 : Type.lib_lit_lit;
  var _27 : Type.lib_assignments_assignments;
  var _28 : ();
  var _29 : ();
  var _30 : bool;
  var _31 : usize;
  var _32 : usize;
  var _33 : Type.lib_lit_lit;
  var _34 : borrowed (Type.lib_lit_lit);
  var _35 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _36 : borrowed (Type.lib_clause_clause);
  var _37 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _38 : usize;
  var _39 : Type.lib_lit_lit;
  var _40 : borrowed (Type.lib_lit_lit);
  var _41 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _42 : borrowed (Type.lib_clause_clause);
  var _43 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _44 : usize;
  var _45 : usize;
  var _46 : Type.lib_lit_lit;
  var _47 : borrowed (Type.lib_lit_lit);
  var _48 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _49 : borrowed (Type.lib_clause_clause);
  var _50 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _51 : usize;
  var _52 : Type.lib_lit_lit;
  var _53 : borrowed (Type.lib_lit_lit);
  var _54 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _55 : borrowed (Type.lib_clause_clause);
  var _56 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _57 : usize;
  var _58 : usize;
  var _59 : Type.lib_lit_lit;
  var _60 : borrowed (Type.lib_lit_lit);
  var _61 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _62 : borrowed (Type.lib_clause_clause);
  var _63 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _64 : usize;
  var end'_65 : usize;
  var _66 : usize;
  var _67 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _68 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _69 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _70 : usize;
  var _71 : ();
  var _72 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _73 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _74 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)));
  var _75 : usize;
  var _76 : usize;
  var _77 : usize;
  var _78 : ();
  var _79 : Type.core_option_option (Type.lib_watches_watcher);
  var _80 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _81 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _82 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)));
  var _83 : usize;
  var _84 : isize;
  var w_85 : Type.lib_watches_watcher;
  var _86 : ();
  var _87 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _88 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _89 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)));
  var _90 : usize;
  var _91 : Type.lib_lit_lit;
  var _92 : Type.lib_watches_watcher;
  var _93 : ();
  var _94 : ();
  var _95 : ();
  var _96 : ();
  {
    f_1 <- f;
    a_2 <- a;
    trail_3 <- trail;
    watches_4 <- watches;
    cref_5 <- cref;
    j_6 <- j;
    k_7 <- k;
    watchidx_8 <- watchidx;
    first_lit_9 <- first_lit;
    second_lit_10 <- second_lit;
    lit_11 <- lit;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve trail_3 };
    _17 <- Type.lib_formula_formula_Formula_clauses ( * f_1);
    assume { Resolve1.resolve _18 };
    _18 <- cref_5;
    _16 <- Index0.index _17 _18;
    goto BB1
  }
  BB1 {
    _15 <- Type.lib_clause_clause_Clause_rest _16;
    assume { Resolve2.resolve _16 };
    assume { Resolve1.resolve _19 };
    _19 <- k_7;
    _14 <- Index1.index _15 _19;
    goto BB2
  }
  BB2 {
    assume { Resolve3.resolve curr_lit_13 };
    curr_lit_13 <- _14;
    assume { Resolve4.resolve _14 };
    assume { Resolve3.resolve _23 };
    _23 <- curr_lit_13;
    _24 <-  * a_2;
    _22 <- LitUnset0.lit_unset _23 _24;
    goto BB6
  }
  BB3 {
    assume { Resolve5.resolve a_2 };
    _21 <- true;
    goto BB5
  }
  BB4 {
    assume { Resolve3.resolve _26 };
    _26 <- curr_lit_13;
    _27 <-  * a_2;
    assume { Resolve5.resolve a_2 };
    _25 <- LitSat0.lit_sat _26 _27;
    goto BB7
  }
  BB5 {
    switch (_21)
      | False -> goto BB34
      | _ -> goto BB8
      end
  }
  BB6 {
    switch (_22)
      | False -> goto BB4
      | _ -> goto BB3
      end
  }
  BB7 {
    assume { Resolve15.resolve _21 };
    _21 <- _25;
    goto BB5
  }
  BB8 {
    assume { Resolve1.resolve _31 };
    _31 <- Type.lib_lit_lit_Lit_idx first_lit_9;
    assume { Resolve1.resolve _32 };
    _32 <- Type.lib_lit_lit_Lit_idx lit_11;
    assume { Resolve3.resolve lit_11 };
    _30 <- _31 = _32;
    switch (_30)
      | False -> goto BB14
      | _ -> goto BB9
      end
  }
  BB9 {
    assume { Resolve3.resolve second_lit_10 };
    assume { Resolve3.resolve _33 };
    _33 <- curr_lit_13;
    _37 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Type.Lib_Formula_Formula a b =  * f_1 in Type.Lib_Formula_Formula ( ^ _37) b) };
    assume { Resolve1.resolve _38 };
    _38 <- cref_5;
    _36 <- IndexMut0.index_mut _37 _38;
    goto BB10
  }
  BB10 {
    _35 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * _36));
    _36 <- { _36 with current = (let Type.Lib_Clause_Clause a =  * _36 in Type.Lib_Clause_Clause ( ^ _35)) };
    assume { Resolve6.resolve _36 };
    _34 <- IndexMut1.index_mut _35 (0 : usize);
    goto BB11
  }
  BB11 {
    assume { Resolve3.resolve ( * _34) };
    _34 <- { _34 with current = _33 };
    assume { Resolve7.resolve _34 };
    assume { Resolve3.resolve _39 };
    _39 <- first_lit_9;
    assume { Resolve3.resolve first_lit_9 };
    _43 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Type.Lib_Formula_Formula a b =  * f_1 in Type.Lib_Formula_Formula ( ^ _43) b) };
    assume { Resolve8.resolve f_1 };
    assume { Resolve1.resolve _44 };
    _44 <- cref_5;
    assume { Resolve1.resolve cref_5 };
    _42 <- IndexMut0.index_mut _43 _44;
    goto BB12
  }
  BB12 {
    _41 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * _42));
    _42 <- { _42 with current = (let Type.Lib_Clause_Clause a =  * _42 in Type.Lib_Clause_Clause ( ^ _41)) };
    assume { Resolve6.resolve _42 };
    assume { Resolve1.resolve _45 };
    _45 <- k_7;
    assume { Resolve1.resolve k_7 };
    _40 <- IndexMut1.index_mut _41 _45;
    goto BB13
  }
  BB13 {
    assume { Resolve3.resolve ( * _40) };
    _40 <- { _40 with current = _39 };
    assume { Resolve7.resolve _40 };
    _29 <- ();
    assume { Resolve9.resolve _29 };
    goto BB21
  }
  BB14 {
    assume { Resolve3.resolve _46 };
    _46 <- curr_lit_13;
    _50 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Type.Lib_Formula_Formula a b =  * f_1 in Type.Lib_Formula_Formula ( ^ _50) b) };
    assume { Resolve1.resolve _51 };
    _51 <- cref_5;
    _49 <- IndexMut0.index_mut _50 _51;
    goto BB15
  }
  BB15 {
    _48 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * _49));
    _49 <- { _49 with current = (let Type.Lib_Clause_Clause a =  * _49 in Type.Lib_Clause_Clause ( ^ _48)) };
    assume { Resolve6.resolve _49 };
    _47 <- IndexMut1.index_mut _48 (0 : usize);
    goto BB16
  }
  BB16 {
    assume { Resolve3.resolve ( * _47) };
    _47 <- { _47 with current = _46 };
    assume { Resolve7.resolve _47 };
    assume { Resolve3.resolve _52 };
    _52 <- second_lit_10;
    assume { Resolve3.resolve second_lit_10 };
    _56 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Type.Lib_Formula_Formula a b =  * f_1 in Type.Lib_Formula_Formula ( ^ _56) b) };
    assume { Resolve1.resolve _57 };
    _57 <- cref_5;
    _55 <- IndexMut0.index_mut _56 _57;
    goto BB17
  }
  BB17 {
    _54 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * _55));
    _55 <- { _55 with current = (let Type.Lib_Clause_Clause a =  * _55 in Type.Lib_Clause_Clause ( ^ _54)) };
    assume { Resolve6.resolve _55 };
    assume { Resolve1.resolve _58 };
    _58 <- k_7;
    assume { Resolve1.resolve k_7 };
    _53 <- IndexMut1.index_mut _54 _58;
    goto BB18
  }
  BB18 {
    assume { Resolve3.resolve ( * _53) };
    _53 <- { _53 with current = _52 };
    assume { Resolve7.resolve _53 };
    assume { Resolve3.resolve _59 };
    _59 <- first_lit_9;
    assume { Resolve3.resolve first_lit_9 };
    _63 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Type.Lib_Formula_Formula a b =  * f_1 in Type.Lib_Formula_Formula ( ^ _63) b) };
    assume { Resolve8.resolve f_1 };
    assume { Resolve1.resolve _64 };
    _64 <- cref_5;
    assume { Resolve1.resolve cref_5 };
    _62 <- IndexMut0.index_mut _63 _64;
    goto BB19
  }
  BB19 {
    _61 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * _62));
    _62 <- { _62 with current = (let Type.Lib_Clause_Clause a =  * _62 in Type.Lib_Clause_Clause ( ^ _61)) };
    assume { Resolve6.resolve _62 };
    _60 <- IndexMut1.index_mut _61 (1 : usize);
    goto BB20
  }
  BB20 {
    assume { Resolve3.resolve ( * _60) };
    _60 <- { _60 with current = _59 };
    assume { Resolve7.resolve _60 };
    _29 <- ();
    assume { Resolve9.resolve _29 };
    goto BB21
  }
  BB21 {
    _69 <- Type.lib_watches_watches_Watches_watches ( * watches_4);
    assume { Resolve1.resolve _70 };
    _70 <- watchidx_8;
    _68 <- Index2.index _69 _70;
    goto BB22
  }
  BB22 {
    _67 <- _68;
    assume { Resolve10.resolve _68 };
    _66 <- Len0.len _67;
    goto BB23
  }
  BB23 {
    end'_65 <- _66 - (1 : usize);
    _74 <- borrow_mut (Type.lib_watches_watches_Watches_watches ( * watches_4));
    watches_4 <- { watches_4 with current = (let Type.Lib_Watches_Watches a =  * watches_4 in Type.Lib_Watches_Watches ( ^ _74)) };
    assume { Resolve1.resolve _75 };
    _75 <- watchidx_8;
    _73 <- IndexMut2.index_mut _74 _75;
    goto BB24
  }
  BB24 {
    _72 <- borrow_mut ( * _73);
    _73 <- { _73 with current = ( ^ _72) };
    assume { Resolve1.resolve _76 };
    _76 <- j_6;
    assume { Resolve1.resolve j_6 };
    assume { Resolve1.resolve _77 };
    _77 <- end'_65;
    assume { Resolve1.resolve end'_65 };
    _71 <- Swap0.swap _72 _76 _77;
    goto BB25
  }
  BB25 {
    assume { Resolve11.resolve _73 };
    _82 <- borrow_mut (Type.lib_watches_watches_Watches_watches ( * watches_4));
    watches_4 <- { watches_4 with current = (let Type.Lib_Watches_Watches a =  * watches_4 in Type.Lib_Watches_Watches ( ^ _82)) };
    assume { Resolve1.resolve _83 };
    _83 <- watchidx_8;
    assume { Resolve1.resolve watchidx_8 };
    _81 <- IndexMut2.index_mut _82 _83;
    goto BB26
  }
  BB26 {
    _80 <- borrow_mut ( * _81);
    _81 <- { _81 with current = ( ^ _80) };
    _79 <- Pop0.pop _80;
    goto BB27
  }
  BB27 {
    assume { Resolve11.resolve _81 };
    switch (_79)
      | Type.Core_Option_Option_None -> goto BB28
      | Type.Core_Option_Option_Some _ -> goto BB30
      end
  }
  BB28 {
    assume { Resolve12.resolve watches_4 };
    assume { Resolve3.resolve curr_lit_13 };
    assume { Resolve13.resolve _79 };
    absurd
  }
  BB29 {
    assume { Resolve12.resolve watches_4 };
    assume { Resolve3.resolve curr_lit_13 };
    assume { Resolve13.resolve _79 };
    absurd
  }
  BB30 {
    assume { Resolve14.resolve w_85 };
    w_85 <- Type.core_option_option_Some_0 _79;
    assume { Resolve13.resolve _79 };
    _89 <- borrow_mut (Type.lib_watches_watches_Watches_watches ( * watches_4));
    watches_4 <- { watches_4 with current = (let Type.Lib_Watches_Watches a =  * watches_4 in Type.Lib_Watches_Watches ( ^ _89)) };
    assume { Resolve12.resolve watches_4 };
    _91 <- curr_lit_13;
    assume { Resolve3.resolve curr_lit_13 };
    _90 <- ToNegWatchidx0.to_neg_watchidx _91;
    goto BB31
  }
  BB31 {
    _88 <- IndexMut2.index_mut _89 _90;
    goto BB32
  }
  BB32 {
    _87 <- borrow_mut ( * _88);
    _88 <- { _88 with current = ( ^ _87) };
    assume { Resolve14.resolve _92 };
    _92 <- w_85;
    _86 <- Push0.push _87 _92;
    goto BB33
  }
  BB33 {
    assume { Resolve11.resolve _88 };
    _78 <- ();
    assume { Resolve9.resolve _78 };
    _95 <- ();
    _0 <- Type.Core_Result_Result_Err _95;
    goto BB35
  }
  BB34 {
    assume { Resolve8.resolve f_1 };
    assume { Resolve12.resolve watches_4 };
    assume { Resolve1.resolve cref_5 };
    assume { Resolve1.resolve j_6 };
    assume { Resolve1.resolve k_7 };
    assume { Resolve1.resolve watchidx_8 };
    assume { Resolve3.resolve first_lit_9 };
    assume { Resolve3.resolve second_lit_10 };
    assume { Resolve3.resolve lit_11 };
    assume { Resolve3.resolve curr_lit_13 };
    _20 <- ();
    assume { Resolve9.resolve _20 };
    _96 <- ();
    _0 <- Type.Core_Result_Result_Ok _96;
    goto BB35
  }
  BB35 {
    return _0
  }
  
end
module Lib_Assignments_Impl1_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_assignments_assignments) (f : Type.lib_formula_formula)
end
module Lib_Assignments_Impl1_Invariant
  use Type
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate invariant' (self : Type.lib_assignments_assignments) (f : Type.lib_formula_formula) = 
    UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length (Model0.model self) && UInt64.to_int (Type.lib_assignments_assignments_Assignments_1 self) <= UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)
end
module Lib_Assignments_Impl2_SetAssignment_Interface
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.UInt8
  use prelude.Prelude
  use Type
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant0
  clone Lib_Assignments_Impl0_Model_Interface as Model1
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val set_assignment [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {0 <= UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) && UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < Seq.length (Model0.model self)}
    ensures { Seq.length (Model1.model ( ^ self)) = Seq.length (Model0.model self) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model1.model ( * self)) j = Seq.get (Model1.model ( ^ self)) j }
    ensures { if Type.lib_lit_lit_Lit_polarity lit then
      UInt8.to_int (Seq.get (Model1.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 1
    else
      UInt8.to_int (Seq.get (Model1.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 0
     }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model1.model ( * self)) j = Seq.get (Model1.model ( ^ self)) j }
    ensures { UInt8.to_int (Seq.get (Model1.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 1 || UInt8.to_int (Seq.get (Model1.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 0 }
    ensures { Invariant0.invariant' ( ^ self) _f }
    ensures { Invariant0.invariant' ( * self) _f }
    
end
module Lib_Assignments_Impl2_SetAssignment
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.UInt8
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Assignments_Impl1_Invariant as Invariant0 with function Model0.model = Model1.model
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val set_assignment [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {0 <= UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) && UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < Seq.length (Model0.model self)}
    ensures { Seq.length (Model1.model ( ^ self)) = Seq.length (Model0.model self) }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model1.model ( * self)) j = Seq.get (Model1.model ( ^ self)) j }
    ensures { if Type.lib_lit_lit_Lit_polarity lit then
      UInt8.to_int (Seq.get (Model1.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 1
    else
      UInt8.to_int (Seq.get (Model1.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 0
     }
    ensures { forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model1.model ( * self)) j = Seq.get (Model1.model ( ^ self)) j }
    ensures { UInt8.to_int (Seq.get (Model1.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 1 || UInt8.to_int (Seq.get (Model1.model ( ^ self)) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit))) = 0 }
    ensures { Invariant0.invariant' ( ^ self) _f }
    ensures { Invariant0.invariant' ( * self) _f }
    
end
module Lib_Clause_Impl1_ModelTy
  use seq.Seq
  use Type
  type modelTy  = 
    Seq.seq (Type.lib_lit_lit)
end
module Lib_Clause_Impl1_Model_Interface
  use Type
  use seq.Seq
  function model (self : Type.lib_clause_clause) : Seq.seq (Type.lib_lit_lit)
end
module Lib_Clause_Impl1_Model
  use Type
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_lit_lit
  function model (self : Type.lib_clause_clause) : Seq.seq (Type.lib_lit_lit) = 
    Model0.model (Type.lib_clause_clause_Clause_rest self)
end
module Lib_Clause_Impl1
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Clause_Impl1_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy0.modelTy, function model = Model0.model
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.lib_clause_clause,
  type modelTy = ModelTy0.modelTy
end
module Lib_Lit_Impl1_UnsatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unsat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8)
end
module Lib_Lit_Impl1_UnsatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  use mach.int.Int32
  predicate unsat_inner (self : Type.lib_lit_lit) (a : Seq.seq uint8) = 
    if Type.lib_lit_lit_Lit_polarity self then
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 0
    else
      UInt8.to_int (Seq.get a (UInt64.to_int (Type.lib_lit_lit_Lit_idx self))) = 1
    
end
module Lib_Clause_Impl2_PostUnitInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate post_unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Clause_Impl2_PostUnitInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Lit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Lit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate post_unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && SatInner0.sat_inner (Seq.get (Model0.model self) i) a && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> i -> UnsatInner0.unsat_inner (Seq.get (Model0.model self) j) a)
end
module Lib_Clause_Impl2_PostUnit_Interface
  use Type
  predicate post_unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Clause_Impl2_PostUnit
  use Type
  clone Lib_Clause_Impl2_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate post_unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    PostUnitInner0.post_unit_inner self (Model0.model a)
end
module Lib_Trail_TrailInvariant_Interface
  use seq.Seq
  use Type
  predicate trail_invariant (trail : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit))) (f : Type.lib_formula_formula)
    
end
module Lib_Trail_TrailInvariant
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_lit_lit
  predicate trail_invariant (trail : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit))) (f : Type.lib_formula_formula)
    
   = 
    forall i : (int) . 0 <= i && i < Seq.length trail -> (forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Seq.get trail i)) -> 0 <= UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model (Seq.get trail i)) j)) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model (Seq.get trail i)) j)) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f))
end
module Lib_Trail_VardataInvariant_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  predicate vardata_invariant (vardata : Seq.seq (usize, Type.lib_trail_reason)) (n : int)
end
module Lib_Trail_VardataInvariant
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  predicate vardata_invariant (vardata : Seq.seq (usize, Type.lib_trail_reason)) (n : int) = 
    Seq.length vardata = n
end
module Lib_Trail_CrefsInRange_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  predicate crefs_in_range (vardata : Seq.seq (usize, Type.lib_trail_reason)) (f : Type.lib_formula_formula)
end
module Lib_Trail_CrefsInRange
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  use mach.int.Int32
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate crefs_in_range (vardata : Seq.seq (usize, Type.lib_trail_reason)) (f : Type.lib_formula_formula) = 
    forall j : (int) . 0 <= j && j < Seq.length vardata -> match (let (_, a) = Seq.get vardata j in a) with
      | Type.Lib_Trail_Reason_Long k -> 0 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))
      | _ -> true
      end
end
module Lib_Trail_TrailInvariantFull_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate trail_invariant_full (trail : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit))) (vardata : Seq.seq (usize, Type.lib_trail_reason)) (f : Type.lib_formula_formula)
    
end
module Lib_Trail_TrailInvariantFull
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Trail_CrefsInRange_Interface as CrefsInRange0
  clone Lib_Trail_VardataInvariant_Interface as VardataInvariant0
  clone Lib_Trail_TrailInvariant_Interface as TrailInvariant0
  predicate trail_invariant_full (trail : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit))) (vardata : Seq.seq (usize, Type.lib_trail_reason)) (f : Type.lib_formula_formula)
    
   = 
    TrailInvariant0.trail_invariant trail f && VardataInvariant0.vardata_invariant vardata (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && CrefsInRange0.crefs_in_range vardata f
end
module Lib_Trail_Impl2_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Trail_Impl2_Invariant
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Trail_TrailInvariantFull_Interface as TrailInvariantFull0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  predicate invariant' (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    TrailInvariantFull0.trail_invariant_full (Model0.model (Type.lib_trail_trail_Trail_trail self)) (Model1.model (Type.lib_trail_trail_Trail_vardata self)) f
end
module Lib_Trail_LongArePostUnit_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  predicate long_are_post_unit (vardata : Seq.seq (usize, Type.lib_trail_reason)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
    
end
module Lib_Trail_LongArePostUnit
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  use mach.int.Int32
  clone Lib_Lit_Impl1_Sat_Interface as Sat0
  clone Lib_Clause_Impl1_Model_Interface as Model1
  clone Lib_Clause_Impl2_PostUnit_Interface as PostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate long_are_post_unit (vardata : Seq.seq (usize, Type.lib_trail_reason)) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
    
   = 
    forall j : (int) . 0 <= j && j < Seq.length vardata -> match (let (_, a) = Seq.get vardata j in a) with
      | Type.Lib_Trail_Reason_Long k -> PostUnit0.post_unit (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k)) a && (exists i : (int) . 0 <= i && i < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) i)) = j && Sat0.sat (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int k))) i) a)
      | _ -> true
      end
end
module Lib_Trail_Impl2_TrailSemInvariant_Interface
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = (usize, Type.lib_trail_reason)
  predicate trail_sem_invariant (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
    
end
module Lib_Trail_Impl2_TrailSemInvariant
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = (usize, Type.lib_trail_reason)
  predicate trail_sem_invariant (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
    
   = 
    LongArePostUnit0.long_are_post_unit (Model0.model (Type.lib_trail_trail_Trail_vardata self)) f a
  axiom trail_sem_invariant_spec : forall self : Type.lib_trail_trail, f : Type.lib_formula_formula, a : Type.lib_assignments_assignments . trail_sem_invariant self f a = LongArePostUnit0.long_are_post_unit (Model0.model (Type.lib_trail_trail_Trail_vardata self)) f a
end
module Lib_Trail_Impl2_TrailSemInvariant_Impl
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model3 with function Model0.model = Model5.model
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model2 with function Model0.model = Model4.model
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model3.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model1.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model2.model,
  predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = (usize, Type.lib_trail_reason)
  let rec ghost function trail_sem_invariant (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) : bool
    ensures { result = LongArePostUnit0.long_are_post_unit (Model0.model (Type.lib_trail_trail_Trail_vardata self)) f a }
    
   = 
    let a' = let a' = Type.lib_trail_trail_Trail_vardata self in Model0.model a' in LongArePostUnit0.long_are_post_unit a' f a
end
module Lib_Trail_Impl3_EnqAssignment_Interface
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model4 with type t = Type.lib_lit_lit
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model3 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model3.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Lit_Impl1_Sat_Interface as Sat0
  clone Lib_Clause_Impl1_Model_Interface as Model1
  clone Lib_Clause_Impl2_PostUnit_Interface as PostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val enq_assignment [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (lit : Type.lib_lit_lit) (reason : Type.lib_trail_reason) (_f : Type.lib_formula_formula) (_a : Type.lib_assignments_assignments) : ()
    requires {match (reason) with
      | Type.Lib_Trail_Reason_Undefined -> true
      | Type.Lib_Trail_Reason_Decision -> true
      | Type.Lib_Trail_Reason_Unit -> true
      | Type.Lib_Trail_Reason_Long k -> 0 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) && PostUnit0.post_unit (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k)) _a && (exists i : (int) . 0 <= i && i < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k))) && Type.lib_lit_lit_Lit_polarity (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k))) i) = Type.lib_lit_lit_Lit_polarity lit && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k))) i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) && Sat0.sat (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k))) i) _a)
      end}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) > 0}
    requires {0 <= UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) && UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {Invariant0.invariant' ( * self) _f}
    requires {TrailSemInvariant0.trail_sem_invariant ( * self) _f _a}
    ensures { (let (_, a) = Seq.get (Model3.model (Type.lib_trail_trail_Trail_vardata ( ^ self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) in a) = reason }
    ensures { UInt64.to_int (let (a, _) = Seq.get (Model3.model (Type.lib_trail_trail_Trail_vardata ( ^ self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) in a) = Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) - 1 }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model3.model (Type.lib_trail_trail_Trail_vardata ( * self))) && i <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model3.model (Type.lib_trail_trail_Trail_vardata ( * self))) i = Seq.get (Model3.model (Type.lib_trail_trail_Trail_vardata ( ^ self))) i }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) - 1 -> Seq.get (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) i = Seq.get (Model2.model (Type.lib_trail_trail_Trail_trail ( ^ self))) i }
    ensures { Model4.model (Seq.get (Model2.model (Type.lib_trail_trail_Trail_trail ( ^ self))) (Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) - 1)) = Seq.snoc (Model4.model (Seq.get (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) (Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) - 1))) lit }
    ensures { Seq.length (Model3.model (Type.lib_trail_trail_Trail_vardata ( ^ self))) = Seq.length (Model3.model (Type.lib_trail_trail_Trail_vardata ( * self))) }
    ensures { Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( ^ self))) = Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ self) _f _a }
    
end
module Lib_Trail_Impl3_EnqAssignment
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model5 with function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model4.model
  clone Lib_Clause_Impl1_Model as Model1 with function Model0.model = Model4.model
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model5.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model0.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model2.model,
  function Model1.model = Model3.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model0.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model1.model,
  predicate Sat0.sat = Sat0.sat
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model3.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val enq_assignment [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (lit : Type.lib_lit_lit) (reason : Type.lib_trail_reason) (_f : Type.lib_formula_formula) (_a : Type.lib_assignments_assignments) : ()
    requires {match (reason) with
      | Type.Lib_Trail_Reason_Undefined -> true
      | Type.Lib_Trail_Reason_Decision -> true
      | Type.Lib_Trail_Reason_Unit -> true
      | Type.Lib_Trail_Reason_Long k -> 0 <= UInt64.to_int k && UInt64.to_int k < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) && PostUnit0.post_unit (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k)) _a && (exists i : (int) . 0 <= i && i < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k))) && Type.lib_lit_lit_Lit_polarity (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k))) i) = Type.lib_lit_lit_Lit_polarity lit && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k))) i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) && Sat0.sat (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses _f)) (UInt64.to_int k))) i) _a)
      end}
    requires {Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) > 0}
    requires {0 <= UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) && UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {Invariant0.invariant' ( * self) _f}
    requires {TrailSemInvariant0.trail_sem_invariant ( * self) _f _a}
    ensures { (let (_, a) = Seq.get (Model3.model (Type.lib_trail_trail_Trail_vardata ( ^ self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) in a) = reason }
    ensures { UInt64.to_int (let (a, _) = Seq.get (Model3.model (Type.lib_trail_trail_Trail_vardata ( ^ self))) (UInt64.to_int (Type.lib_lit_lit_Lit_idx lit)) in a) = Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) - 1 }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model3.model (Type.lib_trail_trail_Trail_vardata ( * self))) && i <> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) -> Seq.get (Model3.model (Type.lib_trail_trail_Trail_vardata ( * self))) i = Seq.get (Model3.model (Type.lib_trail_trail_Trail_vardata ( ^ self))) i }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) - 1 -> Seq.get (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) i = Seq.get (Model2.model (Type.lib_trail_trail_Trail_trail ( ^ self))) i }
    ensures { Model4.model (Seq.get (Model2.model (Type.lib_trail_trail_Trail_trail ( ^ self))) (Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) - 1)) = Seq.snoc (Model4.model (Seq.get (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) (Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) - 1))) lit }
    ensures { Seq.length (Model3.model (Type.lib_trail_trail_Trail_vardata ( ^ self))) = Seq.length (Model3.model (Type.lib_trail_trail_Trail_vardata ( * self))) }
    ensures { Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( ^ self))) = Seq.length (Model2.model (Type.lib_trail_trail_Trail_trail ( * self))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ self) _f _a }
    
end
module Lib_UnitProp_UnitPropDoOuter_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val unit_prop_do_outer [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (j : usize) (watchidx : usize) (lit : Type.lib_lit_lit) : Type.core_result_result bool usize
    
end
module Lib_UnitProp_UnitPropDoOuter
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  use prelude.UInt8
  use mach.int.Int64
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model17 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model11 with function Model0.model = Model17.model
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model11.model
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model11.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model16 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model15 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model14 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model13 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve16 with type self = uint8
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve15 with type self = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy5 with type t = uint8
  clone CreusotContracts_Logic_Model_Impl0_Model as Model9 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy5.modelTy, function Model0.model = Model17.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index4 with type t = uint8,
  function Model0.model = Model9.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve14 with type self = Type.core_result_result () ()
  clone Lib_UnitProp_UnitPropCheckRest_Interface as UnitPropCheckRest0
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve13 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model7.model
  clone Lib_Clause_Impl1_Model as Model12 with function Model0.model = Model7.model
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model12.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model11.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve12 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model5.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Trail_Impl2_Invariant as Invariant2 with function Model0.model = Model13.model,
  function Model1.model = Model14.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model5.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model12.model,
  predicate Sat0.sat = Sat0.sat
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model14.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone Lib_Trail_Impl3_EnqAssignment_Interface as EnqAssignment0 with function Model0.model = Model5.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model12.model,
  predicate Sat0.sat = Sat0.sat, function Model2.model = Model13.model,
  predicate Invariant0.invariant' = Invariant2.invariant',
  predicate TrailSemInvariant0.trail_sem_invariant = TrailSemInvariant0.trail_sem_invariant,
  function Model3.model = Model14.model, function Model4.model = Model7.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve11 with type self = ()
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve10 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve9 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve8 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_formula_formula
  clone Lib_Assignments_Impl0_ModelTy as ModelTy4
  clone CreusotContracts_Logic_Model_Impl1_Model as Model10 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy4.modelTy, function Model0.model = Model11.model
  clone Lib_Assignments_Impl2_SetAssignment_Interface as SetAssignment0 with function Model0.model = Model10.model,
  function Model1.model = Model11.model, predicate Invariant0.invariant' = Invariant1.invariant'
  clone CreusotContracts_Logic_Model_Impl0_Model as Model4 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy4.modelTy, function Model0.model = Model11.model
  clone Lib_Lit_Impl1_Invariant as Invariant0
  clone Lib_Lit_Impl2_LitSat_Interface as LitSat0 with function Model0.model = Model4.model,
  predicate Invariant0.invariant' = Invariant0.invariant', predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve6 with type self = borrowed (Type.lib_assignments_assignments)
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve5 with type self = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve4 with type self = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy3 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl1_Model as Model8 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model7.model
  clone CreusotContracts_Std1_Vec_Impl1_Swap_Interface as Swap0 with type t = Type.lib_lit_lit,
  function Model0.model = Model8.model, function Model1.model = Model7.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut1 with type t = Type.lib_lit_lit,
  function Model0.model = Model7.model, function Model1.model = Model8.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model7.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_lit_lit,
  function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index3 with type t = Type.lib_lit_lit,
  function Model0.model = Model3.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve3 with type self = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Logic_Model_Impl1_Model as Model6 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = Type.lib_clause_clause,
  function Model0.model = Model5.model, function Model1.model = Model6.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause),
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index2 with type t = Type.lib_clause_clause,
  function Model0.model = Model2.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve2 with type self = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model16.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_watches_watcher,
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model15.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model0.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve0 with type self = usize
  let rec cfg unit_prop_do_outer [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (j : usize) (watchidx : usize) (lit : Type.lib_lit_lit) : Type.core_result_result bool usize
    
   = 
  var _0 : Type.core_result_result bool usize;
  var f_1 : borrowed (Type.lib_formula_formula);
  var a_2 : borrowed (Type.lib_assignments_assignments);
  var trail_3 : borrowed (Type.lib_trail_trail);
  var watches_4 : borrowed (Type.lib_watches_watches);
  var j_5 : usize;
  var watchidx_6 : usize;
  var lit_7 : Type.lib_lit_lit;
  var _8 : ();
  var cref_9 : usize;
  var _10 : Type.lib_watches_watcher;
  var _11 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _12 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _13 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _14 : usize;
  var _15 : usize;
  var first_lit_16 : Type.lib_lit_lit;
  var _17 : Type.lib_lit_lit;
  var _18 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _19 : Type.lib_clause_clause;
  var _20 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _21 : usize;
  var _22 : ();
  var _23 : bool;
  var _24 : Type.lib_lit_lit;
  var _25 : Type.lib_assignments_assignments;
  var _26 : borrowed (Type.lib_assignments_assignments);
  var _27 : ();
  var second_lit_28 : Type.lib_lit_lit;
  var _29 : Type.lib_lit_lit;
  var _30 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _31 : Type.lib_clause_clause;
  var _32 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _33 : usize;
  var _34 : ();
  var _35 : bool;
  var _36 : Type.lib_lit_lit;
  var _37 : Type.lib_assignments_assignments;
  var _38 : borrowed (Type.lib_assignments_assignments);
  var _39 : ();
  var _40 : Type.lib_lit_lit;
  var _41 : borrowed (Type.lib_lit_lit);
  var _42 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _43 : borrowed (Type.lib_clause_clause);
  var _44 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _45 : usize;
  var _46 : Type.lib_lit_lit;
  var _47 : borrowed (Type.lib_lit_lit);
  var _48 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _49 : borrowed (Type.lib_clause_clause);
  var _50 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _51 : usize;
  var k_52 : usize;
  var clause_len_53 : usize;
  var _54 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _55 : Type.lib_clause_clause;
  var _56 : Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause);
  var _57 : usize;
  var _58 : ();
  var _59 : ();
  var _60 : bool;
  var _61 : usize;
  var _62 : usize;
  var _63 : ();
  var _64 : Type.core_result_result () ();
  var _65 : borrowed (Type.lib_formula_formula);
  var _66 : borrowed (Type.lib_assignments_assignments);
  var _67 : borrowed (Type.lib_trail_trail);
  var _68 : borrowed (Type.lib_watches_watches);
  var _69 : usize;
  var _70 : usize;
  var _71 : usize;
  var _72 : usize;
  var _73 : Type.lib_lit_lit;
  var _74 : Type.lib_lit_lit;
  var _75 : Type.lib_lit_lit;
  var _76 : isize;
  var _77 : ();
  var _78 : ();
  var _79 : ();
  var _80 : ();
  var _81 : ();
  var _82 : bool;
  var _83 : uint8;
  var _84 : uint8;
  var _85 : Type.creusotcontracts_std1_vec_vec uint8;
  var _86 : usize;
  var _87 : ();
  var _88 : borrowed (Type.lib_assignments_assignments);
  var _89 : Type.lib_lit_lit;
  var _90 : Type.lib_formula_formula;
  var _91 : ();
  var _92 : borrowed (Type.lib_trail_trail);
  var _93 : Type.lib_lit_lit;
  var _94 : Type.lib_trail_reason;
  var _95 : usize;
  var _96 : Type.lib_formula_formula;
  var _97 : Type.lib_assignments_assignments;
  var _98 : bool;
  var _99 : uint8;
  var _100 : uint8;
  var _101 : Type.creusotcontracts_std1_vec_vec uint8;
  var _102 : usize;
  var _103 : ();
  var _104 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _105 : borrowed (Type.lib_clause_clause);
  var _106 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.lib_clause_clause));
  var _107 : usize;
  var _108 : ();
  var _109 : borrowed (Type.lib_assignments_assignments);
  var _110 : Type.lib_lit_lit;
  var _111 : Type.lib_formula_formula;
  var _112 : ();
  var _113 : borrowed (Type.lib_trail_trail);
  var _114 : Type.lib_lit_lit;
  var _115 : Type.lib_trail_reason;
  var _116 : usize;
  var _117 : Type.lib_formula_formula;
  var _118 : Type.lib_assignments_assignments;
  var _119 : ();
  var _120 : usize;
  {
    f_1 <- f;
    a_2 <- a;
    trail_3 <- trail;
    watches_4 <- watches;
    j_5 <- j;
    watchidx_6 <- watchidx;
    lit_7 <- lit;
    goto BB0
  }
  BB0 {
    _13 <- Type.lib_watches_watches_Watches_watches ( * watches_4);
    assume { Resolve0.resolve _14 };
    _14 <- watchidx_6;
    _12 <- Index0.index _13 _14;
    goto BB1
  }
  BB1 {
    _11 <- _12;
    assume { Resolve1.resolve _12 };
    assume { Resolve0.resolve _15 };
    _15 <- j_5;
    _10 <- Index1.index _11 _15;
    goto BB2
  }
  BB2 {
    assume { Resolve0.resolve cref_9 };
    cref_9 <- Type.lib_watches_watcher_Watcher_cref _10;
    assume { Resolve2.resolve _10 };
    _20 <- Type.lib_formula_formula_Formula_clauses ( * f_1);
    assume { Resolve0.resolve _21 };
    _21 <- cref_9;
    _19 <- Index2.index _20 _21;
    goto BB3
  }
  BB3 {
    _18 <- Type.lib_clause_clause_Clause_rest _19;
    assume { Resolve3.resolve _19 };
    _17 <- Index3.index _18 (0 : usize);
    goto BB4
  }
  BB4 {
    assume { Resolve4.resolve first_lit_16 };
    first_lit_16 <- _17;
    assume { Resolve5.resolve _17 };
    assume { Resolve4.resolve _24 };
    _24 <- first_lit_16;
    _26 <- a_2;
    _25 <-  * _26;
    assume { Resolve6.resolve _26 };
    _23 <- LitSat0.lit_sat _24 _25;
    goto BB5
  }
  BB5 {
    switch (_23)
      | False -> goto BB7
      | _ -> goto BB6
      end
  }
  BB6 {
    assume { Resolve7.resolve f_1 };
    assume { Resolve8.resolve a_2 };
    assume { Resolve9.resolve trail_3 };
    assume { Resolve10.resolve watches_4 };
    assume { Resolve0.resolve j_5 };
    assume { Resolve0.resolve watchidx_6 };
    assume { Resolve4.resolve lit_7 };
    assume { Resolve0.resolve cref_9 };
    assume { Resolve4.resolve first_lit_16 };
    _0 <- Type.Core_Result_Result_Ok true;
    goto BB41
  }
  BB7 {
    _22 <- ();
    assume { Resolve11.resolve _22 };
    _32 <- Type.lib_formula_formula_Formula_clauses ( * f_1);
    assume { Resolve0.resolve _33 };
    _33 <- cref_9;
    _31 <- Index2.index _32 _33;
    goto BB8
  }
  BB8 {
    _30 <- Type.lib_clause_clause_Clause_rest _31;
    assume { Resolve3.resolve _31 };
    _29 <- Index3.index _30 (1 : usize);
    goto BB9
  }
  BB9 {
    assume { Resolve4.resolve second_lit_28 };
    second_lit_28 <- _29;
    assume { Resolve5.resolve _29 };
    assume { Resolve4.resolve _36 };
    _36 <- second_lit_28;
    _38 <- a_2;
    _37 <-  * _38;
    assume { Resolve6.resolve _38 };
    _35 <- LitSat0.lit_sat _36 _37;
    goto BB10
  }
  BB10 {
    switch (_35)
      | False -> goto BB16
      | _ -> goto BB11
      end
  }
  BB11 {
    assume { Resolve8.resolve a_2 };
    assume { Resolve9.resolve trail_3 };
    assume { Resolve10.resolve watches_4 };
    assume { Resolve0.resolve j_5 };
    assume { Resolve0.resolve watchidx_6 };
    assume { Resolve4.resolve lit_7 };
    assume { Resolve4.resolve _40 };
    _40 <- second_lit_28;
    assume { Resolve4.resolve second_lit_28 };
    _44 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Type.Lib_Formula_Formula a b =  * f_1 in Type.Lib_Formula_Formula ( ^ _44) b) };
    assume { Resolve0.resolve _45 };
    _45 <- cref_9;
    _43 <- IndexMut0.index_mut _44 _45;
    goto BB12
  }
  BB12 {
    _42 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * _43));
    _43 <- { _43 with current = (let Type.Lib_Clause_Clause a =  * _43 in Type.Lib_Clause_Clause ( ^ _42)) };
    assume { Resolve12.resolve _43 };
    _41 <- IndexMut1.index_mut _42 (0 : usize);
    goto BB13
  }
  BB13 {
    assume { Resolve4.resolve ( * _41) };
    _41 <- { _41 with current = _40 };
    assume { Resolve13.resolve _41 };
    assume { Resolve4.resolve _46 };
    _46 <- first_lit_16;
    assume { Resolve4.resolve first_lit_16 };
    _50 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Type.Lib_Formula_Formula a b =  * f_1 in Type.Lib_Formula_Formula ( ^ _50) b) };
    assume { Resolve7.resolve f_1 };
    assume { Resolve0.resolve _51 };
    _51 <- cref_9;
    assume { Resolve0.resolve cref_9 };
    _49 <- IndexMut0.index_mut _50 _51;
    goto BB14
  }
  BB14 {
    _48 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * _49));
    _49 <- { _49 with current = (let Type.Lib_Clause_Clause a =  * _49 in Type.Lib_Clause_Clause ( ^ _48)) };
    assume { Resolve12.resolve _49 };
    _47 <- IndexMut1.index_mut _48 (1 : usize);
    goto BB15
  }
  BB15 {
    assume { Resolve4.resolve ( * _47) };
    _47 <- { _47 with current = _46 };
    assume { Resolve13.resolve _47 };
    _0 <- Type.Core_Result_Result_Ok true;
    goto BB40
  }
  BB16 {
    _34 <- ();
    assume { Resolve11.resolve _34 };
    k_52 <- (2 : usize);
    _56 <- Type.lib_formula_formula_Formula_clauses ( * f_1);
    assume { Resolve0.resolve _57 };
    _57 <- cref_9;
    _55 <- Index2.index _56 _57;
    goto BB17
  }
  BB17 {
    _54 <- Type.lib_clause_clause_Clause_rest _55;
    assume { Resolve3.resolve _55 };
    clause_len_53 <- Len0.len _54;
    goto BB18
  }
  BB18 {
    goto BB19
  }
  BB19 {
    assume { Resolve0.resolve _61 };
    _61 <- k_52;
    assume { Resolve0.resolve _62 };
    _62 <- clause_len_53;
    _60 <- _61 < _62;
    switch (_60)
      | False -> goto BB25
      | _ -> goto BB20
      end
  }
  BB20 {
    _65 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _65) };
    _66 <- borrow_mut ( * a_2);
    a_2 <- { a_2 with current = ( ^ _66) };
    _67 <- borrow_mut ( * trail_3);
    trail_3 <- { trail_3 with current = ( ^ _67) };
    _68 <- borrow_mut ( * watches_4);
    watches_4 <- { watches_4 with current = ( ^ _68) };
    assume { Resolve0.resolve _69 };
    _69 <- cref_9;
    assume { Resolve0.resolve _70 };
    _70 <- j_5;
    assume { Resolve0.resolve _71 };
    _71 <- k_52;
    assume { Resolve0.resolve _72 };
    _72 <- watchidx_6;
    assume { Resolve4.resolve _73 };
    _73 <- first_lit_16;
    assume { Resolve4.resolve _74 };
    _74 <- second_lit_28;
    assume { Resolve4.resolve _75 };
    _75 <- lit_7;
    _64 <- UnitPropCheckRest0.unit_prop_check_rest _65 _66 _67 _68 _69 _70 _71 _72 _73 _74 _75;
    goto BB21
  }
  BB21 {
    assume { Resolve14.resolve _64 };
    switch (_64)
      | Type.Core_Result_Result_Ok _ -> goto BB24
      | Type.Core_Result_Result_Err _ -> goto BB22
      end
  }
  BB22 {
    assume { Resolve7.resolve f_1 };
    assume { Resolve8.resolve a_2 };
    assume { Resolve9.resolve trail_3 };
    assume { Resolve10.resolve watches_4 };
    assume { Resolve0.resolve j_5 };
    assume { Resolve0.resolve watchidx_6 };
    assume { Resolve4.resolve lit_7 };
    assume { Resolve0.resolve cref_9 };
    assume { Resolve4.resolve first_lit_16 };
    assume { Resolve4.resolve second_lit_28 };
    assume { Resolve0.resolve k_52 };
    assume { Resolve0.resolve clause_len_53 };
    _0 <- Type.Core_Result_Result_Ok false;
    goto BB39
  }
  BB23 {
    assume { Resolve7.resolve f_1 };
    assume { Resolve8.resolve a_2 };
    assume { Resolve9.resolve trail_3 };
    assume { Resolve10.resolve watches_4 };
    assume { Resolve0.resolve j_5 };
    assume { Resolve0.resolve watchidx_6 };
    assume { Resolve4.resolve lit_7 };
    assume { Resolve0.resolve cref_9 };
    assume { Resolve4.resolve first_lit_16 };
    assume { Resolve4.resolve second_lit_28 };
    assume { Resolve0.resolve k_52 };
    assume { Resolve0.resolve clause_len_53 };
    absurd
  }
  BB24 {
    _63 <- ();
    assume { Resolve11.resolve _63 };
    k_52 <- k_52 + (1 : usize);
    _59 <- ();
    assume { Resolve11.resolve _59 };
    goto BB19
  }
  BB25 {
    assume { Resolve10.resolve watches_4 };
    assume { Resolve0.resolve j_5 };
    assume { Resolve0.resolve watchidx_6 };
    assume { Resolve4.resolve lit_7 };
    assume { Resolve0.resolve k_52 };
    assume { Resolve0.resolve clause_len_53 };
    _58 <- ();
    assume { Resolve11.resolve _58 };
    _85 <- Type.lib_assignments_assignments_Assignments_0 ( * a_2);
    assume { Resolve0.resolve _86 };
    _86 <- Type.lib_lit_lit_Lit_idx first_lit_16;
    _84 <- Index4.index _85 _86;
    goto BB26
  }
  BB26 {
    assume { Resolve15.resolve _83 };
    _83 <- _84;
    assume { Resolve16.resolve _84 };
    _82 <- _83 >= (2 : uint8);
    switch (_82)
      | False -> goto BB30
      | _ -> goto BB27
      end
  }
  BB27 {
    assume { Resolve4.resolve second_lit_28 };
    _88 <- borrow_mut ( * a_2);
    a_2 <- { a_2 with current = ( ^ _88) };
    assume { Resolve4.resolve _89 };
    _89 <- first_lit_16;
    _90 <-  * f_1;
    _87 <- SetAssignment0.set_assignment _88 _89 _90;
    goto BB28
  }
  BB28 {
    _92 <- borrow_mut ( * trail_3);
    trail_3 <- { trail_3 with current = ( ^ _92) };
    assume { Resolve4.resolve _93 };
    _93 <- first_lit_16;
    assume { Resolve4.resolve first_lit_16 };
    assume { Resolve0.resolve _95 };
    _95 <- cref_9;
    assume { Resolve0.resolve cref_9 };
    _94 <- Type.Lib_Trail_Reason_Long _95;
    _96 <-  * f_1;
    assume { Resolve7.resolve f_1 };
    _97 <-  * a_2;
    assume { Resolve8.resolve a_2 };
    _91 <- EnqAssignment0.enq_assignment _92 _93 _94 _96 _97;
    goto BB29
  }
  BB29 {
    assume { Resolve9.resolve trail_3 };
    _81 <- ();
    assume { Resolve11.resolve _81 };
    goto BB38
  }
  BB30 {
    assume { Resolve4.resolve first_lit_16 };
    _101 <- Type.lib_assignments_assignments_Assignments_0 ( * a_2);
    assume { Resolve0.resolve _102 };
    _102 <- Type.lib_lit_lit_Lit_idx second_lit_28;
    _100 <- Index4.index _101 _102;
    goto BB31
  }
  BB31 {
    assume { Resolve15.resolve _99 };
    _99 <- _100;
    assume { Resolve16.resolve _100 };
    _98 <- _99 >= (2 : uint8);
    switch (_98)
      | False -> goto BB37
      | _ -> goto BB32
      end
  }
  BB32 {
    _106 <- borrow_mut (Type.lib_formula_formula_Formula_clauses ( * f_1));
    f_1 <- { f_1 with current = (let Type.Lib_Formula_Formula a b =  * f_1 in Type.Lib_Formula_Formula ( ^ _106) b) };
    assume { Resolve0.resolve _107 };
    _107 <- cref_9;
    _105 <- IndexMut0.index_mut _106 _107;
    goto BB33
  }
  BB33 {
    _104 <- borrow_mut (Type.lib_clause_clause_Clause_rest ( * _105));
    _105 <- { _105 with current = (let Type.Lib_Clause_Clause a =  * _105 in Type.Lib_Clause_Clause ( ^ _104)) };
    _103 <- Swap0.swap _104 (0 : usize) (1 : usize);
    goto BB34
  }
  BB34 {
    assume { Resolve12.resolve _105 };
    _109 <- borrow_mut ( * a_2);
    a_2 <- { a_2 with current = ( ^ _109) };
    assume { Resolve4.resolve _110 };
    _110 <- second_lit_28;
    _111 <-  * f_1;
    _108 <- SetAssignment0.set_assignment _109 _110 _111;
    goto BB35
  }
  BB35 {
    _113 <- borrow_mut ( * trail_3);
    trail_3 <- { trail_3 with current = ( ^ _113) };
    assume { Resolve4.resolve _114 };
    _114 <- second_lit_28;
    assume { Resolve4.resolve second_lit_28 };
    assume { Resolve0.resolve _116 };
    _116 <- cref_9;
    assume { Resolve0.resolve cref_9 };
    _115 <- Type.Lib_Trail_Reason_Long _116;
    _117 <-  * f_1;
    assume { Resolve7.resolve f_1 };
    _118 <-  * a_2;
    assume { Resolve8.resolve a_2 };
    _112 <- EnqAssignment0.enq_assignment _113 _114 _115 _117 _118;
    goto BB36
  }
  BB36 {
    assume { Resolve9.resolve trail_3 };
    _81 <- ();
    assume { Resolve11.resolve _81 };
    goto BB38
  }
  BB37 {
    assume { Resolve7.resolve f_1 };
    assume { Resolve8.resolve a_2 };
    assume { Resolve9.resolve trail_3 };
    assume { Resolve4.resolve second_lit_28 };
    assume { Resolve0.resolve _120 };
    _120 <- cref_9;
    assume { Resolve0.resolve cref_9 };
    _0 <- Type.Core_Result_Result_Err _120;
    goto BB39
  }
  BB38 {
    _0 <- Type.Core_Result_Result_Ok true;
    goto BB39
  }
  BB39 {
    goto BB40
  }
  BB40 {
    goto BB41
  }
  BB41 {
    return _0
  }
  
end
module Lib_Lit_Impl0_ToWatchidxLogic_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  function to_watchidx_logic (self : Type.lib_lit_lit) : int
end
module Lib_Lit_Impl0_ToWatchidxLogic
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  use mach.int.Int32
  function to_watchidx_logic (self : Type.lib_lit_lit) : int = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then 0 else 1)
end
module Lib_Lit_Impl2_ToWatchidx_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Lit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  val to_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      0
    else
      1
    ) }
    ensures { UInt64.to_int result = ToWatchidxLogic0.to_watchidx_logic self }
    
end
module Lib_Lit_Impl2_ToWatchidx
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Lit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  val to_watchidx [@cfg:stackify] (self : Type.lib_lit_lit) : usize
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx self) < div 18446744073709551615 2}
    ensures { UInt64.to_int result = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) * 2 + (if Type.lib_lit_lit_Lit_polarity self then
      0
    else
      1
    ) }
    ensures { UInt64.to_int result = ToWatchidxLogic0.to_watchidx_logic self }
    
end
module Core_Ops_TryTrait_Try_Output
  type self   
  type output   
end
module Core_Ops_TryTrait_Try_Residual
  type self   
  type residual   
end
module Core_Ops_TryTrait_Try_FromOutput_Interface
  type self   
  clone Core_Ops_TryTrait_Try_Output as Output0 with type self = self
  val from_output [@cfg:stackify] (output : Output0.output) : self
    requires {false}
    
end
module Core_Ops_TryTrait_Try_FromOutput
  type self   
  clone Core_Ops_TryTrait_Try_Output as Output0 with type self = self
  val from_output [@cfg:stackify] (output : Output0.output) : self
    requires {false}
    
end
module Core_Ops_TryTrait_Try_Branch_Interface
  type self   
  use Type
  clone Core_Ops_TryTrait_Try_Output as Output0 with type self = self
  clone Core_Ops_TryTrait_Try_Residual as Residual0 with type self = self
  val branch [@cfg:stackify] (self : self) : Type.core_ops_controlflow_controlflow Residual0.residual Output0.output
    requires {false}
    
end
module Core_Ops_TryTrait_Try_Branch
  type self   
  use Type
  clone Core_Ops_TryTrait_Try_Output as Output0 with type self = self
  clone Core_Ops_TryTrait_Try_Residual as Residual0 with type self = self
  val branch [@cfg:stackify] (self : self) : Type.core_ops_controlflow_controlflow Residual0.residual Output0.output
    requires {false}
    
end
module Core_Result_Impl27_Output
  type t   
  type e   
  type output  = 
    t
end
module Core_Result_Impl27_Residual
  type t   
  type e   
  use Type
  type residual  = 
    Type.core_result_result (Type.core_convert_infallible) e
end
module Core_Result_Impl27_FromOutput_Interface
  type t   
  type e   
  use Type
  val from_output [@cfg:stackify] (output : t) : Type.core_result_result t e
    requires {false}
    
end
module Core_Result_Impl27_FromOutput
  type t   
  type e   
  use Type
  val from_output [@cfg:stackify] (output : t) : Type.core_result_result t e
    requires {false}
    
end
module Core_Result_Impl27_Branch_Interface
  type t   
  type e   
  use Type
  val branch [@cfg:stackify] (self : Type.core_result_result t e) : Type.core_ops_controlflow_controlflow (Type.core_result_result (Type.core_convert_infallible) e) t
    requires {false}
    
end
module Core_Result_Impl27_Branch
  type t   
  type e   
  use Type
  val branch [@cfg:stackify] (self : Type.core_result_result t e) : Type.core_ops_controlflow_controlflow (Type.core_result_result (Type.core_convert_infallible) e) t
    requires {false}
    
end
module Core_Result_Impl27
  type t   
  type e   
  use Type
  clone Core_Result_Impl27_Branch_Interface as Branch0 with type t = t, type e = e
  clone Core_Result_Impl27_FromOutput_Interface as FromOutput0 with type t = t, type e = e
  clone Core_Result_Impl27_Residual as Residual0 with type t = t, type e = e
  clone Core_Ops_TryTrait_Try_Residual as Residual1 with type self = Type.core_result_result t e,
  type residual = Residual0.residual
  clone Core_Result_Impl27_Output as Output0 with type t = t, type e = e
  clone Core_Ops_TryTrait_Try_Branch_Interface as Branch1 with type self = Type.core_result_result t e,
  type Residual0.residual = Residual0.residual, type Output0.output = Output0.output, val branch = Branch0.branch
  clone Core_Ops_TryTrait_Try_FromOutput_Interface as FromOutput1 with type self = Type.core_result_result t e,
  type Output0.output = Output0.output, val from_output = FromOutput0.from_output
  clone Core_Ops_TryTrait_Try_Output as Output1 with type self = Type.core_result_result t e,
  type output = Output0.output
end
module Core_Ops_TryTrait_FromResidual_FromResidual_Interface
  type self   
  type r   
  val from_residual [@cfg:stackify] (residual : r) : self
    requires {false}
    
end
module Core_Ops_TryTrait_FromResidual_FromResidual
  type self   
  type r   
  val from_residual [@cfg:stackify] (residual : r) : self
    requires {false}
    
end
module Core_Result_Impl28_FromResidual_Interface
  type t   
  type e   
  type f   
  use Type
  val from_residual [@cfg:stackify] (residual : Type.core_result_result (Type.core_convert_infallible) e) : Type.core_result_result t f
    requires {false}
    
end
module Core_Result_Impl28_FromResidual
  type t   
  type e   
  type f   
  use Type
  val from_residual [@cfg:stackify] (residual : Type.core_result_result (Type.core_convert_infallible) e) : Type.core_result_result t f
    requires {false}
    
end
module Core_Result_Impl28
  type t   
  type e   
  type f   
  use Type
  clone Core_Result_Impl28_FromResidual_Interface as FromResidual0 with type t = t, type e = e, type f = f
  clone Core_Ops_TryTrait_FromResidual_FromResidual_Interface as FromResidual1 with type self = Type.core_result_result t f,
  type r = Type.core_result_result (Type.core_convert_infallible) e, val from_residual = FromResidual0.from_residual
end
module Lib_UnitProp_UnitPropCurrentLevel_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val unit_prop_current_level [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (i : usize) (d : usize) : Type.core_result_result () usize
    
end
module Lib_UnitProp_UnitPropCurrentLevel
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  use mach.int.Int64
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve12 with type self = ()
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve11 with type self = bool
  clone Core_Result_Impl28_FromResidual_Interface as FromResidual0 with type t = (), type e = usize, type f = usize
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve10 with type self = Type.core_result_result (Type.core_convert_infallible) usize
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve9 with type self = Type.core_ops_controlflow_controlflow (Type.core_result_result (Type.core_convert_infallible) usize) bool
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve8 with type t = Type.lib_watches_watches
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve7 with type t = Type.lib_trail_trail
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve6 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve5 with type t = Type.lib_formula_formula
  clone Core_Result_Impl27_Branch_Interface as Branch0 with type t = bool, type e = usize
  clone Lib_UnitProp_UnitPropDoOuter_Interface as UnitPropDoOuter0
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy3 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Logic_Model_Impl0_Model as Model3 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model7.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_watches_watcher,
  function Model0.model = Model3.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve4 with type self = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone CreusotContracts_Logic_Model_Impl0_Model as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)),
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model6.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher),
  function Model0.model = Model2.model
  clone Lib_Lit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone Lib_Lit_Impl2_ToWatchidx_Interface as ToWatchidx0 with function ToWatchidxLogic0.to_watchidx_logic = ToWatchidxLogic0.to_watchidx_logic
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve3 with type self = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve2 with type self = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = Type.lib_lit_lit,
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  function Model0.model = Model0.model
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve0 with type self = usize
  let rec cfg unit_prop_current_level [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) (i : usize) (d : usize) : Type.core_result_result () usize
    
   = 
  var _0 : Type.core_result_result () usize;
  var f_1 : borrowed (Type.lib_formula_formula);
  var a_2 : borrowed (Type.lib_assignments_assignments);
  var trail_3 : borrowed (Type.lib_trail_trail);
  var watches_4 : borrowed (Type.lib_watches_watches);
  var i_5 : usize;
  var d_6 : usize;
  var j_7 : usize;
  var lit_8 : Type.lib_lit_lit;
  var _9 : Type.lib_lit_lit;
  var _10 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _11 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _12 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _13 : usize;
  var _14 : usize;
  var watchidx_15 : usize;
  var _16 : Type.lib_lit_lit;
  var _17 : ();
  var _18 : ();
  var _19 : bool;
  var _20 : usize;
  var _21 : usize;
  var _22 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _23 : Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher);
  var _24 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher));
  var _25 : usize;
  var _26 : bool;
  var _27 : Type.core_ops_controlflow_controlflow (Type.core_result_result (Type.core_convert_infallible) usize) bool;
  var _28 : Type.core_result_result bool usize;
  var _29 : borrowed (Type.lib_formula_formula);
  var _30 : borrowed (Type.lib_assignments_assignments);
  var _31 : borrowed (Type.lib_trail_trail);
  var _32 : borrowed (Type.lib_watches_watches);
  var _33 : usize;
  var _34 : usize;
  var _35 : Type.lib_lit_lit;
  var _36 : isize;
  var residual_37 : Type.core_result_result (Type.core_convert_infallible) usize;
  var _38 : ();
  var _39 : Type.core_result_result (Type.core_convert_infallible) usize;
  var val'_40 : bool;
  var _41 : ();
  var _42 : ();
  var _43 : ();
  var _44 : ();
  {
    f_1 <- f;
    a_2 <- a;
    trail_3 <- trail;
    watches_4 <- watches;
    i_5 <- i;
    d_6 <- d;
    goto BB0
  }
  BB0 {
    j_7 <- (0 : usize);
    _12 <- Type.lib_trail_trail_Trail_trail ( * trail_3);
    assume { Resolve0.resolve _13 };
    _13 <- d_6;
    assume { Resolve0.resolve d_6 };
    _11 <- Index0.index _12 _13;
    goto BB1
  }
  BB1 {
    _10 <- _11;
    assume { Resolve1.resolve _11 };
    assume { Resolve0.resolve _14 };
    _14 <- i_5;
    assume { Resolve0.resolve i_5 };
    _9 <- Index1.index _10 _14;
    goto BB2
  }
  BB2 {
    assume { Resolve2.resolve lit_8 };
    lit_8 <- _9;
    assume { Resolve3.resolve _9 };
    _16 <- lit_8;
    watchidx_15 <- ToWatchidx0.to_watchidx _16;
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    assume { Resolve0.resolve _20 };
    _20 <- j_7;
    _24 <- Type.lib_watches_watches_Watches_watches ( * watches_4);
    assume { Resolve0.resolve _25 };
    _25 <- watchidx_15;
    _23 <- Index2.index _24 _25;
    goto BB5
  }
  BB5 {
    _22 <- _23;
    assume { Resolve4.resolve _23 };
    _21 <- Len0.len _22;
    goto BB6
  }
  BB6 {
    _19 <- _20 < _21;
    switch (_19)
      | False -> goto BB17
      | _ -> goto BB7
      end
  }
  BB7 {
    _29 <- borrow_mut ( * f_1);
    f_1 <- { f_1 with current = ( ^ _29) };
    _30 <- borrow_mut ( * a_2);
    a_2 <- { a_2 with current = ( ^ _30) };
    _31 <- borrow_mut ( * trail_3);
    trail_3 <- { trail_3 with current = ( ^ _31) };
    _32 <- borrow_mut ( * watches_4);
    watches_4 <- { watches_4 with current = ( ^ _32) };
    assume { Resolve0.resolve _33 };
    _33 <- j_7;
    assume { Resolve0.resolve _34 };
    _34 <- watchidx_15;
    assume { Resolve2.resolve _35 };
    _35 <- lit_8;
    _28 <- UnitPropDoOuter0.unit_prop_do_outer _29 _30 _31 _32 _33 _34 _35;
    goto BB8
  }
  BB8 {
    _27 <- Branch0.branch _28;
    goto BB9
  }
  BB9 {
    switch (_27)
      | Type.Core_Ops_ControlFlow_ControlFlow_Continue _ -> goto BB10
      | Type.Core_Ops_ControlFlow_ControlFlow_Break _ -> goto BB12
      end
  }
  BB10 {
    assume { Resolve11.resolve val'_40 };
    val'_40 <- Type.core_ops_controlflow_controlflow_Continue_0 _27;
    assume { Resolve9.resolve _27 };
    assume { Resolve11.resolve _26 };
    _26 <- val'_40;
    assume { Resolve11.resolve val'_40 };
    switch (_26)
      | False -> goto BB15
      | _ -> goto BB14
      end
  }
  BB11 {
    assume { Resolve5.resolve f_1 };
    assume { Resolve6.resolve a_2 };
    assume { Resolve7.resolve trail_3 };
    assume { Resolve8.resolve watches_4 };
    assume { Resolve0.resolve j_7 };
    assume { Resolve2.resolve lit_8 };
    assume { Resolve0.resolve watchidx_15 };
    assume { Resolve9.resolve _27 };
    absurd
  }
  BB12 {
    assume { Resolve5.resolve f_1 };
    assume { Resolve6.resolve a_2 };
    assume { Resolve7.resolve trail_3 };
    assume { Resolve8.resolve watches_4 };
    assume { Resolve0.resolve j_7 };
    assume { Resolve2.resolve lit_8 };
    assume { Resolve0.resolve watchidx_15 };
    assume { Resolve10.resolve residual_37 };
    residual_37 <- Type.core_ops_controlflow_controlflow_Break_0 _27;
    assume { Resolve9.resolve _27 };
    assume { Resolve10.resolve _39 };
    _39 <- residual_37;
    assume { Resolve10.resolve residual_37 };
    _0 <- FromResidual0.from_residual _39;
    goto BB13
  }
  BB13 {
    goto BB18
  }
  BB14 {
    j_7 <- j_7 + (1 : usize);
    _18 <- ();
    assume { Resolve12.resolve _18 };
    goto BB16
  }
  BB15 {
    _18 <- ();
    assume { Resolve12.resolve _18 };
    goto BB16
  }
  BB16 {
    goto BB4
  }
  BB17 {
    assume { Resolve5.resolve f_1 };
    assume { Resolve6.resolve a_2 };
    assume { Resolve7.resolve trail_3 };
    assume { Resolve8.resolve watches_4 };
    assume { Resolve0.resolve j_7 };
    assume { Resolve2.resolve lit_8 };
    assume { Resolve0.resolve watchidx_15 };
    _17 <- ();
    assume { Resolve12.resolve _17 };
    _44 <- ();
    _0 <- Type.Core_Result_Result_Ok _44;
    goto BB18
  }
  BB18 {
    return _0
  }
  
end
module Core_Clone_Clone_Clone_Interface
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    requires {false}
    
end
module Core_Clone_Clone_Clone
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    requires {false}
    
end
module Core_Clone_Clone_CloneFrom_Interface
  type self   
  use prelude.Prelude
  val clone_from [@cfg:stackify] (self : borrowed self) (source : self) : ()
    requires {false}
    
end
module Core_Clone_Clone_CloneFrom
  type self   
  use prelude.Prelude
  val clone_from [@cfg:stackify] (self : borrowed self) (source : self) : ()
    requires {false}
    
end
module Lib_Lit_Impl5_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit
end
module Lib_Lit_Impl5_Clone
  use prelude.Prelude
  use Type
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve0 with type self = Type.lib_lit_lit
  let rec cfg clone' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit = 
  var _0 : Type.lib_lit_lit;
  var self_1 : Type.lib_lit_lit;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _0 };
    _0 <- self_1;
    assume { Resolve1.resolve self_1 };
    return _0
  }
  
end
module Lib_Lit_Impl5
  use Type
  clone Lib_Lit_Impl5_Clone_Interface as Clone0
  clone Core_Clone_Clone_Clone_Interface as Clone1 with type self = Type.lib_lit_lit, val clone' = Clone0.clone'
end
module Lib_Lit_Impl1_IsOpp_Interface
  use Type
  predicate is_opp (self : Type.lib_lit_lit) (o : Type.lib_lit_lit)
end
module Lib_Lit_Impl1_IsOpp
  use Type
  use mach.int.UInt64
  predicate is_opp (self : Type.lib_lit_lit) (o : Type.lib_lit_lit) = 
    UInt64.to_int (Type.lib_lit_lit_Lit_idx self) = UInt64.to_int (Type.lib_lit_lit_Lit_idx o) && Type.lib_lit_lit_Lit_polarity self <> Type.lib_lit_lit_Lit_polarity o
end
module Lib_Lit_Impl1_LitInInternal_Interface
  use Type
  use seq.Seq
  predicate lit_in_internal (self : Type.lib_lit_lit) (c : Seq.seq (Type.lib_lit_lit))
end
module Lib_Lit_Impl1_LitInInternal
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  predicate lit_in_internal (self : Type.lib_lit_lit) (c : Seq.seq (Type.lib_lit_lit)) = 
    exists i : (int) . 0 <= i && i < Seq.length c && Seq.get c i = self
end
module Lib_Lit_Impl1_LitIn_Interface
  use Type
  predicate lit_in (self : Type.lib_lit_lit) (c : Type.lib_clause_clause)
end
module Lib_Lit_Impl1_LitIn
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate lit_in (self : Type.lib_lit_lit) (c : Type.lib_clause_clause) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && Seq.get (Model0.model c) i = self
end
module Lib_Lit_Impl1_Unsat_Interface
  use Type
  predicate unsat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments)
end
module Lib_Lit_Impl1_Unsat
  use Type
  clone Lib_Lit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate unsat (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) = 
    UnsatInner0.unsat_inner self (Model0.model a)
end
module Lib_Lit_Impl2_LitUnsat_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Lit_Impl1_Unsat_Interface as Unsat0
  clone Lib_Lit_Impl1_Invariant_Interface as Invariant0
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val lit_unsat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unsat0.unsat self a }
    
end
module Lib_Lit_Impl2_LitUnsat
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Lit_Impl1_Unsat as Unsat0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Lit_Impl1_Invariant as Invariant0
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val lit_unsat [@cfg:stackify] (self : Type.lib_lit_lit) (a : Type.lib_assignments_assignments) : bool
    requires {Invariant0.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Unsat0.unsat self a }
    
end
module Core_Cmp_PartialEq_Eq_Interface
  type self   
  type rhs   
  use prelude.Prelude
  val eq [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Core_Cmp_PartialEq_Eq
  type self   
  type rhs   
  use prelude.Prelude
  val eq [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Core_Cmp_PartialEq_Ne_Interface
  type self   
  type rhs   
  use prelude.Prelude
  val ne [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Core_Cmp_PartialEq_Ne
  type self   
  type rhs   
  use prelude.Prelude
  val ne [@cfg:stackify] (self : self) (other : rhs) : bool
    requires {false}
    
end
module Lib_Lit_Impl3_Eq_Interface
  use prelude.Prelude
  use Type
  val eq [@cfg:stackify] (self : Type.lib_lit_lit) (other : Type.lib_lit_lit) : bool
    ensures { result = (self = other) }
    
end
module Lib_Lit_Impl3_Eq
  use prelude.Prelude
  use Type
  val eq [@cfg:stackify] (self : Type.lib_lit_lit) (other : Type.lib_lit_lit) : bool
    ensures { result = (self = other) }
    
end
module Lib_Lit_Impl3
  use Type
  clone Lib_Lit_Impl3_Eq_Interface as Eq0
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.lib_lit_lit, type rhs = Type.lib_lit_lit,
  val eq = Eq0.eq
end
module Core_Ops_Bit_Not_Output
  type self   
  type output   
end
module Core_Ops_Bit_Not_Not_Interface
  type self   
  clone Core_Ops_Bit_Not_Output as Output0 with type self = self
  val not' [@cfg:stackify] (self : self) : Output0.output
    requires {false}
    
end
module Core_Ops_Bit_Not_Not
  type self   
  clone Core_Ops_Bit_Not_Output as Output0 with type self = self
  val not' [@cfg:stackify] (self : self) : Output0.output
    requires {false}
    
end
module Lib_Lit_Impl4_Output
  use Type
  type output  = 
    Type.lib_lit_lit
end
module Lib_Lit_Impl4_Not_Interface
  use mach.int.UInt64
  use Type
  val not' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit
    ensures { Type.lib_lit_lit_Lit_polarity result = not (Type.lib_lit_lit_Lit_polarity self) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx result) = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) }
    
end
module Lib_Lit_Impl4_Not
  use mach.int.UInt64
  use Type
  val not' [@cfg:stackify] (self : Type.lib_lit_lit) : Type.lib_lit_lit
    ensures { Type.lib_lit_lit_Lit_polarity result = not (Type.lib_lit_lit_Lit_polarity self) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx result) = UInt64.to_int (Type.lib_lit_lit_Lit_idx self) }
    
end
module Lib_Lit_Impl4
  use Type
  clone Lib_Lit_Impl4_Not_Interface as Not0
  clone Lib_Lit_Impl4_Output as Output0
  clone Core_Ops_Bit_Not_Not_Interface as Not1 with type self = Type.lib_lit_lit, type Output0.output = Output0.output,
  val not' = Not0.not'
  clone Core_Ops_Bit_Not_Output as Output1 with type self = Type.lib_lit_lit, type output = Output0.output
end
module CreusotContracts_Std1_Clone_Clone_Clone_Interface
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    ensures { result = self }
    
end
module CreusotContracts_Std1_Clone_Clone_Clone
  type self   
  use prelude.Prelude
  val clone' [@cfg:stackify] (self : self) : self
    ensures { result = self }
    
end
module Lib_Clause_Impl0_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.lib_clause_clause) : Type.lib_clause_clause
    ensures { result = self }
    
end
module Lib_Clause_Impl0_Clone
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.lib_clause_clause) : Type.lib_clause_clause
    ensures { result = self }
    
end
module Lib_Clause_Impl0
  use Type
  clone Lib_Clause_Impl0_Clone_Interface as Clone0
  clone CreusotContracts_Std1_Clone_Clone_Clone_Interface as Clone1 with type self = Type.lib_clause_clause,
  val clone' = Clone0.clone'
end
module Lib_Clause_NoDuplicateIndexesInner_Interface
  use seq.Seq
  use Type
  predicate no_duplicate_indexes_inner (s : Seq.seq (Type.lib_lit_lit))
end
module Lib_Clause_NoDuplicateIndexesInner
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  predicate no_duplicate_indexes_inner (s : Seq.seq (Type.lib_lit_lit)) = 
    forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length s && 0 <= k && k < j -> not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get s k)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get s j)))
end
module Lib_Clause_VarsInRangeInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate vars_in_range_inner (s : Seq.seq (Type.lib_lit_lit)) (n : int)
end
module Lib_Clause_VarsInRangeInner
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Lit_Impl1_Invariant_Interface as Invariant0
  predicate vars_in_range_inner (s : Seq.seq (Type.lib_lit_lit)) (n : int) = 
    forall i : (int) . 0 <= i && i < Seq.length s -> Invariant0.invariant' (Seq.get s i) n
end
module Lib_Clause_InvariantInternal_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate invariant_internal (s : Seq.seq (Type.lib_lit_lit)) (n : int)
end
module Lib_Clause_InvariantInternal
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Clause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Clause_VarsInRangeInner_Interface as VarsInRangeInner0
  predicate invariant_internal (s : Seq.seq (Type.lib_lit_lit)) (n : int) = 
    VarsInRangeInner0.vars_in_range_inner s n && NoDuplicateIndexesInner0.no_duplicate_indexes_inner s
end
module Lib_Logic_Unset_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unset (v : uint8)
end
module Lib_Logic_Unset
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  predicate unset (v : uint8) = 
    if UInt8.to_int v >= 2 then true else false
end
module Lib_Assignments_CompleteInner_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate complete_inner (a : Seq.seq uint8)
end
module Lib_Assignments_CompleteInner
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_Unset_Interface as Unset0
  predicate complete_inner (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length a -> not (Unset0.unset (Seq.get a i))
end
module Lib_Clause_Impl3_SatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate sat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Clause_Impl3_SatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Lit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate sat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && SatInner0.sat_inner (Seq.get (Model0.model self) i) a
end
module Lib_Formula_FormulaSatInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate formula_sat_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (a : Seq.seq uint8)
end
module Lib_Formula_FormulaSatInner
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Clause_Impl3_SatInner_Interface as SatInner0
  predicate formula_sat_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> SatInner0.sat_inner (Seq.get (let (a, _) = f in a) i) a
end
module Lib_Formula_EventuallySatCompleteNoAss_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate eventually_sat_complete_no_ass (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Formula_EventuallySatCompleteNoAss
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_FormulaSatInner_Interface as FormulaSatInner0
  clone Lib_Assignments_CompleteInner_Interface as CompleteInner0
  predicate eventually_sat_complete_no_ass (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = (let (_, a) = f in a) && CompleteInner0.complete_inner a2 && FormulaSatInner0.formula_sat_inner f a2
end
module Lib_Clause_EquisatExtensionInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  predicate equisat_extension_inner (c : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Clause_EquisatExtensionInner
  use Type
  use seq.Seq
  use mach.int.Int
  clone Lib_Formula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  predicate equisat_extension_inner (c : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c, let (_, a) = f in a)
end
module Lib_Clause_Impl3_VarsInRange_Interface
  use Type
  use mach.int.Int
  predicate vars_in_range (self : Type.lib_clause_clause) (n : int)
end
module Lib_Clause_Impl3_VarsInRange
  use Type
  use mach.int.Int
  clone Lib_Clause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate vars_in_range (self : Type.lib_clause_clause) (n : int) = 
    VarsInRangeInner0.vars_in_range_inner (Model0.model self) n
end
module Lib_Clause_Impl3_UnitInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Clause_Impl3_UnitInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Lit_Impl1_UnsetInner_Interface as UnsetInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  clone Lib_Clause_Impl3_SatInner_Interface as SatInner0
  clone Lib_Clause_Impl3_VarsInRange_Interface as VarsInRange0
  predicate unit_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    VarsInRange0.vars_in_range self (Seq.length a) && not (SatInner0.sat_inner self a) && (exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && UnsetInner0.unset_inner (Seq.get (Model0.model self) i) a && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> i -> not (UnsetInner0.unset_inner (Seq.get (Model0.model self) j) a)))
end
module Lib_Clause_Impl2_UnitInner2_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unit_inner2 (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Clause_Impl2_UnitInner2
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Lit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Lit_Impl1_UnsetInner_Interface as UnsetInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate unit_inner2 (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model self) && UnsetInner0.unset_inner (Seq.get (Model0.model self) i) a && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) && j <> i -> UnsatInner0.unsat_inner (Seq.get (Model0.model self) j) a)
end
module Lib_Clause_LemmaUnitEq_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl2_UnitInner2_Interface as UnitInner20
  clone Lib_Clause_Impl3_UnitInner_Interface as UnitInner0
  function lemma_unit_eq (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
end
module Lib_Clause_LemmaUnitEq
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl2_UnitInner2_Interface as UnitInner20
  clone Lib_Clause_Impl3_UnitInner_Interface as UnitInner0
  function lemma_unit_eq (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
  axiom lemma_unit_eq_spec : forall c : Type.lib_clause_clause, a : Seq.seq uint8 . UnitInner0.unit_inner c a -> UnitInner20.unit_inner2 c a
end
module Lib_Clause_LemmaUnitEq2_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl3_UnitInner_Interface as UnitInner0
  clone Lib_Clause_Impl2_UnitInner2_Interface as UnitInner20
  clone Lib_Clause_Impl3_VarsInRange_Interface as VarsInRange0
  function lemma_unit_eq2 (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
end
module Lib_Clause_LemmaUnitEq2
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl3_UnitInner_Interface as UnitInner0
  clone Lib_Clause_Impl2_UnitInner2_Interface as UnitInner20
  clone Lib_Clause_Impl3_VarsInRange_Interface as VarsInRange0
  function lemma_unit_eq2 (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
  axiom lemma_unit_eq2_spec : forall c : Type.lib_clause_clause, a : Seq.seq uint8 . VarsInRange0.vars_in_range c (Seq.length a) -> UnitInner20.unit_inner2 c a -> UnitInner0.unit_inner c a
end
module Lib_Clause_Impl2_Unit2_Interface
  use Type
  predicate unit2 (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Clause_Impl2_Unit2
  use Type
  clone Lib_Clause_Impl2_UnitInner2_Interface as UnitInner20
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate unit2 (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    UnitInner20.unit_inner2 self (Model0.model a)
end
module Lib_Formula_Impl0_ModelTy
  use seq.Seq
  use Type
  use mach.int.Int
  type modelTy  = 
    (Seq.seq (Type.lib_clause_clause), int)
end
module Lib_Formula_Impl0_Model_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  function model (self : Type.lib_formula_formula) : (Seq.seq (Type.lib_clause_clause), int)
end
module Lib_Formula_Impl0_Model
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  function model (self : Type.lib_formula_formula) : (Seq.seq (Type.lib_clause_clause), int) = 
    (Model0.model (Type.lib_formula_formula_Formula_clauses self), UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self))
end
module Lib_Formula_Impl0
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Formula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy, function model = Model0.model
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.lib_formula_formula,
  type modelTy = ModelTy0.modelTy
end
module Lib_Clause_Impl3_EquisatExtension_Interface
  use Type
  predicate equisat_extension (self : Type.lib_clause_clause) (f : Type.lib_formula_formula)
end
module Lib_Clause_Impl3_EquisatExtension
  use Type
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Formula_Impl0_Model_Interface as Model0
  predicate equisat_extension (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) = 
    EquisatExtensionInner0.equisat_extension_inner self (Model0.model f)
end
module Lib_Clause_Impl3_NoDuplicateIndexes_Interface
  use Type
  predicate no_duplicate_indexes (self : Type.lib_clause_clause)
end
module Lib_Clause_Impl3_NoDuplicateIndexes
  use Type
  clone Lib_Clause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate no_duplicate_indexes (self : Type.lib_clause_clause) = 
    NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model0.model self)
end
module Lib_Clause_Impl3_Invariant_Interface
  use Type
  use mach.int.Int
  predicate invariant' (self : Type.lib_clause_clause) (n : int)
end
module Lib_Clause_Impl3_Invariant
  use Type
  use mach.int.Int
  clone Lib_Clause_Impl3_NoDuplicateIndexes_Interface as NoDuplicateIndexes0
  clone Lib_Clause_Impl3_VarsInRange_Interface as VarsInRange0
  predicate invariant' (self : Type.lib_clause_clause) (n : int) = 
    VarsInRange0.vars_in_range self n && NoDuplicateIndexes0.no_duplicate_indexes self
end
module Lib_Formula_Impl2_InvariantOld_Interface
  use Type
  predicate invariant_old (self : Type.lib_formula_formula)
end
module Lib_Formula_Impl2_InvariantOld
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate invariant_old (self : Type.lib_formula_formula) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) -> Invariant0.invariant' (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self))
end
module Lib_Formula_Impl2_Invariant_Interface
  use Type
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  predicate invariant' (self : Type.lib_formula_formula)
end
module Lib_Formula_Impl2_Invariant
  use Type
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  predicate invariant' (self : Type.lib_formula_formula)
  axiom invariant'_spec : forall self : Type.lib_formula_formula . invariant' self = InvariantOld0.invariant_old self
end
module Lib_Clause_Impl3_Equals_Interface
  use Type
  predicate equals (self : Type.lib_clause_clause) (o : Type.lib_clause_clause)
end
module Lib_Clause_Impl3_Equals
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate equals (self : Type.lib_clause_clause) (o : Type.lib_clause_clause) = 
    Seq.length (Model0.model self) = Seq.length (Model0.model o) && (forall j : (int) . 0 <= j && j < Seq.length (Model0.model self) -> Seq.get (Model0.model self) j = Seq.get (Model0.model o) j)
end
module Lib_Formula_Compatible_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Formula_Compatible
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Clause_Impl3_Equals_Interface as Equals0
  predicate compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int)) = 
    (let (_, a) = f in a) = (let (_, a) = o in a) && Seq.length (let (a, _) = o in a) >= Seq.length (let (a, _) = f in a) && (forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Equals0.equals (Seq.get (let (a, _) = f in a) i) (Seq.get (let (a, _) = o in a) i))
end
module Lib_Formula_Equisat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Formula_Equisat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Formula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  predicate equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int)) = 
    EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass o
end
module Lib_Formula_EquisatCompatibleInner_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate equisat_compatible_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
    
end
module Lib_Formula_EquisatCompatibleInner
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Formula_Equisat_Interface as Equisat0
  clone Lib_Formula_Compatible_Interface as Compatible0
  predicate equisat_compatible_inner (f : (Seq.seq (Type.lib_clause_clause), int)) (o : (Seq.seq (Type.lib_clause_clause), int))
    
   = 
    Compatible0.compatible f o && Equisat0.equisat f o
end
module Lib_Formula_Impl2_EquisatCompatible_Interface
  use Type
  predicate equisat_compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula)
end
module Lib_Formula_Impl2_EquisatCompatible
  use Type
  clone Lib_Formula_EquisatCompatibleInner_Interface as EquisatCompatibleInner0
  clone Lib_Formula_Impl0_Model_Interface as Model0
  predicate equisat_compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula) = 
    EquisatCompatibleInner0.equisat_compatible_inner (Model0.model self) (Model0.model o)
end
module Lib_Clause_Impl3_EquisatExtensionDouble_Interface
  use Type
  predicate equisat_extension_double (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula)
    
end
module Lib_Clause_Impl3_EquisatExtensionDouble
  use Type
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Clause_Impl1_Model_Interface as Model1
  clone Lib_Clause_Impl3_Equals_Interface as Equals0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  predicate equisat_extension_double (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula)
    
   = 
    Invariant0.invariant' f && Invariant0.invariant' f2 && UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f2) && Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) + 1 = Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) -> Equals0.equals (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i) (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) i)) && Model1.model (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) (Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f2)) - 1)) = Model1.model self && EquisatCompatible0.equisat_compatible f f2
end
module Lib_Clause_Impl3_SameIdxSamePolarityExcept_Interface
  use Type
  use mach.int.Int
  predicate same_idx_same_polarity_except (self : Type.lib_clause_clause) (other : Type.lib_clause_clause) (exception' : int)
    
end
module Lib_Clause_Impl3_SameIdxSamePolarityExcept
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate same_idx_same_polarity_except (self : Type.lib_clause_clause) (other : Type.lib_clause_clause) (exception' : int)
    
   = 
    forall j : (int) . forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) && 0 <= j && j < Seq.length (Model0.model other) -> UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model self) i)) <> exception' && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model self) i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model other) j)) -> Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model self) i) = Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model other) j)
end
module Lib_Clause_Impl3_ResolventOf_Interface
  use Type
  use mach.int.Int
  predicate resolvent_of (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (k : int) (m : int)
    
end
module Lib_Clause_Impl3_ResolventOf
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Lit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Lit_Impl1_LitIn_Interface as LitIn0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate resolvent_of (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (k : int) (m : int)
    
   = 
    (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) && i <> m -> LitIn0.lit_in (Seq.get (Model0.model c) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c2) && i <> k -> LitIn0.lit_in (Seq.get (Model0.model c2) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> LitIn0.lit_in (Seq.get (Model0.model self) i) c || LitIn0.lit_in (Seq.get (Model0.model self) i) c2) && not (LitIn0.lit_in (Seq.get (Model0.model c) m) self) && not (LitIn0.lit_in (Seq.get (Model0.model c2) k) self) && IsOpp0.is_opp (Seq.get (Model0.model c2) k) (Seq.get (Model0.model c) m)
end
module Lib_Clause_Impl3_ResolventOfIdx_Interface
  use Type
  use mach.int.Int
  predicate resolvent_of_idx (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int)
    
end
module Lib_Clause_Impl3_ResolventOfIdx
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Lit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Lit_Impl1_LitIn_Interface as LitIn0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate resolvent_of_idx (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int)
    
   = 
    (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c2) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c2) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c2) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> LitIn0.lit_in (Seq.get (Model0.model self) i) c || LitIn0.lit_in (Seq.get (Model0.model self) i) c2) && (exists m : (int) . exists k : (int) . 0 <= k && k < Seq.length (Model0.model c2) && 0 <= m && m < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) m)) = idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c2) k)) = idx && IsOpp0.is_opp (Seq.get (Model0.model c2) k) (Seq.get (Model0.model c) m))
end
module Lib_Clause_Impl3_ResolventOfIdx2_Interface
  use Type
  use mach.int.Int
  predicate resolvent_of_idx2 (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int) (c_idx : int)
    
end
module Lib_Clause_Impl3_ResolventOfIdx2
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Lit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Lit_Impl1_LitIn_Interface as LitIn0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate resolvent_of_idx2 (self : Type.lib_clause_clause) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (idx : int) (c_idx : int)
    
   = 
    (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model c2) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c2) i)) <> idx -> LitIn0.lit_in (Seq.get (Model0.model c2) i) self) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> LitIn0.lit_in (Seq.get (Model0.model self) i) c || LitIn0.lit_in (Seq.get (Model0.model self) i) c2) && 0 <= c_idx && c_idx < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length (Model0.model c2) && IsOpp0.is_opp (Seq.get (Model0.model c2) k) (Seq.get (Model0.model c) c_idx))
end
module Lib_Clause_Impl3_InFormula_Interface
  use Type
  predicate in_formula (self : Type.lib_clause_clause) (f : Type.lib_formula_formula)
end
module Lib_Clause_Impl3_InFormula
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate in_formula (self : Type.lib_clause_clause) (f : Type.lib_formula_formula) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f)) && Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) i = self
end
module Lib_Clause_Impl3_InFormulaInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  predicate in_formula_inner (self : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Clause_Impl3_InFormulaInner
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  predicate in_formula_inner (self : Type.lib_clause_clause) (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    exists i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) && Seq.get (let (a, _) = f in a) i = self
end
module Lib_Clause_Impl3_Unit_Interface
  use Type
  predicate unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Clause_Impl3_Unit
  use Type
  clone Lib_Clause_Impl3_UnitInner_Interface as UnitInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate unit (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    UnitInner0.unit_inner self (Model0.model a)
end
module Lib_Clause_Impl3_UnsatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unsat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8)
end
module Lib_Clause_Impl3_UnsatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Lit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  predicate unsat_inner (self : Type.lib_clause_clause) (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> UnsatInner0.unsat_inner (Seq.get (Model0.model self) i) a
end
module Lib_Clause_Impl3_Unsat_Interface
  use Type
  predicate unsat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Clause_Impl3_Unsat
  use Type
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate unsat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    UnsatInner0.unsat_inner self (Model0.model a)
end
module Lib_Clause_Impl3_Sat_Interface
  use Type
  predicate sat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Clause_Impl3_Sat
  use Type
  clone Lib_Clause_Impl3_SatInner_Interface as SatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    SatInner0.sat_inner self (Model0.model a)
end
module Lib_Clause_Impl3_Unknown_Interface
  use Type
  predicate unknown (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments)
end
module Lib_Clause_Impl3_Unknown
  use Type
  clone Lib_Clause_Impl3_Unsat_Interface as Unsat0
  clone Lib_Clause_Impl3_Sat_Interface as Sat0
  predicate unknown (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) = 
    not (Sat0.sat self a) && not (Unsat0.unsat self a)
end
module Lib_Clause_Impl4_ClauseFromVec_Interface
  use prelude.Prelude
  use Type
  val clause_from_vec [@cfg:stackify] (vec : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : Type.lib_clause_clause
    
end
module Lib_Clause_Impl4_ClauseFromVec
  use prelude.Prelude
  use Type
  val clause_from_vec [@cfg:stackify] (vec : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : Type.lib_clause_clause
    
end
module Lib_Assignments_Impl1_Complete_Interface
  use Type
  predicate complete (self : Type.lib_assignments_assignments)
end
module Lib_Assignments_Impl1_Complete
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate complete (self : Type.lib_assignments_assignments) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model self) -> not (Unset0.unset (Seq.get (Model0.model self) i))
end
module Lib_Clause_Impl4_CheckIfUnit_Interface
  use seq.Seq
  use Type
  use prelude.Prelude
  clone Lib_Clause_Impl3_Sat_Interface as Sat0
  clone Lib_Clause_Impl3_Unsat_Interface as Unsat0
  clone Lib_Clause_Impl3_Unit_Interface as Unit0
  clone Lib_Assignments_Impl1_Complete_Interface as Complete0
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant2
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant0
  val check_if_unit [@cfg:stackify] (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (f : Type.lib_formula_formula) : Type.lib_clause_clausestate
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    requires {Invariant2.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Type.Lib_Clause_ClauseState_Unknown -> not (Complete0.complete a) }
    ensures { result = Type.Lib_Clause_ClauseState_Unit -> Unit0.unit self a && not (Complete0.complete a) }
    ensures { result = Type.Lib_Clause_ClauseState_Unsat -> Unsat0.unsat self a }
    ensures { result = Type.Lib_Clause_ClauseState_Sat -> Sat0.sat self a }
    
end
module Lib_Clause_Impl4_CheckIfUnit
  use seq.Seq
  use Type
  use prelude.Prelude
  use mach.int.Int
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant3
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model4.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Lit_Impl1_SatInner as SatInner1
  clone Lib_Clause_Impl3_SatInner as SatInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner0 with function Model0.model = Model4.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Lit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Clause_Impl3_UnitInner as UnitInner0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, function Model0.model = Model4.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model4.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_Invariant as Invariant2 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Clause_Impl3_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Clause_Impl3_Unsat as Unsat0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Clause_Impl3_Unit as Unit0 with function Model0.model = Model1.model,
  predicate UnitInner0.unit_inner = UnitInner0.unit_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant0 with function Model0.model = Model1.model
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_Impl1_Complete as Complete0 with function Model0.model = Model1.model,
  predicate Unset0.unset = Unset0.unset
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val check_if_unit [@cfg:stackify] (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (f : Type.lib_formula_formula) : Type.lib_clause_clausestate
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    requires {Invariant2.invariant' self (Seq.length (Model0.model a))}
    ensures { result = Type.Lib_Clause_ClauseState_Unknown -> not (Complete0.complete a) }
    ensures { result = Type.Lib_Clause_ClauseState_Unit -> Unit0.unit self a && not (Complete0.complete a) }
    ensures { result = Type.Lib_Clause_ClauseState_Unsat -> Unsat0.unsat self a }
    ensures { result = Type.Lib_Clause_ClauseState_Sat -> Sat0.sat self a }
    
end
module Lib_Clause_Impl4_GetUnit_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Clause_Impl1_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Lib_Clause_Impl3_Unit_Interface as Unit0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant0
  val get_unit [@cfg:stackify] (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (f : Type.lib_formula_formula) : Type.lib_lit_lit
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    requires {Unit0.unit self a}
    ensures { Unset0.unset (Seq.get (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx result))) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx result) < Seq.length (Model0.model a) }
    ensures { exists j : (int) . 0 <= j && j < Seq.length (Model1.model self) && Seq.get (Model1.model self) j = result }
    
end
module Lib_Clause_Impl4_GetUnit
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant3
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_SatInner as SatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model3 with function Model0.model = Model6.model
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model3.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_SatInner as SatInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model3.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant2 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Lit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Clause_Impl3_UnitInner as UnitInner0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, function Model0.model = Model3.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model2 with function Model0.model = Model4.model
  clone Lib_Clause_Impl3_Unit as Unit0 with function Model0.model = Model2.model,
  predicate UnitInner0.unit_inner = UnitInner0.unit_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant0 with function Model0.model = Model2.model
  clone Lib_Clause_Impl1_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model3.model
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  val get_unit [@cfg:stackify] (self : Type.lib_clause_clause) (a : Type.lib_assignments_assignments) (f : Type.lib_formula_formula) : Type.lib_lit_lit
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    requires {Unit0.unit self a}
    ensures { Unset0.unset (Seq.get (Model0.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx result))) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx result) < Seq.length (Model0.model a) }
    ensures { exists j : (int) . 0 <= j && j < Seq.length (Model1.model self) && Seq.get (Model1.model self) j = result }
    
end
module Lib_Assignments_AssignmentsEquality_Interface
  use Type
  predicate assignments_equality (a : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments)
end
module Lib_Assignments_AssignmentsEquality
  use Type
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate assignments_equality (a : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments) = 
    Seq.length (Model0.model a) = Seq.length (Model0.model a2) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model a) -> Seq.get (Model0.model a) i = Seq.get (Model0.model a2) i)
end
module Lib_Assignments_CompatibleInner_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate compatible_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Lib_Assignments_CompatibleInner
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Logic_Unset_Interface as Unset0
  predicate compatible_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8) = 
    Seq.length a = Seq.length a2 && (forall i : (int) . 0 <= i && i < Seq.length a -> Unset0.unset (Seq.get a i) || Seq.get a i = Seq.get a2 i)
end
module Lib_Assignments_CompatibleCompleteInner_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate compatible_complete_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8)
end
module Lib_Assignments_CompatibleCompleteInner
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Assignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Assignments_CompatibleInner_Interface as CompatibleInner0
  predicate compatible_complete_inner (a : Seq.seq uint8) (a2 : Seq.seq uint8) = 
    CompatibleInner0.compatible_inner a a2 && CompleteInner0.complete_inner a2
end
module Lib_Assignments_AssignmentsInvariant_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  predicate assignments_invariant (a : Seq.seq uint8) (f : Type.lib_formula_formula)
end
module Lib_Assignments_AssignmentsInvariant
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use Type
  use mach.int.UInt64
  predicate assignments_invariant (a : Seq.seq uint8) (f : Type.lib_formula_formula) = 
    UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a
end
module Lib_Assignments_Impl1_Compatible_Interface
  use Type
  predicate compatible (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments)
end
module Lib_Assignments_Impl1_Compatible
  use Type
  clone Lib_Assignments_CompatibleInner_Interface as CompatibleInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate compatible (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments) = 
    CompatibleInner0.compatible_inner (Model0.model self) (Model0.model a2)
end
module Lib_Assignments_Impl1_CompatibleComplete_Interface
  use Type
  predicate compatible_complete (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments)
end
module Lib_Assignments_Impl1_CompatibleComplete
  use Type
  clone Lib_Assignments_Impl1_Complete_Interface as Complete0
  clone Lib_Assignments_Impl1_Compatible_Interface as Compatible0
  predicate compatible_complete (self : Type.lib_assignments_assignments) (a2 : Type.lib_assignments_assignments) = 
    Compatible0.compatible self a2 && Complete0.complete a2
end
module Lib_Assignments_Impl2_New_Interface
  use prelude.Prelude
  use Type
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_assignments_assignments
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result f }
    
end
module Lib_Assignments_Impl2_New
  use prelude.Prelude
  use Type
  use mach.int.Int
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant3
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model3.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model3.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_Invariant as Invariant2 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model0 with function Model0.model = Model2.model
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_assignments_assignments
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result f }
    
end
module Lib_Decision_Impl0_Invariant_Interface
  use Type
  use mach.int.Int
  predicate invariant' (self : Type.lib_decision_decisions) (n : int)
end
module Lib_Decision_Impl0_Invariant
  use Type
  use mach.int.Int
  use seq.Seq
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = usize
  predicate invariant' (self : Type.lib_decision_decisions) (n : int) = 
    Seq.length (Model0.model (Type.lib_decision_decisions_Decisions_lit_order self)) = n && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_decision_decisions_Decisions_lit_order self)) -> UInt64.to_int (Seq.get (Model0.model (Type.lib_decision_decisions_Decisions_lit_order self)) i) < n)
end
module Lib_Assignments_Impl2_FindUnassigned_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Assignments_Impl1_Complete_Interface as Complete0
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Assignments_Impl0_Model_Interface as Model1
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Decision_Impl0_Invariant_Interface as Invariant0
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val find_unassigned [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (_f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Invariant0.invariant' d (Seq.length (Model0.model self))}
    requires {Invariant1.invariant' ( * self) _f}
    ensures { Invariant1.invariant' ( ^ self) _f }
    ensures { Model0.model self = Model1.model ( ^ self) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some res -> UInt64.to_int res < Seq.length (Model0.model self) && Unset0.unset (Seq.get (Model0.model self) (UInt64.to_int res))
      | Type.Core_Option_Option_None -> Complete0.complete ( * self)
      end }
    
end
module Lib_Assignments_Impl2_FindUnassigned
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use prelude.UInt8
  clone Lib_Logic_Unset as Unset0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model1 with function Model0.model = Model3.model
  clone Lib_Assignments_Impl1_Complete as Complete0 with function Model0.model = Model1.model,
  predicate Unset0.unset = Unset0.unset
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone Lib_Decision_Impl0_Invariant as Invariant0 with function Model0.model = Model2.model
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val find_unassigned [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (_f : Type.lib_formula_formula) : Type.core_option_option usize
    requires {Invariant0.invariant' d (Seq.length (Model0.model self))}
    requires {Invariant1.invariant' ( * self) _f}
    ensures { Invariant1.invariant' ( ^ self) _f }
    ensures { Model0.model self = Model1.model ( ^ self) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some res -> UInt64.to_int res < Seq.length (Model0.model self) && Unset0.unset (Seq.get (Model0.model self) (UInt64.to_int res))
      | Type.Core_Option_Option_None -> Complete0.complete ( * self)
      end }
    
end
module Lib_Formula_Impl2_SatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Formula_Impl2_SatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Clause_Impl3_SatInner_Interface as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) -> SatInner0.sat_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) a
end
module Lib_Formula_Impl2_EventuallySatCompleteInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate eventually_sat_complete_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Formula_Impl2_EventuallySatCompleteInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Assignments_CompatibleCompleteInner_Interface as CompatibleCompleteInner0
  predicate eventually_sat_complete_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) && CompatibleCompleteInner0.compatible_complete_inner a a2 && SatInner0.sat_inner self a2
end
module Lib_Formula_Impl2_EventuallySatComplete_Interface
  use Type
  predicate eventually_sat_complete (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Formula_Impl2_EventuallySatComplete
  use Type
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate eventually_sat_complete (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) = 
    EventuallySatCompleteInner0.eventually_sat_complete_inner self (Model0.model a)
end
module Lib_Assignments_Impl2_UnitPropOnce_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  clone Lib_Assignments_Impl1_Compatible_Interface as Compatible0
  clone Lib_Formula_Impl2_EventuallySatComplete_Interface as EventuallySatComplete0
  clone Lib_Clause_Impl3_Unit_Interface as Unit0
  clone Lib_Clause_Impl3_Sat_Interface as Sat0
  clone Lib_Clause_Impl3_Unsat_Interface as Unsat0
  clone Lib_Assignments_Impl0_Model_Interface as Model3
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model2 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Lib_Assignments_Impl1_Complete_Interface as Complete0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  val unit_prop_once [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (i : usize) (f : borrowed (Type.lib_formula_formula)) (t : borrowed (Type.lib_trail_trail)) : Type.lib_clause_clausestate
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {0 <= UInt64.to_int i && UInt64.to_int i < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Invariant1.invariant' ( * self) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Complete0.complete ( * self) ->  * self =  ^ self && (result = Type.Lib_Clause_ClauseState_Unsat || result = Type.Lib_Clause_ClauseState_Sat) }
    ensures { result = Type.Lib_Clause_ClauseState_Unknown -> Model2.model self = Model3.model ( ^ self) && not (Complete0.complete ( ^ self)) }
    ensures { result = Type.Lib_Clause_ClauseState_Unsat -> Unsat0.unsat (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int i)) ( ^ self) && Model2.model self = Model3.model ( ^ self) }
    ensures { result = Type.Lib_Clause_ClauseState_Sat -> Sat0.sat (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int i)) ( ^ self) && Model2.model self = Model3.model ( ^ self) }
    ensures { result = Type.Lib_Clause_ClauseState_Unit -> Unit0.unit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int i)) ( * self) && not (Complete0.complete ( * self)) }
    ensures { EventuallySatComplete0.eventually_sat_complete ( * f) ( * self) = EventuallySatComplete0.eventually_sat_complete ( * f) ( ^ self) }
    ensures { Compatible0.compatible ( * self) ( ^ self) }
    ensures { Invariant1.invariant' ( ^ self) ( * f) }
    ensures { Invariant0.invariant' ( ^ t) ( * f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) }
    
end
module Lib_Assignments_Impl2_UnitPropOnce
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant4
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model6 with function Model0.model = Model7.model
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model6.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant3 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model7.model
  clone Lib_Lit_Impl1_UnsetInner as UnsetInner0
  clone Lib_Lit_Impl1_SatInner as SatInner1
  clone Lib_Clause_Impl3_SatInner as SatInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Clause_Impl3_UnitInner as UnitInner0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, function Model0.model = Model6.model,
  predicate UnsetInner0.unset_inner = UnsetInner0.unset_inner
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner0 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model3 with function Model0.model = Model5.model
  clone Lib_Clause_Impl3_Unit as Unit0 with function Model0.model = Model3.model,
  predicate UnitInner0.unit_inner = UnitInner0.unit_inner
  clone Lib_Clause_Impl3_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Clause_Impl3_Unsat as Unsat0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model3.model
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model2 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model3.model
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Assignments_CompatibleInner as CompatibleInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Assignments_CompatibleCompleteInner as CompatibleCompleteInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner
  clone Lib_Assignments_Impl1_Compatible as Compatible0 with function Model0.model = Model3.model,
  predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner
  clone Lib_Assignments_Impl1_Complete as Complete0 with function Model0.model = Model3.model,
  predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_SatInner as SatInner2 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_Impl2_EventuallySatCompleteInner as EventuallySatCompleteInner0 with predicate CompatibleCompleteInner0.compatible_complete_inner = CompatibleCompleteInner0.compatible_complete_inner,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Formula_Impl2_EventuallySatComplete as EventuallySatComplete0 with function Model0.model = Model3.model,
  predicate EventuallySatCompleteInner0.eventually_sat_complete_inner = EventuallySatCompleteInner0.eventually_sat_complete_inner
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model1.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model4.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  val unit_prop_once [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (i : usize) (f : borrowed (Type.lib_formula_formula)) (t : borrowed (Type.lib_trail_trail)) : Type.lib_clause_clausestate
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {0 <= UInt64.to_int i && UInt64.to_int i < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Invariant1.invariant' ( * self) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Complete0.complete ( * self) ->  * self =  ^ self && (result = Type.Lib_Clause_ClauseState_Unsat || result = Type.Lib_Clause_ClauseState_Sat) }
    ensures { result = Type.Lib_Clause_ClauseState_Unknown -> Model2.model self = Model3.model ( ^ self) && not (Complete0.complete ( ^ self)) }
    ensures { result = Type.Lib_Clause_ClauseState_Unsat -> Unsat0.unsat (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int i)) ( ^ self) && Model2.model self = Model3.model ( ^ self) }
    ensures { result = Type.Lib_Clause_ClauseState_Sat -> Sat0.sat (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int i)) ( ^ self) && Model2.model self = Model3.model ( ^ self) }
    ensures { result = Type.Lib_Clause_ClauseState_Unit -> Unit0.unit (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int i)) ( * self) && not (Complete0.complete ( * self)) }
    ensures { EventuallySatComplete0.eventually_sat_complete ( * f) ( * self) = EventuallySatComplete0.eventually_sat_complete ( * f) ( ^ self) }
    ensures { Compatible0.compatible ( * self) ( ^ self) }
    ensures { Invariant1.invariant' ( ^ self) ( * f) }
    ensures { Invariant0.invariant' ( ^ t) ( * f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) }
    
end
module Lib_Formula_Impl2_Sat_Interface
  use Type
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Formula_Impl2_Sat
  use Type
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
  axiom sat_spec : forall self : Type.lib_formula_formula, a : Type.lib_assignments_assignments . sat self a = SatInner0.sat_inner self (Model0.model a)
end
module Lib_Formula_Impl2_UnsatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate unsat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Formula_Impl2_UnsatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate unsat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    exists i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) && UnsatInner0.unsat_inner (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) a
end
module Lib_Formula_Impl2_Unsat_Interface
  use Type
  predicate unsat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Formula_Impl2_Unsat
  use Type
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate unsat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) = 
    UnsatInner0.unsat_inner self (Model0.model a)
end
module Lib_Assignments_Impl2_UnitPropagate_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  clone Lib_Formula_Impl2_EventuallySatComplete_Interface as EventuallySatComplete0
  clone Lib_Assignments_Impl1_Compatible_Interface as Compatible0
  clone Lib_Formula_Impl2_Unsat_Interface as Unsat0
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model1
  clone Lib_Formula_Impl2_Sat_Interface as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Assignments_Impl1_Complete_Interface as Complete0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  val unit_propagate [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (f : borrowed (Type.lib_formula_formula)) (t : borrowed (Type.lib_trail_trail)) : Type.lib_clause_clausestate
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' ( * self) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Complete0.complete ( * self) ->  * self =  ^ self && (result = Type.Lib_Clause_ClauseState_Unsat || Sat0.sat ( * f) ( * self)) }
    ensures { match (result) with
      | Type.Lib_Clause_ClauseState_Sat -> Sat0.sat ( * f) ( ^ self)
      | Type.Lib_Clause_ClauseState_Unsat -> Unsat0.unsat ( * f) ( ^ self)
      | Type.Lib_Clause_ClauseState_Unknown -> not (Complete0.complete ( ^ self))
      | Type.Lib_Clause_ClauseState_Unit -> not (Complete0.complete ( * self))
      | _ -> true
      end }
    ensures { Compatible0.compatible ( * self) ( ^ self) }
    ensures { EventuallySatComplete0.eventually_sat_complete ( * f) ( ^ self) = EventuallySatComplete0.eventually_sat_complete ( * f) ( * self) }
    ensures { Invariant1.invariant' ( ^ self) ( * f) }
    ensures { Invariant0.invariant' ( ^ t) ( * f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) }
    
end
module Lib_Assignments_Impl2_UnitPropagate
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Lit_Impl1_Invariant as Invariant4
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Lit_Impl1_SatInner as SatInner2
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model6 with function Model0.model = Model5.model
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model6.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant3 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner1 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Clause_Impl3_SatInner as SatInner1 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model4.model
  clone Lib_Formula_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model4.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Formula_Impl2_SatInner as SatInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model4.model,
  predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Formula_Impl2_Unsat as Unsat0 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Formula_Impl2_Sat as Sat0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model2.model
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Assignments_CompatibleInner as CompatibleInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Assignments_CompatibleCompleteInner as CompatibleCompleteInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner
  clone Lib_Formula_Impl2_EventuallySatCompleteInner as EventuallySatCompleteInner0 with predicate CompatibleCompleteInner0.compatible_complete_inner = CompatibleCompleteInner0.compatible_complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_Impl2_EventuallySatComplete as EventuallySatComplete0 with function Model0.model = Model2.model,
  predicate EventuallySatCompleteInner0.eventually_sat_complete_inner = EventuallySatCompleteInner0.eventually_sat_complete_inner
  clone Lib_Assignments_Impl1_Compatible as Compatible0 with function Model0.model = Model2.model,
  predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner
  clone Lib_Assignments_Impl1_Complete as Complete0 with function Model0.model = Model2.model,
  predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  val unit_propagate [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (f : borrowed (Type.lib_formula_formula)) (t : borrowed (Type.lib_trail_trail)) : Type.lib_clause_clausestate
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' ( * self) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { Complete0.complete ( * self) ->  * self =  ^ self && (result = Type.Lib_Clause_ClauseState_Unsat || Sat0.sat ( * f) ( * self)) }
    ensures { match (result) with
      | Type.Lib_Clause_ClauseState_Sat -> Sat0.sat ( * f) ( ^ self)
      | Type.Lib_Clause_ClauseState_Unsat -> Unsat0.unsat ( * f) ( ^ self)
      | Type.Lib_Clause_ClauseState_Unknown -> not (Complete0.complete ( ^ self))
      | Type.Lib_Clause_ClauseState_Unit -> not (Complete0.complete ( * self))
      | _ -> true
      end }
    ensures { Compatible0.compatible ( * self) ( ^ self) }
    ensures { EventuallySatComplete0.eventually_sat_complete ( * f) ( ^ self) = EventuallySatComplete0.eventually_sat_complete ( * f) ( * self) }
    ensures { Invariant1.invariant' ( ^ self) ( * f) }
    ensures { Invariant0.invariant' ( ^ t) ( * f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) }
    
end
module Lib_Assignments_Impl2_DoUnitPropagation_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Formula_Impl2_EventuallySatComplete_Interface as EventuallySatComplete0
  clone Lib_Assignments_Impl1_Compatible_Interface as Compatible0
  clone Lib_Assignments_Impl1_Complete_Interface as Complete0
  clone Lib_Formula_Impl2_Unsat_Interface as Unsat0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  val do_unit_propagation [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (f : borrowed (Type.lib_formula_formula)) (t : borrowed (Type.lib_trail_trail)) : Type.core_result_result () usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' ( * self) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { match (result) with
      | Type.Core_Result_Result_Err cref -> Unsat0.unsat ( * f) ( ^ self)
      | Type.Core_Result_Result_Ok _ -> not (Complete0.complete ( ^ self)) || not (Unsat0.unsat ( * f) ( ^ self))
      end }
    ensures { Compatible0.compatible ( * self) ( ^ self) }
    ensures { EventuallySatComplete0.eventually_sat_complete ( * f) ( * self) = EventuallySatComplete0.eventually_sat_complete ( * f) ( ^ self) }
    ensures { Invariant1.invariant' ( ^ self) ( * f) }
    ensures { Invariant0.invariant' ( ^ t) ( * f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) }
    
end
module Lib_Assignments_Impl2_DoUnitPropagation
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use mach.int.UInt64
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant4
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Lit_Impl1_SatInner as SatInner2
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner2
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model6 with function Model0.model = Model5.model
  clone Lib_Clause_Impl3_SatInner as SatInner1 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model6.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant3 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner1 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_SatInner as SatInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model4.model
  clone Lib_Formula_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model4.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model4.model,
  predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Formula_Impl2_Unsat as Unsat0 with function Model0.model = Model2.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model2.model
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Assignments_CompatibleInner as CompatibleInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Assignments_CompatibleCompleteInner as CompatibleCompleteInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner
  clone Lib_Formula_Impl2_EventuallySatCompleteInner as EventuallySatCompleteInner0 with predicate CompatibleCompleteInner0.compatible_complete_inner = CompatibleCompleteInner0.compatible_complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_Impl2_EventuallySatComplete as EventuallySatComplete0 with function Model0.model = Model2.model,
  predicate EventuallySatCompleteInner0.eventually_sat_complete_inner = EventuallySatCompleteInner0.eventually_sat_complete_inner
  clone Lib_Assignments_Impl1_Compatible as Compatible0 with function Model0.model = Model2.model,
  predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner
  clone Lib_Assignments_Impl1_Complete as Complete0 with function Model0.model = Model2.model,
  predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  val do_unit_propagation [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (f : borrowed (Type.lib_formula_formula)) (t : borrowed (Type.lib_trail_trail)) : Type.core_result_result () usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' ( * self) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { match (result) with
      | Type.Core_Result_Result_Err cref -> Unsat0.unsat ( * f) ( ^ self)
      | Type.Core_Result_Result_Ok _ -> not (Complete0.complete ( ^ self)) || not (Unsat0.unsat ( * f) ( ^ self))
      end }
    ensures { Compatible0.compatible ( * self) ( ^ self) }
    ensures { EventuallySatComplete0.eventually_sat_complete ( * f) ( * self) = EventuallySatComplete0.eventually_sat_complete ( * f) ( ^ self) }
    ensures { Invariant1.invariant' ( ^ self) ( * f) }
    ensures { Invariant0.invariant' ( ^ t) ( * f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) }
    
end
module CreusotContracts_Logic_Ghost_Impl0_ModelTy
  type t   
  type modelTy  = 
    t
end
module CreusotContracts_Logic_Ghost_Impl0_Model_Interface
  type t   
  use Type
  function model (self : Type.creusotcontracts_logic_ghost_ghost t) : t
end
module CreusotContracts_Logic_Ghost_Impl0_Model
  type t   
  use Type
  function model (self : Type.creusotcontracts_logic_ghost_ghost t) : t
end
module CreusotContracts_Logic_Ghost_Impl0
  type t   
  use Type
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = t
  clone CreusotContracts_Logic_Ghost_Impl0_ModelTy as ModelTy0 with type t = t
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.creusotcontracts_logic_ghost_ghost t,
  type ModelTy0.modelTy = ModelTy0.modelTy, function model = Model0.model
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.creusotcontracts_logic_ghost_ghost t,
  type modelTy = ModelTy0.modelTy
end
module CreusotContracts_Logic_Ghost_Impl1_Record_Interface
  type t   
  use prelude.Prelude
  use Type
  clone CreusotContracts_Logic_Ghost_Impl0_Model_Interface as Model0 with type t = t
  val record [@cfg:stackify] (a : t) : Type.creusotcontracts_logic_ghost_ghost t
    ensures { Model0.model result = a }
    
end
module CreusotContracts_Logic_Ghost_Impl1_Record
  type t   
  use prelude.Prelude
  use Type
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model0 with type t = t
  val record [@cfg:stackify] (a : t) : Type.creusotcontracts_logic_ghost_ghost t
    ensures { Model0.model result = a }
    
end
module Lib_Assignments_Impl2_WipeLevel_Interface
  use mach.int.UInt64
  use seq.Seq
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model3 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone Lib_Clause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariantFull_Interface as TrailInvariantFull0
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason),
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)),
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant0
  val wipe_level [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (trail : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit))) (vardata : borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason))) (curr_level : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) (_f : Type.lib_formula_formula) : ()
    requires {Invariant0.invariant' ( * self) _f}
    requires {TrailInvariantFull0.trail_invariant_full (Model0.model trail) (Model1.model vardata) _f}
    requires {VarsInRangeInner0.vars_in_range_inner (Model2.model curr_level) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {LongArePostUnit0.long_are_post_unit (Model1.model vardata) _f ( * self)}
    ensures { LongArePostUnit0.long_are_post_unit (Model3.model ( ^ vardata)) _f ( ^ self) }
    ensures { TrailInvariantFull0.trail_invariant_full (Model0.model trail) (Model3.model ( ^ vardata)) _f }
    ensures { Invariant0.invariant' ( ^ self) _f }
    ensures { Invariant0.invariant' ( ^ self) _f }
    ensures { Seq.length (Model1.model vardata) = Seq.length (Model3.model ( ^ vardata)) }
    
end
module Lib_Assignments_Impl2_WipeLevel
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model11 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model7 with function Model0.model = Model11.model
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model7.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant0 with function Model0.model = Model7.model
  clone Lib_Lit_Impl1_Invariant as Invariant1
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant1.invariant'
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model10 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Logic_Model_Impl0_Model as Model5 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)),
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model10.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model4.model
  clone Lib_Clause_Impl1_Model as Model9 with function Model0.model = Model4.model
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model9.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model7.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_clause_clause
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model8.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model9.model,
  predicate Sat0.sat = Sat0.sat
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model8.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model3 with type t = borrowed (Type.lib_assignments_assignments)
  clone Lib_Assignments_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl1_Model as Model2 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model7.model
  clone CreusotContracts_Logic_Ghost_Impl0_Model as Model1 with type t = borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason))
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Logic_Model_Impl1_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model6.model
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve16 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve15 with type self = uint8
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve14 with type self = uint8
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy4 with type t = uint8
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve13 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve12 with type self = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve11 with type self = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve10 with type self = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_assignments_assignments))
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve9 with type self = borrowed (Type.lib_assignments_assignments)
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve8 with type self = Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason)))
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve7 with type self = borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason))
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve6 with type self = ()
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve5 with type self = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve4 with type t = Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason)
  clone CreusotContracts_Logic_Resolve_Impl1_Resolve as Resolve3 with type t = Type.lib_assignments_assignments
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve2 with type self = usize
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy3 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve0 with type self = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit))
  clone CreusotContracts_Logic_Model_Impl1_Model as Model14 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy4.modelTy, function Model0.model = Model11.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut1 with type t = uint8,
  function Model0.model = Model11.model, function Model1.model = Model14.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model13 with type t = Type.creusotcontracts_std1_vec_vec uint8,
  type ModelTy0.modelTy = ModelTy4.modelTy, function Model0.model = Model11.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index1 with type t = uint8,
  function Model0.model = Model13.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model12 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy3.modelTy, function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl3_Index_Interface as Index0 with type t = Type.lib_lit_lit,
  function Model0.model = Model12.model
  clone CreusotContracts_Std1_Vec_Impl1_Len_Interface as Len0 with type t = Type.lib_lit_lit,
  function Model0.model = Model12.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record1 with type t = borrowed (Type.lib_assignments_assignments),
  function Model0.model = Model3.model
  clone CreusotContracts_Logic_Ghost_Impl1_Record_Interface as Record0 with type t = borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason)),
  function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl2_IndexMut_Interface as IndexMut0 with type t = (usize, Type.lib_trail_reason),
  function Model0.model = Model6.model, function Model1.model = Model0.model
  let rec cfg wipe_level [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (trail : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit))) (vardata : borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason))) (curr_level : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) (_f : Type.lib_formula_formula) : ()
    requires {Invariant0.invariant' ( * self) _f}
    requires {TrailInvariantFull0.trail_invariant_full (Model5.model trail) (Model0.model vardata) _f}
    requires {VarsInRangeInner0.vars_in_range_inner (Model4.model curr_level) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {LongArePostUnit0.long_are_post_unit (Model0.model vardata) _f ( * self)}
    ensures { LongArePostUnit0.long_are_post_unit (Model6.model ( ^ vardata)) _f ( ^ self) }
    ensures { TrailInvariantFull0.trail_invariant_full (Model5.model trail) (Model6.model ( ^ vardata)) _f }
    ensures { Invariant0.invariant' ( ^ self) _f }
    ensures { Invariant0.invariant' ( ^ self) _f }
    ensures { Seq.length (Model0.model vardata) = Seq.length (Model6.model ( ^ vardata)) }
    
   = 
  var _0 : ();
  var self_1 : borrowed (Type.lib_assignments_assignments);
  var trail_2 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var vardata_3 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason));
  var curr_level_4 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _f_5 : Type.lib_formula_formula;
  var j_6 : usize;
  var curr_level_len_7 : usize;
  var _8 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _9 : ();
  var _10 : bool;
  var _11 : usize;
  var _12 : ();
  var old_vardata_13 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason)));
  var _14 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason));
  var _15 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason));
  var old_self_16 : Type.creusotcontracts_logic_ghost_ghost (borrowed (Type.lib_assignments_assignments));
  var _17 : borrowed (Type.lib_assignments_assignments);
  var _18 : borrowed (Type.lib_assignments_assignments);
  var _19 : ();
  var _20 : bool;
  var _21 : usize;
  var _22 : usize;
  var lit_23 : Type.lib_lit_lit;
  var _24 : Type.lib_lit_lit;
  var _25 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _26 : usize;
  var _27 : usize;
  var _28 : usize;
  var _29 : usize;
  var _30 : Type.lib_trail_reason;
  var _31 : borrowed (usize, Type.lib_trail_reason);
  var _32 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason));
  var _33 : usize;
  var _34 : ();
  var _35 : ();
  var _36 : ();
  var _37 : bool;
  var _38 : uint8;
  var _39 : uint8;
  var _40 : Type.creusotcontracts_std1_vec_vec uint8;
  var _41 : usize;
  var _42 : borrowed uint8;
  var _43 : borrowed (Type.creusotcontracts_std1_vec_vec uint8);
  var _44 : usize;
  var _45 : borrowed uint8;
  var _46 : borrowed (Type.creusotcontracts_std1_vec_vec uint8);
  var _47 : usize;
  var _48 : ();
  var _49 : ();
  var _50 : ();
  {
    self_1 <- self;
    trail_2 <- trail;
    vardata_3 <- vardata;
    curr_level_4 <- curr_level;
    _f_5 <- _f;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve trail_2 };
    assume { Resolve1.resolve _f_5 };
    goto BB1
  }
  BB1 {
    j_6 <- (0 : usize);
    _8 <- curr_level_4;
    curr_level_len_7 <- Len0.len _8;
    goto BB2
  }
  BB2 {
    assume { Resolve2.resolve _11 };
    _11 <- curr_level_len_7;
    _10 <- _11 = (0 : usize);
    switch (_10)
      | False -> goto BB4
      | _ -> goto BB3
      end
  }
  BB3 {
    assume { Resolve3.resolve self_1 };
    assume { Resolve4.resolve vardata_3 };
    assume { Resolve2.resolve j_6 };
    assume { Resolve2.resolve curr_level_len_7 };
    _0 <- ();
    goto BB21
  }
  BB4 {
    _9 <- ();
    assume { Resolve6.resolve _9 };
    _15 <- vardata_3;
    _14 <- _15;
    assume { Resolve7.resolve _15 };
    old_vardata_13 <- Record0.record _14;
    goto BB5
  }
  BB5 {
    assume { Resolve8.resolve old_vardata_13 };
    _18 <- self_1;
    _17 <- _18;
    assume { Resolve9.resolve _18 };
    old_self_16 <- Record1.record _17;
    goto BB6
  }
  BB6 {
    assume { Resolve10.resolve old_self_16 };
    goto BB7
  }
  BB7 {
    goto BB8
  }
  BB8 {
    goto BB9
  }
  BB9 {
    invariant maintains_ass_inv2 { Invariant0.invariant' ( * self_1) _f_5 };
    invariant same_len_trail { Seq.length (Model0.model vardata_3) = Seq.length (Model0.model (Model1.model old_vardata_13)) };
    invariant same_len_ass { Seq.length (Model2.model self_1) = Seq.length (Model2.model (Model3.model old_self_16)) };
    invariant intact_self2 {  ^ self_1 =  ^ Model3.model old_self_16 };
    invariant intact_vardata {  ^ vardata_3 =  ^ Model1.model old_vardata_13 };
    invariant crefs { CrefsInRange0.crefs_in_range (Model0.model vardata_3) _f_5 };
    invariant j_less { 0 <= UInt64.to_int j_6 && UInt64.to_int j_6 <= Seq.length (Model4.model curr_level_4) };
    invariant wiped { forall k : (int) . 0 <= k && k < UInt64.to_int j_6 -> Seq.get (Model0.model vardata_3) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model4.model curr_level_4) (UInt64.to_int curr_level_len_7 - k - 1)))) = ((0 : usize), Type.Lib_Trail_Reason_Undefined) };
    invariant maintains_post_unit { LongArePostUnit0.long_are_post_unit (Model0.model vardata_3) _f_5 ( * self_1) };
    assume { Resolve2.resolve _21 };
    _21 <- j_6;
    assume { Resolve2.resolve _22 };
    _22 <- curr_level_len_7;
    _20 <- _21 < _22;
    switch (_20)
      | False -> goto BB20
      | _ -> goto BB10
      end
  }
  BB10 {
    _25 <- curr_level_4;
    assume { Resolve2.resolve _28 };
    _28 <- curr_level_len_7;
    assume { Resolve2.resolve _29 };
    _29 <- j_6;
    _27 <- _28 - _29;
    _26 <- _27 - (1 : usize);
    _24 <- Index0.index _25 _26;
    goto BB11
  }
  BB11 {
    assume { Resolve11.resolve lit_23 };
    lit_23 <- _24;
    assume { Resolve12.resolve _24 };
    _30 <- Type.Lib_Trail_Reason_Undefined;
    _32 <- borrow_mut ( * vardata_3);
    vardata_3 <- { vardata_3 with current = ( ^ _32) };
    assume { Resolve2.resolve _33 };
    _33 <- Type.lib_lit_lit_Lit_idx lit_23;
    _31 <- IndexMut0.index_mut _32 _33;
    goto BB12
  }
  BB12 {
    _31 <- { _31 with current = ((0 : usize), _30) };
    assume { Resolve13.resolve _31 };
    assert { LongArePostUnit0.long_are_post_unit (Model0.model vardata_3) _f_5 ( * self_1) };
    _34 <- ();
    assume { Resolve6.resolve _34 };
    assert { Seq.get (Model0.model vardata_3) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model4.model curr_level_4) (UInt64.to_int curr_level_len_7 - UInt64.to_int j_6 - 1)))) = ((0 : usize), Type.Lib_Trail_Reason_Undefined) };
    goto BB13
  }
  BB13 {
    _35 <- ();
    assume { Resolve6.resolve _35 };
    _40 <- Type.lib_assignments_assignments_Assignments_0 ( * self_1);
    assume { Resolve2.resolve _41 };
    _41 <- Type.lib_lit_lit_Lit_idx lit_23;
    _39 <- Index1.index _40 _41;
    goto BB14
  }
  BB14 {
    assume { Resolve14.resolve _38 };
    _38 <- _39;
    assume { Resolve15.resolve _39 };
    _37 <- _38 = (0 : uint8);
    switch (_37)
      | False -> goto BB17
      | _ -> goto BB15
      end
  }
  BB15 {
    _43 <- borrow_mut (Type.lib_assignments_assignments_Assignments_0 ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Assignments_Assignments a b =  * self_1 in Type.Lib_Assignments_Assignments ( ^ _43) b) };
    assume { Resolve2.resolve _44 };
    _44 <- Type.lib_lit_lit_Lit_idx lit_23;
    assume { Resolve11.resolve lit_23 };
    _42 <- IndexMut1.index_mut _43 _44;
    goto BB16
  }
  BB16 {
    _42 <- { _42 with current = (2 : uint8) };
    assume { Resolve16.resolve _42 };
    _36 <- ();
    assume { Resolve6.resolve _36 };
    goto BB19
  }
  BB17 {
    _46 <- borrow_mut (Type.lib_assignments_assignments_Assignments_0 ( * self_1));
    self_1 <- { self_1 with current = (let Type.Lib_Assignments_Assignments a b =  * self_1 in Type.Lib_Assignments_Assignments ( ^ _46) b) };
    assume { Resolve2.resolve _47 };
    _47 <- Type.lib_lit_lit_Lit_idx lit_23;
    assume { Resolve11.resolve lit_23 };
    _45 <- IndexMut1.index_mut _46 _47;
    goto BB18
  }
  BB18 {
    _45 <- { _45 with current = (3 : uint8) };
    assume { Resolve16.resolve _45 };
    _36 <- ();
    assume { Resolve6.resolve _36 };
    goto BB19
  }
  BB19 {
    j_6 <- j_6 + (1 : usize);
    _19 <- ();
    assume { Resolve6.resolve _19 };
    goto BB9
  }
  BB20 {
    assume { Resolve3.resolve self_1 };
    assume { Resolve4.resolve vardata_3 };
    assume { Resolve2.resolve j_6 };
    assume { Resolve2.resolve curr_level_len_7 };
    _0 <- ();
    goto BB21
  }
  BB21 {
    assume { Resolve5.resolve curr_level_4 };
    return _0
  }
  
end
module Lib_Assignments_Impl2_CancelUntil_Interface
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant1
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant0
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val cancel_until [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (level : usize) (_f : Type.lib_formula_formula) : ()
    requires {TrailSemInvariant0.trail_sem_invariant ( * trail) _f ( * self)}
    requires {UInt64.to_int level > 0}
    requires {Invariant0.invariant' ( * self) _f}
    requires {Invariant1.invariant' ( * trail) _f}
    requires {UInt64.to_int level <= Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail)))}
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ trail) _f ( ^ self) }
    ensures { forall j : (int) . 0 <= j && j < UInt64.to_int level -> Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) j = Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) j }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) = UInt64.to_int level }
    ensures { Invariant0.invariant' ( ^ self) _f }
    ensures { Invariant1.invariant' ( ^ trail) _f }
    
end
module Lib_Assignments_Impl2_CancelUntil
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model6.model
  clone Lib_Clause_Impl1_Model as Model4 with function Model0.model = Model6.model
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model2 with function Model0.model = Model5.model
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model2.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant0 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model3.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model3.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model4.model,
  predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_Invariant as Invariant1 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val cancel_until [@cfg:stackify] (self : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (level : usize) (_f : Type.lib_formula_formula) : ()
    requires {TrailSemInvariant0.trail_sem_invariant ( * trail) _f ( * self)}
    requires {UInt64.to_int level > 0}
    requires {Invariant0.invariant' ( * self) _f}
    requires {Invariant1.invariant' ( * trail) _f}
    requires {UInt64.to_int level <= Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail)))}
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ trail) _f ( ^ self) }
    ensures { forall j : (int) . 0 <= j && j < UInt64.to_int level -> Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) j = Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) j }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) = UInt64.to_int level }
    ensures { Invariant0.invariant' ( ^ self) _f }
    ensures { Invariant1.invariant' ( ^ trail) _f }
    
end
module Lib_Formula_Impl1_Eq_Interface
  use prelude.Prelude
  use Type
  val eq [@cfg:stackify] (self : Type.lib_formula_satstate) (other : Type.lib_formula_satstate) : bool
end
module Lib_Formula_Impl1_Eq
  use prelude.Prelude
  use Type
  val eq [@cfg:stackify] (self : Type.lib_formula_satstate) (other : Type.lib_formula_satstate) : bool
end
module Lib_Formula_Impl1
  use Type
  clone Lib_Formula_Impl1_Eq_Interface as Eq0
  clone Core_Cmp_PartialEq_Eq_Interface as Eq1 with type self = Type.lib_formula_satstate,
  type rhs = Type.lib_formula_satstate, val eq = Eq0.eq
end
module Lib_Formula_FormulaInvariant_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate formula_invariant (f : (Seq.seq (Type.lib_clause_clause), int))
end
module Lib_Formula_FormulaInvariant
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  predicate formula_invariant (f : (Seq.seq (Type.lib_clause_clause), int)) = 
    forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Invariant0.invariant' (Seq.get (let (a, _) = f in a) i) (let (_, a) = f in a)
end
module Lib_Formula_Impl2_EventuallySatCompleteNoAss_Interface
  use Type
  predicate eventually_sat_complete_no_ass (self : Type.lib_formula_formula)
end
module Lib_Formula_Impl2_EventuallySatCompleteNoAss
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Assignments_CompleteInner_Interface as CompleteInner0
  predicate eventually_sat_complete_no_ass (self : Type.lib_formula_formula) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) && CompleteInner0.complete_inner a2 && SatInner0.sat_inner self a2
end
module Lib_Formula_Impl2_Equisat_Interface
  use Type
  predicate equisat (self : Type.lib_formula_formula) (o : Type.lib_formula_formula)
end
module Lib_Formula_Impl2_Equisat
  use Type
  clone Lib_Formula_Impl2_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  predicate equisat (self : Type.lib_formula_formula) (o : Type.lib_formula_formula) = 
    EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass self = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass o
end
module Lib_Formula_Impl2_Compatible_Interface
  use Type
  predicate compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula)
end
module Lib_Formula_Impl2_Compatible
  use Type
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  clone Lib_Clause_Impl3_Equals_Interface as Equals0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  predicate compatible (self : Type.lib_formula_formula) (o : Type.lib_formula_formula) = 
    UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars o) && Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses o)) >= Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses self)) -> Equals0.equals (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses self)) i) (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses o)) i))
end
module Lib_Formula_Impl2_EventuallySatInner_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  predicate eventually_sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8)
end
module Lib_Formula_Impl2_EventuallySatInner
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Assignments_CompatibleInner_Interface as CompatibleInner0
  predicate eventually_sat_inner (self : Type.lib_formula_formula) (a : Seq.seq uint8) = 
    exists a2 : (Seq.seq uint8) . Seq.length a2 = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars self) && CompatibleInner0.compatible_inner a a2 && SatInner0.sat_inner self a2
end
module Lib_Formula_Impl2_EventuallySat_Interface
  use Type
  predicate eventually_sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
end
module Lib_Formula_Impl2_EventuallySat
  use Type
  clone Lib_Formula_Impl2_EventuallySatInner_Interface as EventuallySatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate eventually_sat (self : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) = 
    EventuallySatInner0.eventually_sat_inner self (Model0.model a)
end
module Lib_Formula_Impl3_AddClause_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Clause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone Lib_Clause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Clause_Impl1_Model_Interface as Model1
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Formula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model0 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val add_clause [@cfg:stackify] (self : borrowed (Type.lib_formula_formula)) (clause : Type.lib_clause_clause) (watches : borrowed (Type.lib_watches_watches)) (_t : Type.lib_trail_trail) : usize
    requires {EquisatExtensionInner0.equisat_extension_inner clause (Model0.model self)}
    requires {NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model1.model clause)}
    requires {VarsInRangeInner0.vars_in_range_inner (Model1.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)))}
    requires {Seq.length (Model1.model clause) >= 2}
    requires {Invariant0.invariant' _t ( * self)}
    requires {Invariant1.invariant' ( * self)}
    ensures { Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) + 1 = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ self))) }
    ensures { UInt64.to_int result = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) }
    ensures { EquisatCompatible0.equisat_compatible ( * self) ( ^ self) }
    ensures { Invariant0.invariant' _t ( * self) }
    ensures { Invariant1.invariant' ( ^ self) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ self)) }
    
end
module Lib_Formula_Impl3_AddClause
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Lit_Impl1_SatInner as SatInner1
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model2.model
  clone Lib_Formula_Impl0_Model as Model3 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Lit_Impl1_Invariant as Invariant2
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model4.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model5.model,
  function Model1.model = Model6.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Clause_Impl1_Model as Model1 with function Model0.model = Model4.model
  clone Lib_Clause_Impl3_Equals as Equals0 with function Model0.model = Model1.model
  clone Lib_Formula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model1.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model1.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant3 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Clause_Impl3_SatInner as SatInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Formula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Formula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Formula_Impl2_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model3.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Clause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Formula_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl1_Model as Model0 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model3.model
  val add_clause [@cfg:stackify] (self : borrowed (Type.lib_formula_formula)) (clause : Type.lib_clause_clause) (watches : borrowed (Type.lib_watches_watches)) (_t : Type.lib_trail_trail) : usize
    requires {EquisatExtensionInner0.equisat_extension_inner clause (Model0.model self)}
    requires {NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model1.model clause)}
    requires {VarsInRangeInner0.vars_in_range_inner (Model1.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)))}
    requires {Seq.length (Model1.model clause) >= 2}
    requires {Invariant0.invariant' _t ( * self)}
    requires {Invariant1.invariant' ( * self)}
    ensures { Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) + 1 = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( ^ self))) }
    ensures { UInt64.to_int result = Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses ( * self))) }
    ensures { EquisatCompatible0.equisat_compatible ( * self) ( ^ self) }
    ensures { Invariant0.invariant' _t ( * self) }
    ensures { Invariant1.invariant' ( ^ self) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * self)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ self)) }
    
end
module Lib_Logic_LemmaSamePol_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl3_SameIdxSamePolarityExcept_Interface as SameIdxSamePolarityExcept0
  clone Lib_Clause_Impl2_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  clone Lib_Lit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner0
  function lemma_same_pol (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Seq.seq uint8) (idx : int) : ()
    
end
module Lib_Logic_LemmaSamePol
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl3_SameIdxSamePolarityExcept_Interface as SameIdxSamePolarityExcept0
  clone Lib_Clause_Impl2_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  clone Lib_Lit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner0
  function lemma_same_pol (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (a : Seq.seq uint8) (idx : int) : ()
    
  axiom lemma_same_pol_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, a : Seq.seq uint8, idx : int . UnsatInner0.unsat_inner c2 a -> (exists i : (int) . 0 <= i && i < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) i)) = idx && SatInner0.sat_inner (Seq.get (Model0.model c) i) a) -> Invariant0.invariant' c2 (Seq.length a) -> Invariant0.invariant' c (Seq.length a) -> PostUnitInner0.post_unit_inner c a -> SameIdxSamePolarityExcept0.same_idx_same_polarity_except c2 c idx
end
module Lib_Logic_LemmaResolvedPostAndUnsatIsUnsat_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl2_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  clone Lib_Lit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  clone Lib_Clause_Impl3_ResolventOf_Interface as ResolventOf0
  function lemma_resolved_post_and_unsat_is_unsat (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (a : Seq.seq uint8) (c_idx : int) (c2_idx : int) : ()
    
end
module Lib_Logic_LemmaResolvedPostAndUnsatIsUnsat
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl2_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  clone Lib_Lit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  clone Lib_Clause_Impl3_ResolventOf_Interface as ResolventOf0
  function lemma_resolved_post_and_unsat_is_unsat (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (a : Seq.seq uint8) (c_idx : int) (c2_idx : int) : ()
    
  axiom lemma_resolved_post_and_unsat_is_unsat_spec : forall c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, a : Seq.seq uint8, c_idx : int, c2_idx : int . ResolventOf0.resolvent_of c3 c c2 c2_idx c_idx -> 0 <= c2_idx && c2_idx < Seq.length (Model0.model c2) -> 0 <= c_idx && c_idx < Seq.length (Model0.model c) -> UnsatInner0.unsat_inner c2 a -> SatInner0.sat_inner (Seq.get (Model0.model c) c_idx) a -> Invariant0.invariant' c2 (Seq.length a) -> Invariant0.invariant' c (Seq.length a) -> PostUnitInner0.post_unit_inner c a -> UnsatInner0.unsat_inner c3 a
end
module Lib_Logic_LemmaEqFormulas_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Clause_Impl3_Equals_Interface as Equals0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  function lemma_eq_formulas (f : (Seq.seq (Type.lib_clause_clause), int)) (f2 : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
end
module Lib_Logic_LemmaEqFormulas
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone Lib_Clause_Impl3_Equals_Interface as Equals0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  function lemma_eq_formulas (f : (Seq.seq (Type.lib_clause_clause), int)) (f2 : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
  axiom lemma_eq_formulas_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), f2 : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause . FormulaInvariant0.formula_invariant f -> (let (a, _) = f2 in a) = Seq.snoc (let (a, _) = f in a) c -> Seq.length (let (a, _) = f in a) + 1 = Seq.length (let (a, _) = f2 in a) && (forall i : (int) . 0 <= i && i < Seq.length (let (a, _) = f in a) -> Equals0.equals (Seq.get (let (a, _) = f in a) i) (Seq.get (let (a, _) = f2 in a) i)) && Model0.model (Seq.get (let (a, _) = f2 in a) (Seq.length (let (a, _) = f2 in a) - 1)) = Model0.model c
end
module Lib_Trail_TrailInvariantFullNoSep_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate trail_invariant_full_no_sep (trail : (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason))) (f : Type.lib_formula_formula)
    
end
module Lib_Trail_TrailInvariantFullNoSep
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Trail_TrailInvariantFull_Interface as TrailInvariantFull0
  predicate trail_invariant_full_no_sep (trail : (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason))) (f : Type.lib_formula_formula)
    
   = 
    TrailInvariantFull0.trail_invariant_full (let (a, _) = trail in a) (let (_, a) = trail in a) f
end
module Lib_Logic_LemmaEqTrail_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Trail_TrailInvariantFullNoSep_Interface as TrailInvariantFullNoSep0
  function lemma_eq_trail (t : (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason))) (t2 : (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason))) (f : Type.lib_formula_formula) (l : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : ()
    
end
module Lib_Logic_LemmaEqTrail
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Trail_TrailInvariantFullNoSep_Interface as TrailInvariantFullNoSep0
  function lemma_eq_trail (t : (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason))) (t2 : (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason))) (f : Type.lib_formula_formula) (l : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : ()
    
  axiom lemma_eq_trail_spec : forall t : (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason)), t2 : (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason)), f : Type.lib_formula_formula, l : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit) . TrailInvariantFullNoSep0.trail_invariant_full_no_sep t2 f -> (let (_, a) = t2 in a) = (let (_, a) = t in a) -> (let (a, _) = t2 in a) = Seq.snoc (let (a, _) = t in a) l -> TrailInvariantFullNoSep0.trail_invariant_full_no_sep t f && Seq.length (let (a, _) = t in a) + 1 = Seq.length (let (a, _) = t2 in a)
end
module Lib_Logic_LemmaSatGivesSat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Clause_Impl3_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Clause_Impl3_ResolventOf_Interface as ResolventOf0
  clone Lib_Formula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  function lemma_sat_gives_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
end
module Lib_Logic_LemmaSatGivesSat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Clause_Impl3_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Clause_Impl3_ResolventOf_Interface as ResolventOf0
  clone Lib_Formula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  function lemma_sat_gives_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
  axiom lemma_sat_gives_sat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, k : int, m : int . EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f -> ResolventOf0.resolvent_of c3 c c2 k m -> EquisatExtensionInner0.equisat_extension_inner c2 f -> InFormulaInner0.in_formula_inner c f -> FormulaInvariant0.formula_invariant f -> EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a)
end
module Lib_Logic_LemmaNotSatGivesNotSat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Formula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  function lemma_not_sat_gives_not_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) : ()
    
end
module Lib_Logic_LemmaNotSatGivesNotSat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Formula_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  function lemma_not_sat_gives_not_sat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) : ()
    
  axiom lemma_not_sat_gives_not_sat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause . not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass f) -> FormulaInvariant0.formula_invariant f -> not (EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass (Seq.snoc (let (a, _) = f in a) c3, let (_, a) = f in a))
end
module Lib_Logic_LemmaExtendedFormulaIsEquisatCompatible_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Clause_Impl3_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Clause_Impl3_ResolventOf_Interface as ResolventOf0
  function lemma_extended_formula_is_equisat_compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
end
module Lib_Logic_LemmaExtendedFormulaIsEquisatCompatible
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Clause_Impl3_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Clause_Impl3_ResolventOf_Interface as ResolventOf0
  function lemma_extended_formula_is_equisat_compatible (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
  axiom lemma_extended_formula_is_equisat_compatible_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, k : int, m : int . ResolventOf0.resolvent_of c3 c c2 k m -> InFormulaInner0.in_formula_inner c2 f -> InFormulaInner0.in_formula_inner c f -> FormulaInvariant0.formula_invariant f -> EquisatExtensionInner0.equisat_extension_inner c3 f
end
module Lib_Logic_LemmaResolventOfEquisatExtensionIsEquisat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Clause_Impl3_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Clause_Impl3_ResolventOf_Interface as ResolventOf0
  function lemma_resolvent_of_equisat_extension_is_equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
end
module Lib_Logic_LemmaResolventOfEquisatExtensionIsEquisat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Clause_Impl3_InFormulaInner_Interface as InFormulaInner0
  clone Lib_Clause_Impl3_ResolventOf_Interface as ResolventOf0
  function lemma_resolvent_of_equisat_extension_is_equisat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) (c2 : Type.lib_clause_clause) (c3 : Type.lib_clause_clause) (k : int) (m : int) : ()
    
  axiom lemma_resolvent_of_equisat_extension_is_equisat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause, c2 : Type.lib_clause_clause, c3 : Type.lib_clause_clause, k : int, m : int . ResolventOf0.resolvent_of c3 c c2 k m -> InFormulaInner0.in_formula_inner c2 f -> EquisatExtensionInner0.equisat_extension_inner c f -> FormulaInvariant0.formula_invariant f -> EquisatExtensionInner0.equisat_extension_inner c3 f
end
module Lib_Logic_LemmaExtendingWithEquiExtIsEquiCompat_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Formula_EquisatCompatibleInner_Interface as EquisatCompatibleInner0
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  function lemma_extending_with_equi_ext_is_equi_compat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
end
module Lib_Logic_LemmaExtendingWithEquiExtIsEquiCompat
  use seq.Seq
  use Type
  use mach.int.Int
  clone Lib_Formula_EquisatCompatibleInner_Interface as EquisatCompatibleInner0
  clone Lib_Formula_FormulaInvariant_Interface as FormulaInvariant0
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  function lemma_extending_with_equi_ext_is_equi_compat (f : (Seq.seq (Type.lib_clause_clause), int)) (c : Type.lib_clause_clause) : ()
    
  axiom lemma_extending_with_equi_ext_is_equi_compat_spec : forall f : (Seq.seq (Type.lib_clause_clause), int), c : Type.lib_clause_clause . EquisatExtensionInner0.equisat_extension_inner c f -> FormulaInvariant0.formula_invariant f -> EquisatCompatibleInner0.equisat_compatible_inner f (Seq.snoc (let (a, _) = f in a) c, let (_, a) = f in a)
end
module Lib_Logic_LemmaEquisatIsTrans_Interface
  use Type
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  function lemma_equisat_is_trans (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (f3 : Type.lib_formula_formula) : ()
    
end
module Lib_Logic_LemmaEquisatIsTrans
  use Type
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  function lemma_equisat_is_trans (f : Type.lib_formula_formula) (f2 : Type.lib_formula_formula) (f3 : Type.lib_formula_formula) : ()
    
  axiom lemma_equisat_is_trans_spec : forall f : Type.lib_formula_formula, f2 : Type.lib_formula_formula, f3 : Type.lib_formula_formula . EquisatCompatible0.equisat_compatible f2 f3 -> EquisatCompatible0.equisat_compatible f f2 -> Invariant0.invariant' f3 -> Invariant0.invariant' f2 -> Invariant0.invariant' f -> EquisatCompatible0.equisat_compatible f f3
end
module Lib_Logic_BoolToAssignedstate_Interface
  use prelude.UInt8
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  function bool_to_assignedstate (b : bool) : uint8
end
module Lib_Logic_BoolToAssignedstate
  use prelude.UInt8
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  function bool_to_assignedstate (b : bool) : uint8
  axiom bool_to_assignedstate_spec : forall b : bool . (b -> UInt8.to_int (bool_to_assignedstate b) = 1) && (not b -> UInt8.to_int (bool_to_assignedstate b) = 0)
end
module Lib_Logic_FlipV_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function flip_v (v : uint8) : uint8
end
module Lib_Logic_FlipV
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  use mach.int.Int32
  function flip_v (v : uint8) : uint8 = 
    if UInt8.to_int v = 0 then (1 : uint8) else if UInt8.to_int v = 1 then (0 : uint8) else v
end
module Lib_Logic_Pos_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function pos () : uint8
end
module Lib_Logic_Pos
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function pos () : uint8 = 
    (1 : uint8)
end
module Lib_Logic_Neg_Interface
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function neg () : uint8
end
module Lib_Logic_Neg
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  function neg () : uint8 = 
    (0 : uint8)
end
module Lib_Logic_LemmaCompleteImpliesSatOrUnsat_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Assignments_CompleteInner_Interface as CompleteInner0
  function lemma_complete_implies_sat_or_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_LemmaCompleteImpliesSatOrUnsat
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Assignments_CompleteInner_Interface as CompleteInner0
  function lemma_complete_implies_sat_or_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
  axiom lemma_complete_implies_sat_or_unsat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . CompleteInner0.complete_inner a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> UnsatInner0.unsat_inner f a || SatInner0.sat_inner f a
end
module Lib_Logic_LemmaCompleteAndNotSatImpliesUnsat_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Assignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  function lemma_complete_and_not_sat_implies_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_LemmaCompleteAndNotSatImpliesUnsat
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Assignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  function lemma_complete_and_not_sat_implies_unsat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
  axiom lemma_complete_and_not_sat_implies_unsat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . not (SatInner0.sat_inner f a) -> CompleteInner0.complete_inner a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> UnsatInner0.unsat_inner f a
end
module Lib_Logic_LemmaCompleteAndNotUnsatImpliesSat_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Assignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner0
  function lemma_complete_and_not_unsat_implies_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_LemmaCompleteAndNotUnsatImpliesSat
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Assignments_CompleteInner_Interface as CompleteInner0
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner0
  function lemma_complete_and_not_unsat_implies_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
  axiom lemma_complete_and_not_unsat_implies_sat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . not (UnsatInner0.unsat_inner f a) -> CompleteInner0.complete_inner a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> SatInner0.sat_inner f a
end
module Lib_Logic_LemmaNotSatFormulaImpliesUnsatFormula_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner0
  function lemma_not_sat_formula_implies_unsat_formula (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
end
module Lib_Logic_LemmaNotSatFormulaImpliesUnsatFormula
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_AssignmentsInvariant_Interface as AssignmentsInvariant0
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner0
  function lemma_not_sat_formula_implies_unsat_formula (f : Type.lib_formula_formula) (a : Seq.seq uint8) : ()
  axiom lemma_not_sat_formula_implies_unsat_formula_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8 . UnsatInner0.unsat_inner f a -> AssignmentsInvariant0.assignments_invariant a f -> Invariant0.invariant' f -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f a)
end
module Lib_Logic_LemmaNotSatClauseImpliesUnsatFormula_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner1
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner0
  clone Lib_Clause_Impl3_InFormula_Interface as InFormula0
  function lemma_not_sat_clause_implies_unsat_formula (f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
    
end
module Lib_Logic_LemmaNotSatClauseImpliesUnsatFormula
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner1
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner0
  clone Lib_Clause_Impl3_InFormula_Interface as InFormula0
  function lemma_not_sat_clause_implies_unsat_formula (f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (a : Seq.seq uint8) : ()
    
  axiom lemma_not_sat_clause_implies_unsat_formula_spec : forall f : Type.lib_formula_formula, c : Type.lib_clause_clause, a : Seq.seq uint8 . InFormula0.in_formula c f -> UnsatInner0.unsat_inner c a -> UnsatInner1.unsat_inner f a
end
module Lib_Logic_LemmaUnitForces_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_FlipV_Interface as FlipV0
  function lemma_unit_forces (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_LemmaUnitForces
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_FlipV_Interface as FlipV0
  function lemma_unit_forces (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
  axiom lemma_unit_forces_spec : forall c : Type.lib_clause_clause, f : Type.lib_formula_formula, a : Seq.seq uint8, ix : int, v : uint8 . not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (FlipV0.flip_v v))) -> EventuallySatCompleteInner0.eventually_sat_complete_inner f a -> not (Unset0.unset v) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a -> Invariant0.invariant' f -> EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix v)
end
module Lib_Logic_LemmaUnitWrongPolarityUnsatFormula_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_FlipV_Interface as FlipV0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Clause_Impl3_UnitInner_Interface as UnitInner0
  clone Lib_Clause_Impl3_InFormula_Interface as InFormula0
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  clone Lib_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Lit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  function lemma_unit_wrong_polarity_unsat_formula (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_LemmaUnitWrongPolarityUnsatFormula
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Formula_Impl2_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_FlipV_Interface as FlipV0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Clause_Impl3_UnitInner_Interface as UnitInner0
  clone Lib_Clause_Impl3_InFormula_Interface as InFormula0
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  clone Lib_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Lit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  function lemma_unit_wrong_polarity_unsat_formula (c : Type.lib_clause_clause) (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
  axiom lemma_unit_wrong_polarity_unsat_formula_spec : forall c : Type.lib_clause_clause, f : Type.lib_formula_formula, a : Seq.seq uint8, ix : int, v : uint8 . (forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) && not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix) -> UnsatInner0.unsat_inner (Seq.get (Model0.model c) j) a) -> (exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model c) j)) = v) -> Invariant0.invariant' c (Seq.length a) -> InFormula0.in_formula c f -> UnitInner0.unit_inner c a -> not (Unset0.unset v) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length a -> Invariant1.invariant' f -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (FlipV0.flip_v v))) && UnsatInner1.unsat_inner f (Seq.set a ix (FlipV0.flip_v v))
end
module Lib_Logic_LemmaCorrectPolarityMakesClauseSat_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl3_SatInner_Interface as SatInner0
  clone Lib_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Clause_Impl1_Model_Interface as Model0
  function lemma_correct_polarity_makes_clause_sat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_LemmaCorrectPolarityMakesClauseSat
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl3_SatInner_Interface as SatInner0
  clone Lib_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Clause_Impl1_Model_Interface as Model0
  function lemma_correct_polarity_makes_clause_sat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
  axiom lemma_correct_polarity_makes_clause_sat_spec : forall c : Type.lib_clause_clause, a : Seq.seq uint8, ix : int, v : uint8 . (exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Seq.get (Model0.model c) j)) = v) -> 0 <= ix && ix < Seq.length a -> SatInner0.sat_inner c (Seq.set a ix v)
end
module Lib_Logic_LemmaIncorrectPolarityMakesClauseUnsat_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Clause_Impl3_UnitInner_Interface as UnitInner0
  clone Lib_Clause_Impl3_SatInner_Interface as SatInner1
  clone Lib_Lit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  clone Lib_Lit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  function lemma_incorrect_polarity_makes_clause_unsat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
end
module Lib_Logic_LemmaIncorrectPolarityMakesClauseUnsat
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner1
  clone Lib_Logic_FlipV_Interface as FlipV0
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Clause_Impl3_UnitInner_Interface as UnitInner0
  clone Lib_Clause_Impl3_SatInner_Interface as SatInner1
  clone Lib_Lit_Impl1_SatInner_Interface as SatInner0
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  clone Lib_Lit_Impl1_UnsatInner_Interface as UnsatInner0
  clone Lib_Clause_Impl1_Model_Interface as Model0
  function lemma_incorrect_polarity_makes_clause_unsat (c : Type.lib_clause_clause) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
    
  axiom lemma_incorrect_polarity_makes_clause_unsat_spec : forall c : Type.lib_clause_clause, a : Seq.seq uint8, ix : int, v : uint8 . (forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) && not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix) -> UnsatInner0.unsat_inner (Seq.get (Model0.model c) j) a) -> Invariant0.invariant' c (Seq.length a) -> (exists j : (int) . 0 <= j && j < Seq.length (Model0.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)) = ix && SatInner0.sat_inner (Seq.get (Model0.model c) j) a) -> not (SatInner1.sat_inner c a) -> UnitInner0.unit_inner c a -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> not (Unset0.unset v) -> (forall j : (int) . 0 <= j && j < Seq.length (Model0.model c) -> not (Unset0.unset (Seq.get (Seq.set a ix v) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) j)))))) && not (Unset0.unset (Seq.get (Seq.set a ix (FlipV0.flip_v v)) ix)) && UnsatInner1.unsat_inner c (Seq.set a ix (FlipV0.flip_v v)) && not (SatInner1.sat_inner c (Seq.set a ix (FlipV0.flip_v v)))
end
module Lib_Logic_LemmaExtensionSatBaseSat_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  function lemma_extension_sat_base_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
end
module Lib_Logic_LemmaExtensionSatBaseSat
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  function lemma_extension_sat_base_sat (f : Type.lib_formula_formula) (a : Seq.seq uint8) (ix : int) (v : uint8) : ()
  axiom lemma_extension_sat_base_sat_spec : forall f : Type.lib_formula_formula, a : Seq.seq uint8, ix : int, v : uint8 . EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix v) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> EventuallySatCompleteInner0.eventually_sat_complete_inner f a
end
module Lib_Logic_LemmaExtensionsUnsatBaseUnsat_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Logic_Neg_Interface as Neg0
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_Pos_Interface as Pos0
  function lemma_extensions_unsat_base_unsat (a : Seq.seq uint8) (ix : int) (f : Type.lib_formula_formula) : ()
end
module Lib_Logic_LemmaExtensionsUnsatBaseUnsat
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use prelude.UInt8
  use Type
  clone Lib_Logic_Unset_Interface as Unset0
  clone Lib_Logic_Neg_Interface as Neg0
  clone Lib_Formula_Impl2_EventuallySatCompleteInner_Interface as EventuallySatCompleteInner0
  clone Lib_Logic_Pos_Interface as Pos0
  function lemma_extensions_unsat_base_unsat (a : Seq.seq uint8) (ix : int) (f : Type.lib_formula_formula) : ()
  axiom lemma_extensions_unsat_base_unsat_spec : forall a : Seq.seq uint8, ix : int, f : Type.lib_formula_formula . not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (Pos0.pos ()))) -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f (Seq.set a ix (Neg0.neg ()))) -> 0 <= ix && ix < Seq.length a && Unset0.unset (Seq.get a ix) -> not (EventuallySatCompleteInner0.eventually_sat_complete_inner f a)
end
module Lib_SolverDpll_IsClauseSat_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone Lib_Clause_Impl3_Sat_Interface as Sat0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val is_clause_sat [@cfg:stackify] (f : Type.lib_formula_formula) (idx : usize) (a : Type.lib_assignments_assignments) : bool
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    ensures { result = Sat0.sat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int idx)) a }
    
end
module Lib_SolverDpll_IsClauseSat
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant3
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model3.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model3.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant2 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Lit_Impl1_SatInner as SatInner1
  clone Lib_Clause_Impl3_SatInner as SatInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Clause_Impl3_Sat as Sat0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant0 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val is_clause_sat [@cfg:stackify] (f : Type.lib_formula_formula) (idx : usize) (a : Type.lib_assignments_assignments) : bool
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    ensures { result = Sat0.sat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int idx)) a }
    
end
module Lib_SolverDpll_IsClauseUnsat_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone Lib_Clause_Impl3_Unsat_Interface as Unsat0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val is_clause_unsat [@cfg:stackify] (f : Type.lib_formula_formula) (idx : usize) (a : Type.lib_assignments_assignments) : bool
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    ensures { result = Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int idx)) a }
    
end
module Lib_SolverDpll_IsClauseUnsat
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant3
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model3.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model3.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant2 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model1 with function Model0.model = Model2.model
  clone Lib_Clause_Impl3_Unsat as Unsat0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant0 with function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val is_clause_unsat [@cfg:stackify] (f : Type.lib_formula_formula) (idx : usize) (a : Type.lib_assignments_assignments) : bool
    requires {UInt64.to_int idx < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Invariant0.invariant' a f}
    requires {Invariant1.invariant' f}
    ensures { result = Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int idx)) a }
    
end
module Lib_SolverDpll_LearnUnit_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use mach.int.UInt64
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val learn_unit [@cfg:stackify] (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (lit : Type.lib_lit_lit) (f : Type.lib_formula_formula) : ()
    requires {TrailSemInvariant0.trail_sem_invariant ( * trail) f ( * a)}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) > 0}
    requires {Invariant0.invariant' ( * trail) f}
    requires {Invariant1.invariant' ( * a) f}
    requires {Invariant2.invariant' f}
    ensures { Invariant1.invariant' ( ^ a) f }
    ensures { Invariant0.invariant' ( ^ trail) f }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) = 1 }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ trail) f ( ^ a) }
    
end
module Lib_SolverDpll_LearnUnit
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  use mach.int.UInt64
  clone Lib_Lit_Impl1_Invariant as Invariant4
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner0
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model6.model
  clone Lib_Clause_Impl1_Model as Model4 with function Model0.model = Model6.model
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model4.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model4.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant3 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model2 with function Model0.model = Model5.model
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model2.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model2.model
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model3.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model3.model,
  predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model3.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model4.model,
  predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val learn_unit [@cfg:stackify] (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (lit : Type.lib_lit_lit) (f : Type.lib_formula_formula) : ()
    requires {TrailSemInvariant0.trail_sem_invariant ( * trail) f ( * a)}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) > 0}
    requires {Invariant0.invariant' ( * trail) f}
    requires {Invariant1.invariant' ( * a) f}
    requires {Invariant2.invariant' f}
    ensures { Invariant1.invariant' ( ^ a) f }
    ensures { Invariant0.invariant' ( ^ trail) f }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) = 1 }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ trail) f ( ^ a) }
    
end
module Lib_SolverDpll_UnitPropagateUnverified_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  clone Lib_Assignments_Impl1_Compatible_Interface as Compatible0
  clone Lib_Formula_Impl2_EventuallySatComplete_Interface as EventuallySatComplete0
  clone Lib_Clause_Impl3_Unsat_Interface as Unsat1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_Unsat_Interface as Unsat0
  clone Lib_Formula_Impl2_EventuallySat_Interface as EventuallySat0
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model2.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  val unit_propagate_UNVERIFIED [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) : Type.core_result_result () usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) > 0}
    requires {Invariant0.invariant' ( * trail) ( * f)}
    requires {Invariant1.invariant' ( * a) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    requires {TrailSemInvariant0.trail_sem_invariant ( * trail) ( * f) ( * a)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ trail) ( ^ f) }
    ensures { EventuallySat0.eventually_sat ( * f) ( * a) = EventuallySat0.eventually_sat ( ^ f) ( * a) }
    ensures {  ^ f =  * f }
    ensures { Invariant2.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok () -> not (Unsat0.unsat ( ^ f) ( ^ a))
      | Type.Core_Result_Result_Err n -> UInt64.to_int n < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f))) && Unsat0.unsat ( ^ f) ( ^ a) && Unsat1.unsat (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int n)) ( * a)
      end }
    ensures { EventuallySatComplete0.eventually_sat_complete ( * f) ( * a) = EventuallySatComplete0.eventually_sat_complete ( ^ f) ( ^ a) }
    ensures { Compatible0.compatible ( * a) ( ^ a) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ trail) ( ^ f) ( ^ a) }
    
end
module Lib_SolverDpll_UnitPropagateUnverified
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant4
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_SatInner as SatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model6 with function Model0.model = Model7.model
  clone Lib_Clause_Impl3_SatInner as SatInner2 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Clause_Impl3_Equals as Equals0 with function Model0.model = Model6.model
  clone Lib_Formula_Compatible as Compatible1 with predicate Equals0.equals = Equals0.equals
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model6.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant3 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model7.model
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Formula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Formula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Formula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible1.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Assignments_CompatibleInner as CompatibleInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Assignments_CompatibleCompleteInner as CompatibleCompleteInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner1 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model3 with function Model0.model = Model5.model
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model3.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Assignments_Impl1_Compatible as Compatible0 with function Model0.model = Model3.model,
  predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner
  clone Lib_Clause_Impl3_Unsat as Unsat1 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model3.model
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_SatInner as SatInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Formula_Impl2_EventuallySatCompleteInner as EventuallySatCompleteInner0 with predicate CompatibleCompleteInner0.compatible_complete_inner = CompatibleCompleteInner0.compatible_complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_Impl2_EventuallySatComplete as EventuallySatComplete0 with function Model0.model = Model3.model,
  predicate EventuallySatCompleteInner0.eventually_sat_complete_inner = EventuallySatCompleteInner0.eventually_sat_complete_inner
  clone Lib_Formula_Impl2_EventuallySatInner as EventuallySatInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_Impl2_EventuallySat as EventuallySat0 with function Model0.model = Model3.model,
  predicate EventuallySatInner0.eventually_sat_inner = EventuallySatInner0.eventually_sat_inner
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model1.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Formula_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Formula_Impl2_Unsat as Unsat0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Formula_Impl0_Model as Model4 with function Model0.model = Model1.model
  clone Lib_Formula_Impl2_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model4.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model1.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model6.model,
  predicate Sat0.sat = Sat0.sat
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model2.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  val unit_propagate_UNVERIFIED [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) : Type.core_result_result () usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) > 0}
    requires {Invariant0.invariant' ( * trail) ( * f)}
    requires {Invariant1.invariant' ( * a) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    requires {TrailSemInvariant0.trail_sem_invariant ( * trail) ( * f) ( * a)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ trail) ( ^ f) }
    ensures { EventuallySat0.eventually_sat ( * f) ( * a) = EventuallySat0.eventually_sat ( ^ f) ( * a) }
    ensures {  ^ f =  * f }
    ensures { Invariant2.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok () -> not (Unsat0.unsat ( ^ f) ( ^ a))
      | Type.Core_Result_Result_Err n -> UInt64.to_int n < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f))) && Unsat0.unsat ( ^ f) ( ^ a) && Unsat1.unsat (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int n)) ( * a)
      end }
    ensures { EventuallySatComplete0.eventually_sat_complete ( * f) ( * a) = EventuallySatComplete0.eventually_sat_complete ( ^ f) ( ^ a) }
    ensures { Compatible0.compatible ( * a) ( ^ a) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ trail) ( ^ f) ( ^ a) }
    
end
module Lib_SolverDpll_HandleConflict_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Formula_Impl2_Unsat_Interface as Unsat1
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Clause_Impl3_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model2.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val handle_conflict [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (t : borrowed (Type.lib_trail_trail)) (cref : usize) (w : borrowed (Type.lib_watches_watches)) : bool
    requires {TrailSemInvariant0.trail_sem_invariant ( * t) ( * f) ( * a)}
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref)) ( * a)}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' ( * a) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ t) ( ^ f) }
    ensures { Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail ( ^ t))) > 0 }
    ensures { Invariant2.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ t) ( ^ f) ( ^ a) }
    ensures { if result then true else Unsat1.unsat ( ^ f) ( ^ a) }
    
end
module Lib_SolverDpll_HandleConflict
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Lit_Impl1_Invariant as Invariant4
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model7.model
  clone Lib_Clause_Impl1_Model as Model5 with function Model0.model = Model7.model
  clone Lib_Clause_Impl3_SatInner as SatInner1 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Formula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Clause_Impl3_Equals as Equals0 with function Model0.model = Model5.model
  clone Lib_Formula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Formula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model5.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model5.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant3 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model3 with function Model0.model = Model6.model
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model3.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model3.model
  clone Lib_Clause_Impl3_Unsat as Unsat0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model0.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Formula_Impl2_UnsatInner as UnsatInner1 with function Model0.model = Model0.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Formula_Impl2_Unsat as Unsat1 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Formula_Impl0_Model as Model4 with function Model0.model = Model0.model
  clone Lib_Formula_Impl2_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model4.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model0.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model5.model,
  predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model1.model,
  function Model1.model = Model2.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model2.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val handle_conflict [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (t : borrowed (Type.lib_trail_trail)) (cref : usize) (w : borrowed (Type.lib_watches_watches)) : bool
    requires {TrailSemInvariant0.trail_sem_invariant ( * t) ( * f) ( * a)}
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f))) (UInt64.to_int cref)) ( * a)}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses ( * f)))}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' ( * a) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ t) ( ^ f) }
    ensures { Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail ( ^ t))) > 0 }
    ensures { Invariant2.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ t) ( ^ f) ( ^ a) }
    ensures { if result then true else Unsat1.unsat ( ^ f) ( ^ a) }
    
end
module Lib_SolverDpll_UnitPropStep_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  clone Lib_Formula_Impl2_Unsat_Interface as Unsat0
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Decision_Impl0_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val unit_prop_step [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    requires {TrailSemInvariant0.trail_sem_invariant ( * t) ( * f) ( * a)}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant2.invariant' ( * a) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ t) ( ^ f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) > 0 }
    ensures { Invariant3.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ t) ( ^ f) ( ^ a) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some (True) -> not (Unsat0.unsat ( ^ f) ( ^ a))
      | Type.Core_Option_Option_Some (False) -> Unsat0.unsat ( ^ f) ( ^ a)
      | Type.Core_Option_Option_None -> true
      end }
    
end
module Lib_SolverDpll_UnitPropStep
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Lit_Impl1_Invariant as Invariant5
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model8.model
  clone Lib_Clause_Impl1_Model as Model6 with function Model0.model = Model8.model
  clone Lib_Clause_Impl3_SatInner as SatInner1 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Formula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Clause_Impl3_Equals as Equals0 with function Model0.model = Model6.model
  clone Lib_Formula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Formula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model6.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant4 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner1 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model3 with function Model0.model = Model7.model
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model3.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant2 with function Model0.model = Model3.model
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model5.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Formula_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Formula_Impl2_Unsat as Unsat0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Formula_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Formula_Impl2_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model4.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model5.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model6.model,
  predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone Lib_Decision_Impl0_Invariant as Invariant1 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val unit_prop_step [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    requires {TrailSemInvariant0.trail_sem_invariant ( * t) ( * f) ( * a)}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant2.invariant' ( * a) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ t) ( ^ f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) > 0 }
    ensures { Invariant3.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ t) ( ^ f) ( ^ a) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some (True) -> not (Unsat0.unsat ( ^ f) ( ^ a))
      | Type.Core_Option_Option_Some (False) -> Unsat0.unsat ( ^ f) ( ^ a)
      | Type.Core_Option_Option_None -> true
      end }
    
end
module Lib_SolverDpll_UnitPropLoop_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone Lib_Formula_Impl2_Unsat_Interface as Unsat0
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Decision_Impl0_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  val unit_prop_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : bool
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {TrailSemInvariant0.trail_sem_invariant ( * t) ( * f) ( * a)}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant2.invariant' ( * a) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ t) ( ^ f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) > 0 }
    ensures { Invariant3.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ t) ( ^ f) ( ^ a) }
    ensures { result -> not (Unsat0.unsat ( ^ f) ( ^ a)) }
    ensures { not result -> Unsat0.unsat ( ^ f) ( ^ a) }
    
end
module Lib_SolverDpll_UnitPropLoop
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Lit_Impl1_Invariant as Invariant5
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model8.model
  clone Lib_Clause_Impl1_Model as Model6 with function Model0.model = Model8.model
  clone Lib_Clause_Impl3_SatInner as SatInner1 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Formula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Clause_Impl3_Equals as Equals0 with function Model0.model = Model6.model
  clone Lib_Formula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Formula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model6.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant4 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner1 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model3 with function Model0.model = Model7.model
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model3.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant2 with function Model0.model = Model3.model
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model5.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Formula_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Formula_Impl2_Unsat as Unsat0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Formula_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Formula_Impl2_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model4.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model5.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model6.model,
  predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone Lib_Decision_Impl0_Invariant as Invariant1 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  val unit_prop_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : bool
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {TrailSemInvariant0.trail_sem_invariant ( * t) ( * f) ( * a)}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant2.invariant' ( * a) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { Invariant2.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ t) ( ^ f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) > 0 }
    ensures { Invariant3.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ t) ( ^ f) ( ^ a) }
    ensures { result -> not (Unsat0.unsat ( ^ f) ( ^ a)) }
    ensures { not result -> Unsat0.unsat ( ^ f) ( ^ a) }
    
end
module Lib_SolverDpll_OuterLoop_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  clone Lib_Formula_Impl2_Unsat_Interface as Unsat0
  clone Lib_Assignments_Impl1_Complete_Interface as Complete0
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model2
  clone Lib_Formula_Impl2_Sat_Interface as Sat0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Decision_Impl0_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val outer_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    requires {TrailSemInvariant0.trail_sem_invariant ( * t) ( * f) ( * a)}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant2.invariant' ( * a) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some (True) -> Sat0.sat ( ^ f) ( ^ a) && Complete0.complete ( ^ a)
      | Type.Core_Option_Option_Some (False) -> Unsat0.unsat ( ^ f) ( ^ a)
      | Type.Core_Option_Option_None -> true
      end }
    ensures { Invariant2.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ t) ( ^ f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) > 0 }
    ensures { Invariant3.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ t) ( ^ f) ( ^ a) }
    
end
module Lib_SolverDpll_OuterLoop
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant5
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Lit_Impl1_SatInner as SatInner2
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model8.model
  clone Lib_Clause_Impl1_Model as Model6 with function Model0.model = Model8.model
  clone Lib_Clause_Impl3_Equals as Equals0 with function Model0.model = Model6.model
  clone Lib_Formula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model6.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant4 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner1 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Clause_Impl3_SatInner as SatInner1 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Formula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model3 with function Model0.model = Model7.model
  clone Lib_Lit_Impl1_Sat as Sat1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model3.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant2 with function Model0.model = Model3.model
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model5.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Formula_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Formula_Impl2_Unsat as Unsat0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Formula_Impl2_SatInner as SatInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_Impl2_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Formula_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model5.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model6.model,
  predicate Sat0.sat = Sat1.sat
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Formula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Formula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Formula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Formula_Impl2_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model4.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Assignments_Impl1_Complete as Complete0 with function Model0.model = Model3.model,
  predicate Unset0.unset = Unset0.unset
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone Lib_Decision_Impl0_Invariant as Invariant1 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val outer_loop [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : Type.core_option_option bool
    requires {TrailSemInvariant0.trail_sem_invariant ( * t) ( * f) ( * a)}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant2.invariant' ( * a) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { match (result) with
      | Type.Core_Option_Option_Some (True) -> Sat0.sat ( ^ f) ( ^ a) && Complete0.complete ( ^ a)
      | Type.Core_Option_Option_Some (False) -> Unsat0.unsat ( ^ f) ( ^ a)
      | Type.Core_Option_Option_None -> true
      end }
    ensures { Invariant2.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ t) ( ^ f) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ t))) > 0 }
    ensures { Invariant3.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ t) ( ^ f) ( ^ a) }
    
end
module Lib_SolverDpll_Inner_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone Lib_Formula_Impl2_Unsat_Interface as Unsat0
  clone Lib_Formula_Impl2_EventuallySatCompleteNoAss_Interface as EventuallySatCompleteNoAss0
  clone Lib_Formula_Impl2_SatInner_Interface as SatInner0
  clone Lib_Assignments_Impl0_Model_Interface as Model2
  clone Lib_Formula_Impl2_Sat_Interface as Sat0 with function Model0.model = Model2.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant2
  clone Lib_Decision_Impl0_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val inner [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : bool
    requires {TrailSemInvariant0.trail_sem_invariant ( * t) ( * f) ( * a)}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant2.invariant' ( * a) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { if result then
      Sat0.sat ( ^ f) ( ^ a) && Sat0.sat ( * f) ( ^ a) && EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass ( * f)
    else
      Unsat0.unsat ( ^ f) ( ^ a)
     }
    
end
module Lib_SolverDpll_Inner
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant5
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant5.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Lit_Impl1_SatInner as SatInner2
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model8.model
  clone Lib_Clause_Impl1_Model as Model6 with function Model0.model = Model8.model
  clone Lib_Clause_Impl3_Equals as Equals0 with function Model0.model = Model6.model
  clone Lib_Formula_Compatible as Compatible0 with predicate Equals0.equals = Equals0.equals
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model6.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant4 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner1 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Clause_Impl3_SatInner as SatInner1 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Formula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Formula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss1 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Formula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss1.eventually_sat_complete_no_ass
  clone Lib_Formula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible0.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model3 with function Model0.model = Model7.model
  clone Lib_Lit_Impl1_Sat as Sat1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model3.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant2 with function Model0.model = Model3.model
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model5.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Formula_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Formula_Impl2_Unsat as Unsat0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Formula_Impl2_SatInner as SatInner0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_Impl2_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_Impl2_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, axiom .
  clone Lib_Formula_Impl0_Model as Model4 with function Model0.model = Model5.model
  clone Lib_Formula_Impl2_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model4.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant3 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model5.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model6.model,
  predicate Sat0.sat = Sat1.sat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = usize
  clone Lib_Decision_Impl0_Invariant as Invariant1 with function Model0.model = Model2.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val inner [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (d : Type.lib_decision_decisions) (t : borrowed (Type.lib_trail_trail)) (w : borrowed (Type.lib_watches_watches)) : bool
    requires {TrailSemInvariant0.trail_sem_invariant ( * t) ( * f) ( * a)}
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * t))) > 0}
    requires {Invariant0.invariant' ( * t) ( * f)}
    requires {Invariant1.invariant' d (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)))}
    requires {Invariant2.invariant' ( * a) ( * f)}
    requires {Invariant3.invariant' ( * f)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { if result then
      Sat0.sat ( ^ f) ( ^ a) && Sat0.sat ( * f) ( ^ a) && EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass ( * f)
    else
      Unsat0.unsat ( ^ f) ( ^ a)
     }
    
end
module Lib_SolverDpll_Solver_Interface
  use prelude.Prelude
  use Type
  val solver [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (units : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : bool
    
end
module Lib_SolverDpll_Solver
  use prelude.Prelude
  use Type
  val solver [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (units : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) : bool
    
end
module Lib_Util_SortedRangeRev_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_range_rev (s : Seq.seq (usize, usize)) (l : int) (u : int)
end
module Lib_Util_SortedRangeRev
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_range_rev (s : Seq.seq (usize, usize)) (l : int) (u : int) = 
    forall j : (int) . forall i : (int) . l <= i && i < j && j < u -> (let (a, _) = Seq.get s i in a) >= (let (a, _) = Seq.get s j in a)
end
module Lib_Util_SortedRev_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate sorted_rev (s : Seq.seq (usize, usize))
end
module Lib_Util_SortedRev
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use mach.int.Int32
  clone Lib_Util_SortedRangeRev_Interface as SortedRangeRev0
  predicate sorted_rev (s : Seq.seq (usize, usize)) = 
    SortedRangeRev0.sorted_range_rev s 0 (Seq.length s)
end
module Lib_Util_PartitionRev_Interface
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  predicate partition_rev (v : Seq.seq (usize, usize)) (i : int)
end
module Lib_Util_PartitionRev
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use mach.int.Int32
  predicate partition_rev (v : Seq.seq (usize, usize)) (i : int) = 
    forall k2 : (int) . forall k1 : (int) . 0 <= k1 && k1 < i && i <= k2 && k2 < Seq.length v -> (let (a, _) = Seq.get v k1 in a) >= (let (a, _) = Seq.get v k2 in a)
end
module CreusotContracts_Logic_Seq_Impl1_PermutationOf_Interface
  type t   
  use seq.Seq
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t)
end
module CreusotContracts_Logic_Seq_Impl1_PermutationOf
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use seq.Permut
  predicate permutation_of (self : Seq.seq t) (o : Seq.seq t) = 
    Permut.permut self o 0 (Seq.length self)
end
module Lib_Util_SortReverse_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone Lib_Util_SortedRev_Interface as SortedRev0
  clone CreusotContracts_Logic_Seq_Impl1_PermutationOf_Interface as PermutationOf0 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = (usize, usize)
  clone CreusotContracts_Logic_Model_Impl1_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize),
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = (usize, usize)
  val sort_reverse [@cfg:stackify] (v : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize))) : ()
    ensures { PermutationOf0.permutation_of (Model0.model ( ^ v)) (Model1.model v) }
    ensures { SortedRev0.sorted_rev (Model0.model ( ^ v)) }
    
end
module Lib_Util_SortReverse
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  clone Lib_Util_SortedRangeRev as SortedRangeRev0
  clone Lib_Util_SortedRev as SortedRev0 with predicate SortedRangeRev0.sorted_range_rev = SortedRangeRev0.sorted_range_rev
  clone CreusotContracts_Logic_Seq_Impl1_PermutationOf as PermutationOf0 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = (usize, usize)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = (usize, usize)
  clone CreusotContracts_Logic_Model_Impl1_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec (usize, usize),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  val sort_reverse [@cfg:stackify] (v : borrowed (Type.creusotcontracts_std1_vec_vec (usize, usize))) : ()
    ensures { PermutationOf0.permutation_of (Model0.model ( ^ v)) (Model1.model v) }
    ensures { SortedRev0.sorted_rev (Model0.model ( ^ v)) }
    
end
module Lib_Decision_Impl1_New_Interface
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone Lib_Decision_Impl0_Invariant_Interface as Invariant1
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_decision_decisions
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) }
    
end
module Lib_Decision_Impl1_New
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  use mach.int.Int
  clone Lib_Lit_Impl1_Invariant as Invariant3
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model2 with function Model0.model = Model3.model
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model2.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model2.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_Invariant as Invariant2 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = usize
  clone Lib_Decision_Impl0_Invariant as Invariant1 with function Model0.model = Model0.model
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_decision_decisions
    requires {Invariant0.invariant' f}
    ensures { Invariant1.invariant' result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) }
    
end
module Lib_Decision_Impl1_GetNext_Interface
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val get_next [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (a : Type.lib_assignments_assignments) : Type.core_option_option usize
    
end
module Lib_Decision_Impl1_GetNext
  use prelude.Prelude
  use Type
  use mach.int.Int
  use mach.int.UInt64
  val get_next [@cfg:stackify] (self : borrowed (Type.lib_decision_decisions)) (a : Type.lib_assignments_assignments) : Type.core_option_option usize
    
end
module Lib_Trail_Impl5_Clone_Interface
  use prelude.Prelude
  use Type
  val clone' [@cfg:stackify] (self : Type.lib_trail_reason) : Type.lib_trail_reason
end
module Lib_Trail_Impl5_Clone
  use prelude.Prelude
  use Type
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = Type.lib_trail_reason
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve0 with type self = Type.lib_trail_reason
  let rec cfg clone' [@cfg:stackify] (self : Type.lib_trail_reason) : Type.lib_trail_reason = 
  var _0 : Type.lib_trail_reason;
  var self_1 : Type.lib_trail_reason;
  {
    self_1 <- self;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _0 };
    _0 <- self_1;
    assume { Resolve1.resolve self_1 };
    return _0
  }
  
end
module Lib_Trail_Impl5
  use Type
  clone Lib_Trail_Impl5_Clone_Interface as Clone0
  clone Core_Clone_Clone_Clone_Interface as Clone1 with type self = Type.lib_trail_reason, val clone' = Clone0.clone'
end
module Lib_Trail_Impl1_ModelTy
  use seq.Seq
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  type modelTy  = 
    (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason))
end
module Lib_Trail_Impl1_Model_Interface
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  function model (self : Type.lib_trail_trail) : (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason))
    
end
module Lib_Trail_Impl1_Model
  use Type
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  function model (self : Type.lib_trail_trail) : (Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)), Seq.seq (usize, Type.lib_trail_reason))
    
   = 
    (Model0.model (Type.lib_trail_trail_Trail_trail self), Model1.model (Type.lib_trail_trail_Trail_vardata self))
end
module Lib_Trail_Impl1
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_Impl1_Model as Model0 with function Model0.model = Model2.model, function Model1.model = Model3.model
  clone Lib_Trail_Impl1_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Model_Model as Model1 with type self = Type.lib_trail_trail,
  type ModelTy0.modelTy = ModelTy0.modelTy, function model = Model0.model
  clone CreusotContracts_Logic_Model_Model_ModelTy as ModelTy1 with type self = Type.lib_trail_trail,
  type modelTy = ModelTy0.modelTy
end
module Lib_Trail_Impl2_VardataInvariant_Interface
  use Type
  use mach.int.Int
  predicate vardata_invariant (self : Type.lib_trail_trail) (n : int)
end
module Lib_Trail_Impl2_VardataInvariant
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Trail_VardataInvariant_Interface as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = (usize, Type.lib_trail_reason)
  predicate vardata_invariant (self : Type.lib_trail_trail) (n : int) = 
    VardataInvariant0.vardata_invariant (Model0.model (Type.lib_trail_trail_Trail_vardata self)) n
end
module Lib_Trail_Impl2_TrailInvariant_Interface
  use Type
  predicate trail_invariant (self : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Trail_Impl2_TrailInvariant
  use Type
  clone Lib_Trail_TrailInvariant_Interface as TrailInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  predicate trail_invariant (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    TrailInvariant0.trail_invariant (Model0.model (Type.lib_trail_trail_Trail_trail self)) f
end
module Lib_Trail_Impl2_CrefsInRange_Interface
  use Type
  predicate crefs_in_range (self : Type.lib_trail_trail) (f : Type.lib_formula_formula)
end
module Lib_Trail_Impl2_CrefsInRange
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Trail_CrefsInRange_Interface as CrefsInRange0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = (usize, Type.lib_trail_reason)
  predicate crefs_in_range (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) = 
    CrefsInRange0.crefs_in_range (Model0.model (Type.lib_trail_trail_Trail_vardata self)) f
end
module Lib_Trail_Impl2_OldTrailEntriesAreAssigned_Interface
  use Type
  predicate old_trail_entries_are_assigned (self : Type.lib_trail_trail) (a : Type.lib_assignments_assignments)
end
module Lib_Trail_Impl2_OldTrailEntriesAreAssigned
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.UInt8
  clone Lib_Assignments_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  predicate old_trail_entries_are_assigned (self : Type.lib_trail_trail) (a : Type.lib_assignments_assignments) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail self)) -> (forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail self)) i)) -> UInt8.to_int (Seq.get (Model2.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail self)) i)) j)))) < 2)
end
module Lib_Trail_Impl2_TrailEntriesAreAssigned_Interface
  use Type
  predicate trail_entries_are_assigned (self : Type.lib_trail_trail) (a : Type.lib_assignments_assignments)
end
module Lib_Trail_Impl2_TrailEntriesAreAssigned
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  clone Lib_Logic_BoolToAssignedstate_Interface as BoolToAssignedstate0 with axiom .
  clone Lib_Assignments_Impl0_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  predicate trail_entries_are_assigned (self : Type.lib_trail_trail) (a : Type.lib_assignments_assignments) = 
    forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail self)) -> (forall k : (int) . 0 <= k && k < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail self)) j)) -> Seq.get (Model2.model a) (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail self)) j)) k))) = BoolToAssignedstate0.bool_to_assignedstate (Type.lib_lit_lit_Lit_polarity (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail self)) j)) k)))
end
module Lib_Trail_Impl2_UnassignedNotInTrail_Interface
  use Type
  predicate unassigned_not_in_trail (self : Type.lib_trail_trail) (a : Type.lib_assignments_assignments)
end
module Lib_Trail_Impl2_UnassignedNotInTrail
  use Type
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use prelude.UInt8
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Assignments_Impl0_Model_Interface as Model0
  predicate unassigned_not_in_trail (self : Type.lib_trail_trail) (a : Type.lib_assignments_assignments) = 
    forall i : (int) . 0 <= i && i < Seq.length (Model0.model a) -> UInt8.to_int (Seq.get (Model0.model a) i) >= 2 -> (forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail self)) -> (forall k : (int) . 0 <= k && k < Seq.length (Model2.model (Seq.get (Model1.model (Type.lib_trail_trail_Trail_trail self)) j)) -> not (UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model2.model (Seq.get (Model1.model (Type.lib_trail_trail_Trail_trail self)) j)) k)) = i)))
end
module Lib_Trail_Impl2_AssignmentsInvariant_Interface
  use Type
  predicate assignments_invariant (self : Type.lib_trail_trail) (a : Type.lib_assignments_assignments)
end
module Lib_Trail_Impl2_AssignmentsInvariant
  use Type
  clone Lib_Trail_Impl2_UnassignedNotInTrail_Interface as UnassignedNotInTrail0
  clone Lib_Trail_Impl2_TrailEntriesAreAssigned_Interface as TrailEntriesAreAssigned0
  predicate assignments_invariant (self : Type.lib_trail_trail) (a : Type.lib_assignments_assignments) = 
    TrailEntriesAreAssigned0.trail_entries_are_assigned self a && UnassignedNotInTrail0.unassigned_not_in_trail self a
end
module Lib_Trail_Impl2_LongArePostUnit_Interface
  use Type
  predicate long_are_post_unit (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
    
end
module Lib_Trail_Impl2_LongArePostUnit
  use Type
  use mach.int.Int
  use prelude.Prelude
  use mach.int.UInt64
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = (usize, Type.lib_trail_reason)
  predicate long_are_post_unit (self : Type.lib_trail_trail) (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments)
    
   = 
    LongArePostUnit0.long_are_post_unit (Model0.model (Type.lib_trail_trail_Trail_vardata self)) f a
end
module CreusotContracts_Std1_Vec_Impl1_New_Interface
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = t
  val new [@cfg:stackify] () : Type.creusotcontracts_std1_vec_vec t
    ensures { Seq.length (Model0.model result) = 0 }
    
end
module CreusotContracts_Std1_Vec_Impl1_New
  type t   
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = t
  val new [@cfg:stackify] () : Type.creusotcontracts_std1_vec_vec t
    ensures { Seq.length (Model0.model result) = 0 }
    
end
module Lib_Trail_Impl3_New_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use mach.int.UInt64
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model1.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  val new [@cfg:stackify] (f : Type.lib_formula_formula) (_a : Type.lib_assignments_assignments) : Type.lib_trail_trail
    ensures { TrailSemInvariant0.trail_sem_invariant result f _a }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail result)) = 1 }
    ensures { Invariant0.invariant' result f }
    
end
module Lib_Trail_Impl3_New
  use mach.int.UInt64
  use mach.int.Int
  use seq.Seq
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model4 with function Model0.model = Model6.model
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model5.model
  clone Lib_Clause_Impl1_Model as Model3 with function Model0.model = Model5.model
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model4.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model2.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model2.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model3.model,
  predicate Sat0.sat = Sat0.sat
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model1.model,
  function Model1.model = Model0.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model0.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve5 with type self = Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason)
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve4 with type self = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit))
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve3 with type self = Type.lib_formula_formula
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve2 with type self = ()
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve1 with type self = usize
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve as Resolve0 with type self = Type.lib_assignments_assignments
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New2 with type t = Type.lib_lit_lit,
  function Model0.model = Model5.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model8 with type t = Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)),
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model1.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  function Model0.model = Model1.model, function Model1.model = Model8.model
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  function Model0.model = Model1.model
  clone CreusotContracts_Logic_Model_Impl1_Model as Model7 with type t = Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model0.model
  clone CreusotContracts_Std1_Vec_Impl1_Push_Interface as Push0 with type t = (usize, Type.lib_trail_reason),
  function Model0.model = Model0.model, function Model1.model = Model7.model
  clone CreusotContracts_Std1_Vec_Impl1_New_Interface as New0 with type t = (usize, Type.lib_trail_reason),
  function Model0.model = Model0.model
  let rec cfg new [@cfg:stackify] (f : Type.lib_formula_formula) (_a : Type.lib_assignments_assignments) : Type.lib_trail_trail
    ensures { TrailSemInvariant0.trail_sem_invariant result f _a }
    ensures { Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail result)) = 1 }
    ensures { Invariant0.invariant' result f }
    
   = 
  var _0 : Type.lib_trail_trail;
  var f_1 : Type.lib_formula_formula;
  var _a_2 : Type.lib_assignments_assignments;
  var vardata_3 : Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason);
  var i_4 : usize;
  var _5 : ();
  var _6 : ();
  var _7 : bool;
  var _8 : usize;
  var _9 : usize;
  var _10 : ();
  var _11 : borrowed (Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason));
  var _12 : (usize, Type.lib_trail_reason);
  var _13 : Type.lib_trail_reason;
  var _14 : ();
  var _15 : ();
  var _16 : ();
  var trail_17 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _18 : ();
  var _19 : borrowed (Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)));
  var _20 : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit);
  var _21 : Type.creusotcontracts_std1_vec_vec (Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit));
  var _22 : Type.creusotcontracts_std1_vec_vec (usize, Type.lib_trail_reason);
  {
    f_1 <- f;
    _a_2 <- _a;
    goto BB0
  }
  BB0 {
    assume { Resolve0.resolve _a_2 };
    vardata_3 <- New0.new ();
    goto BB1
  }
  BB1 {
    i_4 <- (0 : usize);
    goto BB2
  }
  BB2 {
    goto BB3
  }
  BB3 {
    goto BB4
  }
  BB4 {
    invariant i_less { UInt64.to_int i_4 <= UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f_1) };
    invariant len_correct { Seq.length (Model0.model vardata_3) = UInt64.to_int i_4 };
    invariant all_undef { forall j : (int) . 0 <= j && j < UInt64.to_int i_4 -> UInt64.to_int (let (a, _) = Seq.get (Model0.model vardata_3) j in a) = 0 && (let (_, a) = Seq.get (Model0.model vardata_3) j in a) = Type.Lib_Trail_Reason_Undefined };
    assume { Resolve1.resolve _8 };
    _8 <- i_4;
    assume { Resolve1.resolve _9 };
    _9 <- Type.lib_formula_formula_Formula_num_vars f_1;
    _7 <- _8 < _9;
    switch (_7)
      | False -> goto BB7
      | _ -> goto BB5
      end
  }
  BB5 {
    _11 <- borrow_mut vardata_3;
    vardata_3 <-  ^ _11;
    _13 <- Type.Lib_Trail_Reason_Undefined;
    _12 <- ((0 : usize), _13);
    _10 <- Push0.push _11 _12;
    goto BB6
  }
  BB6 {
    i_4 <- i_4 + (1 : usize);
    _6 <- ();
    assume { Resolve2.resolve _6 };
    goto BB4
  }
  BB7 {
    assume { Resolve3.resolve f_1 };
    assume { Resolve1.resolve i_4 };
    _5 <- ();
    assume { Resolve2.resolve _5 };
    trail_17 <- New1.new ();
    goto BB8
  }
  BB8 {
    _19 <- borrow_mut trail_17;
    trail_17 <-  ^ _19;
    _20 <- New2.new ();
    goto BB9
  }
  BB9 {
    _18 <- Push1.push _19 _20;
    goto BB10
  }
  BB10 {
    assume { Resolve4.resolve _21 };
    _21 <- trail_17;
    assume { Resolve5.resolve _22 };
    _22 <- vardata_3;
    _0 <- Type.Lib_Trail_Trail _21 _22;
    goto BB11
  }
  BB11 {
    goto BB12
  }
  BB12 {
    goto BB13
  }
  BB13 {
    goto BB14
  }
  BB14 {
    return _0
  }
  
end
module Lib_Trail_Impl3_AddLevel_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  val add_level [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (_f : Type.lib_formula_formula) : ()
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self)))))) = 0 }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) + 1 }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) -> Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) i = Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) i }
    ensures { Model2.model (Type.lib_trail_trail_Trail_vardata ( * self)) = Model2.model (Type.lib_trail_trail_Trail_vardata ( ^ self)) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Trail_Impl3_AddLevel
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use mach.int.UInt64
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model3.model
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model1.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  val add_level [@cfg:stackify] (self : borrowed (Type.lib_trail_trail)) (_f : Type.lib_formula_formula) : ()
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) (Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self)))))) = 0 }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) + 1 }
    ensures { forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) -> Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail ( * self))) i = Seq.get (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ self))) i }
    ensures { Model2.model (Type.lib_trail_trail_Trail_vardata ( * self)) = Model2.model (Type.lib_trail_trail_Trail_vardata ( ^ self)) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_WatchesInvariantInternal_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate watches_invariant_internal (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (n : int)
    
end
module Lib_Watches_WatchesInvariantInternal
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  predicate watches_invariant_internal (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (n : int)
    
   = 
    2 * n = Seq.length w
end
module Lib_Watches_WatchesInvariantInternal2_Interface
  use seq.Seq
  use Type
  use mach.int.Int
  predicate watches_invariant_internal2 (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (n : int) (f : Type.lib_formula_formula)
    
end
module Lib_Watches_WatchesInvariantInternal2
  use seq.Seq
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  clone Lib_Clause_Impl1_Model_Interface as Model2
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_watches_watcher
  predicate watches_invariant_internal2 (w : Seq.seq (Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher))) (n : int) (f : Type.lib_formula_formula)
    
   = 
    2 * n = Seq.length w && (forall i : (int) . 0 <= i && i < Seq.length w -> (forall j : (int) . 0 <= j && j < Seq.length (Model0.model (Seq.get w i)) -> UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get (Model0.model (Seq.get w i)) j)) < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses f)) && Seq.length (Model2.model (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get (Model0.model (Seq.get w i)) j))))) > 1))
end
module Lib_Watches_Impl0_Invariant_Interface
  use Type
  predicate invariant' (self : Type.lib_watches_watches) (f : Type.lib_formula_formula)
end
module Lib_Watches_Impl0_Invariant
  use Type
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use seq.Seq
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  predicate invariant' (self : Type.lib_watches_watches) (f : Type.lib_formula_formula) = 
    2 * UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) = Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches self)) && (forall i : (int) . 0 <= i && i < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches self)) -> (forall j : (int) . 0 <= j && j < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches self)) i)) -> UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches self)) i)) j)) < Seq.length (Model2.model (Type.lib_formula_formula_Formula_clauses f))))
end
module Lib_Watches_Impl1_New_Interface
  use prelude.Prelude
  use Type
  clone Lib_Watches_Impl0_Invariant_Interface as Invariant0
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_watches_watches
    ensures { Invariant0.invariant' result f }
    
end
module Lib_Watches_Impl1_New
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Watches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model, function Model2.model = Model2.model
  val new [@cfg:stackify] (f : Type.lib_formula_formula) : Type.lib_watches_watches
    ensures { Invariant0.invariant' result f }
    
end
module Lib_Watches_Impl1_AddWatcher_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Watches_Impl0_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Lit_Impl0_ToNegWatchidxLogic_Interface as ToNegWatchidxLogic0
  val add_watcher [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (lit : Type.lib_lit_lit) (cref : usize) (_f : Type.lib_formula_formula) : ()
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) _f}
    requires {UInt64.to_int cref < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses _f))}
    ensures { Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) = Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl1_AddWatcher
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Watches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model, function Model2.model = Model1.model
  clone Lib_Lit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  val add_watcher [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (lit : Type.lib_lit_lit) (cref : usize) (_f : Type.lib_formula_formula) : ()
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) _f}
    requires {UInt64.to_int cref < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses _f))}
    ensures { Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) = Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( ^ self))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl1_UpdateWatch_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Watches_Impl0_Invariant_Interface as Invariant0
  clone Lib_Lit_Impl0_ToWatchidxLogic_Interface as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Lit_Impl0_ToNegWatchidxLogic_Interface as ToNegWatchidxLogic0
  val update_watch [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (old_lit : Type.lib_lit_lit) (new_lit : Type.lib_lit_lit) (cref : usize) (_f : Type.lib_formula_formula) : ()
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic new_lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {ToWatchidxLogic0.to_watchidx_logic old_lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx new_lit) < div 18446744073709551615 2}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx old_lit) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) _f}
    requires {exists j : (int) . 0 <= j && j < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (ToWatchidxLogic0.to_watchidx_logic old_lit))) && UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (ToWatchidxLogic0.to_watchidx_logic old_lit))) j)) = UInt64.to_int cref}
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl1_UpdateWatch
  use seq.Seq
  use mach.int.Int
  use mach.int.UInt64
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone Lib_Lit_Impl0_ToWatchidxLogic as ToWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Watches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model, function Model2.model = Model2.model
  clone Lib_Lit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  val update_watch [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (old_lit : Type.lib_lit_lit) (new_lit : Type.lib_lit_lit) (cref : usize) (_f : Type.lib_formula_formula) : ()
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic new_lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {ToWatchidxLogic0.to_watchidx_logic old_lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx new_lit) < div 18446744073709551615 2}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx old_lit) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) _f}
    requires {exists j : (int) . 0 <= j && j < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (ToWatchidxLogic0.to_watchidx_logic old_lit))) && UInt64.to_int (Type.lib_watches_watcher_Watcher_cref (Seq.get (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (ToWatchidxLogic0.to_watchidx_logic old_lit))) j)) = UInt64.to_int cref}
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl1_MoveToEnd_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Watches_Impl0_Invariant_Interface as Invariant0
  clone Lib_Lit_Impl0_ToNegWatchidxLogic_Interface as ToNegWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  val move_to_end [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (old_idx : usize) (old_pos : usize) (new_lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {UInt64.to_int old_pos < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx)))}
    requires {UInt64.to_int old_idx < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic new_lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx new_lit) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( ^ self))) (UInt64.to_int old_idx))) = Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl1_MoveToEnd
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Lit_Impl0_ToNegWatchidxLogic as ToNegWatchidxLogic0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Watches_Impl0_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model1.model, function Model2.model = Model2.model
  val move_to_end [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (old_idx : usize) (old_pos : usize) (new_lit : Type.lib_lit_lit) (_f : Type.lib_formula_formula) : ()
    requires {UInt64.to_int old_pos < Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx)))}
    requires {UInt64.to_int old_idx < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {ToNegWatchidxLogic0.to_neg_watchidx_logic new_lit < Seq.length (Model0.model (Type.lib_watches_watches_Watches_watches ( * self)))}
    requires {UInt64.to_int (Type.lib_lit_lit_Lit_idx new_lit) < div 18446744073709551615 2}
    requires {Invariant0.invariant' ( * self) _f}
    ensures { Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( ^ self))) (UInt64.to_int old_idx))) = Seq.length (Model1.model (Seq.get (Model0.model (Type.lib_watches_watches_Watches_watches ( * self))) (UInt64.to_int old_idx))) }
    ensures { Invariant0.invariant' ( ^ self) _f }
    
end
module Lib_Watches_Impl1_InitWatches_Interface
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Watches_Impl0_Invariant_Interface as Invariant1
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val init_watches [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (f : Type.lib_formula_formula) : ()
    requires {Invariant0.invariant' f}
    requires {Invariant1.invariant' ( * self) f}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) < div 18446744073709551615 2}
    ensures { Invariant1.invariant' ( ^ self) f }
    
end
module Lib_Watches_Impl1_InitWatches
  use mach.int.UInt64
  use mach.int.Int
  use prelude.Prelude
  use mach.int.Int32
  use Type
  clone Lib_Lit_Impl1_Invariant as Invariant3
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model4 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model3 with function Model0.model = Model4.model
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model3.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model3.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_Invariant as Invariant2 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model2.model,
  predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant0 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_watches_watcher
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_watches_watcher)
  clone Lib_Watches_Impl0_Invariant as Invariant1 with function Model0.model = Model0.model,
  function Model1.model = Model1.model, function Model2.model = Model2.model
  val init_watches [@cfg:stackify] (self : borrowed (Type.lib_watches_watches)) (f : Type.lib_formula_formula) : ()
    requires {Invariant0.invariant' f}
    requires {Invariant1.invariant' ( * self) f}
    requires {UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f) < div 18446744073709551615 2}
    ensures { Invariant1.invariant' ( ^ self) f }
    
end
module Lib_ConflictAnalysis_LemmaIdx_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Lit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Clause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Lit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
end
module Lib_ConflictAnalysis_LemmaIdx
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Lit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Clause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Lit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
  axiom lemma_idx_spec : forall c : Seq.seq (Type.lib_lit_lit), o : Seq.seq (Type.lib_lit_lit), new : Seq.seq (Type.lib_lit_lit), i : int, idx : int, c_idx : int, _f : Type.lib_formula_formula . (exists k : (int) . 0 <= k && k < Seq.length new && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get new k))) -> (forall j : (int) . 0 <= j && j < Seq.length new -> LitInInternal0.lit_in_internal (Seq.get new j) c || LitInInternal0.lit_in_internal (Seq.get new j) o) -> (forall j : (int) . 0 <= j && j < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c j)) <> idx -> LitInInternal0.lit_in_internal (Seq.get c j) new) -> InvariantInternal0.invariant_internal c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> InvariantInternal0.invariant_internal o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> 0 <= i && i < Seq.length o && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) <> idx -> (forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length o && 0 <= k && k < Seq.length c && k <> c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o j)) <> idx -> not (IsOpp0.is_opp (Seq.get c k) (Seq.get o j))) -> 0 <= c_idx && c_idx < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length o && k <> i && IsOpp0.is_opp (Seq.get o k) (Seq.get c c_idx)) -> (exists k : (int) . 0 <= k && k < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c k)) || LitInInternal0.lit_in_internal (Seq.get o i) new) && (exists k : (int) . 0 <= k && k < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c k)) && Type.lib_lit_lit_Lit_polarity (Seq.get o i) = Type.lib_lit_lit_Lit_polarity (Seq.get c k) || LitInInternal0.lit_in_internal (Seq.get o i) new)
end
module Lib_ConflictAnalysis_LemmaIdx2_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Lit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Clause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Lit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx2 (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
end
module Lib_ConflictAnalysis_LemmaIdx2
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use Type
  clone Lib_Lit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Clause_InvariantInternal_Interface as InvariantInternal0
  clone Lib_Lit_Impl1_LitInInternal_Interface as LitInInternal0
  function lemma_idx2 (c : Seq.seq (Type.lib_lit_lit)) (o : Seq.seq (Type.lib_lit_lit)) (new : Seq.seq (Type.lib_lit_lit)) (i : int) (idx : int) (c_idx : int) (_f : Type.lib_formula_formula) : ()
    
  axiom lemma_idx2_spec : forall c : Seq.seq (Type.lib_lit_lit), o : Seq.seq (Type.lib_lit_lit), new : Seq.seq (Type.lib_lit_lit), i : int, idx : int, c_idx : int, _f : Type.lib_formula_formula . (exists k : (int) . 0 <= k && k < Seq.length new && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get new k))) -> (forall j : (int) . 0 <= j && j < Seq.length new -> LitInInternal0.lit_in_internal (Seq.get new j) c || LitInInternal0.lit_in_internal (Seq.get new j) o) -> (forall j : (int) . 0 <= j && j < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c j)) <> idx -> LitInInternal0.lit_in_internal (Seq.get c j) new) -> InvariantInternal0.invariant_internal c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> InvariantInternal0.invariant_internal o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) -> 0 <= i && i < Seq.length o && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o i)) <> idx -> (forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length o && 0 <= k && k < Seq.length c && k <> c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get o j)) <> idx -> not (IsOpp0.is_opp (Seq.get c k) (Seq.get o j))) -> 0 <= c_idx && c_idx < Seq.length c && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get c c_idx)) = idx && (exists k : (int) . 0 <= k && k < Seq.length o && k <> i && IsOpp0.is_opp (Seq.get o k) (Seq.get c c_idx)) -> LitInInternal0.lit_in_internal (Seq.get o i) new
end
module Lib_ConflictAnalysis_IdxIn_Interface
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy0.modelTy
  val idx_in [@cfg:stackify] (v : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) (idx : usize) : bool
    ensures { result = (exists i : (int) . 0 <= i && i < Seq.length (Model0.model v) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model v) i)) = UInt64.to_int idx) }
    
end
module Lib_ConflictAnalysis_IdxIn
  use mach.int.Int
  use mach.int.Int32
  use seq.Seq
  use mach.int.UInt64
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_lit_lit
  clone CreusotContracts_Std1_Vec_Impl0_ModelTy as ModelTy0 with type t = Type.lib_lit_lit
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit),
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model1.model
  val idx_in [@cfg:stackify] (v : Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)) (idx : usize) : bool
    ensures { result = (exists i : (int) . 0 <= i && i < Seq.length (Model0.model v) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model v) i)) = UInt64.to_int idx) }
    
end
module Lib_ConflictAnalysis_Resolve_Interface
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Formula_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model2 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy2.modelTy
  clone Lib_Clause_Impl3_InFormula_Interface as InFormula0
  clone Lib_Lit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Clause_Impl1_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone Lib_Clause_Impl3_SameIdxSamePolarityExcept_Interface as SameIdxSamePolarityExcept0
  clone Lib_Clause_Impl2_PostUnitInner_Interface as PostUnitInner0
  clone Lib_Clause_Impl3_Invariant_Interface as Invariant0
  clone Lib_Clause_Impl3_UnsatInner_Interface as UnsatInner0
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val resolve [@cfg:stackify] (_f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (o : Type.lib_clause_clause) (idx : usize) (c_idx : usize) (_a : Type.lib_assignments_assignments) : Type.lib_clause_clause
    requires {UnsatInner0.unsat_inner c (Model0.model _a)}
    requires {Invariant0.invariant' o (Seq.length (Model0.model _a))}
    requires {Invariant0.invariant' c (Seq.length (Model0.model _a))}
    requires {PostUnitInner0.post_unit_inner o (Model0.model _a)}
    requires {UInt64.to_int idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {SameIdxSamePolarityExcept0.same_idx_same_polarity_except c o (UInt64.to_int idx)}
    requires {forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length (Model1.model o) && 0 <= k && k < Seq.length (Model1.model c) && k <> UInt64.to_int c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o) j)) <> UInt64.to_int idx -> not (IsOpp0.is_opp (Seq.get (Model1.model c) k) (Seq.get (Model1.model o) j))}
    requires {UInt64.to_int c_idx < Seq.length (Model1.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c) (UInt64.to_int c_idx))) = UInt64.to_int idx && (exists k : (int) . 0 <= k && k < Seq.length (Model1.model o) && IsOpp0.is_opp (Seq.get (Model1.model o) k) (Seq.get (Model1.model c) (UInt64.to_int c_idx)))}
    requires {Invariant0.invariant' o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant0.invariant' c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {InFormula0.in_formula o _f}
    requires {EquisatExtensionInner0.equisat_extension_inner c (Model2.model _f)}
    requires {Invariant1.invariant' _f}
    ensures { UnsatInner0.unsat_inner result (Model0.model _a) }
    ensures { EquisatExtensionInner0.equisat_extension_inner result (Model2.model _f) }
    ensures { Invariant0.invariant' result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    
end
module Lib_ConflictAnalysis_Resolve
  use seq.Seq
  use mach.int.UInt64
  use mach.int.Int
  use mach.int.Int32
  use prelude.Prelude
  use Type
  use prelude.UInt8
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Lit_Impl1_Invariant as Invariant2
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant2.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model8 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model4 with function Model0.model = Model8.model
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model4.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model4.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant0 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Clause_Impl3_SameIdxSamePolarityExcept as SameIdxSamePolarityExcept0 with function Model0.model = Model4.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model3 with function Model0.model = Model7.model
  clone Lib_Formula_Impl0_ModelTy as ModelTy2
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model5.model,
  predicate Invariant0.invariant' = Invariant0.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant1 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Formula_Impl0_Model as Model6 with function Model0.model = Model5.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model2 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy2.modelTy, function Model0.model = Model6.model
  clone Lib_Clause_Impl3_InFormula as InFormula0 with function Model0.model = Model5.model
  clone Lib_Lit_Impl1_IsOpp as IsOpp0
  clone Lib_Clause_Impl1_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model as Model1 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model4.model
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone Lib_Clause_Impl3_SatInner as SatInner1 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Clause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner1
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model4.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner0 with function Model0.model = Model4.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model3.model
  val resolve [@cfg:stackify] (_f : Type.lib_formula_formula) (c : Type.lib_clause_clause) (o : Type.lib_clause_clause) (idx : usize) (c_idx : usize) (_a : Type.lib_assignments_assignments) : Type.lib_clause_clause
    requires {UnsatInner0.unsat_inner c (Model0.model _a)}
    requires {Invariant0.invariant' o (Seq.length (Model0.model _a))}
    requires {Invariant0.invariant' c (Seq.length (Model0.model _a))}
    requires {PostUnitInner0.post_unit_inner o (Model0.model _a)}
    requires {UInt64.to_int idx < UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)}
    requires {SameIdxSamePolarityExcept0.same_idx_same_polarity_except c o (UInt64.to_int idx)}
    requires {forall k : (int) . forall j : (int) . 0 <= j && j < Seq.length (Model1.model o) && 0 <= k && k < Seq.length (Model1.model c) && k <> UInt64.to_int c_idx && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model o) j)) <> UInt64.to_int idx -> not (IsOpp0.is_opp (Seq.get (Model1.model c) k) (Seq.get (Model1.model o) j))}
    requires {UInt64.to_int c_idx < Seq.length (Model1.model c) && UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model1.model c) (UInt64.to_int c_idx))) = UInt64.to_int idx && (exists k : (int) . 0 <= k && k < Seq.length (Model1.model o) && IsOpp0.is_opp (Seq.get (Model1.model o) k) (Seq.get (Model1.model c) (UInt64.to_int c_idx)))}
    requires {Invariant0.invariant' o (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {Invariant0.invariant' c (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f))}
    requires {InFormula0.in_formula o _f}
    requires {EquisatExtensionInner0.equisat_extension_inner c (Model2.model _f)}
    requires {Invariant1.invariant' _f}
    ensures { UnsatInner0.unsat_inner result (Model0.model _a) }
    ensures { EquisatExtensionInner0.equisat_extension_inner result (Model2.model _f) }
    ensures { Invariant0.invariant' result (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars _f)) }
    
end
module Lib_ConflictAnalysis_ChooseLiteral_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Lit_Impl1_IsOpp_Interface as IsOpp0
  clone Lib_Clause_Impl1_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy0.modelTy
  val choose_literal [@cfg:stackify] (c : Type.lib_clause_clause) (trail : Type.lib_trail_trail) (i : borrowed usize) (j : borrowed usize) : (Type.lib_lit_lit, usize)
    ensures { IsOpp0.is_opp (Seq.get (Model0.model c) (UInt64.to_int (let (_, a) = result in a))) (let (a, _) = result in a) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) (UInt64.to_int (let (_, a) = result in a)))) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (let (a, _) = result in a)) }
    ensures { UInt64.to_int (let (_, a) = result in a) < Seq.length (Model0.model c) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx (let (a, _) = result in a)) < Seq.length (Model1.model (Type.lib_trail_trail_Trail_vardata trail)) }
    
end
module Lib_ConflictAnalysis_ChooseLiteral
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use prelude.Prelude
  use Type
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model3 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model2 with function Model0.model = Model3.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Lit_Impl1_IsOpp as IsOpp0
  clone Lib_Clause_Impl1_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model0 with type t = Type.lib_clause_clause,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model2.model
  val choose_literal [@cfg:stackify] (c : Type.lib_clause_clause) (trail : Type.lib_trail_trail) (i : borrowed usize) (j : borrowed usize) : (Type.lib_lit_lit, usize)
    ensures { IsOpp0.is_opp (Seq.get (Model0.model c) (UInt64.to_int (let (_, a) = result in a))) (let (a, _) = result in a) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx (Seq.get (Model0.model c) (UInt64.to_int (let (_, a) = result in a)))) = UInt64.to_int (Type.lib_lit_lit_Lit_idx (let (a, _) = result in a)) }
    ensures { UInt64.to_int (let (_, a) = result in a) < Seq.length (Model0.model c) }
    ensures { UInt64.to_int (Type.lib_lit_lit_Lit_idx (let (a, _) = result in a)) < Seq.length (Model1.model (Type.lib_trail_trail_Trail_vardata trail)) }
    
end
module Lib_ConflictAnalysis_AnalyzeConflictNew_Interface
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  clone Lib_Clause_EquisatExtensionInner_Interface as EquisatExtensionInner0
  clone Lib_Formula_Impl0_ModelTy as ModelTy1
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model4 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy1.modelTy
  clone Lib_Clause_NoDuplicateIndexesInner_Interface as NoDuplicateIndexesInner0
  clone Lib_Clause_VarsInRangeInner_Interface as VarsInRangeInner0
  clone Lib_Clause_Impl1_Model_Interface as Model3
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model_Interface as Model2 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model5 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model5.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Clause_Impl3_Unsat_Interface as Unsat0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.lib_clause_clause
  val analyze_conflict_new [@cfg:stackify] (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (trail : Type.lib_trail_trail) (cref : usize) : Type.lib_conflictanalysis_conflict
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) a}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' a f}
    requires {Invariant2.invariant' f}
    requires {TrailSemInvariant0.trail_sem_invariant trail f a}
    ensures { match (result) with
      | Type.Lib_ConflictAnalysis_Conflict_Unit lit -> true
      | Type.Lib_ConflictAnalysis_Conflict_Learned level lit clause -> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < Seq.length (Model2.model a) && Seq.length (Model3.model clause) > 1 && VarsInRangeInner0.vars_in_range_inner (Model3.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model3.model clause) && EquisatExtensionInner0.equisat_extension_inner clause (Model4.model f)
      | _ -> true
      end }
    
end
module Lib_ConflictAnalysis_AnalyzeConflictNew
  use mach.int.UInt64
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Lit_Impl1_SatInner as SatInner0
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model9 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model5 with function Model0.model = Model9.model
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model5.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model5.model
  clone Lib_Formula_Impl0_ModelTy as ModelTy1
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_Invariant as Invariant3
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant3.invariant'
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model7.model
  clone Lib_Clause_Impl1_Model as Model3 with function Model0.model = Model7.model
  clone Lib_Clause_Impl3_SatInner as SatInner1 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Clause_EquisatExtensionInner as EquisatExtensionInner0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner0.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model5.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model3.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model3.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant4 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Clause_Impl3_Unsat as Unsat0 with function Model0.model = Model5.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Assignments_Impl0_ModelTy as ModelTy0
  clone CreusotContracts_Logic_Model_Impl0_Model as Model2 with type t = Type.lib_assignments_assignments,
  type ModelTy0.modelTy = ModelTy0.modelTy, function Model0.model = Model5.model
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model6 with type t = (usize, Type.lib_trail_reason)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.lib_clause_clause
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model0.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model1.model,
  function Model1.model = Model6.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  clone Lib_Formula_Impl0_Model as Model8 with function Model0.model = Model0.model
  clone CreusotContracts_Logic_Model_Impl0_Model as Model4 with type t = Type.lib_formula_formula,
  type ModelTy0.modelTy = ModelTy1.modelTy, function Model0.model = Model8.model
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model0.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model3.model,
  predicate Sat0.sat = Sat0.sat
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model6.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model0.model,
  predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  val analyze_conflict_new [@cfg:stackify] (f : Type.lib_formula_formula) (a : Type.lib_assignments_assignments) (trail : Type.lib_trail_trail) (cref : usize) : Type.lib_conflictanalysis_conflict
    requires {Unsat0.unsat (Seq.get (Model0.model (Type.lib_formula_formula_Formula_clauses f)) (UInt64.to_int cref)) a}
    requires {UInt64.to_int cref < Seq.length (Model0.model (Type.lib_formula_formula_Formula_clauses f))}
    requires {Seq.length (Model1.model (Type.lib_trail_trail_Trail_trail trail)) > 0}
    requires {Invariant0.invariant' trail f}
    requires {Invariant1.invariant' a f}
    requires {Invariant2.invariant' f}
    requires {TrailSemInvariant0.trail_sem_invariant trail f a}
    ensures { match (result) with
      | Type.Lib_ConflictAnalysis_Conflict_Unit lit -> true
      | Type.Lib_ConflictAnalysis_Conflict_Learned level lit clause -> UInt64.to_int (Type.lib_lit_lit_Lit_idx lit) < Seq.length (Model2.model a) && Seq.length (Model3.model clause) > 1 && VarsInRangeInner0.vars_in_range_inner (Model3.model clause) (UInt64.to_int (Type.lib_formula_formula_Formula_num_vars f)) && NoDuplicateIndexesInner0.no_duplicate_indexes_inner (Model3.model clause) && EquisatExtensionInner0.equisat_extension_inner clause (Model4.model f)
      | _ -> true
      end }
    
end
module Lib_UnitProp_UnitPropagateWip_Interface
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  clone Lib_Assignments_Impl1_Compatible_Interface as Compatible0
  clone Lib_Formula_Impl2_EventuallySatComplete_Interface as EventuallySatComplete0
  clone Lib_Clause_Impl3_Unsat_Interface as Unsat1
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model1 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_Unsat_Interface as Unsat0
  clone Lib_Formula_Impl2_EventuallySat_Interface as EventuallySat0
  clone Lib_Formula_Impl2_EquisatCompatible_Interface as EquisatCompatible0
  clone Lib_Trail_LongArePostUnit_Interface as LongArePostUnit0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model2 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant_Interface as TrailSemInvariant0 with function Model0.model = Model2.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone Lib_Formula_Impl2_InvariantOld_Interface as InvariantOld0
  clone Lib_Formula_Impl2_Invariant_Interface as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone Lib_Assignments_Impl1_Invariant_Interface as Invariant1
  clone Lib_Trail_Impl2_Invariant_Interface as Invariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model_Interface as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  val unit_propagate_WIP [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) : Type.core_result_result () usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) > 0}
    requires {Invariant0.invariant' ( * trail) ( * f)}
    requires {Invariant1.invariant' ( * a) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    requires {TrailSemInvariant0.trail_sem_invariant ( * trail) ( * f) ( * a)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ trail) ( ^ f) }
    ensures { EventuallySat0.eventually_sat ( * f) ( * a) = EventuallySat0.eventually_sat ( ^ f) ( * a) }
    ensures {  ^ f =  * f }
    ensures { Invariant2.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok () -> not (Unsat0.unsat ( ^ f) ( ^ a))
      | Type.Core_Result_Result_Err n -> UInt64.to_int n < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f))) && Unsat0.unsat ( ^ f) ( ^ a) && Unsat1.unsat (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int n)) ( * a)
      end }
    ensures { EventuallySatComplete0.eventually_sat_complete ( * f) ( * a) = EventuallySatComplete0.eventually_sat_complete ( ^ f) ( ^ a) }
    ensures { Compatible0.compatible ( * a) ( ^ a) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ trail) ( ^ f) ( ^ a) }
    
end
module Lib_UnitProp_UnitPropagateWip
  use seq.Seq
  use mach.int.Int
  use mach.int.Int32
  use mach.int.UInt64
  use Type
  use prelude.Prelude
  use prelude.UInt8
  clone Lib_Lit_Impl1_Invariant as Invariant4
  clone Lib_Clause_VarsInRangeInner as VarsInRangeInner0 with predicate Invariant0.invariant' = Invariant4.invariant'
  clone Lib_Clause_NoDuplicateIndexesInner as NoDuplicateIndexesInner0
  clone Lib_Lit_Impl1_SatInner as SatInner1
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model7 with type t = Type.lib_lit_lit
  clone Lib_Clause_Impl1_Model as Model6 with function Model0.model = Model7.model
  clone Lib_Clause_Impl3_SatInner as SatInner2 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Formula_FormulaSatInner as FormulaSatInner0 with predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Clause_Impl3_Equals as Equals0 with function Model0.model = Model6.model
  clone Lib_Formula_Compatible as Compatible1 with predicate Equals0.equals = Equals0.equals
  clone Lib_Clause_Impl3_NoDuplicateIndexes as NoDuplicateIndexes0 with function Model0.model = Model6.model,
  predicate NoDuplicateIndexesInner0.no_duplicate_indexes_inner = NoDuplicateIndexesInner0.no_duplicate_indexes_inner
  clone Lib_Clause_Impl3_VarsInRange as VarsInRange0 with function Model0.model = Model6.model,
  predicate VarsInRangeInner0.vars_in_range_inner = VarsInRangeInner0.vars_in_range_inner
  clone Lib_Clause_Impl3_Invariant as Invariant3 with predicate VarsInRange0.vars_in_range = VarsInRange0.vars_in_range,
  predicate NoDuplicateIndexes0.no_duplicate_indexes = NoDuplicateIndexes0.no_duplicate_indexes
  clone Lib_Trail_TrailInvariant as TrailInvariant0 with function Model0.model = Model7.model
  clone Lib_Logic_Unset as Unset0
  clone Lib_Assignments_CompleteInner as CompleteInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Formula_EventuallySatCompleteNoAss as EventuallySatCompleteNoAss0 with predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner,
  predicate FormulaSatInner0.formula_sat_inner = FormulaSatInner0.formula_sat_inner
  clone Lib_Formula_Equisat as Equisat0 with predicate EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass = EventuallySatCompleteNoAss0.eventually_sat_complete_no_ass
  clone Lib_Formula_EquisatCompatibleInner as EquisatCompatibleInner0 with predicate Compatible0.compatible = Compatible1.compatible,
  predicate Equisat0.equisat = Equisat0.equisat
  clone Lib_Assignments_CompatibleInner as CompatibleInner0 with predicate Unset0.unset = Unset0.unset
  clone Lib_Assignments_CompatibleCompleteInner as CompatibleCompleteInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate CompleteInner0.complete_inner = CompleteInner0.complete_inner
  clone Lib_Lit_Impl1_UnsatInner as UnsatInner2
  clone Lib_Clause_Impl2_PostUnitInner as PostUnitInner0 with function Model0.model = Model6.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner, predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone Lib_Clause_Impl3_UnsatInner as UnsatInner1 with function Model0.model = Model6.model,
  predicate UnsatInner0.unsat_inner = UnsatInner2.unsat_inner
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model5 with type t = uint8
  clone Lib_Assignments_Impl0_Model as Model3 with function Model0.model = Model5.model
  clone Lib_Lit_Impl1_Sat as Sat0 with function Model0.model = Model3.model,
  predicate SatInner0.sat_inner = SatInner1.sat_inner
  clone Lib_Clause_Impl2_PostUnit as PostUnit0 with function Model0.model = Model3.model,
  predicate PostUnitInner0.post_unit_inner = PostUnitInner0.post_unit_inner
  clone Lib_Assignments_Impl1_Compatible as Compatible0 with function Model0.model = Model3.model,
  predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner
  clone Lib_Clause_Impl3_Unsat as Unsat1 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Assignments_Impl1_Invariant as Invariant1 with function Model0.model = Model3.model
  clone Lib_Trail_VardataInvariant as VardataInvariant0
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model1 with type t = Type.lib_clause_clause
  clone Lib_Formula_Impl2_SatInner as SatInner0 with function Model0.model = Model1.model,
  predicate SatInner0.sat_inner = SatInner2.sat_inner
  clone Lib_Formula_Impl2_EventuallySatCompleteInner as EventuallySatCompleteInner0 with predicate CompatibleCompleteInner0.compatible_complete_inner = CompatibleCompleteInner0.compatible_complete_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_Impl2_EventuallySatComplete as EventuallySatComplete0 with function Model0.model = Model3.model,
  predicate EventuallySatCompleteInner0.eventually_sat_complete_inner = EventuallySatCompleteInner0.eventually_sat_complete_inner
  clone Lib_Formula_Impl2_EventuallySatInner as EventuallySatInner0 with predicate CompatibleInner0.compatible_inner = CompatibleInner0.compatible_inner,
  predicate SatInner0.sat_inner = SatInner0.sat_inner
  clone Lib_Formula_Impl2_EventuallySat as EventuallySat0 with function Model0.model = Model3.model,
  predicate EventuallySatInner0.eventually_sat_inner = EventuallySatInner0.eventually_sat_inner
  clone Lib_Trail_CrefsInRange as CrefsInRange0 with function Model0.model = Model1.model
  clone Lib_Trail_TrailInvariantFull as TrailInvariantFull0 with predicate TrailInvariant0.trail_invariant = TrailInvariant0.trail_invariant,
  predicate VardataInvariant0.vardata_invariant = VardataInvariant0.vardata_invariant,
  predicate CrefsInRange0.crefs_in_range = CrefsInRange0.crefs_in_range
  clone Lib_Formula_Impl2_UnsatInner as UnsatInner0 with function Model0.model = Model1.model,
  predicate UnsatInner0.unsat_inner = UnsatInner1.unsat_inner
  clone Lib_Formula_Impl2_Unsat as Unsat0 with function Model0.model = Model3.model,
  predicate UnsatInner0.unsat_inner = UnsatInner0.unsat_inner
  clone Lib_Formula_Impl0_Model as Model4 with function Model0.model = Model1.model
  clone Lib_Formula_Impl2_EquisatCompatible as EquisatCompatible0 with function Model0.model = Model4.model,
  predicate EquisatCompatibleInner0.equisat_compatible_inner = EquisatCompatibleInner0.equisat_compatible_inner
  clone Lib_Trail_LongArePostUnit as LongArePostUnit0 with function Model0.model = Model1.model,
  predicate PostUnit0.post_unit = PostUnit0.post_unit, function Model1.model = Model6.model,
  predicate Sat0.sat = Sat0.sat
  clone Lib_Formula_Impl2_InvariantOld as InvariantOld0 with function Model0.model = Model1.model,
  predicate Invariant0.invariant' = Invariant3.invariant'
  clone Lib_Formula_Impl2_Invariant as Invariant2 with predicate InvariantOld0.invariant_old = InvariantOld0.invariant_old,
  axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model2 with type t = (usize, Type.lib_trail_reason)
  clone Lib_Trail_Impl2_TrailSemInvariant as TrailSemInvariant0 with function Model0.model = Model2.model,
  predicate LongArePostUnit0.long_are_post_unit = LongArePostUnit0.long_are_post_unit, axiom .
  clone CreusotContracts_Std1_Vec_Impl0_Model as Model0 with type t = Type.creusotcontracts_std1_vec_vec (Type.lib_lit_lit)
  clone Lib_Trail_Impl2_Invariant as Invariant0 with function Model0.model = Model0.model,
  function Model1.model = Model2.model,
  predicate TrailInvariantFull0.trail_invariant_full = TrailInvariantFull0.trail_invariant_full
  val unit_propagate_WIP [@cfg:stackify] (f : borrowed (Type.lib_formula_formula)) (a : borrowed (Type.lib_assignments_assignments)) (trail : borrowed (Type.lib_trail_trail)) (watches : borrowed (Type.lib_watches_watches)) : Type.core_result_result () usize
    requires {Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) > 0}
    requires {Invariant0.invariant' ( * trail) ( * f)}
    requires {Invariant1.invariant' ( * a) ( * f)}
    requires {Invariant2.invariant' ( * f)}
    requires {TrailSemInvariant0.trail_sem_invariant ( * trail) ( * f) ( * a)}
    ensures { EquisatCompatible0.equisat_compatible ( * f) ( ^ f) }
    ensures { Invariant1.invariant' ( ^ a) ( ^ f) }
    ensures { Invariant0.invariant' ( ^ trail) ( ^ f) }
    ensures { EventuallySat0.eventually_sat ( * f) ( * a) = EventuallySat0.eventually_sat ( ^ f) ( * a) }
    ensures {  ^ f =  * f }
    ensures { Invariant2.invariant' ( ^ f) }
    ensures { UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( * f)) = UInt64.to_int (Type.lib_formula_formula_Formula_num_vars ( ^ f)) }
    ensures { match (result) with
      | Type.Core_Result_Result_Ok () -> not (Unsat0.unsat ( ^ f) ( ^ a))
      | Type.Core_Result_Result_Err n -> UInt64.to_int n < Seq.length (Model1.model (Type.lib_formula_formula_Formula_clauses ( * f))) && Unsat0.unsat ( ^ f) ( ^ a) && Unsat1.unsat (Seq.get (Model1.model (Type.lib_formula_formula_Formula_clauses ( ^ f))) (UInt64.to_int n)) ( * a)
      end }
    ensures { EventuallySatComplete0.eventually_sat_complete ( * f) ( * a) = EventuallySatComplete0.eventually_sat_complete ( ^ f) ( ^ a) }
    ensures { Compatible0.compatible ( * a) ( ^ a) }
    ensures { Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( ^ trail))) = Seq.length (Model0.model (Type.lib_trail_trail_Trail_trail ( * trail))) }
    ensures { TrailSemInvariant0.trail_sem_invariant ( ^ trail) ( ^ f) ( ^ a) }
    
end
module Lib_Lit_Impl6
  
end
module Lib_Trail_Impl4
  
end
